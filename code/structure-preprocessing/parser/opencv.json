{"code": "\n\n\n\n\n\n\n@Configuration\n@PropertySource(\"classpath:/batch-hsql.properties\")\npublic class DataSourceConfiguration {\n\t\n\t@Autowired\n\tprivate Environment environment;\n\t\n\t@Autowired\n\tprivate ResourceLoader resourceLoader;\n\t\n\t@PostConstruct\n\tprotected void initialize() {\n\t\tResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n\t\tpopulator.addScript(resourceLoader.getResource(environment.getProperty(\"batch.schema.script\")));\n\t\tpopulator.setContinueOnError(true);\n\t\tDatabasePopulatorUtils.execute(populator , dataSource());\n\t}\n\t\n\t@Bean(destroyMethod=\"close\")\n\tpublic DataSource dataSource() {\n\t\tBasicDataSource dataSource = new BasicDataSource();\n\t\tdataSource.setDriverClassName(environment.getProperty(\"batch.jdbc.driver\"));\n\t\tdataSource.setUrl(environment.getProperty(\"batch.jdbc.url\"));\n\t\tdataSource.setUsername(environment.getProperty(\"batch.jdbc.user\"));\n\t\tdataSource.setPassword(environment.getProperty(\"batch.jdbc.password\"));\n\t\treturn dataSource;\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class CascadeClassifier {\n\n    protected final long nativeObj;\n    protected CascadeClassifier(long addr) { nativeObj = addr; }\n\n\n\n    public   CascadeClassifier()\n    {\n        \n        nativeObj = CascadeClassifier_0();\n        \n        return;\n    }\n\n\n\n    public   CascadeClassifier(String filename)\n    {\n        \n        nativeObj = CascadeClassifier_1(filename);\n        \n        return;\n    }\n\n\n\n    public  boolean load(String filename)\n    {\n        \n        boolean retVal = load_0(nativeObj, filename);\n        \n        return retVal;\n    }\n\n\n\n    public  boolean empty()\n    {\n        \n        boolean retVal = empty_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n\n\n\n    public  void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)\n    {\n        Mat objects_mat = objects;\n        detectMultiScale_0(nativeObj, image.nativeObj, objects_mat.nativeObj, scaleFactor, minNeighbors, flags, minSize.width, minSize.height, maxSize.width, maxSize.height);\n        \n        return;\n    }\n\n    public  void detectMultiScale(Mat image, MatOfRect objects)\n    {\n        Mat objects_mat = objects;\n        detectMultiScale_1(nativeObj, image.nativeObj, objects_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)\n    {\n        Mat objects_mat = objects;\n        Mat numDetections_mat = numDetections;\n        detectMultiScale2_0(nativeObj, image.nativeObj, objects_mat.nativeObj, numDetections_mat.nativeObj, scaleFactor, minNeighbors, flags, minSize.width, minSize.height, maxSize.width, maxSize.height);\n        \n        return;\n    }\n\n    public  void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections)\n    {\n        Mat objects_mat = objects;\n        Mat numDetections_mat = numDetections;\n        detectMultiScale2_1(nativeObj, image.nativeObj, objects_mat.nativeObj, numDetections_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize, boolean outputRejectLevels)\n    {\n        Mat objects_mat = objects;\n        Mat rejectLevels_mat = rejectLevels;\n        Mat levelWeights_mat = levelWeights;\n        detectMultiScale3_0(nativeObj, image.nativeObj, objects_mat.nativeObj, rejectLevels_mat.nativeObj, levelWeights_mat.nativeObj, scaleFactor, minNeighbors, flags, minSize.width, minSize.height, maxSize.width, maxSize.height, outputRejectLevels);\n        \n        return;\n    }\n\n    public  void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights)\n    {\n        Mat objects_mat = objects;\n        Mat rejectLevels_mat = rejectLevels;\n        Mat levelWeights_mat = levelWeights;\n        detectMultiScale3_1(nativeObj, image.nativeObj, objects_mat.nativeObj, rejectLevels_mat.nativeObj, levelWeights_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  boolean isOldFormatCascade()\n    {\n        \n        boolean retVal = isOldFormatCascade_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  Size getOriginalWindowSize()\n    {\n        \n        Size retVal = new Size(getOriginalWindowSize_0(nativeObj));\n        \n        return retVal;\n    }\n\n\n\n    public  int getFeatureType()\n    {\n        \n        int retVal = getFeatureType_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public static boolean convert(String oldcascade, String newcascade)\n    {\n        \n        boolean retVal = convert_0(oldcascade, newcascade);\n        \n        return retVal;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n    private static native long CascadeClassifier_0();\n\n    private static native long CascadeClassifier_1(String filename);\n\n    private static native boolean load_0(long nativeObj, String filename);\n\n    private static native boolean empty_0(long nativeObj);\n\n    private static native void detectMultiScale_0(long nativeObj, long image_nativeObj, long objects_mat_nativeObj, double scaleFactor, int minNeighbors, int flags, double minSize_width, double minSize_height, double maxSize_width, double maxSize_height);\n    private static native void detectMultiScale_1(long nativeObj, long image_nativeObj, long objects_mat_nativeObj);\n\n    private static native void detectMultiScale2_0(long nativeObj, long image_nativeObj, long objects_mat_nativeObj, long numDetections_mat_nativeObj, double scaleFactor, int minNeighbors, int flags, double minSize_width, double minSize_height, double maxSize_width, double maxSize_height);\n    private static native void detectMultiScale2_1(long nativeObj, long image_nativeObj, long objects_mat_nativeObj, long numDetections_mat_nativeObj);\n\n    private static native void detectMultiScale3_0(long nativeObj, long image_nativeObj, long objects_mat_nativeObj, long rejectLevels_mat_nativeObj, long levelWeights_mat_nativeObj, double scaleFactor, int minNeighbors, int flags, double minSize_width, double minSize_height, double maxSize_width, double maxSize_height, boolean outputRejectLevels);\n    private static native void detectMultiScale3_1(long nativeObj, long image_nativeObj, long objects_mat_nativeObj, long rejectLevels_mat_nativeObj, long levelWeights_mat_nativeObj);\n\n    private static native boolean isOldFormatCascade_0(long nativeObj);\n\n    private static native double[] getOriginalWindowSize_0(long nativeObj);\n\n    private static native int getFeatureType_0(long nativeObj);\n\n    private static native boolean convert_0(String oldcascade, String newcascade);\n\n    private static native void delete(long nativeObj);\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n@Service\npublic class BlogService {\n\n    private static final Log logger = LogFactory.getLog(BlogService.class);\n\n    private final PostFormAdapter postFormAdapter;\n    private final PostRepository postRepository;\n    private final SearchService searchService;\n    private final DateFactory dateFactory;\n    private final PostSearchEntryMapper mapper = new PostSearchEntryMapper();\n\n    @Value(\"${disqus_shortname}\")\n    private String disqusShortname;\n\n    @Autowired\n    public BlogService(PostRepository postRepository, PostFormAdapter postFormAdapter, DateFactory dateFactory,\n                       SearchService searchService) {\n        this.postRepository = postRepository;\n        this.postFormAdapter = postFormAdapter;\n        this.dateFactory = dateFactory;\n        this.searchService = searchService;\n    }\n\n\n    public String getDisqusShortname() {\n        return disqusShortname;\n    }\n\n\n    public Post getPost(Long postId) {\n        Post post = postRepository.findOne(postId);\n        if (post == null) {\n            throw new PostNotFoundException(postId);\n        }\n        return post;\n    }\n\n    public Post getPost(String title, Date createdAt) {\n        return postRepository.findByTitleAndCreatedAt(title, createdAt);\n    }\n\n    public Page<Post> getDraftPosts(Pageable pageRequest) {\n        return postRepository.findByDraftTrue(pageRequest);\n    }\n\n    public Page<Post> getScheduledPosts(Pageable pageRequest) {\n        return postRepository.findByDraftFalseAndPublishAtAfter(dateFactory.now(), pageRequest);\n    }\n\n    public Page<Post> getPublishedPosts(Pageable pageRequest) {\n        return postRepository.findByDraftFalseAndPublishAtBeforeOrderByPublishAtDesc(dateFactory.now(), pageRequest);\n    }\n\n    public Post getPublishedPost(String publicSlug) {\n        Date now = dateFactory.now();\n        Post post = postRepository.findByPublicSlugAndDraftFalseAndPublishAtBefore(publicSlug, now);\n        if (post == null) {\n            post = postRepository.findByPublicSlugAliasesInAndDraftFalseAndPublishAtBefore(\n                    Collections.singleton(publicSlug), now);\n            if (post != null) {\n                throw new PostMovedException(post.getPublicSlug());\n            }\n            throw new PostNotFoundException(publicSlug);\n        }\n        return post;\n    }\n\n    public List<Post> getAllPublishedPosts() {\n        return postRepository.findByDraftFalseAndPublishAtBeforeOrderByPublishAtDesc(dateFactory.now());\n    }\n\n    public Page<Post> getPublishedPostsByDate(int year, int month, int day, Pageable pageRequest) {\n        return postRepository.findByDate(year, month, day, pageRequest);\n    }\n\n    public Page<Post> getPublishedPostsByDate(int year, int month, Pageable pageRequest) {\n        return postRepository.findByDate(year, month, pageRequest);\n    }\n\n    public Page<Post> getPublishedPostsByDate(int year, Pageable pageRequest) {\n        return postRepository.findByDate(year, pageRequest);\n    }\n\n    public Page<Post> getPublishedPosts(PostCategory category, Pageable pageRequest) {\n        return postRepository.findByCategoryAndDraftFalseAndPublishAtBefore(category, dateFactory.now(), pageRequest);\n    }\n\n    public Page<Post> getPublishedBroadcastPosts(Pageable pageRequest) {\n        return postRepository.findByBroadcastAndDraftFalseAndPublishAtBefore(true, dateFactory.now(), pageRequest);\n    }\n\n    public Page<Post> getPublishedPostsForMember(MemberProfile profile, Pageable pageRequest) {\n        return postRepository.findByDraftFalseAndAuthorAndPublishAtBeforeOrderByPublishAtDesc(profile, dateFactory.now(), pageRequest);\n    }\n\n    public Page<Post> getAllPosts(Pageable pageRequest) {\n        return postRepository.findAll(pageRequest);\n    }\n\n    public Post addPost(PostForm postForm, String username) {\n        Post post = postFormAdapter.createPostFromPostForm(postForm, username);\n        postRepository.save(post);\n        saveToIndex(post);\n        return post;\n    }\n\n    public void updatePost(Post post, PostForm postForm) {\n        postFormAdapter.updatePostFromPostForm(post, postForm);\n        postRepository.save(post);\n        saveToIndex(post);\n    }\n\n    public void deletePost(Post post) {\n        postRepository.delete(post);\n    }\n\n    private void saveToIndex(Post post) {\n        if (post.isLiveOn(dateFactory.now())) {\n            try {\n                searchService.saveToIndex(mapper.map(post));\n            } catch (Exception e) {\n                logger.error(e);\n            }\n        }\n    }\n\n    public void resummarizeAllPosts() {\n        List<Post> posts = postRepository.findAll();\n        for (Post post : posts) {\n            postFormAdapter.summarize(post);\n            postRepository.save(post);\n        }\n    }\n\n    public Page<Post> refreshPosts(int page, int size) {\n        PageRequest pageRequest = new PageRequest(page, size, Sort.Direction.DESC, \"id\");\n        Page<Post> posts = postRepository.findAll(pageRequest);\n        for (Post post : posts) {\n            postFormAdapter.refreshPost(post);\n            postRepository.save(post);\n        }\n        return posts;\n    }\n}", "nl": "spring"}
{"code": "\t\n\n\n\npublic class ImageSegmentation extends Application\n{\n\t\n\t@Override\n\tpublic void start(Stage primaryStage)\n\t{\n\t\ttry\n\t\t{\n\t\t\tFXMLLoader loader = new FXMLLoader(getClass().getResource(\"ImageSeg.fxml\"));\n\t\t\tBorderPane root = (BorderPane) loader.load();\n\t\t\t\t\t\t\t\t\t\n\t\t\troot.setStyle(\"-fx-background-color: whitesmoke;\");\n\t\t\tScene scene = new Scene(root, 800, 600);\n\t\t\tscene.getStylesheets().add(getClass().getResource(\"application.css\").toExternalForm());\n\t\t\tprimaryStage.setTitle(\"Image Segmentation\");\n\t\t\tprimaryStage.setScene(scene);\n\t\t\t\n\t\t\tprimaryStage.show();\n\t\t\t\n\t\t\tImageSegController controller = loader.getController();\t\t\t\n\t\t\tcontroller.init();\n\t\t\t\n\t\t\tprimaryStage.setOnCloseRequest((new EventHandler<WindowEvent>() {\n\t\t\t\tpublic void handle(WindowEvent we)\n\t\t\t\t{\n\t\t\t\t\tcontroller.setClosed();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tSystem.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\t\t\n\t\tlaunch(args);\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n@Controller\n@RequestMapping(\"/projects\")\n@Navigation(Section.PROJECTS)\nclass ProjectsController {\n\n    private ProjectMetadataService projectMetadataService;\n    private GettingStartedGuides gsGuides;\n    private Tutorials tutorials;\n    private Topicals topicals;\n\n    @Autowired\n    public ProjectsController(ProjectMetadataService projectMetadataService,\n                              GettingStartedGuides gsGuides, Tutorials tutorials, Topicals topicals) {\n        this.projectMetadataService = projectMetadataService;\n        this.gsGuides = gsGuides;\n        this.tutorials = tutorials;\n        this.topicals = topicals;\n    }\n\n\t@RequestMapping(method = { GET, HEAD })\n\tpublic String listProjects(Model model) {\n    \tthis.projectMetadataService.getProjects()\n\t\t\t\t.forEach(project -> model.addAttribute(project.getId().replaceAll(\"-\", \"\"), project));\n\t\treturn \"projects/index\";\n\t}\n\n\t@RequestMapping(value = \"/{projectName}\", method = { GET, HEAD })\n    public String showProject(Model model, @PathVariable String projectName) {\n\t\tProject project = projectMetadataService.getProject(projectName);\n\t\tif (project == null) {\n\t\t\tthrow new ResourceNotFoundException(\"project \" + projectName);\n\t\t}\n        List<Project> projects = this.projectMetadataService.getActiveTopLevelProjects();\n        model.addAttribute(\"selectedProject\", project);\n        model.addAttribute(\"projectStackOverflow\", stackOverflowUrl(project));\n        model.addAttribute(\"projects\", projects);\n        model.addAttribute(\"currentRelease\", project.getMostCurrentRelease());\n        model.addAttribute(\"otherReleases\", project.getNonMostCurrentReleases());\n\n        model.addAttribute(\"guides\", Arrays.asList(gsGuides.findByProject(project)));\n        model.addAttribute(\"topicals\", Arrays.asList(topicals.findByProject(project)));\n        model.addAttribute(\"tutorials\", Arrays.asList(tutorials.findByProject(project)));\n\n        return \"projects/show\";\n    }\n\n    private String stackOverflowUrl(Project project) {\n        return \"https://stackoverflow.com/questions/tagged/\"\n                + Joiner.on(\"+or+\").join(project.getStackOverflowTagList());\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class EdgeDetectionEffect extends Effect {\n\t\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat();\n\t\tImgproc.Canny(frame, newFrame, 80, 100);\n\t\tImgproc.cvtColor(newFrame, newFrame, Imgproc.COLOR_GRAY2BGRA, 4);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Edge Detection\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Entity\n@SuppressWarnings(\"serial\")\npublic class Post {\n\n    private static final SimpleDateFormat SLUG_DATE_FORMAT = new SimpleDateFormat(\"yyyy/MM/dd\");\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @ManyToOne(cascade = CascadeType.PERSIST, optional = false)\n    private MemberProfile author;\n\n    @Column(nullable = false)\n    private String title;\n\n    @Column(nullable = false)\n    @Enumerated(EnumType.STRING)\n    private PostCategory category;\n\n    @Column(nullable = false)\n    @Enumerated(EnumType.STRING)\n    private PostFormat format;\n\n    @Column(nullable = false)\n    @Type(type = \"text\")\n    private String rawContent;\n\n    @Column(nullable = false)\n    @Type(type = \"text\")\n    private String renderedContent;\n\n    @Column(nullable = false)\n    @Type(type = \"text\")\n    private String renderedSummary;\n\n    @Column(nullable = false)\n    private Date createdAt = new Date();\n\n    @Column(nullable = false)\n    private boolean draft = true;\n\n    @Column(nullable = false)\n    private boolean broadcast = false;\n\n    @Column(nullable = true)\n    private Date publishAt;\n\n    @Column(nullable = true)\n    private String publicSlug;\n\n    @ElementCollection\n    private Set<String> publicSlugAliases = new HashSet<>();\n\n    @SuppressWarnings(\"unused\")\n    private Post() {\n    }\n\n    public Post(String title, String content, PostCategory category, PostFormat format) {\n        this.title = title;\n        this.rawContent = content;\n        this.category = category;\n        this.format = format;\n    }\n\n    \n    public Post(Long id, String title, String content, PostCategory category, PostFormat format) {\n        this(title, content, category, format);\n        this.id = id;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public MemberProfile getAuthor() {\n        return author;\n    }\n\n    public void setAuthor(MemberProfile author) {\n        this.author = author;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public PostCategory getCategory() {\n        return category;\n    }\n\n    public void setCategory(PostCategory category) {\n        this.category = category;\n    }\n\n    public PostFormat getFormat() {\n        return format;\n    }\n\n    public void setFormat(PostFormat format) {\n        this.format = format;\n    }\n\n    public String getRawContent() {\n        return rawContent;\n    }\n\n    public void setRawContent(String rawContent) {\n        this.rawContent = rawContent;\n    }\n\n    public String getRenderedContent() {\n        return renderedContent;\n    }\n\n    public void setRenderedContent(String renderedContent) {\n        this.renderedContent = renderedContent;\n    }\n\n    public String getRenderedSummary() {\n        return renderedSummary;\n    }\n\n    public void setRenderedSummary(String renderedSummary) {\n        this.renderedSummary = renderedSummary;\n    }\n\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    public Date getPublishAt() {\n        return publishAt;\n    }\n\n    public void setPublishAt(Date publishAt) {\n        this.publishAt = publishAt;\n        publicSlug = publishAt == null ? null : generatePublicSlug();\n    }\n\n    public boolean isDraft() {\n        return draft;\n    }\n\n    public void setDraft(boolean draft) {\n        this.draft = draft;\n    }\n\n    public void setBroadcast(boolean isBroadcast) {\n        broadcast = isBroadcast;\n    }\n\n    public boolean isBroadcast() {\n        return broadcast;\n    }\n\n    @JsonIgnore\n    public boolean isScheduled() {\n        return publishAt == null;\n    }\n\n    @JsonIgnore\n    public boolean isLiveOn(Date date) {\n        return !(isDraft() || publishAt.after(date));\n    }\n\n    public String getPublicSlug() {\n        return publicSlug;\n    }\n\n    public void addPublicSlugAlias(String alias) {\n        if (alias != null) {\n            this.publicSlugAliases.add(alias);\n        }\n    }\n\n    @JsonIgnore\n    public String getAdminSlug() {\n        return String.format(\"%s-%s\", getId(), getSlug());\n    }\n\n    private String generatePublicSlug() {\n        return String.format(\"%s/%s\", SLUG_DATE_FORMAT.format(getPublishAt()), getSlug());\n    }\n\n    @JsonIgnore\n    private String getSlug() {\n        if (title == null) {\n            return \"\";\n        }\n\n        String cleanedTitle = title.toLowerCase().replace(\"\\n\", \" \").replaceAll(\"[^a-z\\\\d\\\\s]\", \" \");\n        return StringUtils.arrayToDelimitedString(StringUtils.tokenizeToStringArray(cleanedTitle, \" \"), \"-\");\n    }\n\n    @Override\n    public String toString() {\n        return \"Post{\" + \"id=\" + id + \", title='\" + title + '\\'' + '}';\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n@Entity\n@NamedEntityGraph(name = \"Project.tree\",\n        attributeNodes = @NamedAttributeNode(\"childProjectList\"))\n@JsonIgnoreProperties(ignoreUnknown = true)\n@JsonInclude(value = JsonInclude.Include.NON_NULL)\npublic class Project {\n\n    @Id\n    private String id;\n    private String name;\n    private String repoUrl;\n    private String siteUrl;\n    private String category;\n    private String rawBootConfig;\n    private String renderedBootConfig;\n    private String rawOverview;\n    private String renderedOverview;\n    private int displayOrder = Integer.MAX_VALUE;\n\n    @ManyToOne\n    @JsonIgnore\n    private Project parentProject;\n\n    @OneToMany(mappedBy = \"parentProject\")\n    @OrderBy(\"displayOrder\")\n    private List<Project> childProjectList;\n\n    @ElementCollection\n    private List<ProjectRelease> releaseList = new ArrayList<>();\n    private String stackOverflowTags;\n\n    @ElementCollection\n    private List<ProjectSample> sampleList = new ArrayList<>();\n\n    @SuppressWarnings(\"unused\")\n    private Project() {\n    }\n\n    public Project(String id, String name, String repoUrl, String siteUrl,\n                   List<ProjectRelease> releaseList, String category) {\n        this.id = id;\n        this.name = name;\n        this.repoUrl = repoUrl;\n        this.siteUrl = siteUrl;\n        this.releaseList = releaseList;\n        this.category = category;\n    }\n\n    public Project(String id, String name, String repoUrl, String siteUrl, int displayOrder, List<ProjectRelease> releaseList,\n                   String category, String stackOverflowTags, String bootconfig) {\n        this(id, name, repoUrl, siteUrl, releaseList, category);\n        this.setDisplayOrder(displayOrder);\n        this.setStackOverflowTags(stackOverflowTags);\n        this.setRawBootConfig(bootconfig);\n    }\n\n    public String getCategory() {\n        return category;\n    }\n\n    public void setCategory(String category) {\n        this.category = category;\n    }\n\n    public void setProjectReleases(List<ProjectRelease> releases) {\n        this.releaseList = releases;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setRepoUrl(String repoUrl) {\n        this.repoUrl = repoUrl;\n    }\n\n    public void setSiteUrl(String siteUrl) {\n        this.siteUrl = siteUrl;\n    }\n\n    public void setReleaseList(List<ProjectRelease> releaseList) {\n        this.releaseList = releaseList;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    \n    public List<ProjectRelease> getProjectReleases() {\n        if (releaseList == null) {\n            return new ArrayList<>();\n        }\n        releaseList.sort(Collections.reverseOrder(ProjectRelease::compareTo));\n        return releaseList;\n    }\n\n    public String getRepoUrl() {\n        return repoUrl;\n    }\n\n    public String getSiteUrl() {\n        return siteUrl;\n    }\n\n    public boolean hasSite() {\n        return !siteUrl.isEmpty();\n    }\n\n    public String getStackOverflowTags() {\n        return stackOverflowTags;\n    }\n\n    public void setStackOverflowTags(String stackOverflowTags) {\n        this.stackOverflowTags = stackOverflowTags != null ?\n                stackOverflowTags.replaceAll(\" \", \"\") : \"\";\n    }\n\n    public Set<String> getStackOverflowTagList() {\n        return StringUtils.commaDelimitedListToSet(this.stackOverflowTags);\n    }\n\n    public String getRawBootConfig() {\n        return rawBootConfig;\n    }\n\n    public void setRawBootConfig(String rawBootConfig) {\n        this.rawBootConfig = rawBootConfig;\n    }\n\n    public String getRenderedBootConfig() {\n        return renderedBootConfig;\n    }\n\n    public void setRenderedBootConfig(String renderedBootConfig) {\n        this.renderedBootConfig = renderedBootConfig;\n    }\n\n    public String getRawOverview() {\n        return rawOverview;\n    }\n\n    public void setRawOverview(String rawOverview) {\n        this.rawOverview = rawOverview;\n    }\n\n    public String getRenderedOverview() {\n        return renderedOverview;\n    }\n\n    public void setRenderedOverview(String renderedOverview) {\n        this.renderedOverview = renderedOverview;\n    }\n\n    public int getDisplayOrder() {\n        return displayOrder;\n    }\n\n    public void setDisplayOrder(int displayOrder) {\n        this.displayOrder = displayOrder;\n    }\n\n    public Project getParentProject() {\n        return parentProject;\n    }\n\n    public String getParentId() {\n        if (parentProject == null) {\n            return null;\n        }\n\n        return parentProject.getId();\n    }\n\n    public void setParentProject(Project parentProject) {\n        this.parentProject = parentProject;\n    }\n\n    public List<Project> getChildProjectList() {\n        return childProjectList;\n    }\n\n    public void setChildProjectList(List<Project> childProjectList) {\n        this.childProjectList = childProjectList;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n\n        Project project = (Project) o;\n\n        if (id != null ? !id.equals(project.id) : project.id != null)\n            return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return id != null ? id.hashCode() : 0;\n    }\n\n    @Override\n    public String toString() {\n        return \"Project{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", repoUrl='\" + repoUrl + '\\'' +\n                \", siteUrl='\" + siteUrl + '\\'' +\n                \", releaseList=\" + releaseList +\n                \", stackOverflowTags=\" + stackOverflowTags +\n                '}';\n    }\n\n    public boolean updateProjectRelease(ProjectRelease release) {\n        boolean found = false;\n        List<ProjectRelease> releases = getProjectReleases();\n        for (int i = 0; i < releases.size(); i++) {\n            ProjectRelease projectRelease = releases.get(i);\n            if (release.getRepository() != null && release.getRepository().equals(projectRelease.getRepository())) {\n                release.setRepository(projectRelease.getRepository());\n            }\n            if (projectRelease.getVersion().equals(release.getVersion())) {\n                releases.set(i, release);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            releases.add(release);\n        }\n        release.replaceVersionPattern();\n        return found;\n    }\n\n    public ProjectRelease removeProjectRelease(String version) {\n        List<ProjectRelease> releases = getProjectReleases();\n        ProjectRelease release = null;\n        for (int i = 0; i < releases.size(); i++) {\n            ProjectRelease projectRelease = releases.get(i);\n            if (projectRelease.getVersion().equals(version)) {\n                release = releases.remove(i);\n                return release;\n            }\n        }\n        return null;\n    }\n\n    public ProjectRelease getProjectRelease(String version) {\n        List<ProjectRelease> releases = getProjectReleases();\n        for (ProjectRelease release : releases) {\n            if (release.getVersion().equals(version)) {\n                return release;\n            }\n        }\n        return null;\n    }\n\n    public Optional<ProjectRelease> getMostCurrentRelease() {\n        return this.getProjectReleases().stream()\n                .filter(ProjectRelease::isCurrent)\n                .findFirst();\n    }\n\n    public List<ProjectRelease> getNonMostCurrentReleases() {\n        Optional<ProjectRelease> mostCurrentRelease = this.getMostCurrentRelease();\n        if (mostCurrentRelease.isPresent()) {\n            return this.getProjectReleases().stream()\n                    .filter(projectRelease -> !projectRelease.equals(mostCurrentRelease.get()))\n                    .collect(Collectors.toList());\n        }\n        else {\n            return this.getProjectReleases();\n        }\n    }\n\n    public boolean isTopLevelProject() {\n        return parentProject == null;\n    }\n\n    public List<ProjectSample> getProjectSamples() {\n        sampleList.sort(Comparator.comparingInt(ProjectSample::getDisplayOrder));\n        return sampleList;\n    }\n\n    public void setProjectSamples(List<ProjectSample> sampleList) {\n        this.sampleList = sampleList;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\npublic final class WebSocketConnectHandlerDecoratorFactory implements WebSocketHandlerDecoratorFactory {\n\n\tprivate static final Log logger = LogFactory.getLog(WebSocketConnectHandlerDecoratorFactory.class);\n\n\tprivate final ApplicationEventPublisher eventPublisher;\n\n\t\n\tpublic WebSocketConnectHandlerDecoratorFactory(ApplicationEventPublisher eventPublisher) {\n\t\tAssert.notNull(eventPublisher, \"eventPublisher cannot be null\");\n\t\tthis.eventPublisher = eventPublisher;\n\t}\n\n\t@Override\n\tpublic WebSocketHandler decorate(WebSocketHandler handler) {\n\t\treturn new SessionWebSocketHandler(handler);\n\t}\n\n\tprivate final class SessionWebSocketHandler extends WebSocketHandlerDecorator {\n\n\t\tSessionWebSocketHandler(WebSocketHandler delegate) {\n\t\t\tsuper(delegate);\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterConnectionEstablished(WebSocketSession wsSession) throws Exception {\n\t\t\tsuper.afterConnectionEstablished(wsSession);\n\n\t\t\tpublishEvent(new SessionConnectEvent(this, wsSession));\n\t\t}\n\n\t\tprivate void publishEvent(ApplicationEvent event) {\n\t\t\ttry {\n\t\t\t\tWebSocketConnectHandlerDecoratorFactory.this.eventPublisher.publishEvent(event);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.error(\"Error publishing \" + event + \".\", ex);\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "nl": "spring"}
{"code": "    \n\n\n\n\n@SpringBootApplication\npublic class Application {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(Application.class);\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class);\n\t}\n\n\t@Bean\n\tpublic CommandLineRunner demo(CustomerRepository repository) {\n\t\treturn (args) -> {\n\t\t\trepository.save(new Customer(\"Jack\", \"Bauer\"));\n\t\t\trepository.save(new Customer(\"Chloe\", \"O'Brian\"));\n\t\t\trepository.save(new Customer(\"Kim\", \"Bauer\"));\n\t\t\trepository.save(new Customer(\"David\", \"Palmer\"));\n\t\t\trepository.save(new Customer(\"Michelle\", \"Dessler\"));\n\n\t\t\tlog.info(\"Customers found with findAll():\");\n\t\t\tlog.info(\"-------------------------------\");\n\t\t\tfor (Customer customer : repository.findAll()) {\n\t\t\t\tlog.info(customer.toString());\n\t\t\t}\n\t\t\tlog.info(\"\");\n\n\t\t\trepository.findById(1L)\n\t\t\t\t.ifPresent(customer -> {\n\t\t\t\t\tlog.info(\"Customer found with findById(1L):\");\n\t\t\t\t\tlog.info(\"--------------------------------\");\n\t\t\t\t\tlog.info(customer.toString());\n\t\t\t\t\tlog.info(\"\");\n\t\t\t\t});\n\n\t\t\tlog.info(\"Customer found with findByLastName('Bauer'):\");\n\t\t\tlog.info(\"--------------------------------------------\");\n\t\t\trepository.findByLastName(\"Bauer\").forEach(bauer -> {\n\t\t\t\tlog.info(bauer.toString());\n\t\t\t});\n\t\t\tlog.info(\"\");\n\t\t};\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class CannyEdgeDetection {\n   public static void main(String args[]) throws Exception {\n      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n      String file = \"E:/OpenCV/chap17/canny_input.jpg\";\n\n      Mat src = Imgcodecs.imread(file);\n\n      Mat gray = new Mat();\n\n      Imgproc.cvtColor(src, gray, Imgproc.COLOR_BGR2GRAY);\n      Mat edges = new Mat();\n\n      Imgproc.Canny(gray, edges, 60, 60*3);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap17/canny_output.jpg\", edges);\n      System.out.println(\"Image Loaded\");\n   } \n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Controller\npublic class FileUploadController {\n\n    private final StorageService storageService;\n\n    @Autowired\n    public FileUploadController(StorageService storageService) {\n        this.storageService = storageService;\n    }\n\n    @GetMapping(\"/\")\n    public String listUploadedFiles(Model model) throws IOException {\n\n        model.addAttribute(\"files\", storageService.loadAll().map(\n                path -> MvcUriComponentsBuilder.fromMethodName(FileUploadController.class,\n                        \"serveFile\", path.getFileName().toString()).build().toString())\n                .collect(Collectors.toList()));\n\n        return \"uploadForm\";\n    }\n\n    @GetMapping(\"/files/{filename:.+}\")\n    @ResponseBody\n    public ResponseEntity<Resource> serveFile(@PathVariable String filename) {\n\n        Resource file = storageService.loadAsResource(filename);\n        return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,\n                \"attachment; filename=\\\"\" + file.getFilename() + \"\\\"\").body(file);\n    }\n\n    @PostMapping(\"/\")\n    public String handleFileUpload(@RequestParam(\"file\") MultipartFile file,\n            RedirectAttributes redirectAttributes) {\n\n        storageService.store(file);\n        redirectAttributes.addFlashAttribute(\"message\",\n                \"You successfully uploaded \" + file.getOriginalFilename() + \"!\");\n\n        return \"redirect:/\";\n    }\n\n    @ExceptionHandler(StorageFileNotFoundException.class)\n    public ResponseEntity<?> handleStorageFileNotFound(StorageFileNotFoundException exc) {\n        return ResponseEntity.notFound().build();\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class Features implements SVMCallback {\n\n    enum Direction {\n        VERTICAL, HORIZONTAL\n    }\n\n    public Mat getHistogramFeatures(Mat image) {\n        Mat grayImage = new Mat();\n        Imgproc.cvtColor(image, grayImage, Imgproc.COLOR_BGR2GRAY);\n\n        Mat img_threshold = new Mat();\n        Imgproc.threshold(grayImage, img_threshold, 0, 255, Imgproc.THRESH_OTSU);\n\n        return features(img_threshold, 0);\n    }\n\n    \n    private float[] projectedHistogram(Mat img, Direction direction) {\n        int sz = 0;\n        switch (direction) {\n            case HORIZONTAL:\n                sz = img.rows();\n                break;\n\n            case VERTICAL:\n                sz = img.cols();\n                break;\n\n            default:\n                break;\n        }\n\n        float[] nonZeroMat = new float[sz];\n        Core.extractChannel(img, img, 0);\n        for (int j = 0; j < sz; j++) {\n            Mat data = (direction == Direction.HORIZONTAL) ? img.row(j) : img.col(j);\n            int count = Core.countNonZero(data);\n            nonZeroMat[j] = count;\n        }\n\n        float max = 0;\n        for (int j = 0; j < nonZeroMat.length; ++j) {\n            max = Math.max(max, nonZeroMat[j]);\n        }\n\n        if (max > 0) {\n            for (int j = 0; j < nonZeroMat.length; ++j) {\n                nonZeroMat[j] /= max;\n            }\n        }\n\n        return nonZeroMat;\n    }\n\n    \n    private Mat features(Mat in, int sizeData) {\n        float[] vhist = projectedHistogram(in, Direction.VERTICAL);\n        float[] hhist = projectedHistogram(in, Direction.HORIZONTAL);\n\n        Mat lowData = new Mat();\n        if (sizeData > 0) {\n            Imgproc.resize(in, lowData, new Size(sizeData, sizeData));\n        }\n\n        int numCols = vhist.length + hhist.length + lowData.cols() * lowData.rows();\n        Mat out = new Mat();\n        out.create(1, numCols, CvType.CV_32F);\n\n        int j = 0;\n        for (int i = 0; i < vhist.length; i++, j++) {\n            out.put(0, j, vhist[i]);\n        }\n\n        for (int i = 0; i < hhist.length; i++, j++) {\n            out.put(0, j, hhist[i]);\n        }\n\n        for (int x = 0; x < lowData.rows(); x++) {\n            for (int y = 0; y < lowData.cols(); y++, j++) {\n                float[] arr = new float[1];\n                lowData.get(x, y, arr);\n                out.put(0, j, arr[0]);\n            }\n        }\n        return out;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class HoughCircleEffect extends Effect {\n\t\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat();\n\t\tImgproc.cvtColor( frame, newFrame, Imgproc.COLOR_BGR2GRAY );\n\t\tImgproc.GaussianBlur( newFrame, newFrame,new Size(9, 9), 2, 2 );\n\t\tImgproc.Canny(frame, newFrame, 80, 100);\n\n\t\tMat circles = new Mat();\n\n\t\tImgproc.HoughCircles( newFrame, circles, Imgproc.CV_HOUGH_GRADIENT, 1, newFrame.rows()/8, 200, 100, 0, 0 );\n\n\t\tfor( int i = 0; i < circles.cols(); i++ )\n\t\t{\n\t\t\tdouble vCircle[] = circles.get(0,i);\n\t\t\tif (vCircle == null) break;\n\n\t\t\tPoint center = new Point(Math.round(vCircle[0]), Math.round(vCircle[1]));\n\t\t\tint  radius = (int)Math.round(vCircle[2]);\n\n\t\t\tImgproc.circle( frame, center, 3, new Scalar(0,255,0), -1, 8, 0 );\n\t\t\tImgproc.circle( frame, center, radius, new Scalar(0,0,255), 3, 8, 0 );\n\t\t}\n\n\n\t\tframe.copyTo(newFrame);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"Circle Detection\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n@Service\nclass SearchResultParser {\n\n    public SearchResults parseResults(JestResult jestResult, Pageable pageable, String originalSearchTerm) {\n        JsonObject response = jestResult.getJsonObject();\n        JsonObject hits = response.getAsJsonObject(\"hits\");\n        JsonArray resultsArray = hits.getAsJsonArray(\"hits\");\n\n        ArrayList<SearchResult> results = prepareResults(resultsArray, originalSearchTerm);\n\n        int totalResults = hits.get(\"total\").getAsInt();\n        PageImpl<SearchResult> page = new PageImpl<>(results, pageable, totalResults);\n\n        List<SearchFacet> facets = prepareFacets(response);\n        return new SearchResults(page, facets);\n    }\n\n    private List<SearchFacet> prepareFacets(JsonObject response) {\n        JsonObject facets = response.getAsJsonObject(\"facets\");\n        if (facets == null) {\n            return Collections.emptyList();\n        }\n        JsonObject pathsResult = facets.getAsJsonObject(\"facet_paths_result\");\n        List<JsonElement> terms = sortedTermElements(pathsResult.getAsJsonArray(\"terms\"));\n\n        SearchFacetTreeBuilder builder = new SearchFacetTreeBuilder();\n\n        for (JsonElement element : terms) {\n            JsonObject jsonObject = element.getAsJsonObject();\n            String term = jsonObject.get(\"term\").getAsString();\n            int count = jsonObject.get(\"count\").getAsInt();\n            builder.addTerm(term, count);\n        }\n\n        return builder.build();\n    }\n\n    private List<JsonElement> sortedTermElements(JsonArray termArray) {\n        ArrayList<JsonElement> list = Lists.newArrayList(termArray);\n        Collections.sort(list, (o1, o2) -> {\n            String term1 = o1.getAsJsonObject().get(\"term\").getAsString().replace(\" \", \"\");\n            String term2 = o2.getAsJsonObject().get(\"term\").getAsString().replace(\" \", \"\");\n            return term1.compareTo(term2);\n        });\n        return list;\n    }\n\n    private ArrayList<SearchResult> prepareResults(JsonArray hits, String originalSearchTerm) {\n        ArrayList<SearchResult> results = new ArrayList<>();\n        for (JsonElement element : hits) {\n            JsonObject hit = element.getAsJsonObject();\n            String id = hit.get(\"_id\").getAsString();\n\n            JsonObject source = hit.getAsJsonObject(\"_source\");\n            String title = source.get(\"title\").getAsString();\n            String url = source.get(\"path\").getAsString();\n            String type = hit.get(\"_type\").getAsString();\n            String summary = source.get(\"summary\").getAsString();\n            String subtitle = safelyLookupFieldString(source, \"subTitle\");\n\n            String highlight = extractHighlight(hit);\n\n            SearchResult result =\n                    new SearchResult(id, title, subtitle, summary, url, type, highlight, originalSearchTerm);\n            results.add(result);\n        }\n        return results;\n    }\n\n    private String safelyLookupFieldString(JsonObject source, String field) {\n        JsonElement fieldElement = source.get(field);\n        return (fieldElement != null) ? fieldElement.getAsString() : \"\";\n    }\n\n    private String extractHighlight(JsonObject hit) {\n        String summary = null;\n        JsonObject highlight = hit.getAsJsonObject(\"highlight\");\n\n        if (highlight != null) {\n            JsonArray rawContent = highlight.getAsJsonArray(\"rawContent\");\n            summary = rawContent.get(0).getAsString();\n        }\n\n        return summary;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class DescriptorMatcher {\n\n    protected final long nativeObj;\n    protected DescriptorMatcher(long addr) { nativeObj = addr; }\n\n\n    public static final int\n            FLANNBASED = 1,\n            BRUTEFORCE = 2,\n            BRUTEFORCE_L1 = 3,\n            BRUTEFORCE_HAMMING = 4,\n            BRUTEFORCE_HAMMINGLUT = 5,\n            BRUTEFORCE_SL2 = 6;\n\n\n\n    public  boolean isMaskSupported()\n    {\n        \n        boolean retVal = isMaskSupported_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  void add(List<Mat> descriptors)\n    {\n        Mat descriptors_mat = Converters.vector_Mat_to_Mat(descriptors);\n        add_0(nativeObj, descriptors_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  List<Mat> getTrainDescriptors()\n    {\n        List<Mat> retVal = new ArrayList<Mat>();\n        Mat retValMat = new Mat(getTrainDescriptors_0(nativeObj));\n        Converters.Mat_to_vector_Mat(retValMat, retVal);\n        return retVal;\n    }\n\n\n\n    public  void clear()\n    {\n        \n        clear_0(nativeObj);\n        \n        return;\n    }\n\n\n\n    public  boolean empty()\n    {\n        \n        boolean retVal = empty_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  void train()\n    {\n        \n        train_0(nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches, Mat mask)\n    {\n        Mat matches_mat = matches;\n        match_0(nativeObj, queryDescriptors.nativeObj, trainDescriptors.nativeObj, matches_mat.nativeObj, mask.nativeObj);\n        \n        return;\n    }\n\n    public  void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches)\n    {\n        Mat matches_mat = matches;\n        match_1(nativeObj, queryDescriptors.nativeObj, trainDescriptors.nativeObj, matches_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k, Mat mask, boolean compactResult)\n    {\n        Mat matches_mat = new Mat();\n        knnMatch_0(nativeObj, queryDescriptors.nativeObj, trainDescriptors.nativeObj, matches_mat.nativeObj, k, mask.nativeObj, compactResult);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n    public  void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k)\n    {\n        Mat matches_mat = new Mat();\n        knnMatch_1(nativeObj, queryDescriptors.nativeObj, trainDescriptors.nativeObj, matches_mat.nativeObj, k);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n\n\n    public  void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance, Mat mask, boolean compactResult)\n    {\n        Mat matches_mat = new Mat();\n        radiusMatch_0(nativeObj, queryDescriptors.nativeObj, trainDescriptors.nativeObj, matches_mat.nativeObj, maxDistance, mask.nativeObj, compactResult);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n    public  void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance)\n    {\n        Mat matches_mat = new Mat();\n        radiusMatch_1(nativeObj, queryDescriptors.nativeObj, trainDescriptors.nativeObj, matches_mat.nativeObj, maxDistance);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n\n\n    public  void match(Mat queryDescriptors, MatOfDMatch matches, List<Mat> masks)\n    {\n        Mat matches_mat = matches;\n        Mat masks_mat = Converters.vector_Mat_to_Mat(masks);\n        match_2(nativeObj, queryDescriptors.nativeObj, matches_mat.nativeObj, masks_mat.nativeObj);\n        \n        return;\n    }\n\n    public  void match(Mat queryDescriptors, MatOfDMatch matches)\n    {\n        Mat matches_mat = matches;\n        match_3(nativeObj, queryDescriptors.nativeObj, matches_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k, List<Mat> masks, boolean compactResult)\n    {\n        Mat matches_mat = new Mat();\n        Mat masks_mat = Converters.vector_Mat_to_Mat(masks);\n        knnMatch_2(nativeObj, queryDescriptors.nativeObj, matches_mat.nativeObj, k, masks_mat.nativeObj, compactResult);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n    public  void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k)\n    {\n        Mat matches_mat = new Mat();\n        knnMatch_3(nativeObj, queryDescriptors.nativeObj, matches_mat.nativeObj, k);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n\n\n    public  void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance, List<Mat> masks, boolean compactResult)\n    {\n        Mat matches_mat = new Mat();\n        Mat masks_mat = Converters.vector_Mat_to_Mat(masks);\n        radiusMatch_2(nativeObj, queryDescriptors.nativeObj, matches_mat.nativeObj, maxDistance, masks_mat.nativeObj, compactResult);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n    public  void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance)\n    {\n        Mat matches_mat = new Mat();\n        radiusMatch_3(nativeObj, queryDescriptors.nativeObj, matches_mat.nativeObj, maxDistance);\n        Converters.Mat_to_vector_vector_DMatch(matches_mat, matches);\n        matches_mat.release();\n        return;\n    }\n\n\n\n    public  DescriptorMatcher clone(boolean emptyTrainData)\n    {\n        \n        DescriptorMatcher retVal = new DescriptorMatcher(clone_0(nativeObj, emptyTrainData));\n        \n        return retVal;\n    }\n\n    public  DescriptorMatcher clone()\n    {\n        \n        DescriptorMatcher retVal = new DescriptorMatcher(clone_1(nativeObj));\n        \n        return retVal;\n    }\n\n\n\n    public static DescriptorMatcher create(int matcherType)\n    {\n        \n        DescriptorMatcher retVal = new DescriptorMatcher(create_0(matcherType));\n        \n        return retVal;\n    }\n\n\n\n    public  void write(String fileName)\n    {\n        \n        write_0(nativeObj, fileName);\n        \n        return;\n    }\n\n\n\n    public  void read(String fileName)\n    {\n        \n        read_0(nativeObj, fileName);\n        \n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n    private static native boolean isMaskSupported_0(long nativeObj);\n\n    private static native void add_0(long nativeObj, long descriptors_mat_nativeObj);\n\n    private static native long getTrainDescriptors_0(long nativeObj);\n\n    private static native void clear_0(long nativeObj);\n\n    private static native boolean empty_0(long nativeObj);\n\n    private static native void train_0(long nativeObj);\n\n    private static native void match_0(long nativeObj, long queryDescriptors_nativeObj, long trainDescriptors_nativeObj, long matches_mat_nativeObj, long mask_nativeObj);\n    private static native void match_1(long nativeObj, long queryDescriptors_nativeObj, long trainDescriptors_nativeObj, long matches_mat_nativeObj);\n\n    private static native void knnMatch_0(long nativeObj, long queryDescriptors_nativeObj, long trainDescriptors_nativeObj, long matches_mat_nativeObj, int k, long mask_nativeObj, boolean compactResult);\n    private static native void knnMatch_1(long nativeObj, long queryDescriptors_nativeObj, long trainDescriptors_nativeObj, long matches_mat_nativeObj, int k);\n\n    private static native void radiusMatch_0(long nativeObj, long queryDescriptors_nativeObj, long trainDescriptors_nativeObj, long matches_mat_nativeObj, float maxDistance, long mask_nativeObj, boolean compactResult);\n    private static native void radiusMatch_1(long nativeObj, long queryDescriptors_nativeObj, long trainDescriptors_nativeObj, long matches_mat_nativeObj, float maxDistance);\n\n    private static native void match_2(long nativeObj, long queryDescriptors_nativeObj, long matches_mat_nativeObj, long masks_mat_nativeObj);\n    private static native void match_3(long nativeObj, long queryDescriptors_nativeObj, long matches_mat_nativeObj);\n\n    private static native void knnMatch_2(long nativeObj, long queryDescriptors_nativeObj, long matches_mat_nativeObj, int k, long masks_mat_nativeObj, boolean compactResult);\n    private static native void knnMatch_3(long nativeObj, long queryDescriptors_nativeObj, long matches_mat_nativeObj, int k);\n\n    private static native void radiusMatch_2(long nativeObj, long queryDescriptors_nativeObj, long matches_mat_nativeObj, float maxDistance, long masks_mat_nativeObj, boolean compactResult);\n    private static native void radiusMatch_3(long nativeObj, long queryDescriptors_nativeObj, long matches_mat_nativeObj, float maxDistance);\n\n    private static native long clone_0(long nativeObj, boolean emptyTrainData);\n    private static native long clone_1(long nativeObj);\n\n    private static native long create_0(int matcherType);\n\n    private static native void write_0(long nativeObj, String fileName);\n\n    private static native void read_0(long nativeObj, String fileName);\n\n    private static native void delete(long nativeObj);\n\n}", "nl": "opencv"}
{"code": "\npublic class DistanceMeasurement {\n\n  private static final double FOCAL_LENGTH = 906.107;//focal length in pixels obtained from Calibration class\n  private static final double RADIUS_OF_MARKER = 1.0;\n  private static final OpenCVFrameConverter.ToIplImage converter = new OpenCVFrameConverter.ToIplImage();\n\n  public static boolean isPixelBlue(Mat image, int x, int y) {\n      if (x < 0 || y < 0) {\n          return false;\n      }\n      UByteIndexer srcIndexer = image.createIndexer();\n      int[] hsv = new int[3];\n      boolean blue = false;\n      for (int i = 0; i < srcIndexer.rows(); i++) {\n          for (int j = 0; j < srcIndexer.cols(); j++) {\n              if (j == x && i == y) {\n                  srcIndexer.get(i, j, hsv);\n                  if (hsv[0] >= 100 && hsv[0] <= 130 && hsv[1] >= 50 && hsv[1] <= 255 && hsv[2] >= 50 && hsv[2] <= 255) {\n                      blue = true;\n                  }\n              }\n          }\n      }\n      return blue;\n  }\n\n  public static void main(String[] args) {\n      try {\n          OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(0);\n          grabber.start();\n          CanvasFrame canvas = new CanvasFrame(\"Distance Measurement - Emaraic\");\n\n          canvas.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n          canvas.setCanvasSize(660, 660);\n          canvas.setLocationRelativeTo(null);\n          while (true) {\n              Frame frame = grabber.grab();\n              IplImage grabbedImage = converter.convert(frame);\n\n              if (grabbedImage != null && canvas.isVisible()) {\n                  Mat img = converter.convertToMat(frame);\n\n                  \n                  Size size = new Size(640, 640);\n                  resize(img, img, size);\n                  grabbedImage = new IplImage(img);\n\n                  \n                  Mat imghsv = new Mat();\n                  cvtColor(img, imghsv, COLOR_BGR2HSV);\n\n                  \n                  IplImage gray = cvCreateImage(cvGetSize(grabbedImage), IPL_DEPTH_8U, 1);\n                  cvCvtColor(grabbedImage, gray, CV_BGR2GRAY);\n\n\n                  \n                  IplImage binimg = cvCreateImage(cvGetSize(gray), IPL_DEPTH_8U, 1);\n                  cvThreshold(gray, binimg, 0, 255, CV_THRESH_OTSU);\n\n                  \n                  CvMemStorage storage = cvCreateMemStorage(0);\n                  CvSeq contours = new CvSeq();\n                  cvFindContours(binimg, storage, contours, Loader.sizeof(CvContour.class), CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE, cvPoint(0, 0));\n                  CvSeq ptr = new CvSeq();\n                  Mat m = new Mat(grabbedImage);\n                  for (ptr = contours; ptr != null; ptr = ptr.h_next()) {\n                      \n                      Point2f center = new Point2f();\n                      FloatPointer radius = new FloatPointer(1f);\n                      opencv_imgproc.minEnclosingCircle(new Mat(ptr), center, radius);\n                      \n                      if (isPixelBlue(imghsv, (int) center.x(), (int) center.y())) {\n                          double area = contourArea(new Mat(ptr), true);\n                          if (area > 100) {\n                              cvCircle(grabbedImage, new CvPoint((int) center.x(), (int) center.y()), (int) radius.get(0),\n                                      CV_RGB(0, 255, 0), 3, 0, 0);\n                              float rad = radius.get(0);\n                              System.out.println(\"Radius is \" + rad);\n                              double distance = (FOCAL_LENGTH * RADIUS_OF_MARKER) / rad;\n                              System.out.println(\"Distance in cm \" + distance);\n                              putText(m, \"Distance is : \" + distance + \" cm\", new Point(200, 100), 0, 0.5, new Scalar(0, 255, 0, 0));\n                          }\n                      }\n                  }//End for  countors\n                  canvas.showImage(converter.convert(m));\n                  Thread.sleep(150);\n              }//End if\n          }//End while\n      } catch (FrameGrabber.Exception | InterruptedException ex) {\n          ex.printStackTrace();\n      }\n  }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n@Controller\n@RequestMapping(\"/admin/blog\")\nclass BlogAdminController {\n\n    private BlogService service;\n    private TeamRepository teamRepository;\n    private DateFactory dateFactory;\n\n    @Autowired\n    public BlogAdminController(BlogService service, TeamRepository teamRepository, DateFactory dateFactory) {\n        this.service = service;\n        this.teamRepository = teamRepository;\n        this.dateFactory = dateFactory;\n    }\n\n    @RequestMapping(value = \"\", method = { GET, HEAD })\n    public String dashboard(Model model, @RequestParam(defaultValue = \"1\") int page) {\n        Page<PostView> postViewPage = PostView.pageOf(service.getPublishedPosts(PageableFactory.forDashboard(page)), dateFactory);\n        model.addAttribute(\"posts\", postViewPage);\n        model.addAttribute(\"paginationInfo\", new PaginationInfo(postViewPage));\n\n        if(page == 1) {\n            model.addAttribute(\"drafts\", PostView.pageOf(service.getDraftPosts(PageableFactory.all()), dateFactory));\n            model.addAttribute(\"scheduled\", PostView.pageOf(service.getScheduledPosts(PageableFactory.all()), dateFactory));\n        } else {\n            Page<PostView> emptyPage = new PageImpl<PostView>(Collections.emptyList(), PageableFactory.all(), 0);\n            model.addAttribute(\"drafts\", emptyPage);\n            model.addAttribute(\"scheduled\", emptyPage);\n        }\n\n        return \"admin/blog/index\";\n    }\n\n    @RequestMapping(value = \"/new\", method = { GET, HEAD })\n    public String newPost(Model model) {\n        model.addAttribute(\"postForm\", new PostForm());\n        model.addAttribute(\"categories\", PostCategory.values());\n        model.addAttribute(\"formats\", PostFormat.values());\n        return \"admin/blog/new\";\n    }\n\n    @RequestMapping(value = \"/{postId:[0-9]+}{slug:.*}/edit\", method = { GET, HEAD })\n    public String editPost(@PathVariable Long postId, @PathVariable String slug, Model model) {\n        Post post = service.getPost(postId);\n        PostForm postForm = new PostForm(post);\n        String path = PostView.of(post, dateFactory).getPath();\n\n        model.addAttribute(\"categories\", PostCategory.values());\n        model.addAttribute(\"formats\", PostFormat.values());\n        model.addAttribute(\"postForm\", postForm);\n        model.addAttribute(\"post\", post);\n        model.addAttribute(\"path\", path);\n        return \"admin/blog/edit\";\n    }\n\n    @RequestMapping(value = \"/{postId:[0-9]+}{slug:.*}\", method = { GET, HEAD })\n    public String showPost(@PathVariable Long postId, @PathVariable String slug, Model model) {\n        model.addAttribute(\"post\", PostView.of(service.getPost(postId), dateFactory));\n        return \"admin/blog/show\";\n    }\n\n    @RequestMapping(value = \"\", method = { POST })\n    public String createPost(Principal principal, @Valid PostForm postForm, BindingResult bindingResult, Model model) {\n        if (bindingResult.hasErrors()) {\n            model.addAttribute(\"categories\", PostCategory.values());\n            model.addAttribute(\"formats\", PostFormat.values());\n            return \"admin/blog/new\";\n        } else {\n            MemberProfile memberProfile = teamRepository.findById(new Long(principal.getName()));\n            try {\n                Post post = service.addPost(postForm, memberProfile.getUsername());\n                PostView postView = PostView.of(post, dateFactory);\n                return \"redirect:\" + postView.getPath() + \"/edit\";\n            } catch (DataIntegrityViolationException ex) {\n                model.addAttribute(\"categories\", PostCategory.values());\n                model.addAttribute(\"postForm\", postForm);\n                bindingResult.rejectValue(\"title\", \"duplicate_post\",\n                        \"A blog post with this publication date and title already exists\");\n                return \"admin/blog/new\";\n            }\n        }\n    }\n\n    @RequestMapping(value = \"/{postId:[0-9]+}{slug:.*}/edit\", method = PUT)\n    public String updatePost(@PathVariable Long postId, @Valid PostForm postForm, BindingResult bindingResult,\n                             Model model) {\n        Post post = service.getPost(postId);\n        if (!bindingResult.hasErrors()) {\n            service.updatePost(post, postForm);\n        }\n        PostView postView = PostView.of(post, dateFactory);\n        String path = postView.getPath();\n\n        model.addAttribute(\"categories\", PostCategory.values());\n        model.addAttribute(\"formats\", PostFormat.values());\n        model.addAttribute(\"post\", post);\n        model.addAttribute(\"path\", path);\n        return \"/admin/blog/edit\";\n    }\n\n    @RequestMapping(value = \"/{postId:[0-9]+}{slug:.*}\", method = DELETE)\n    public String deletePost(@PathVariable Long postId) {\n        Post post = service.getPost(postId);\n        service.deletePost(post);\n        return \"redirect:/admin/blog\";\n    }\n\n    @RequestMapping(value = \"resummarize\", method = POST)\n    public String resummarizeAllBlogPosts() {\n        service.resummarizeAllPosts();\n        return \"redirect:/admin/blog\";\n    }\n\n    @RequestMapping(value = \"refreshblogposts\", method = POST)\n    @ResponseBody\n    public String refreshBlogPosts(\n            @RequestParam(value=\"page\", defaultValue = \"1\", required = false) int page,\n            @RequestParam(value=\"size\", defaultValue = \"10\", required = false) int size) {\n        Page<Post> posts = service.refreshPosts(page, size);\n        return String.format(\"{page: %s, pageSize: %s, totalPages: %s, totalElements: %s}\",\n                posts.getNumber(), posts.getSize(), posts.getTotalPages(), posts.getTotalElements());\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\npublic final class WebSocketRegistryListener implements ApplicationListener<ApplicationEvent> {\n\n\tprivate static final Log logger = LogFactory.getLog(WebSocketRegistryListener.class);\n\n\tstatic final CloseStatus SESSION_EXPIRED_STATUS = new CloseStatus(CloseStatus.POLICY_VIOLATION.getCode(),\n\t\t\t\"This connection was established under an authenticated HTTP Session that has expired\");\n\n\tprivate final ConcurrentHashMap<String, Map<String, WebSocketSession>> httpSessionIdToWsSessions = new ConcurrentHashMap<>();\n\n\t@Override\n\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\tif (event instanceof SessionDestroyedEvent) {\n\t\t\tSessionDestroyedEvent e = (SessionDestroyedEvent) event;\n\t\t\tcloseWsSessions(e.getSessionId());\n\t\t}\n\t\telse if (event instanceof SessionConnectEvent) {\n\t\t\tSessionConnectEvent e = (SessionConnectEvent) event;\n\t\t\tafterConnectionEstablished(e.getWebSocketSession());\n\t\t}\n\t\telse if (event instanceof SessionDisconnectEvent) {\n\t\t\tSessionDisconnectEvent e = (SessionDisconnectEvent) event;\n\t\t\tMap<String, Object> sessionAttributes = SimpMessageHeaderAccessor\n\t\t\t\t\t.getSessionAttributes(e.getMessage().getHeaders());\n\t\t\tString httpSessionId = (sessionAttributes != null)\n\t\t\t\t\t? SessionRepositoryMessageInterceptor.getSessionId(sessionAttributes) : null;\n\t\t\tafterConnectionClosed(httpSessionId, e.getSessionId());\n\t\t}\n\t}\n\n\tprivate void afterConnectionEstablished(WebSocketSession wsSession) {\n\t\tPrincipal principal = wsSession.getPrincipal();\n\t\tif (principal == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString httpSessionId = getHttpSessionId(wsSession);\n\t\tregisterWsSession(httpSessionId, wsSession);\n\t}\n\n\tprivate String getHttpSessionId(WebSocketSession wsSession) {\n\t\tMap<String, Object> attributes = wsSession.getAttributes();\n\t\treturn SessionRepositoryMessageInterceptor.getSessionId(attributes);\n\t}\n\n\tprivate void afterConnectionClosed(String httpSessionId, String wsSessionId) {\n\t\tif (httpSessionId == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMap<String, WebSocketSession> sessions = this.httpSessionIdToWsSessions.get(httpSessionId);\n\t\tif (sessions != null) {\n\t\t\tboolean result = sessions.remove(wsSessionId) != null;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Removal of \" + wsSessionId + \" was \" + result);\n\t\t\t}\n\t\t\tif (sessions.isEmpty()) {\n\t\t\t\tthis.httpSessionIdToWsSessions.remove(httpSessionId);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Removed the corresponding HTTP Session for \" + wsSessionId\n\t\t\t\t\t\t\t+ \" since it contained no WebSocket mappings\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void registerWsSession(String httpSessionId, WebSocketSession wsSession) {\n\t\tMap<String, WebSocketSession> sessions = this.httpSessionIdToWsSessions.get(httpSessionId);\n\t\tif (sessions == null) {\n\t\t\tsessions = new ConcurrentHashMap<>();\n\t\t\tthis.httpSessionIdToWsSessions.putIfAbsent(httpSessionId, sessions);\n\t\t\tsessions = this.httpSessionIdToWsSessions.get(httpSessionId);\n\t\t}\n\t\tsessions.put(wsSession.getId(), wsSession);\n\t}\n\n\tprivate void closeWsSessions(String httpSessionId) {\n\t\tMap<String, WebSocketSession> sessionsToClose = this.httpSessionIdToWsSessions.remove(httpSessionId);\n\t\tif (sessionsToClose == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing WebSocket connections associated to expired HTTP Session \" + httpSessionId);\n\t\t}\n\t\tfor (WebSocketSession toClose : sessionsToClose.values()) {\n\t\t\ttry {\n\t\t\t\ttoClose.close(SESSION_EXPIRED_STATUS);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tlogger.debug(\"Failed to close WebSocketSession (this is nothing to worry about but for debugging only)\",\n\t\t\t\t\t\tex);\n\t\t\t}\n\t\t}\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .anyRequest()\n            .permitAll()\n            .and().csrf().disable();\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class DarkChannelPriorDehaze {\n\n\tpublic static Mat enhance(Mat image, double krnlRatio, double minAtmosLight, double eps) {\n\t\timage.convertTo(image, CvType.CV_32F);\n\t\tList<Mat> rgb = new ArrayList<>();\n\t\tCore.split(image, rgb);\n\t\tMat rChannel = rgb.get(0);\n\t\tMat gChannel = rgb.get(1);\n\t\tMat bChannel = rgb.get(2);\n\t\tint rows = rChannel.rows();\n\t\tint cols = rChannel.cols();\n\t\tMat dc = rChannel.clone();\n\t\tfor (int i = 0; i < image.rows(); i++) {\n\t\t\tfor (int j = 0; j < image.cols(); j++) {\n\t\t\t\tdouble min = Math.min(rChannel.get(i, j)[0], Math.min(gChannel.get(i, j)[0], bChannel.get(i, j)[0]));\n\t\t\t\tdc.put(i, j, min);\n\t\t\t}\n\t\t}\n\t\tint krnlSz = Double.valueOf(Math.max(Math.max(rows * krnlRatio, cols * krnlRatio), 3.0)).intValue();\n\t\tMat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(krnlSz, krnlSz), new Point(-1, -1));\n\t\tImgproc.erode(dc, dc, kernel);\n\t\tMat t = dc.clone();\n\t\tCore.subtract(t, new Scalar(255.0), t);\n\t\tCore.multiply(t, new Scalar(-1.0), t);\n\t\tCore.divide(t, new Scalar(255.0), t);\n\t\tMat gray = new Mat();\n\t\tImgproc.cvtColor(image, gray, Imgproc.COLOR_RGB2GRAY);\n\t\tCore.divide(gray, new Scalar(255.0), gray);\n\t\tint r = krnlSz * 4;\n\t\tt = Filters.GuidedImageFilter(gray, t, r, eps);\n\t\tminAtmosLight = Math.min(minAtmosLight, Core.minMaxLoc(dc).maxVal);\n\t\trChannel = dehaze(rChannel, t, minAtmosLight);\n\t\tgChannel = dehaze(gChannel, t, minAtmosLight);\n\t\tbChannel = dehaze(bChannel, t, minAtmosLight);\n\t\tMat outval = new Mat();\n\t\tCore.merge(new ArrayList<>(Arrays.asList(rChannel, gChannel, bChannel)), outval);\n\t\toutval.convertTo(outval, CvType.CV_8UC1);\n\t\treturn outval;\n\t}\n\n\tprivate static Mat dehaze(Mat channel, Mat t, double minAtmosLight) {\n\t\tMat t_ = new Mat();\n\t\tCore.subtract(t, new Scalar(1.0), t_);\n\t\tCore.multiply(t_, new Scalar(-1.0 * minAtmosLight), t_);\n\t\tCore.subtract(channel, t_, channel);\n\t\tCore.divide(channel, t, channel);\n\t\treturn channel;\n\t}\n\n}", "nl": "opencv"}
{"code": "    \n\n\n\n\n@RestController\npublic class GreetingController {\n\n    private static final String template = \"Hello, %s!\";\n    private final AtomicLong counter = new AtomicLong();\n\n    @CrossOrigin(origins = \"http://localhost:9000\")\n    @GetMapping(\"/greeting\")\n    public Greeting greeting(@RequestParam(required=false, defaultValue=\"World\") String name) {\n        System.out.println(\"==== in greeting ====\");\n        return new Greeting(counter.incrementAndGet(), String.format(template, name));\n    }\n\n    @GetMapping(\"/greeting-javaconfig\")\n    public Greeting greetingWithJavaconfig(@RequestParam(required=false, defaultValue=\"World\") String name) {\n        System.out.println(\"==== in greeting ====\");\n        return new Greeting(counter.incrementAndGet(), String.format(template, name));\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class HistoTest {\n   public static void main (String[] args) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap20/histo_input.jpg\";\n\n      Mat img = Imgcodecs.imread(file);\n\n      Mat equ = new Mat();\n      img.copyTo(equ);\n\n      Imgproc.blur(equ, equ, new Size(3, 3));\n\n      Imgproc.cvtColor(equ, equ, Imgproc.COLOR_BGR2YCrCb);\n      List<Mat> channels = new ArrayList<Mat>();\n\n      Core.split(equ, channels);\n\n      Imgproc.equalizeHist(channels.get(0), channels.get(0));\n      Core.merge(channels, equ);\n      Imgproc.cvtColor(equ, equ, Imgproc.COLOR_YCrCb2BGR);\n\n      Mat gray = new Mat();\n      Imgproc.cvtColor(equ, gray, Imgproc.COLOR_BGR2GRAY);\n      Mat grayOrig = new Mat();\n      Imgproc.cvtColor(img, grayOrig, Imgproc.COLOR_BGR2GRAY);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap20/histo_output.jpg\", equ);\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class SudokuSolver {\n\n    private static final OpenCVFrameConverter.ToIplImage converter = new OpenCVFrameConverter.ToIplImage();\n    private final static int[] DIGITS = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    private static MultiLayerNetwork NETWORK;\n    private static final org.slf4j.Logger log = LoggerFactory.getLogger(SudokuSolver.class);\n\n    private static MultiLayerNetwork loadNetwork() {\n        MultiLayerNetwork network = null;\n        try {\n            String pathtoexe = System.getProperty(\"user.dir\");\n            File net = new File(pathtoexe, \"cnn-model.data\");\n            network = ModelSerializer.restoreMultiLayerNetwork(net);\n        } catch (IOException ex) {\n            log.error(\"Error While Loading Pretrained Network: \" + ex.getMessage());\n        }\n        return network;\n    }\n\n    \n    private static boolean isSudokuExist(Mat img) {\n        MatVector countours = new MatVector();\n        List<Double> araes = new ArrayList<>();\n        findContours(img.clone(), countours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, new Point(0, 0));\n        for (int i = 0; i < countours.size(); i++) {\n            Mat c = countours.get(i);\n            double area = contourArea(c);\n            araes.add(area);\n        }\n        if (araes.isEmpty()) {\n            return false;\n        }\n        Double d = Collections.max(araes);\n        return d > 40000;\n    }\n\n    \n    private static Rect getLargestRect(Mat img) {\n        MatVector countours = new MatVector();\n        List<Rect> rects = new ArrayList<>();\n        List<Double> araes = new ArrayList<>();\n        findContours(img, countours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, new Point(0, 0));\n        for (int i = 0; i < countours.size(); i++) {\n            Mat c = countours.get(i);\n            double area = contourArea(c);\n            Rect boundingRect = boundingRect(c);\n            araes.add(area);\n            rects.add(boundingRect);\n        }\n        if (araes.isEmpty() || Collections.max(araes) < 4000) {\n            return new Rect(0, 0, img.cols(), img.rows());\n        } else {\n            Double d = Collections.max(araes);\n            return rects.get(araes.indexOf(d));\n        }\n    }\n\n    \n    private static void printCornerPoints(Rect r, Mat colorimg) {\n        Point tl = new Point(r.x(), r.y());\n        Point dl = new Point(r.x(), r.y() + r.height());\n        Point tr = new Point(r.x() + r.width(), r.y());\n        Point dr = new Point(r.x() + r.width(), r.y() + r.height());\n        circle(colorimg, tl, 10, new Scalar(255, 255, 0, 255), CV_FILLED, 8, 0);\n        circle(colorimg, dl, 10, new Scalar(255, 255, 0, 255), CV_FILLED, 8, 0);\n        circle(colorimg, tr, 10, new Scalar(255, 255, 0, 255), CV_FILLED, 8, 0);\n        circle(colorimg, dr, 10, new Scalar(255, 255, 0, 255), CV_FILLED, 8, 0);\n    }\n\n    \n    private static Mat warpPrespectivePuzzle(Mat image) {\n        image = deskewImage(image);\n        Rect rect = getLargestRect(image);\n        Point2f srcPts = new Point2f(4);\n        srcPts.position(0).x((float) rect.x()).y((float) rect.y());\n        srcPts.position(1).x((float) rect.x() + rect.width()).y((float) rect.y());\n        srcPts.position(2).x((float) rect.x() + rect.width()).y((float) rect.y() + rect.height());\n        srcPts.position(3).x((float) rect.x()).y((float) rect.y() + rect.height());\n\n        Point2f dstPts = new Point2f(4);\n        dstPts.position(0).x(0).y(0);\n        dstPts.position(1).x(600 - 2).y(0);\n        dstPts.position(2).x(600 - 2).y(600 - 2);\n        dstPts.position(3).x(0).y(600 - 2);\n\n        Mat p = getPerspectiveTransform(srcPts.position(0), dstPts.position(0));\n        Mat img = new Mat(new Size(600, 600), image.type());//image.size()\n        warpPerspective(image, img, p, img.size());\n        return img;\n    }\n\n    private static Mat deskewImage(Mat img) {\n        MatVector countours = new MatVector();\n        List<Double> araes = new ArrayList<>();\n        findContours(img, countours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, new Point(0, 0));\n        for (int i = 0; i < countours.size(); i++) {\n            Mat c = countours.get(i);\n            double area = contourArea(c);\n            araes.add(area);\n        }\n        if (araes.isEmpty()) {\n            return img;\n        } else {\n            Double d = Collections.max(araes);\n            RotatedRect minAreaRect = minAreaRect(countours.get(araes.indexOf(d)));\n            float angle = minAreaRect.angle();\n            if (angle < -45) {\n                angle = -(90 + angle);\n            } else {\n                angle = -angle;\n            }\n            Mat rot = getRotationMatrix2D(minAreaRect.center(), angle, 1);\n            Mat dst = new Mat(img.size(), img.type());\n            warpAffine(img, dst, rot, dst.size(), WARP_INVERSE_MAP | INTER_LINEAR, BORDER_CONSTANT, new Scalar(0, 0, 0, 0));\n            return dst;\n        }\n    }\n\n    \n    private static boolean checkLines(List<Cluster> vlines, List<Cluster> hlines) {\n        final int diff = 40;//this may vary if you change the image width and hieght in method warpPrespectivePuzzle (600)\n        if (!(vlines.size() == 10 && hlines.size() == 10)) {\n            return false;\n        }\n        for (int i = 0; i < hlines.size() - 1; i++) {\n            Cluster get = hlines.get(i);\n            double r1 = get.getCenter().getArray().getDouble(0);\n            Cluster get1 = hlines.get(i + 1);\n            double r2 = get1.getCenter().getArray().getDouble(0);\n            if (Math.abs(r1 - r2) < diff) {\n                return false;\n            }\n        }\n        for (int i = 0; i < vlines.size() - 1; i++) {\n            Cluster get = vlines.get(i);\n            double r1 = get.getCenter().getArray().getDouble(0);\n            Cluster get1 = vlines.get(i + 1);\n            double r2 = get1.getCenter().getArray().getDouble(0);\n            if (Math.abs(r1 - r2) < diff) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private static List<Point> getPoint(List<Cluster> vlines, List<Cluster> hlines) {\n        List<Point> points = new ArrayList();\n        for (int i = 0; i < hlines.size(); i++) {\n            Cluster get = hlines.get(i);\n            double r1 = get.getCenter().getArray().getDouble(0);\n            double t1 = get.getCenter().getArray().getDouble(1);\n            for (int j = 0; j < vlines.size(); j++) {\n                Cluster get1 = vlines.get(j);\n                double r2 = get1.getCenter().getArray().getDouble(0);\n                double t2 = get1.getCenter().getArray().getDouble(1);\n                Point o = parametricIntersect(r1, t1, r2, t2);\n                if (o.y() != -1 & o.x() != -1) {\n                    points.add(o);\n                }\n            }\n        }\n        for (int i = 0; i < points.size() - 1; i++) {\n            Point get = points.get(i);\n            Point get1 = points.get(i + 1);\n            if (getDistance(get, get1) < 20) {\n                points.remove(get);\n            }\n        }\n        return points;\n    }\n\n    \n    private static Point parametricIntersect(Double r1, Double t1, Double r2, Double t2) {\n        double ct1 = Math.cos(t1);     //matrix element a\n        double st1 = Math.sin(t1);     //b\n        double ct2 = Math.cos(t2);     //c\n        double st2 = Math.sin(t2);     //d\n        double d = ct1 * st2 - st1 * ct2;//determinative (rearranged matrix for inverse)\n        if (d != 0.0f) {\n            int x = (int) ((st2 * r1 - st1 * r2) / d);\n            int y = (int) ((-ct2 * r1 + ct1 * r2) / d);\n            return new Point(x, y);\n        } else { //lines are parallel and will NEVER intersect!\n            return new Point(-1, -1);\n        }\n    }\n\n    static double getDistance(Point p1, Point p2) {\n        return Math.sqrt(Math.pow((p1.x() - p2.x()), 2) + Math.pow((p1.y() - p2.y()), 2));\n    }\n\n\n    \n    private static Mat detectDigit(Mat img) {\n        Mat res = new Mat();\n        MatVector countours = new MatVector();\n        List<Rect> rects = new ArrayList<>();\n        List<Double> araes = new ArrayList<>();\n        bitwise_not(img, img);\n        findContours(img, countours, opencv_imgproc.CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, new Point(0, 0));\n        for (int i = 0; i < countours.size(); i++) {\n            Mat c = countours.get(i);\n            Rect boundbox = boundingRect(c);\n            if (boundbox.height() > 20 && boundbox.height() < 50 && boundbox.width() > 15 && boundbox.width() < 40) {\n                double aspectRatio = boundbox.height() / boundbox.width();\n                if (aspectRatio >= 1 && aspectRatio < 3) {\n                    rects.add(boundbox);\n                    double area = contourArea(c);\n                    araes.add(area);\n                }\n            }\n        }\n        if (!araes.isEmpty()) {\n            bitwise_not(img, img);\n\n            Double d = Collections.max(araes);\n            res = img.apply(rects.get(araes.indexOf(d)));\n            copyMakeBorder(res, res, 10, 10, 10, 10, BORDER_CONSTANT, new Scalar(255, 255, 255, 255));\n            resize(res, res, new Size(28, 28));\n            return res;\n        } else {\n            return img;//org.bytedeco.javacpp.helper.AbstractMat.EMPTY\n        }\n    }\n\n    \n    private static int recogniseDigit(Mat digit) {\n        int idx = 0;\n        try {\n            NativeImageLoader loader = new NativeImageLoader(28, 28, 1);\n            bitwise_not(digit, digit);\n            INDArray dig = loader.asMatrix(digit);\n            INDArray flaten = dig.reshape(new int[]{1, 784});\n            flaten = flaten.div(255);\n            INDArray output = NETWORK.output(flaten);\n            idx = Nd4j.getExecutioner().execAndReturn(new IAMax(output)).getFinalResult();\n            digit.release();\n        } catch (IOException ex) {\n            log.error(ex.getMessage());\n        }\n        return DIGITS[idx];\n    }\n    \n    private static void printResult(Mat img, INDArray result, INDArray puzzle, List<Rect> rects) {\n        for (int i = 0; i < rects.size(); i++) {\n            Rect rect = rects.get(i);\n            int x = rect.x();\n            int y = rect.y();\n            int d = (int) result.getDouble(i / 9, i % 9);\n            int d1 = (int) puzzle.getDouble(i / 9, i % 9);\n            if (d != d1) {//Print Solution\n\n                putText(img, d + \"\", new Point(x + 20, y + 50),\n                        FONT_HERSHEY_COMPLEX, 1.3, new Scalar(255, 0, 0, 0), 3, 2, false);\n            } else {//Print Recognised Puzzle\n\n                putText(img, d + \"\", new Point(x + 10, y + 40),\n                        FONT_HERSHEY_COMPLEX, 1, new Scalar(0, 0, 255, 0), 2, 2, false);\n            }\n\n        }\n\n    }\n    \n    private static boolean isContainsZero(INDArray puz) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (puz.getInt(i, j) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        \n        NETWORK = loadNetwork();\n\n        final AtomicReference<VideoCapture> capture = new AtomicReference<>(new VideoCapture());\n        capture.get().set(CV_CAP_PROP_FRAME_WIDTH, 1280);\n        capture.get().set(CV_CAP_PROP_FRAME_HEIGHT, 720);\n\n        if (!capture.get().open(0)) {\n            log.error(\"Can not open the cam !!!\");\n        }\n\n        final AtomicReference<Boolean> start = new AtomicReference<>(true);\n\n        Mat colorimg = new Mat();\n\n        CanvasFrame mainframe = new CanvasFrame(\"Real-time Sudoku Solver - Emaraic\");\n        mainframe.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n        mainframe.setCanvasSize(600, 600);\n        mainframe.setLocationRelativeTo(null);\n        mainframe.setLayout(new BoxLayout(mainframe.getContentPane(), BoxLayout.Y_AXIS));\n        JButton control = new JButton(\"Stop\");//start and pause camera capturing\n        control.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                if (SwingUtilities.isLeftMouseButton(e)) {\n                    if (start.get() == true && capture.get().isOpened()) {\n                        start.set(false);\n                        capture.get().release();\n                        control.setText(\"Start\");\n                    } else {\n                        start.set(true);\n                        capture.set(new VideoCapture());\n                        capture.get().open(0);\n                        control.setText(\"Stop\");\n                    }\n                }\n            }\n        });\n        mainframe.add(control, BorderLayout.CENTER);\n        mainframe.pack();\n        mainframe.setVisible(true);\n        mainframe.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                if (capture.get().isOpened()) {\n                    capture.get().release();\n                }\n                System.exit(0);\n            }\n        });\n\n        CanvasFrame procframe = new CanvasFrame(\"Processed Frames - Emaraic\");\n        procframe.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n        procframe.setCanvasSize(400, 400);\n        procframe.setLocation(0, 0);\n        CanvasFrame result = new CanvasFrame(\"Result - Emaraic\");\n        result.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n        result.setCanvasSize(500, 500);\n        result.setLocation(0, 440);\n\n        while (true) {\n            while (start.get() && capture.get().read(colorimg)) {\n                if (mainframe.isVisible()) {\n\n                    \n                    Mat sourceGrey = new Mat(colorimg.size(), CV_8UC1);\n                    cvtColor(colorimg, sourceGrey, COLOR_BGR2GRAY);\n\n                    \n                    Mat blurimg = new Mat(colorimg.size(), CV_8UC1);\n                    GaussianBlur(sourceGrey, blurimg, new Size(5, 5), 0);\n\n                    \n                    Mat binimg = new Mat(colorimg.size());\n                    adaptiveThreshold(blurimg, binimg, 255, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY_INV, 19, 3);\n\n                    Rect r = getLargestRect(binimg);\n                    Mat procimg = warpPrespectivePuzzle(binimg.clone());\n\n\n                    \n                    Mat color = new Mat(colorimg);\n                    if (isSudokuExist(binimg)) {\n                        printCornerPoints(r, colorimg);\n                        mainframe.showImage(converter.convert(colorimg));\n                        bitwise_not(procimg, procimg);\n                        Mat clonedf = new Mat(procimg.clone());\n                        Mat canimg = new Mat(procimg.size());\n                        Canny(procimg, canimg, 30, 90);\n\n                        \n                        Mat lines = new Mat();//vector stores the parameters (rho,theta) of the detected lines\n                        HoughLines(canimg, lines, 1, CV_PI / 180, 100);\n\n                        FloatRawIndexer srcIndexer = lines.createIndexer();\n\n                        \n                        List<org.deeplearning4j.clustering.cluster.Point> hpoints = new ArrayList<>();\n                        List<org.deeplearning4j.clustering.cluster.Point> vpoints = new ArrayList<>();\n\n                        for (int i = 0; i < srcIndexer.rows(); i++) {\n                            float[] data = new float[2]; //data[0] is rho and data[1] is theta\n                            srcIndexer.get(0, i, data);\n                            double d[] = {data[0], data[1]};\n                            if (Math.sin(data[1]) > 0.8) {//horizontal lines have a sin value equals 1, I just considered >.8 is horizontal line.\n                                hpoints.add(new org.deeplearning4j.clustering.cluster.Point(\"hrho\" + Math.sin(data[1]), \"hrho\", d));\n                            } else if (Math.cos(data[1]) > 0.8) {//vertical lines have a cos value equals 1,\n                                vpoints.add(new org.deeplearning4j.clustering.cluster.Point(\"vrho\" + Math.cos(data[1]), \"vrho\", d));\n                            }\n                        }\n\n                        \n                        KMeansClustering kmeans = KMeansClustering.setup(10, 10, \"euclidean\");\n\n                        log.info(\"Lines Number \" + vpoints.size() + \" \" + hpoints.size());\n                        if (vpoints.size() >= 10 && hpoints.size() >= 10) {\n                            ClusterSet hcs = kmeans.applyTo(hpoints);\n                            List<Cluster> hlines = hcs.getClusters();\n                            Collections.sort(hlines, new LinesComparator());\n\n                            ClusterSet vcs = kmeans.applyTo(vpoints);\n                            List<Cluster> vlines = vcs.getClusters();\n                            Collections.sort(vlines, new LinesComparator());\n                            if (checkLines(vlines, hlines)) {\n                                List<Point> points = getPoint(vlines, hlines);\n                                if (points.size() != 100) {\n                                    break;\n                                }\n\n                                \n                                for (Point point : points) {\n                                    circle(procimg, point, 10, new Scalar(0, 0, 0, 255), CV_FILLED, 8, 0);\n                                }\n\n                                vlines.addAll(hlines);//appen hlines to vlines to print them in one for loop\n                                for (int i = 0; i < vlines.size(); i++) {\n                                    Cluster get = vlines.get(i);\n                                    double rho = get.getCenter().getArray().getDouble(0);\n                                    double theta = get.getCenter().getArray().getDouble(1);\n                                    double a = Math.cos(theta), b = Math.sin(theta);\n                                    double x0 = a * rho, y0 = b * rho;\n                                    CvPoint pt1 = cvPoint((int) Math.round(x0 + 1000 * (-b)), (int) Math.round(y0 + 1000 * (a))), pt2 = cvPoint((int) Math.round(x0 - 1000 * (-b)), (int) Math.round(y0 - 1000 * (a)));\n                                    line(procimg, new Point(pt1.x(), pt1.y()),\n                                            new Point(pt2.x(), pt2.y()), new Scalar(0, 0, 0, 0), 3, CV_AA, 0);\n\n                                }\n\n                                double puzzel[] = new double[81];\n                                int j = 0;\n                                List<Rect> rects = new ArrayList<>();\n                                for (int i = 0; i < points.size() - 11; i++) {\n                                    int ri = i / 10;\n                                    int ci = i % 10;\n                                    if (ci != 9 && ri != 9) {\n                                        Point get = points.get(i);\n                                        Point get2 = points.get(i + 11);\n                                        Rect r1 = new Rect(get, get2);\n                                        if ((r1.x() + r1.width() <= clonedf.cols()) && (r1.y() + r1.height() <= clonedf.rows()) && r1.x() >= 0 && r1.y() >= 0) {\n                                            Mat s = detectDigit(clonedf.apply(r1));\n                                            rects.add(r1);\n                                            if (s.cols() == 28 && s.rows() == 28) {\n                                                puzzel[j] = recogniseDigit(s);\n                                            } else {\n                                                puzzel[j] = 0;\n                                            }\n                                            j++;\n                                        }\n                                    }\n                                }\n                                imwrite(\"procimg.jpg\", procimg);\n                                INDArray pd = Nd4j.create(puzzel);\n                                INDArray puz = pd.reshape(new int[]{9, 9});\n                                System.out.println(puz);\n                                INDArray solvedpuz = puz.dup();\n                                if (Sudoku.isValid(puzzel)) {\n                                    ExecutorService service = Executors.newSingleThreadExecutor();\n                                    try {\n                                        Future<Object> solver = (Future<Object>) service.submit(() -> {\n                                            Sudoku.solve(0, 0, solvedpuz);\n                                        });\n                                        System.out.println(solver.get(5, TimeUnit.SECONDS));\n                                    } catch (final TimeoutException e) {\n                                        log.info(\"It takes a lot of time to solve, Going to break!!\");\n                                        \n                                        break;\n                                    } catch (final Exception e) {\n                                        log.error(e.getMessage());\n                                    } finally {\n                                        service.shutdown();\n                                    }\n\n                                    if (isContainsZero(solvedpuz)) {\n                                        \n                                        break; //break to get another image if solution is invalid\n                                    } else {\n                                        \n                                        color = new Mat(procimg.size(), CV_8UC3);\n                                        cvtColor(procimg, color, COLOR_GRAY2BGR);\n                                        printResult(color, solvedpuz, puz, rects);\n                                    }\n                                } else {//break to get another image if sudoku is invalid\n                                    break;\n                                }\n                                start.set(Boolean.FALSE);\n                                capture.get().release();\n                                control.setText(\"Try Again\");\n                            }//End if checkLines\n                        }\n\n                        procframe.showImage(converter.convert(procimg));\n                        result.showImage(converter.convert(color));\n\n                    } else {//End If sudoku puzzle exists\n                        mainframe.showImage(converter.convert(colorimg));\n                        procframe.showImage(converter.convert(procimg));\n                        result.showImage(converter.convert(color));\n                    }\n                } else {//End if graabbed image equal null\n                    System.out.println(\"Error!!!!\");\n                    System.exit(1);\n                }\n                try {\n                    Thread.sleep(150);\n                } catch (InterruptedException ex) {\n                    log.error(ex.getMessage());\n                }\n            }//End While Start's Condition\n            try {\n                Thread.sleep(400);\n            } catch (InterruptedException ex) {\n                log.error(ex.getMessage());\n            }\n        }//End While True\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Controller\nclass QuestionsController {\n\n    private final ProjectMetadataService projectMetadata;\n    private final StackOverflowClient stackOverflow;\n\n    private final Log logger = LogFactory.getLog(QuestionsController.class);\n\n    @Autowired\n    public QuestionsController(ProjectMetadataService projectMetadata, StackOverflowClient stackOverflow) {\n        this.projectMetadata = projectMetadata;\n        this.stackOverflow = stackOverflow;\n    }\n\n    @ExceptionHandler(HttpClientErrorException.class)\n    public ModelAndView handleStackOverflowAPIException(HttpClientErrorException clientErrorException) {\n\n        logger.error(\"Error while fetching questions from StackOverflow API\", clientErrorException);\n        ModelAndView mav = new ModelAndView(\"questions/index\");\n        mav.addObject(\"questions\", Collections.emptyList());\n        mav.addObject(\"projects\", getProjectList());\n\n        return mav;\n    }\n\n    @RequestMapping(\"/questions\")\n    public String show(Model model) {\n\n        model.addAttribute(\"questions\", stackOverflow.searchForQuestionsTagged(\"spring\"));\n        model.addAttribute(\"projects\", getProjectList());\n\n        return \"questions/index\";\n    }\n\n    private List<Project> getProjectList() {\n\n        return projectMetadata.getProjects().stream()\n                .filter(project -> !project.getCategory().equals(\"attic\"))\n                .filter(project -> !project.getStackOverflowTagList().isEmpty())\n                .sorted((p1, p2) -> p1.getName().compareToIgnoreCase(p2.getName()))\n                .collect(Collectors.toList());\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n@SpringBootApplication\n@ClientCacheApplication(name = \"CachingGemFireApplication\", logLevel = \"error\")\n@EnableCachingDefinedRegions(clientRegionShortcut = ClientRegionShortcut.LOCAL)\n@EnableGemfireCaching\n@SuppressWarnings(\"unused\")\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    ApplicationRunner runner(QuoteService quoteService) {\n\n        return args -> {\n            Quote quote = requestQuote(quoteService, 12L);\n            requestQuote(quoteService, quote.getId());\n            requestQuote(quoteService, 10L);\n        };\n    }\n\n    private Quote requestQuote(QuoteService quoteService, Long id) {\n\n        long startTime = System.currentTimeMillis();\n\n        Quote quote = Optional.ofNullable(id)\n            .map(quoteService::requestQuote)\n            .orElseGet(quoteService::requestRandomQuote);\n\n        long elapsedTime = System.currentTimeMillis();\n\n        System.out.printf(\"\\\"%1$s\\\"%nCache Miss [%2$s] - Elapsed Time [%3$s ms]%n\", quote,\n            quoteService.isCacheMiss(), (elapsedTime - startTime));\n\n        return quote;\n    }\n}", "nl": "spring"}
{"code": "\n\npublic class BilateralFilter {\n   public static void main(String args[]) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap11/filter_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Imgproc.bilateralFilter(src, dst, 15, 80, 80, Core.BORDER_DEFAULT);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap11/bilateralfilter.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\npublic class DistanceTransform {\n   public static void main(String args[]) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap19/input.jpg\";\n      Mat src = Imgcodecs.imread(file,0);\n\n      Mat dst = new Mat();\n      Mat binary = new Mat();\n\n      Imgproc.threshold(src, binary, 100, 255, Imgproc.THRESH_BINARY);\n\n      Imgproc.distanceTransform(mat, dst, Imgproc.DIST_C, 3);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap19/distnceTransform.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\npublic class HttpRequestTest {\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    public void greetingShouldReturnDefaultMessage() throws Exception {\n        assertThat(this.restTemplate.getForObject(\"http://localhost:\" + port + \"/\",\n                String.class)).contains(\"Hello World\");\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@Component\nclass StackOverflowClient {\n\n    private static final String DEFAULT_BASE_URL = \"https://api.stackexchange.com/2.2\";\n    private static final String SEARCH_TEMPLATE = \"/search\";\n\n    private static final String TAGGED_PARAM = \"tagged\";\n\n    private static final Map<String, String> PARAMETERS = new HashMap<>();\n\n    static {\n        PARAMETERS.put(\"filter\", \"withbody\");\n        PARAMETERS.put(\"site\", \"stackoverflow\");\n    }\n\n    private final RestOperations restOperations;\n    private final CachedRestClient restClient;\n    private String baseUrl;\n\n    @Autowired\n    public StackOverflowClient(CachedRestClient restClient, RestOperations restOperations) {\n        this.restOperations = restOperations;\n        this.restClient = restClient;\n        this.baseUrl = DEFAULT_BASE_URL;\n    }\n\n    \n    public List<Question> searchForQuestionsTagged(String... tags) {\n        UriComponentsBuilder builder = getBuilderFor(baseUrl + SEARCH_TEMPLATE);\n\n        if (tags.length > 0) {\n            String tagsString = StringUtils.arrayToDelimitedString(tags, \";\");\n            builder = builder.queryParam(TAGGED_PARAM, tagsString);\n        }\n\n        UriComponents uriComponents = builder.build();\n\n        Questions result = restClient.get(restOperations, uriComponents.toUriString(), Questions.class);\n\n        return result.items;\n    }\n\n    private UriComponentsBuilder getBuilderFor(String uri) {\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(uri);\n\n        for (Entry<String, String> entry : PARAMETERS.entrySet()) {\n            builder.queryParam(entry.getKey(), entry.getValue());\n        }\n\n        return builder;\n    }\n}", "nl": "spring"}
{"code": "    \n\n\n\n\n\n@Configuration\n@ComponentScan\n@EnableAutoConfiguration\n@RestController\n@RequestMapping(\"/dashboard\")\npublic class SsoApplication {\n\n\t@RequestMapping(\"/message\")\n\tpublic Map<String, Object> dashboard() {\n\t\treturn Collections.<String, Object> singletonMap(\"message\", \"Yay!\");\n\t}\n\n\t@RequestMapping(\"/user\")\n\tpublic Principal user(Principal user) {\n\t\treturn user;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SsoApplication.class, args);\n\t}\n\n\t@Controller\n\tpublic static class LoginErrors {\n\n\t\t@RequestMapping(\"/dashboard/login\")\n\t\tpublic String dashboard() {\n\t\t\treturn \"redirect:/#/\";\n\t\t}\n\n\t}\n\n\t@Component\n\t@EnableOAuth2Sso\n\tpublic static class LoginConfigurer extends WebSecurityConfigurerAdapter {\n\n\t\t@Override\n\t\tpublic void configure(HttpSecurity http) throws Exception {\n\t\t\thttp.antMatcher(\"/dashboard/**\").authorizeRequests().anyRequest()\n\t\t\t\t\t.authenticated().and().csrf()\n\t\t\t\t\t.csrfTokenRepository(csrfTokenRepository()).and()\n\t\t\t\t\t.addFilterAfter(csrfHeaderFilter(), CsrfFilter.class)\n\t\t\t\t\t.logout().logoutUrl(\"/dashboard/logout\").permitAll()\n\t\t\t\t\t.logoutSuccessUrl(\"/\");\n\t\t}\n\n\t\tprivate Filter csrfHeaderFilter() {\n\t\t\treturn new OncePerRequestFilter() {\n\t\t\t\t@Override\n\t\t\t\tprotected void doFilterInternal(HttpServletRequest request,\n\t\t\t\t\t\tHttpServletResponse response, FilterChain filterChain)\n\t\t\t\t\t\tthrows ServletException, IOException {\n\t\t\t\t\tCsrfToken csrf = (CsrfToken) request\n\t\t\t\t\t\t\t.getAttribute(CsrfToken.class.getName());\n\t\t\t\t\tif (csrf != null) {\n\t\t\t\t\t\tCookie cookie = new Cookie(\"XSRF-TOKEN\",\n\t\t\t\t\t\t\t\tcsrf.getToken());\n\t\t\t\t\t\tcookie.setPath(\"/\");\n\t\t\t\t\t\tresponse.addCookie(cookie);\n\t\t\t\t\t}\n\t\t\t\t\tfilterChain.doFilter(request, response);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tprivate CsrfTokenRepository csrfTokenRepository() {\n\t\t\tHttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();\n\t\t\trepository.setHeaderName(\"X-XSRF-TOKEN\");\n\t\t\treturn repository;\n\t\t}\n\t}\n}", "nl": "spring"}
{"code": "\n\npublic class BoxFilterTest {\n   public static void main( String[] args ) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file = \"E:/OpenCV/chap11/filter_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Size size = new Size(45, 45);\n      Point point = Point(-1, -1);\n\n      Imgproc.boxFilter(src, dst, 50, size, point, true, Core.BORDER_DEFAULT);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap11/boxfilterjpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "    \n\n\n\n\n\n\n\n\npublic class Histogram1DJava {\n    private int numberOfBins = 256;\n    private IntPointer channels = new IntPointer(1);\n    private Float _minRange = 0.0f;\n    private Float _maxRange = 255.0f;\n\n    public void setRanges(Float minRange, Float maxRange) {\n        _minRange = minRange;\n        _maxRange = maxRange;\n    }\n\n    public BufferedImage getHistogramImage(Mat image) {\n        int width = this.numberOfBins;\n        int height = this.numberOfBins;\n        double[] hist = getHistogramAsArray(image);\n        double scale = 0.9 / max(hist) * height;\n        BufferedImage canvas = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n        Graphics2D g = canvas.createGraphics();\n\n        g.setPaint(Color.WHITE);\n        g.fillRect(0, 0, width, height);\n\n\n        g.setPaint(Color.BLUE);\n\n        for (int bin = 0; bin < numberOfBins; bin++) {\n            int h = Long.valueOf(Math.round(hist[bin] * scale)).intValue();\n            g.drawLine(bin, height - 1, bin, height - h - 1);\n        }\n\n        g.dispose();\n        return canvas;\n    }\n\n    public double[] getHistogramAsArray(Mat image) {\n        Mat hist = getHistogram(image);\n        double[] dest = new double[numberOfBins];\n        Indexer indexer = hist.createIndexer();\n        for (int i = 0; i < numberOfBins; i++) {\n            dest[i] = indexer.getDouble(i);\n        }\n        return dest;\n    }\n\n\n    private Mat getHistogram(Mat image) {\n        return getHistogram(image, new Mat());\n    }\n\n    private Mat getHistogram(Mat image, Mat mask) {\n        IntPointer histSize = new IntPointer(1);\n        histSize.put(0, numberOfBins);\n        FloatPointer ranges = new FloatPointer(_minRange, _maxRange);\n\n        Mat hist = new Mat();\n        calcHist(image, 1, channels, mask, hist, 1, histSize, ranges);\n        return hist;\n    }\n\n\n    private double max(double[] dest) {\n        double max = 0.0;\n        for (double value : dest) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                .antMatchers(\"/\", \"/home\").permitAll()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .loginPage(\"/login\")\n                .permitAll()\n                .and()\n            .logout()\n                .permitAll();\n    }\n\n    @Bean\n    @Override\n    public UserDetailsService userDetailsService() {\n        UserDetails user =\n             User.withDefaultPasswordEncoder()\n                .username(\"user\")\n                .password(\"password\")\n                .roles(\"USER\")\n                .build();\n\n        return new InMemoryUserDetailsManager(user);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@SuppressWarnings(\"unused\")\n@Service\npublic class QuoteService {\n\n\tprotected static final String ID_BASED_QUOTE_SERVICE_URL = \"http://gturnquist-quoters.cfapps.io/api/{id}\";\n\tprotected static final String RANDOM_QUOTE_SERVICE_URL = \"http://gturnquist-quoters.cfapps.io/api/random\";\n\n\tprivate volatile boolean cacheMiss = false;\n\n\tprivate final RestTemplate quoteServiceTemplate = new RestTemplate();\n\n\t\n\tpublic boolean isCacheMiss() {\n\t\tboolean cacheMiss = this.cacheMiss;\n\t\tthis.cacheMiss = false;\n\t\treturn cacheMiss;\n\t}\n\n\tprotected void setCacheMiss() {\n\t\tthis.cacheMiss = true;\n\t}\n\n\t\n\t@Cacheable(\"Quotes\")\n\tpublic Quote requestQuote(Long id) {\n\t\tsetCacheMiss();\n\t\treturn requestQuote(ID_BASED_QUOTE_SERVICE_URL, Collections.singletonMap(\"id\", id));\n\t}\n\n\t\n\t@CachePut(cacheNames = \"Quotes\", key = \"#result.id\")\n\tpublic Quote requestRandomQuote() {\n\t\tsetCacheMiss();\n\t\treturn requestQuote(RANDOM_QUOTE_SERVICE_URL);\n\t}\n\n\tprotected Quote requestQuote(String URL) {\n\t\treturn requestQuote(URL, Collections.emptyMap());\n\t}\n\n\tprotected Quote requestQuote(String URL, Map<String, Object> urlVariables) {\n\n\t\treturn Optional.ofNullable(this.quoteServiceTemplate.getForObject(URL, QuoteResponse.class, urlVariables))\n\t\t\t.map(QuoteResponse::getQuote)\n\t\t\t.orElse(null);\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class TemplateMatch {\n\n    public static Point match(Mat src, Mat template) {\n        Mat result = Mat.zeros(src.rows(), src.cols(), CvType.CV_32FC1);\n        Imgproc.matchTemplate(src, template, result, Imgproc.TM_SQDIFF_NORMED);\n        Core.normalize(result, result, 0, 1, Core.NORM_MINMAX, -1);\n        Core.MinMaxLocResult mlr = Core.minMaxLoc(result);\n        Point matchLoc = mlr.minLoc;\n        return new Point(matchLoc.x + template.rows() / 2, matchLoc.y + template.cols() / 2);\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\npublic class ScreensComparator {\n\n    private static Logger logger = LoggerFactory.getLogger(ScreensComparator.class);\n\n    public static Pair<Float, String> compareScreens(Mat actualImage, Mat expectedImage,\n                                                     Element.Area actualArea, Element.Area expectedArea,\n                                                     boolean background,\n                                                     boolean isRetina,\n                                                     int inaccuracy,\n                                                     StringBuffer error) {\n        int xActualOffset = 0;\n        int yActualOffset = 0;\n        int xExpectedOffset = 0;\n        int yExpectedOffset = 0;\n\n        int minWidth = 0;\n        int maxWidth = 0;\n        int outerWidth = 0;\n\n        int minHeight = 0;\n        int maxHeight = 0;\n        int outerHeight = 0;\n\n        if (actualArea != null && expectedArea != null) {\n            xActualOffset = actualArea.getLeft().intValue();\n            yActualOffset = actualArea.getTop().intValue();\n            xExpectedOffset = expectedArea.getLeft().intValue();\n            yExpectedOffset = expectedArea.getTop().intValue();\n\n            minWidth = (int) min(actualArea.getWidth(), expectedArea.getWidth());\n            maxWidth = (int) max(actualArea.getWidth(), expectedArea.getWidth());\n            outerWidth = maxWidth - minWidth;\n\n            minHeight = (int) min(actualArea.getHeight(), expectedArea.getHeight());\n            maxHeight = (int) max(actualArea.getHeight(), expectedArea.getHeight());\n            outerHeight = maxHeight - minHeight;\n\n            if (isRetina) {\n                xActualOffset *= 2;\n                yActualOffset *= 2;\n                xExpectedOffset *= 2;\n                yExpectedOffset *= 2;\n                minWidth *= 2;\n                maxWidth *= 2;\n                outerWidth *= 2;\n                minHeight *= 2;\n                maxHeight *= 2;\n                outerHeight *= 2;\n            }\n        } else {\n            minWidth = min(actualImage.width(), expectedImage.width());\n            maxWidth = max(actualImage.width(), expectedImage.width());\n            outerWidth = maxWidth - minWidth;\n\n            minHeight = min(actualImage.height(), expectedImage.height());\n            maxHeight = max(actualImage.height(), expectedImage.height());\n            outerHeight = maxHeight - minHeight;\n        }\n\n        String imagePath = \"\";\n        float diffPercentage = 0.00f;\n        int diffPixels = 0;\n\n        \n        Mat diffResult = null;\n        Mat redMask = null;\n        Mat actualImageMin = null;\n        Mat expectedImageMin = null;\n        Mat diffTemp = null;\n\n        try {\n            actualImageMin = actualImage.submat(new Rect(xActualOffset, yActualOffset, minWidth, minHeight));\n            expectedImageMin = expectedImage.submat(new Rect(xExpectedOffset, yExpectedOffset, minWidth, minHeight));\n\n            redMask = new Mat(minHeight, minWidth, CV_8UC4);\n\n            absdiff(actualImageMin, expectedImageMin, redMask);\n\n            threshold(redMask, redMask, inaccuracy, 255, THRESH_BINARY);\n\n            inRange(redMask, new Scalar(255, 255, 255, 0), new Scalar(255, 255, 255, 0), redMask);\n\n            diffPixels = countNonZero(redMask);\n\n            if (outerWidth > 0) {\n                diffPixels += outerWidth * minHeight;\n            }\n\n            if (outerHeight > 0) {\n                diffPixels += minWidth * outerHeight;\n            }\n\n            if (diffPixels > 0) {\n                diffResult = new Mat(maxHeight, maxWidth, CV_8UC4, new Scalar(0, 0, 255, 255));\n\n                if (background) {\n                    diffTemp = actualImageMin;\n                } else {\n                    diffTemp = new Mat(minHeight, minWidth, CV_8UC4, new Scalar(255, 255, 255, 0));\n                }\n\n                diffTemp.setTo(new Scalar(0, 0, 255, 255), redMask);\n                diffTemp.copyTo(new Mat(diffResult, new Rect(0, 0, minWidth, minHeight)));\n\n                imagePath = saveImage(diffResult, error);\n\n                diffPercentage = (diffPixels * 100.0f) / (maxWidth * maxHeight);\n            }\n        } catch (Exception e) {\n            error.append(System.currentTimeMillis() + \"Could not compare screens: \" + e.getMessage()).append(\"\\n\");\n            logger.error(\"[compare screens]\", e);\n        } finally {\n            if (diffResult != null) {\n                diffResult.release();\n            }\n\n            if (redMask != null) {\n                redMask.release();\n            }\n\n            if (actualImageMin != null) {\n                actualImageMin.release();\n            }\n\n            if (expectedImageMin != null) {\n                expectedImageMin.release();\n            }\n\n            if (diffTemp != null) {\n                diffTemp.release();\n            }\n        }\n\n        return new Pair(diffPercentage, imagePath);\n    }\n\n    public static String saveImage(Mat image, StringBuffer error) {\n        if (!image.empty()) {\n            try {\n                String fileName = String.format(\"%s-%s.png\", new Date().toInstant().getEpochSecond(), randomAlphanumeric(10));\n                imwrite(REPORTS_PATH + fileName, image);\n\n                return fileName;\n            } catch (Exception e) {\n                error.append(System.currentTimeMillis() + \"Could not save image: \" + e.getMessage()).append(\"\\n\");\n                logger.error(\"[save image]\", e);\n            }\n        }\n\n        return \"\";\n    }\n}", "nl": "opencv"}
{"code": "\n\n\npublic class Imgcodecs {\n\n    public static final int\n            CV_LOAD_IMAGE_UNCHANGED = -1,\n            CV_LOAD_IMAGE_GRAYSCALE = 0,\n            CV_LOAD_IMAGE_COLOR = 1,\n            CV_LOAD_IMAGE_ANYDEPTH = 2,\n            CV_LOAD_IMAGE_ANYCOLOR = 4,\n            CV_IMWRITE_JPEG_QUALITY = 1,\n            CV_IMWRITE_JPEG_PROGRESSIVE = 2,\n            CV_IMWRITE_JPEG_OPTIMIZE = 3,\n            CV_IMWRITE_JPEG_RST_INTERVAL = 4,\n            CV_IMWRITE_JPEG_LUMA_QUALITY = 5,\n            CV_IMWRITE_JPEG_CHROMA_QUALITY = 6,\n            CV_IMWRITE_PNG_COMPRESSION = 16,\n            CV_IMWRITE_PNG_STRATEGY = 17,\n            CV_IMWRITE_PNG_BILEVEL = 18,\n            CV_IMWRITE_PNG_STRATEGY_DEFAULT = 0,\n            CV_IMWRITE_PNG_STRATEGY_FILTERED = 1,\n            CV_IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY = 2,\n            CV_IMWRITE_PNG_STRATEGY_RLE = 3,\n            CV_IMWRITE_PNG_STRATEGY_FIXED = 4,\n            CV_IMWRITE_PXM_BINARY = 32,\n            CV_IMWRITE_WEBP_QUALITY = 64,\n            CV_CVTIMG_FLIP = 1,\n            CV_CVTIMG_SWAP_RB = 2,\n            IMREAD_UNCHANGED = -1,\n            IMREAD_GRAYSCALE = 0,\n            IMREAD_COLOR = 1,\n            IMREAD_ANYDEPTH = 2,\n            IMREAD_ANYCOLOR = 4,\n            IMREAD_LOAD_GDAL = 8,\n            IMWRITE_JPEG_QUALITY = 1,\n            IMWRITE_JPEG_PROGRESSIVE = 2,\n            IMWRITE_JPEG_OPTIMIZE = 3,\n            IMWRITE_JPEG_RST_INTERVAL = 4,\n            IMWRITE_JPEG_LUMA_QUALITY = 5,\n            IMWRITE_JPEG_CHROMA_QUALITY = 6,\n            IMWRITE_PNG_COMPRESSION = 16,\n            IMWRITE_PNG_STRATEGY = 17,\n            IMWRITE_PNG_BILEVEL = 18,\n            IMWRITE_PXM_BINARY = 32,\n            IMWRITE_WEBP_QUALITY = 64,\n            IMWRITE_PNG_STRATEGY_DEFAULT = 0,\n            IMWRITE_PNG_STRATEGY_FILTERED = 1,\n            IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY = 2,\n            IMWRITE_PNG_STRATEGY_RLE = 3,\n            IMWRITE_PNG_STRATEGY_FIXED = 4;\n\n\n\n    public static Mat imread(String filename, int flags)\n    {\n        \n        Mat retVal = new Mat(imread_0(filename, flags));\n        \n        return retVal;\n    }\n\n    public static Mat imread(String filename)\n    {\n        \n        Mat retVal = new Mat(imread_1(filename));\n        \n        return retVal;\n    }\n\n\n\n    public static boolean imreadmulti(String filename, List<Mat> mats, int flags)\n    {\n        Mat mats_mat = Converters.vector_Mat_to_Mat(mats);\n        boolean retVal = imreadmulti_0(filename, mats_mat.nativeObj, flags);\n        \n        return retVal;\n    }\n\n    public static boolean imreadmulti(String filename, List<Mat> mats)\n    {\n        Mat mats_mat = Converters.vector_Mat_to_Mat(mats);\n        boolean retVal = imreadmulti_1(filename, mats_mat.nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public static boolean imwrite(String filename, Mat img, MatOfInt params)\n    {\n        Mat params_mat = params;\n        boolean retVal = imwrite_0(filename, img.nativeObj, params_mat.nativeObj);\n        \n        return retVal;\n    }\n\n    public static boolean imwrite(String filename, Mat img)\n    {\n        \n        boolean retVal = imwrite_1(filename, img.nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public static Mat imdecode(Mat buf, int flags)\n    {\n        \n        Mat retVal = new Mat(imdecode_0(buf.nativeObj, flags));\n        \n        return retVal;\n    }\n\n\n\n    public static boolean imencode(String ext, Mat img, MatOfByte buf, MatOfInt params)\n    {\n        Mat buf_mat = buf;\n        Mat params_mat = params;\n        boolean retVal = imencode_0(ext, img.nativeObj, buf_mat.nativeObj, params_mat.nativeObj);\n        \n        return retVal;\n    }\n\n    public static boolean imencode(String ext, Mat img, MatOfByte buf)\n    {\n        Mat buf_mat = buf;\n        boolean retVal = imencode_1(ext, img.nativeObj, buf_mat.nativeObj);\n        \n        return retVal;\n    }\n\n\n\n\n    private static native long imread_0(String filename, int flags);\n    private static native long imread_1(String filename);\n\n    private static native boolean imreadmulti_0(String filename, long mats_mat_nativeObj, int flags);\n    private static native boolean imreadmulti_1(String filename, long mats_mat_nativeObj);\n\n    private static native boolean imwrite_0(String filename, long img_nativeObj, long params_mat_nativeObj);\n    private static native boolean imwrite_1(String filename, long img_nativeObj);\n\n    private static native long imdecode_0(long buf_nativeObj, int flags);\n\n    private static native boolean imencode_0(String ext, long img_nativeObj, long buf_mat_nativeObj, long params_mat_nativeObj);\n    private static native boolean imencode_1(String ext, long img_nativeObj, long buf_mat_nativeObj);\n\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class BlurEffect extends Effect {\n\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\t\n\t\tMat newFrame = new Mat();\n\t\tSize size = new Size(50,50);;\n\t\tImgproc.blur(frame, newFrame, size);\n\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"Blur\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\n@Component\n@RequiredArgsConstructor(onConstructor = @__(@Autowired))\npublic class CustomerResourceProcessor implements ResourceProcessor<Resource<Customer>> {\n\n\tprivate static final String X_FORWARDED_HOST = \"X-Forwarded-Host\";\n\tprivate final StoreIntegration storeIntegration;\n\tprivate final ObjectProvider<HttpServletRequest> request;\n\n\t@Override\n\tpublic Resource<Customer> process(Resource<Customer> resource) {\n\n\t\tCustomer customer = resource.getContent();\n\t\tLocation location = customer.getAddress().getLocation();\n\n\t\tMap<String, Object> parameters = new HashMap<>();\n\t\tparameters.put(\"location\", String.format(\"%s,%s\", location.getLatitude(), location.getLongitude()));\n\t\tparameters.put(\"distance\", \"50km\");\n\t\tString host = this.request.getIfAvailable().getHeader(X_FORWARDED_HOST);\n\t\tLink link = this.storeIntegration.getStoresByLocationLink(parameters, host);\n\t\tif (link != null) {\n\t\t\tresource.add(link.withRel(\"stores-nearby\"));\n\t\t}\n\n\t\treturn resource;\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n@Component\npublic class SimpleBookRepository implements BookRepository {\n\n    @Override\n    @Cacheable(\"books\")\n    public Book getByIsbn(String isbn) {\n        simulateSlowService();\n        return new Book(isbn, \"Some book\");\n    }\n\n    private void simulateSlowService() {\n        try {\n            long time = 3000L;\n            Thread.sleep(time);\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class NegativeEffect extends Effect {\n\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat(frame.size(), frame.type());\n\t\tImgproc.cvtColor(frame, newFrame, Imgproc.COLOR_RGBA2RGB);\n\t\tCore.bitwise_not(newFrame, newFrame);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Negative\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n@Service\npublic class SearchService {\n\n    private static Log logger = LogFactory.getLog(SearchService.class);\n\n    private final JestClient jestClient;\n    private final Gson gson;\n\n    private boolean useRefresh = false;\n    private SearchResultParser searchResultParser;\n\n    @Value(\"${elasticsearch.client.index}\")\n    private String index;\n\n    @Autowired\n    public SearchService(JestClient jestClient, SearchResultParser searchResultParser, Gson gson) {\n        this.jestClient = jestClient;\n        this.searchResultParser = searchResultParser;\n        this.gson = gson;\n    }\n\n    public String getIndexName() {\n        return index;\n    }\n\n    public void saveToIndex(SearchEntry entry) {\n        Index.Builder indexEntryBuilder = new Index.Builder(entry).id(entry.getId()).index(index).type(entry.getType());\n\n        if (useRefresh) {\n            indexEntryBuilder.refresh(true);\n        }\n        logger.debug(\"Indexing \" + entry.getPath());\n        execute(indexEntryBuilder.build());\n    }\n\n    public SearchResults search(String term, Pageable pageable, List<String> filter) {\n        Search.Builder searchBuilder;\n        if (StringUtils.isEmpty(term)) {\n            searchBuilder = SaganQueryBuilders.forEmptyQuery(pageable, filter);\n        }\n        else {\n            searchBuilder = SaganQueryBuilders.fullTextSearch(term, pageable, filter);\n        }\n        searchBuilder.addIndex(index);\n        Search search = searchBuilder.build();\n        logger.debug(search.getData(this.gson));\n        JestResult jestResult = execute(search);\n        return searchResultParser.parseResults(jestResult, pageable, term);\n    }\n\n    public void setUseRefresh(boolean useRefresh) {\n        this.useRefresh = useRefresh;\n    }\n\n    public void removeFromIndex(SearchEntry entry) {\n        Delete delete = new Delete.Builder(entry.getId())\n                .index(index)\n                .type(entry.getType())\n                .build();\n\n        execute(delete);\n    }\n\n    public void removeOldProjectEntriesFromIndex(String projectId, List<String> supportedVersions) {\n        FilteredQueryBuilder builder = SaganQueryBuilders.matchUnsupportedProjectEntries(projectId, supportedVersions);\n        String query = SaganQueryBuilders.wrapQuery(builder.toString());\n        execute(new DeleteByQuery.Builder(query).build());\n    }\n\n    private JestResult execute(Action action) {\n        try {\n            JestResult result = jestClient.execute(action);\n            logger.debug(result.getJsonString());\n            if (!result.isSucceeded()) {\n                logger.warn(\"Failed to execute Elastic Search action: \" + result.getErrorMessage()\n                        + \" \" + result.getJsonString());\n            }\n            return result;\n        } catch (Exception e) {\n            throw new SearchException(e);\n        }\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\nclass GuideResourceAssembler extends ResourceAssemblerSupport<Repository, GuideResource> {\n\n\tGuideResourceAssembler() {\n\t\tsuper(GuidesController.class, GuideResource.class);\n\t}\n\n\t@Override\n\tpublic GuideResource toResource(Repository repository) {\n\t\tGuideResource resource = new GuideResource(repository);\n\t\tresource.add(linkTo(methodOn(GuidesController.class)\n\t\t\t\t.showGuide(resource.getType().getSlug(), resource.getName())).withSelfRel());\n\t\tresource.add(linkTo(methodOn(GuidesController.class)\n\t\t\t\t.renderGuide(resource.getType().getSlug(), resource.getName())).withRel(\"content\"));\n\t\tresource.add(linkTo(methodOn(GuidesController.class).listGuides()).withRel(\"guides\"));\n\t\treturn resource;\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n@Component\npublic class GithubClient {\n\n\tpublic static final String API_URL_BASE = \"https://api.github.com\";\n\n\tprivate static final Pattern NEXT_LINK_PATTERN = Pattern.compile(\".*<([^>]*)>;\\\\s*rel=\\\"next\\\".*\");\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(GithubClient.class);\n\n\tprivate static final String REPOS_LIST_PATH = \"/orgs/%s/repos?per_page=100\";\n\n\tprivate static final String REPO_INFO_PATH = \"/repos/{organization}/{repositoryName}\";\n\n\tprivate static final String REPO_ZIPBALL_PATH = REPO_INFO_PATH + \"/zipball\";\n\n\tprivate static final MediaType GITHUB_PREVIEW_TYPE = MediaType.parseMediaType(\"application/vnd.github.mercy-preview+json\");\n\n\tprivate final RestTemplate restTemplate;\n\n\tpublic GithubClient(RestTemplateBuilder restTemplateBuilder,\n\t\t\tRendererProperties properties) {\n\t\trestTemplateBuilder = restTemplateBuilder\n\t\t\t\t.rootUri(API_URL_BASE)\n\t\t\t\t.additionalInterceptors(new GithubAcceptInterceptor());\n\t\tif (StringUtils.hasText(properties.getGithub().getToken())) {\n\t\t\tthis.restTemplate = restTemplateBuilder\n\t\t\t\t\t.additionalInterceptors(new GithubAppTokenInterceptor(properties.getGithub().getToken()))\n\t\t\t\t\t.build();\n\t\t}\n\t\telse {\n\t\t\tthis.logger.warn(\"GitHub API access will be rate-limited at 60 req/hour\");\n\t\t\tthis.restTemplate = restTemplateBuilder.build();\n\t\t}\n\t}\n\n\t\n\tpublic byte[] downloadRepositoryAsZipball(String organization, String repository) {\n\t\ttry {\n\t\t\tbyte[] response = this.restTemplate.getForObject(REPO_ZIPBALL_PATH,\n\t\t\t\t\tbyte[].class, organization, repository);\n\t\t\treturn response;\n\t\t}\n\t\tcatch (HttpClientErrorException ex) {\n\t\t\tthrow new GithubResourceNotFoundException(organization, ex);\n\t\t}\n\t}\n\n\t\n\tpublic List<Repository> fetchOrgRepositories(String organization) {\n\t\tList<Repository> repositories = new ArrayList<>();\n\t\tOptional<String> nextPage = Optional.of(String.format(REPOS_LIST_PATH, organization));\n\t\twhile (nextPage.isPresent()) {\n\t\t\tResponseEntity<Repository[]> page = this.restTemplate\n\t\t\t\t\t.getForEntity(nextPage.get(), Repository[].class, organization);\n\t\t\trepositories.addAll(Arrays.asList(page.getBody()));\n\t\t\tnextPage = findNextPageLink(page);\n\t\t}\n\t\treturn repositories;\n\t}\n\n\t\n\tpublic Repository fetchOrgRepository(String organization, String repositoryName) {\n\t\ttry {\n\t\t\treturn this.restTemplate\n\t\t\t\t\t.getForObject(REPO_INFO_PATH, Repository.class, organization, repositoryName);\n\t\t}\n\t\tcatch (HttpClientErrorException ex) {\n\t\t\tthrow new GithubResourceNotFoundException(organization, repositoryName, ex);\n\t\t}\n\t}\n\n\tprivate Optional<String> findNextPageLink(ResponseEntity response) {\n\t\tList<String> links = response.getHeaders().get(\"Link\");\n\t\tif (links == null) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn links.stream()\n\t\t\t\t.map(NEXT_LINK_PATTERN::matcher)\n\t\t\t\t.filter(Matcher::matches)\n\t\t\t\t.map(matcher -> matcher.group(1))\n\t\t\t\t.findFirst();\n\t}\n\n\tprivate static class GithubAppTokenInterceptor implements ClientHttpRequestInterceptor {\n\n\t\tprivate final String token;\n\n\t\tGithubAppTokenInterceptor(String token) {\n\t\t\tthis.token = token;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClientHttpResponse intercept(HttpRequest httpRequest, byte[] body,\n\t\t\t\tClientHttpRequestExecution clientHttpRequestExecution) throws IOException {\n\t\t\tif (StringUtils.hasText(this.token)) {\n\t\t\t\thttpRequest.getHeaders().set(HttpHeaders.AUTHORIZATION,\n\t\t\t\t\t\t\"Token \" + this.token);\n\t\t\t}\n\t\t\treturn clientHttpRequestExecution.execute(httpRequest, body);\n\t\t}\n\n\t}\n\n\tprivate static class GithubAcceptInterceptor implements ClientHttpRequestInterceptor {\n\n\t\t@Override\n\t\tpublic ClientHttpResponse intercept(HttpRequest request, byte[] body,\n\t\t\t\tClientHttpRequestExecution execution) throws IOException {\n\t\t\trequest.getHeaders().setAccept(Collections.singletonList(GITHUB_PREVIEW_TYPE));\n\t\t\treturn execution.execute(request, body);\n\t\t}\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\npublic class ImageSegController\n{\n\t\n\t@FXML\n\tprivate Button cameraButton;\n\t@FXML\n\tprivate ImageView originalFrame;\n\t@FXML\n\tprivate CheckBox canny;\n\t@FXML\n\tprivate Slider threshold;\n\t@FXML\n\tprivate CheckBox dilateErode;\n\t@FXML\n\tprivate CheckBox inverse;\n\t\n\tprivate ScheduledExecutorService timer;\n\tprivate VideoCapture capture = new VideoCapture();\n\tprivate boolean cameraActive;\n\t\n\tPoint clickedPoint = new Point(0, 0);\n\tMat oldFrame;\n\t\n\tprotected void init()\n\t{\n\t\tthis.threshold.setShowTickLabels(true);\n\t}\n\t\n\t\n\t@FXML\n\tprotected void startCamera()\n\t{\n\t\toriginalFrame.setFitWidth(380);\n\t\toriginalFrame.setPreserveRatio(true);\n\t\t\n\t\toriginalFrame.setOnMouseClicked(e -> {\n\t\t\tSystem.out.println(\"[\" + e.getX() + \", \" + e.getY() + \"]\");\n\t\t\tclickedPoint.x = e.getX();\n\t\t\tclickedPoint.y = e.getY();\n\t\t});\n\t\t\n\t\tif (!this.cameraActive)\n\t\t{\n\t\t\tthis.canny.setDisable(true);\n\t\t\tthis.dilateErode.setDisable(true);\n\t\t\t\n\t\t\tthis.capture.open(0);\n\t\t\t\n\t\t\tif (this.capture.isOpened())\n\t\t\t{\n\t\t\t\tthis.cameraActive = true;\n\t\t\t\t\n\t\t\t\tRunnable frameGrabber = new Runnable() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run()\n\t\t\t\t\t{\n\t\t\t\t\t\tMat frame = grabFrame();\n\t\t\t\t\t\tImage imageToShow = Utils.mat2Image(frame);\n\t\t\t\t\t\tupdateImageView(originalFrame, imageToShow);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tthis.timer = Executors.newSingleThreadScheduledExecutor();\n\t\t\t\tthis.timer.scheduleAtFixedRate(frameGrabber, 0, 33, TimeUnit.MILLISECONDS);\n\t\t\t\t\n\t\t\t\tthis.cameraButton.setText(\"Stop Camera\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.err.println(\"Failed to open the camera connection...\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.cameraActive = false;\n\t\t\tthis.cameraButton.setText(\"Start Camera\");\n\t\t\tthis.canny.setDisable(false);\n\t\t\tthis.dilateErode.setDisable(false);\n\t\t\t\n\t\t\tthis.stopAcquisition();\n\t\t}\n\t}\n\t\n\t\n\tprivate Mat grabFrame()\n\t{\n\t\tMat frame = new Mat();\n\t\t\n\t\tif (this.capture.isOpened())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis.capture.read(frame);\n\t\t\t\t\n\t\t\t\tif (!frame.empty())\n\t\t\t\t{\n\t\t\t\t\tif (this.canny.isSelected())\n\t\t\t\t\t{\n\t\t\t\t\t\tframe = this.doCanny(frame);\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.dilateErode.isSelected())\n\t\t\t\t\t{\n\t\t\t\t\t\tframe = this.doBackgroundRemovalAbsDiff(frame);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tSystem.err.print(\"Exception in the image elaboration...\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn frame;\n\t}\n\t\n\tprivate Mat doBackgroundRemovalAbsDiff(Mat currFrame)\n\t{\n\t\tMat greyImage = new Mat();\n\t\tMat foregroundImage = new Mat();\n\t\t\n\t\tif (oldFrame == null)\n\t\t\toldFrame = currFrame;\n\t\t\n\t\tCore.absdiff(currFrame, oldFrame, foregroundImage);\n\t\tImgproc.cvtColor(foregroundImage, greyImage, Imgproc.COLOR_BGR2GRAY);\n\t\t\n\t\tint thresh_type = Imgproc.THRESH_BINARY_INV;\n\t\tif (this.inverse.isSelected())\n\t\t\tthresh_type = Imgproc.THRESH_BINARY;\n\t\t\n\t\tImgproc.threshold(greyImage, greyImage, 10, 255, thresh_type);\n\t\tcurrFrame.copyTo(foregroundImage, greyImage);\n\t\t\n\t\toldFrame = currFrame;\n\t\treturn foregroundImage;\n\t\t\n\t}\n\t\n\tprivate Mat doBackgroundRemovalFloodFill(Mat frame)\n\t{\n\t\t\n\t\tScalar newVal = new Scalar(255, 255, 255);\n\t\tScalar loDiff = new Scalar(50, 50, 50);\n\t\tScalar upDiff = new Scalar(50, 50, 50);\n\t\tPoint seedPoint = clickedPoint;\n\t\tMat mask = new Mat();\n\t\tRect rect = new Rect();\n\t\t\n\t\tImgproc.floodFill(frame, mask, seedPoint, newVal, rect, loDiff, upDiff, Imgproc.FLOODFILL_FIXED_RANGE);\n\t\t\n\t\treturn frame;\n\t}\n\t\n\t\n\tprivate Mat doBackgroundRemoval(Mat frame)\n\t{\n\t\tMat hsvImg = new Mat();\n\t\tList<Mat> hsvPlanes = new ArrayList<>();\n\t\tMat thresholdImg = new Mat();\n\t\t\n\t\tint thresh_type = Imgproc.THRESH_BINARY_INV;\n\t\tif (this.inverse.isSelected())\n\t\t\tthresh_type = Imgproc.THRESH_BINARY;\n\t\t\n\t\thsvImg.create(frame.size(), CvType.CV_8U);\n\t\tImgproc.cvtColor(frame, hsvImg, Imgproc.COLOR_BGR2HSV);\n\t\tCore.split(hsvImg, hsvPlanes);\n\t\t\n\t\tdouble threshValue = this.getHistAverage(hsvImg, hsvPlanes.get(0));\n\t\t\n\t\tImgproc.threshold(hsvPlanes.get(0), thresholdImg, threshValue, 179.0, thresh_type);\n\t\t\n\t\tImgproc.blur(thresholdImg, thresholdImg, new Size(5, 5));\n\t\t\n\t\tImgproc.dilate(thresholdImg, thresholdImg, new Mat(), new Point(-1, -1), 1);\n\t\tImgproc.erode(thresholdImg, thresholdImg, new Mat(), new Point(-1, -1), 3);\n\t\t\n\t\tImgproc.threshold(thresholdImg, thresholdImg, threshValue, 179.0, Imgproc.THRESH_BINARY);\n\t\t\n\t\tMat foreground = new Mat(frame.size(), CvType.CV_8UC3, new Scalar(255, 255, 255));\n\t\tframe.copyTo(foreground, thresholdImg);\n\t\t\n\t\treturn foreground;\n\t}\n\t\n\t\n\tprivate double getHistAverage(Mat hsvImg, Mat hueValues)\n\t{\n\t\tdouble average = 0.0;\n\t\tMat hist_hue = new Mat();\n\t\tMatOfInt histSize = new MatOfInt(180);\n\t\tList<Mat> hue = new ArrayList<>();\n\t\thue.add(hueValues);\n\t\t\n\t\tImgproc.calcHist(hue, new MatOfInt(0), new Mat(), hist_hue, histSize, new MatOfFloat(0, 179));\n\t\t\n\t\tfor (int h = 0; h < 180; h++)\n\t\t{\n\t\t\taverage += (hist_hue.get(h, 0)[0] * h);\n\t\t}\n\t\t\n\t\treturn average = average / hsvImg.size().height / hsvImg.size().width;\n\t}\n\t\n\t\n\tprivate Mat doCanny(Mat frame)\n\t{\n\t\tMat grayImage = new Mat();\n\t\tMat detectedEdges = new Mat();\n\t\t\n\t\tImgproc.cvtColor(frame, grayImage, Imgproc.COLOR_BGR2GRAY);\n\t\t\n\t\tImgproc.blur(grayImage, detectedEdges, new Size(3, 3));\n\t\t\n\t\tImgproc.Canny(detectedEdges, detectedEdges, this.threshold.getValue(), this.threshold.getValue() * 3);\n\t\t\n\t\tMat dest = new Mat();\n\t\tframe.copyTo(dest, detectedEdges);\n\t\t\n\t\treturn dest;\n\t}\n\t\n\t\n\tprivate Mat doSobel(Mat frame)\n\t{\n\t\tMat grayImage = new Mat();\n\t\tMat detectedEdges = new Mat();\n\t\tint scale = 1;\n\t\tint delta = 0;\n\t\tint ddepth = CvType.CV_16S;\n\t\tMat grad_x = new Mat();\n\t\tMat grad_y = new Mat();\n\t\tMat abs_grad_x = new Mat();\n\t\tMat abs_grad_y = new Mat();\n\t\t\n\t\tImgproc.GaussianBlur(frame, frame, new Size(3, 3), 0, 0, Core.BORDER_DEFAULT);\n\t\t\n\t\tImgproc.cvtColor(frame, grayImage, Imgproc.COLOR_BGR2GRAY);\n\t\t\n\t\tImgproc.Sobel(grayImage, grad_x, ddepth, 1, 0);\n\t\tCore.convertScaleAbs(grad_x, abs_grad_x);\n\t\t\n\t\tImgproc.Sobel(grayImage, grad_y, ddepth, 0, 1);\n\t\tCore.convertScaleAbs(grad_y, abs_grad_y);\n\t\t\n\t\tCore.addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, detectedEdges);\n\t\t\n\t\treturn detectedEdges;\n\t\t\n\t}\n\t\n\t\n\t@FXML\n\tprotected void cannySelected()\n\t{\n\t\tif (this.dilateErode.isSelected())\n\t\t{\n\t\t\tthis.dilateErode.setSelected(false);\n\t\t\tthis.inverse.setDisable(true);\n\t\t}\n\t\t\n\t\tif (this.canny.isSelected())\n\t\t\tthis.threshold.setDisable(false);\n\t\telse\n\t\t\tthis.threshold.setDisable(true);\n\t\t\n\t\tthis.cameraButton.setDisable(false);\n\t}\n\t\n\t\n\t@FXML\n\tprotected void dilateErodeSelected()\n\t{\n\t\tif (this.canny.isSelected())\n\t\t{\n\t\t\tthis.canny.setSelected(false);\n\t\t\tthis.threshold.setDisable(true);\n\t\t}\n\t\t\n\t\tif (this.dilateErode.isSelected())\n\t\t\tthis.inverse.setDisable(false);\n\t\telse\n\t\t\tthis.inverse.setDisable(true);\n\t\t\n\t\tthis.cameraButton.setDisable(false);\n\t}\n\t\n\t\n\tprivate void stopAcquisition()\n\t{\n\t\tif (this.timer != null && !this.timer.isShutdown())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis.timer.shutdown();\n\t\t\t\tthis.timer.awaitTermination(33, TimeUnit.MILLISECONDS);\n\t\t\t}\n\t\t\tcatch (InterruptedException e)\n\t\t\t{\n\t\t\t\tSystem.err.println(\"Exception in stopping the frame capture, trying to release the camera now... \" + e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.capture.isOpened())\n\t\t{\n\t\t\tthis.capture.release();\n\t\t}\n\t}\n\t\n\t\n\tprivate void updateImageView(ImageView view, Image image)\n\t{\n\t\tUtils.onFXThread(view.imageProperty(), image);\n\t}\n\t\n\t\n\tprotected void setClosed()\n\t{\n\t\tthis.stopAcquisition();\n\t}\n\t\n}", "nl": "opencv"}
{"code": "\n\n\n\n@SpringBootApplication\npublic class Application implements CommandLineRunner {\n\n    private static final Logger log = LoggerFactory.getLogger(Application.class);\n\n    public static void main(String args[]) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    @Override\n    public void run(String... strings) throws Exception {\n\n        log.info(\"Creating tables\");\n\n        jdbcTemplate.execute(\"DROP TABLE customers IF EXISTS\");\n        jdbcTemplate.execute(\"CREATE TABLE customers(\" +\n                \"id SERIAL, first_name VARCHAR(255), last_name VARCHAR(255))\");\n\n        List<Object[]> splitUpNames = Arrays.asList(\"John Woo\", \"Jeff Dean\", \"Josh Bloch\", \"Josh Long\").stream()\n                .map(name -> name.split(\" \"))\n                .collect(Collectors.toList());\n\n        splitUpNames.forEach(name -> log.info(String.format(\"Inserting customer record for %s %s\", name[0], name[1])));\n\n        jdbcTemplate.batchUpdate(\"INSERT INTO customers(first_name, last_name) VALUES (?,?)\", splitUpNames);\n\n        log.info(\"Querying for customer records where first_name = 'Josh':\");\n        jdbcTemplate.query(\n                \"SELECT id, first_name, last_name FROM customers WHERE first_name = ?\", new Object[] { \"Josh\" },\n                (rs, rowNum) -> new Customer(rs.getLong(\"id\"), rs.getString(\"first_name\"), rs.getString(\"last_name\"))\n        ).forEach(customer -> log.info(customer.toString()));\n    }\n}", "nl": "spring"}
{"code": "\n\n\nclass DownloadLinkExtractor {\n    public DownloadLink createDownloadLink(FileDownload download) {\n        String url = download.getBucket() + download.getFile();\n        String fileType;\n        if (download.getFile().endsWith(\".tar.gz\")) {\n            fileType = \"tar.gz\";\n        } else {\n            fileType = download.getFile().substring(download.getFile().lastIndexOf(\".\") + 1);\n        }\n        String architecture = download.getDescription().indexOf(\"64bit\") != -1 ? \"64\" : \"32\";\n        return new DownloadLink(url, fileType, download.getSize(), download.getOs(), architecture);\n    }\n}", "nl": "spring"}
{"code": "\nclass SimpleSample {\n\n  static{ System.loadLibrary(Core.NATIVE_LIBRARY_NAME); }\n\n  public static void main(String[] args) {\n    System.out.println(\"Welcome to OpenCV \" + Core.VERSION);\n    Mat m = new Mat(5, 10, CvType.CV_8UC1, new Scalar(0));\n    System.out.println(\"OpenCV Mat: \" + m);\n    Mat mr1 = m.row(1);\n    mr1.setTo(new Scalar(1));\n    Mat mc5 = m.col(5);\n    mc5.setTo(new Scalar(5));\n    System.out.println(\"OpenCV Mat data:\\n\" + m.dump());\n  }\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@Controller\n@RequestMapping(\"/tools3\")\nclass ToolsController {\n\n    private ToolsService toolsService;\n\n    @Autowired\n    public ToolsController(ToolsService toolsService) {\n        this.toolsService = toolsService;\n    }\n\n    @RequestMapping(method = { GET, HEAD })\n    public String index(Model model) throws Exception {\n        ToolSuiteDownloads stsDownloads = toolsService.getStsGaDownloads();\n        model.addAttribute(\"stsDownloadLinks\", stsDownloads.getPreferredDownloadLinks());\n        model.addAttribute(\"stsVersion\", stsDownloads.getReleaseName());\n        return \"tools/index\";\n    }\n\n    @RequestMapping(value = \"/sts\", method = { GET, HEAD })\n    public String stsIndex(Model model) throws Exception {\n        ToolSuiteDownloads stsDownloads = toolsService.getStsGaDownloads();\n        model.addAttribute(\"downloadLinks\", stsDownloads.getPreferredDownloadLinks());\n        model.addAttribute(\"version\", stsDownloads.getReleaseName());\n        return \"tools/sts/index\";\n    }\n\n    @RequestMapping(value = \"/sts/welcome\", method = { GET, HEAD })\n    public String stsWelcome(Model model) throws Exception {\n        return \"tools/sts/welcome\";\n    }\n\n    @RequestMapping(value = \"/sts/all\", method = { GET, HEAD })\n    public String allStsDownloads(Model model) throws Exception {\n        ToolSuiteDownloads stsDownloads = toolsService.getStsGaDownloads();\n        ToolSuiteDownloads milestoneDownloads = toolsService.getStsMilestoneDownloads();\n        model.addAttribute(\"gaRelease\", stsDownloads);\n        model.addAttribute(\"milestoneRelease\", milestoneDownloads);\n        model.addAttribute(\"updateSiteArchives\", stsDownloads.getArchives());\n        return \"tools/sts/all\";\n    }\n\n    @RequestMapping(value = \"/sts/legacy\", method = { GET, HEAD })\n    public String legacyStsDownloads(Model model) throws Exception {\n        Collection<ToolSuiteDownloads> stsDownloads = toolsService.getStsLegacyDownloads();\n        model.addAttribute(\"legacyReleases\", stsDownloads);\n        return \"tools/sts/legacy\";\n    }\n\n    @RequestMapping(value = \"/eclipse\", method = { GET, HEAD })\n    public String eclipseIndex(Model model) throws Exception {\n        EclipseDownloads eclipseDownloads = toolsService.getEclipseDownloads();\n        Map<String, EclipsePlatform> allPlatforms = eclipseDownloads.getPlatforms();\n        List<EclipsePlatform> platforms = new ArrayList<>();\n        platforms.add(allPlatforms.get(\"windows\"));\n        platforms.add(allPlatforms.get(\"mac\"));\n        platforms.add(allPlatforms.get(\"linux\"));\n        model.addAttribute(\"platforms\", platforms);\n        return \"tools/eclipse/index\";\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n@Component\nclass GuideRenderer {\n\n\tprivate final GithubClient githubClient;\n\n\tprivate final RendererProperties properties;\n\n\tprivate final List<GuideContentContributor> contributors;\n\n\tpublic GuideRenderer(GithubClient githubClient, RendererProperties properties,\n\t\t\tList<GuideContentContributor> contributors) {\n\t\tthis.githubClient = githubClient;\n\t\tthis.properties = properties;\n\t\tthis.contributors = contributors;\n\t}\n\n\tGuideContentResource render(GuideType type, String guideName) {\n\t\tGuideContentResource guideContent = new GuideContentResource();\n\t\tguideContent.setName(guideName);\n\t\tString repositoryName = type.getPrefix() + guideName;\n\t\tString org = this.properties.getGuides().getOrganization();\n\t\tString tempFilePrefix = org + \"-\" + repositoryName;\n\n\t\tFile unzippedRoot = null;\n\t\tFile zipball = null;\n\t\ttry {\n\t\t\tbyte[] download = this.githubClient.downloadRepositoryAsZipball(org, repositoryName);\n\t\t\tzipball = File.createTempFile(tempFilePrefix, \".zip\");\n\t\t\tzipball.deleteOnExit();\n\t\t\tFileOutputStream zipOut = new FileOutputStream(zipball);\n\t\t\tzipOut.write(download);\n\t\t\tzipOut.close();\n\n\t\t\ttry (ZipFile zipFile = new ZipFile(zipball)) {\n\t\t\t\tunzippedRoot = null;\n\t\t\t\tfor (Enumeration<? extends ZipEntry> e = zipFile.entries(); e\n\t\t\t\t\t\t.hasMoreElements(); ) {\n\t\t\t\t\tZipEntry entry = e.nextElement();\n\t\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\t\tFile dir = new File(\n\t\t\t\t\t\t\t\tzipball.getParent() + File.separator + entry.getName());\n\t\t\t\t\t\tdir.mkdir();\n\t\t\t\t\t\tif (unzippedRoot == null) {\n\t\t\t\t\t\t\tunzippedRoot = dir; // first directory is the root\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(zipFile.getInputStream(entry),\n\t\t\t\t\t\t\t\tnew FileOutputStream(zipball.getParent() + File.separator\n\t\t\t\t\t\t\t\t\t\t+ entry.getName()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(GuideContentContributor contentContributor : this.contributors) {\n\t\t\t\tcontentContributor.contribute(guideContent, unzippedRoot);\n\t\t\t}\n\t\t\treturn guideContent;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Could not create temp file for source: \" + tempFilePrefix, ex);\n\t\t}\n\t\tfinally {\n\t\t\tFileSystemUtils.deleteRecursively(zipball);\n\t\t\tFileSystemUtils.deleteRecursively(unzippedRoot);\n\t\t}\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class ImageProcessingUtils {\n\t\n\t\n\tpublic static void jpg2png(String inputImageFileName,String outputImageFileName){\n\t\topencv_core.Mat inputImage = opencv_imgcodecs.imread(inputImageFileName, opencv_imgcodecs.IMREAD_COLOR);\n\t\topencv_core.Mat hsvImg = new opencv_core.Mat();\n\t\topencv_imgproc.cvtColor(inputImage, hsvImg, opencv_imgproc.CV_BGR2HSV);\n\t\tint hMin = 180, hMax = 0, sMin = 255, sMax = 0, vMin = 255, vMax = 0;\n\t\tint rows = hsvImg.rows();\n\t\tint cols = hsvImg.cols();\n\t\tfor (int row = 0; row < rows; row++) {\n\t\t\tBytePointer p = hsvImg.ptr(row, 0);\n\t\t\tint b = p.get(0) & 0xFF;\n\t\t\tif (b > hMax) {\n\t\t\t\thMax = b;\n\t\t\t}\n\t\t\tif (b < hMin) {\n\t\t\t\thMin = b;\n\t\t\t}\n\t\t\tint g = p.get(1) & 0xFF;\n\t\t\tif (g > sMax) {\n\t\t\t\tsMax = g;\n\t\t\t}\n\t\t\tif (g < sMin) {\n\t\t\t\tsMin = g;\n\t\t\t}\n\t\t\tint r = p.get(2) & 0xFF;\n\t\t\tif (r > vMax) {\n\t\t\t\tvMax = r;\n\t\t\t}\n\t\t\tif (r < vMin) {\n\t\t\t\tvMin = r;\n\t\t\t}\n\t\t\tp = hsvImg.ptr(row, cols - 1);\n\t\t\tb = p.get(0) & 0xFF;\n\t\t\tif (b > hMax) {\n\t\t\t\thMax = b;\n\t\t\t}\n\t\t\tif (b < hMin) {\n\t\t\t\thMin = b;\n\t\t\t}\n\t\t\tg = p.get(1) & 0xFF;\n\t\t\tif (g > sMax) {\n\t\t\t\tsMax = g;\n\t\t\t}\n\t\t\tif (g < sMin) {\n\t\t\t\tsMin = g;\n\t\t\t}\n\t\t\tr = p.get(2) & 0xFF;\n\t\t\tif (r > vMax) {\n\t\t\t\tvMax = r;\n\t\t\t}\n\t\t\tif (r < vMin) {\n\t\t\t\tvMin = r;\n\t\t\t}\n\t\t}\n\t\tfor (int col = 0; col < cols; col++) {\n\t\t\tBytePointer p = hsvImg.ptr(0, col);\n\t\t\tint b = p.get(0) & 0xFF;\n\t\t\tif (b > hMax) {\n\t\t\t\thMax = b;\n\t\t\t}\n\t\t\tif (b < hMin) {\n\t\t\t\thMin = b;\n\t\t\t}\n\t\t\tint g = p.get(1) & 0xFF;\n\t\t\tif (g > sMax) {\n\t\t\t\tsMax = g;\n\t\t\t}\n\t\t\tif (g < sMin) {\n\t\t\t\tsMin = g;\n\t\t\t}\n\t\t\tint r = p.get(2) & 0xFF;\n\t\t\tif (r > vMax) {\n\t\t\t\tvMax = r;\n\t\t\t}\n\t\t\tif (r < vMin) {\n\t\t\t\tvMin = r;\n\t\t\t}\n\t\t\tp = hsvImg.ptr(rows - 1, col);\n\t\t\tb = p.get(0) & 0xFF;\n\t\t\tif (b > hMax) {\n\t\t\t\thMax = b;\n\t\t\t}\n\t\t\tif (b < hMin) {\n\t\t\t\thMin = b;\n\t\t\t}\n\t\t\tg = p.get(1) & 0xFF;\n\t\t\tif (g > sMax) {\n\t\t\t\tsMax = g;\n\t\t\t}\n\t\t\tif (g < sMin) {\n\t\t\t\tsMin = g;\n\t\t\t}\n\t\t\tr = p.get(2) & 0xFF;\n\t\t\tif (r > vMax) {\n\t\t\t\tvMax = r;\n\t\t\t}\n\t\t\tif (r < vMin) {\n\t\t\t\tvMin = r;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(opencv_core.cvScalar(hMin, sMin, vMin, 0));\n\t\tSystem.out.println(opencv_core.cvScalar(hMax, sMax, vMax, 0));\n\t\t\n\t\thMin = hMin - 1;\n\t\thMax = hMax + 1;\n\t\tif (hMin < 0) {\n\t\t\thMin = 0;\n\t\t}\n\t\tif (hMax > 255) {\n\t\t\thMax = 255;\n\t\t}\n\t\t\n\t\tsMin = sMin - 50;\n\t\tsMax = sMax + 50;\n\t\tif (sMin < 0) {\n\t\t\tsMin = 0;\n\t\t}\n\t\tif (sMax > 255) {\n\t\t\tsMax = 255;\n\t\t}\n\t\t\n\t\tvMin = vMin - 50;\n\t\tvMax = vMax + 50;\n\t\tif (vMin < 0) {\n\t\t\tvMin = 0;\n\t\t}\n\t\tif (vMax > 255) {\n\t\t\tvMax = 255;\n\t\t}\n\t\t\n\t\topencv_core.Mat maskHSV = new opencv_core.Mat();\n\t\t\n\t\tSystem.out.println(opencv_core.cvScalar(hMin, sMin, vMin, 0));\n\t\tSystem.out.println(opencv_core.cvScalar(hMax, sMax, vMax, 0));\n\t\t\n\t\topencv_core.inRange(hsvImg, new opencv_core.Mat(new opencv_core.Scalar(hMin, sMin, vMin, 0)), new opencv_core.Mat(new opencv_core.Scalar(hMax, sMax, vMax, 0)), maskHSV);\n\t\topencv_imgcodecs.imwrite(\"D:\\\\mask.jpg\", maskHSV);\n\t\t\n\t\topencv_imgproc.morphologyEx(maskHSV, maskHSV, opencv_imgproc.MORPH_OPEN, new opencv_core.Mat());\n\t\topencv_imgcodecs.imwrite(\"D:\\\\mask2.jpg\", maskHSV);\n\t\t\n\t\topencv_core.Mat mask = new opencv_core.Mat();\n\t\topencv_imgproc.GaussianBlur(maskHSV, mask, new opencv_core.Size(5, 5), 0, 0, opencv_core.BORDER_DEFAULT);\n\t\topencv_imgcodecs.imwrite(\"D:\\\\mask3.jpg\", maskHSV);\n\t\t\n\t\topencv_core.MatVector srcChannels = new opencv_core.MatVector();\n\t\topencv_core.split(inputImage, srcChannels);\n\t\tsrcChannels.push_back(opencv_core.not(mask).asMat());\n\t\t\n\t\topencv_core.Mat dst = new opencv_core.Mat();\n\t\topencv_core.merge(srcChannels, dst);\n\t\topencv_imgcodecs.imwrite(outputImageFileName, dst);\n\t}\n\t\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n@RestController\n@RequestMapping(\"/notes\")\npublic class NotesController {\n\n\tprivate static final UriTemplate TAG_URI_TEMPLATE = new UriTemplate(\"/tags/{id}\");\n\n\tprivate final NoteRepository noteRepository;\n\n\tprivate final TagRepository tagRepository;\n\n\tprivate final NoteResourceAssembler noteResourceAssembler;\n\n\tprivate final TagResourceAssembler tagResourceAssembler;\n\n\t@Autowired\n\tpublic NotesController(NoteRepository noteRepository, TagRepository tagRepository,\n\t\t\tNoteResourceAssembler noteResourceAssembler,\n\t\t\tTagResourceAssembler tagResourceAssembler) {\n\t\tthis.noteRepository = noteRepository;\n\t\tthis.tagRepository = tagRepository;\n\t\tthis.noteResourceAssembler = noteResourceAssembler;\n\t\tthis.tagResourceAssembler = tagResourceAssembler;\n\t}\n\n\t@RequestMapping(method = RequestMethod.GET)\n\tNestedContentResource<NoteResource> all() {\n\t\treturn new NestedContentResource<NoteResource>(\n\t\t\t\tthis.noteResourceAssembler.toResources(this.noteRepository.findAll()));\n\t}\n\n\t@ResponseStatus(HttpStatus.CREATED)\n\t@RequestMapping(method = RequestMethod.POST)\n\tHttpHeaders create(@RequestBody NoteInput noteInput) {\n\t\tNote note = new Note();\n\t\tnote.setTitle(noteInput.getTitle());\n\t\tnote.setBody(noteInput.getBody());\n\t\tnote.setTags(getTags(noteInput.getTagUris()));\n\n\t\tthis.noteRepository.save(note);\n\n\t\tHttpHeaders httpHeaders = new HttpHeaders();\n\t\thttpHeaders\n\t\t\t\t.setLocation(linkTo(NotesController.class).slash(note.getId()).toUri());\n\n\t\treturn httpHeaders;\n\t}\n\n\t@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n\tvoid delete(@PathVariable(\"id\") long id) {\n\t\tthis.noteRepository.deleteById(id);\n\t}\n\n\t@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n\tResource<Note> note(@PathVariable(\"id\") long id) {\n\t\treturn this.noteResourceAssembler.toResource(findNoteById(id));\n\t}\n\n\t@RequestMapping(value = \"/{id}/tags\", method = RequestMethod.GET)\n\tResourceSupport noteTags(@PathVariable(\"id\") long id) {\n\t\treturn new NestedContentResource<TagResource>(\n\t\t\t\tthis.tagResourceAssembler.toResources(findNoteById(id).getTags()));\n\t}\n\n\t@RequestMapping(value = \"/{id}\", method = RequestMethod.PATCH)\n\t@ResponseStatus(HttpStatus.NO_CONTENT)\n\tvoid updateNote(@PathVariable(\"id\") long id, @RequestBody NotePatchInput noteInput) {\n\t\tNote note = findNoteById(id);\n\t\tif (noteInput.getTagUris() != null) {\n\t\t\tnote.setTags(getTags(noteInput.getTagUris()));\n\t\t}\n\t\tif (noteInput.getTitle() != null) {\n\t\t\tnote.setTitle(noteInput.getTitle());\n\t\t}\n\t\tif (noteInput.getBody() != null) {\n\t\t\tnote.setBody(noteInput.getBody());\n\t\t}\n\t\tthis.noteRepository.save(note);\n\t}\n\n\tprivate Note findNoteById(long id) {\n\t\tNote note = this.noteRepository.findById(id);\n\t\tif (note == null) {\n\t\t\tthrow new ResourceDoesNotExistException();\n\t\t}\n\t\treturn note;\n\t}\n\n\tprivate List<Tag> getTags(List<URI> tagLocations) {\n\t\tList<Tag> tags = new ArrayList<>(tagLocations.size());\n\t\tfor (URI tagLocation: tagLocations) {\n\t\t\tTag tag = this.tagRepository.findById(extractTagId(tagLocation));\n\t\t\tif (tag == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"The tag '\" + tagLocation\n\t\t\t\t\t\t\t\t\t\t+ \"' does not exist\");\n\t\t\t}\n\t\t\ttags.add(tag);\n\t\t}\n\t\treturn tags;\n\t}\n\n\tprivate long extractTagId(URI tagLocation) {\n\t\ttry {\n\t\t\tString idString = TAG_URI_TEMPLATE.match(tagLocation.toASCIIString()).get(\n\t\t\t\t\t\"id\");\n\t\t\treturn Long.valueOf(idString);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tthrow new IllegalArgumentException(\"The tag '\" + tagLocation + \"' is invalid\");\n\t\t}\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\n@SpringBootApplication\n@EnableJms\npublic class Application {\n\n    @Bean\n    public JmsListenerContainerFactory<?> myFactory(ConnectionFactory connectionFactory,\n                                                    DefaultJmsListenerContainerFactoryConfigurer configurer) {\n        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();\n        configurer.configure(factory, connectionFactory);\n        return factory;\n    }\n\n    @Bean // Serialize message content to json using TextMessage\n    public MessageConverter jacksonJmsMessageConverter() {\n        MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();\n        converter.setTargetType(MessageType.TEXT);\n        converter.setTypeIdPropertyName(\"_type\");\n        return converter;\n    }\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);\n\n        JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);\n\n        System.out.println(\"Sending an email message.\");\n        jmsTemplate.convertAndSend(\"mailbox\", new Email(\"info@example.com\", \"Hello\"));\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n@RestController\n@SpringBootApplication\npublic class BookApplication {\n\n  @RequestMapping(value = \"/available\")\n  public String available() {\n    return \"Spring in Action\";\n  }\n\n  @RequestMapping(value = \"/checked-out\")\n  public String checkedOut() {\n    return \"Spring Boot in Action\";\n  }\n\n  public static void main(String[] args) {\n    SpringApplication.run(BookApplication.class, args);\n  }\n}", "nl": "spring"}
{"code": "\n\n\n\n@ConfigurationProperties(\"storage\")\npublic class StorageProperties {\n\n    \n    private String location = \"upload-dir\";\n\n    public String getLocation() {\n        return location;\n    }\n\n    public void setLocation(String location) {\n        this.location = location;\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class Download implements FileDownload {\n\n    private String os;\n    private String version;\n    @JacksonXmlProperty(localName = \"eclipse-version\")\n    private String eclipseVersion;\n    private String size;\n\n    private String description;\n    private String file;\n    private String md5;\n    private String sha1;\n    private String bucket;\n\n    public String getOs() {\n        return os;\n    }\n\n    public void setOs(String os) {\n        this.os = os;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public void setVersion(String version) {\n        this.version = version;\n    }\n\n    public String getEclipseVersion() {\n        return eclipseVersion;\n    }\n\n    public void setEclipseVersion(String eclipseVersion) {\n        this.eclipseVersion = eclipseVersion;\n    }\n\n    public String getSize() {\n        return size;\n    }\n\n    public void setSize(String size) {\n        this.size = size;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String getFile() {\n        return file;\n    }\n\n    public void setFile(String file) {\n        this.file = file;\n    }\n\n    public String getBucket() {\n        return bucket;\n    }\n\n    public void setBucket(String bucket) {\n        this.bucket = bucket;\n    }\n\n    public String getMd5() {\n        return md5;\n    }\n\n    public void setMd5(String md5) {\n        this.md5 = md5;\n    }\n\n    public String getSha1() {\n        return sha1;\n    }\n\n    public void setSha1(String sha1) {\n        this.sha1 = sha1;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class SVMTrain {\n\n    private SVMCallback callback = new Features();\n    private static final String hasResistor = \"HasResistor\";\n    private static final String noResistor = \"NoResistor\";\n\n    public SVMTrain(SVMCallback callback) {\n        this.callback = callback;\n    }\n\n    public SVMTrain() {\n\n    }\n\n    private void divideFiles(float factor, String name) {\n        String filePath = \"res/data/learn/\" + name;\n        List<String> files = new ArrayList<String>();\n        Util.getFiles(filePath, files);\n        int size = files.size();\n        if (0 == size) {\n            System.out.println(\"File not found in \" + filePath);\n            return;\n        }\n        Collections.shuffle(files, new Random(new Date().getTime()));\n\n        int boundry = (int) (factor * size);\n\n        Util.recreateDir(\"res/data/train/\" + name);\n        Util.recreateDir(\"res/data/test/\" + name);\n\n        for (int i = 0; i < boundry; i++) {\n            Mat img = Imgcodecs.imread(files.get(i));\n            String str = \"res/data/train/\" + name + \"/\" + name + \"_\" + Integer.valueOf(i).toString() + \".jpg\";\n            Imgcodecs.imwrite(str, img);\n        }\n\n        for (int i = boundry; i < size; i++) {\n            Mat img = Imgcodecs.imread(files.get(i));\n            String str = \"res/data/test/\" + name + \"/\" + name + \"_\" + Integer.valueOf(i).toString() + \".jpg\";\n            Imgcodecs.imwrite(str, img);\n        }\n    }\n\n    private void getResistorTrain(Mat trainingImages, List<Integer> trainingLabels, String name) {\n        int label;\n        if (name.equals(\"HasResistor\")) {\n            label = 1;\n        } else {\n            label = 0;\n        }\n        String filePath = \"res/data/train/\" + name;\n        List<String> files = new ArrayList<String>();\n\n        Util.getFiles(filePath, files);\n\n        int size = files.size();\n        if (0 == size) {\n            System.out.println(\"File not found in \" + filePath);\n            return;\n        }\n\n        for (int i = 0; i < size; i++) {\n            Mat img = Imgcodecs.imread(files.get(i));\n\n            Mat features = callback.getHistogramFeatures(img);\n            features = features.reshape(1, 1);\n\n            trainingImages.push_back(features);\n            trainingLabels.add(label);\n        }\n    }\n\n    private void getResistorTest(List<Mat> trainingImages, List<Integer> trainingLabels, String name) {\n        int label;\n        if (name.equals(\"HasResistor\")) {\n            label = 1;\n        } else {\n            label = 0;\n        }\n        String filePath = \"res/data/test/\" + name;\n        List<String> files = new ArrayList<String>();\n\n        Util.getFiles(filePath, files);\n\n        int size = files.size();\n        if (0 == size) {\n            System.out.println(\"File not found in \" + filePath);\n            return;\n        }\n\n        for (int i = 0; i < size; i++) {\n            Mat img = Imgcodecs.imread(files.get(i));\n            trainingImages.add(img);\n            trainingLabels.add(label);\n        }\n    }\n\n    public void learn2HasResistor() {\n        learn2HasResistor(0.7f);\n    }\n\n    public void learn2HasResistor(float factor) {\n        divideFiles(factor, hasResistor);\n    }\n\n    public void learn2NoResistor() {\n        learn2NoResistor(0.7f);\n    }\n\n    public void learn2NoResistor(float factor) {\n        divideFiles(factor, noResistor);\n    }\n\n    public void getNoResistorTrain(Mat trainingImages, List<Integer> trainingLabels) {\n        getResistorTrain(trainingImages, trainingLabels, noResistor);\n    }\n\n    public void getHasResistorTrain(Mat trainingImages, List<Integer> trainingLabels) {\n        getResistorTrain(trainingImages, trainingLabels, hasResistor);\n    }\n\n\n    public void getHasResistorTest(List<Mat> testingImages, List<Integer> testingLabels) {\n        getResistorTest(testingImages, testingLabels, hasResistor);\n    }\n\n    public void getNoResistorTest(List<Mat> testingImages, List<Integer> testingLabels) {\n        getResistorTest(testingImages, testingLabels, noResistor);\n    }\n\n    public int svmTrain(boolean dividePrepared, boolean trainPrepared) {\n        Mat dataMat = new Mat();    //\n        Mat labelMat = new Mat();   //\n\n\n        Mat trainingImages = new Mat();\n        List<Integer> trainingLabels = new ArrayList<Integer>();\n\n        if (!dividePrepared) {\n            System.out.println(\"devide learn to train and test\");\n            learn2HasResistor();\n            learn2NoResistor();\n        }\n\n        if (!trainPrepared) {\n            System.out.println(\"begin to get train data to memory\");\n            getHasResistorTrain(trainingImages, trainingLabels);\n            getNoResistorTrain(trainingImages, trainingLabels);\n\n            trainingImages.copyTo(dataMat);\n            dataMat.convertTo(dataMat, CvType.CV_32FC1);\n\n            labelMat.create(trainingLabels.size(), 1, CvType.CV_32SC1);\n            for (int i = 0; i < trainingLabels.size(); i++) {\n                labelMat.put(i, 0, trainingLabels.get(i));\n            }\n\n            trainingImages.release();\n            trainingLabels = null;\n        }\n\n        SVM svm = SVM.create();\n        svm.setType(SVM.C_SVC);\n        svm.setKernel(SVM.RBF);\n        svm.setDegree(0.1);\n        svm.setGamma(0.1);\n        svm.setCoef0(0.1);\n        svm.setNu(0.1);\n        svm.setP(0.1);\n        svm.setC(1);\n        svm.setTermCriteria(new TermCriteria(1, 20000, 0.0001));\n\n        TrainData trainData = TrainData.create(dataMat, Ml.ROW_SAMPLE, labelMat);\n        svm.train(trainData.getSamples(), Ml.ROW_SAMPLE, trainData.getResponses());\n\n        dataMat.release();\n        labelMat.release();\n\n        List<Mat> testingImages = new ArrayList<Mat>();\n        List<Integer> testingLabels = new ArrayList<Integer>();\n        System.out.println(\"begin to get test data to memory\");\n\n        getHasResistorTest(testingImages, testingLabels);\n        getNoResistorTest(testingImages, testingLabels);\n\n        double ptrue_rtrue = 0;\n        double ptrue_rfalse = 0;\n        double pfalse_rtrue = 0;\n        double pfalse_rfalse = 0;\n\n        int size = testingImages.size();\n        for (int i = 0; i < size; i++) {\n            Mat p = testingImages.get(i);\n\n            Mat features = callback.getHistogramFeatures(p);\n            features = features.reshape(1, 1);\n            features.convertTo(features, CvType.CV_32FC1);\n\n            int predict = (int) svm.predict(features);\n            int real = testingLabels.get(i);\n\n            if (predict == 1 && real == 1)\n                ptrue_rtrue++;\n            if (predict == 1 && real == 0)\n                ptrue_rfalse++;\n            if (predict == 0 && real == 1)\n                pfalse_rtrue++;\n            if (predict == 0 && real == 0)\n                pfalse_rfalse++;\n        }\n\n        System.out.println(\"ptrue_rtrue: \" + Double.valueOf(ptrue_rtrue).toString());\n        System.out.println(\"ptrue_rfalse: \" + Double.valueOf(ptrue_rfalse).toString());\n        System.out.println(\"pfalse_rtrue: \" + Double.valueOf(pfalse_rtrue).toString());\n        System.out.println(\"pfalse_rfalse: \" + Double.valueOf(pfalse_rfalse).toString());\n        return 0;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n\n    @Autowired\n    private BookRepository bookRepository;\n\n    @GetMapping\n    public Iterable<Book> findAll() {\n        return bookRepository.findAll();\n    }\n\n    @GetMapping(\"/title/{bookTitle}\")\n    public List<Book> findByTitle(@PathVariable String bookTitle) {\n        return bookRepository.findByTitle(bookTitle);\n    }\n\n    @GetMapping(\"/{id}\")\n    public Book findOne(@PathVariable long id) {\n        return bookRepository.findById(id)\n          .orElseThrow(BookNotFoundException::new);\n    }\n\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public Book create(@RequestBody Book book) {\n        Book book1 = bookRepository.save(book);\n        return book1;\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public void delete(@PathVariable long id) {\n        bookRepository.findById(id)\n          .orElseThrow(BookNotFoundException::new);\n        bookRepository.deleteById(id);\n    }\n\n    @PutMapping(\"/{id}\")\n    public Book updateBook(@RequestBody Book book, @PathVariable long id) {\n        if (book.getId() != id) {\n            throw new BookIdMismatchException();\n        }\n        bookRepository.findById(id)\n          .orElseThrow(BookNotFoundException::new);\n        return bookRepository.save(book);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class PyramidUp {\n   public static void main( String[] args ) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap13/pyramid_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Imgproc.pyrUp(src, dst, new Size(src.cols()*2,  src.rows()*2), Core.BORDER_DEFAULT);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap13/pyrUp_output.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\npublic interface ImageTransformer {\n\n    public class Data {\n        public Data() { this(null, null, null, null, 0, 0, 0, null, null, 0); }\n        public Data(IplImage srcImg, IplImage subImg, IplImage srcDotImg, IplImage mask,\n                double zeroThreshold, double outlierThreshold, int pyramidLevel,\n                IplImage transImg, IplImage dstImg, int dstDstDotLength) {\n            this.srcImg    = srcImg;\n            this.subImg    = subImg;\n            this.srcDotImg = srcDotImg;\n            this.mask      = mask;\n            this.zeroThreshold    = zeroThreshold;\n            this.outlierThreshold = outlierThreshold;\n            this.pyramidLevel     = pyramidLevel;\n            this.transImg  = transImg;\n            this.dstImg    = dstImg;\n            this.dstDstDot = dstDstDotLength == 0 ? null : \n                    ByteBuffer.allocateDirect(dstDstDotLength*8).\n                            order(ByteOrder.nativeOrder()).asDoubleBuffer();\n        }\n\n        public IplImage srcImg, subImg, srcDotImg, mask;\n        public double   zeroThreshold, outlierThreshold;\n        public int      pyramidLevel;\n\n        public IplImage transImg, dstImg;\n        public int      dstCount, dstCountZero, dstCountOutlier;\n        public double   srcDstDot;\n        public DoubleBuffer dstDstDot;\n    }\n\n    public interface Parameters extends Cloneable {\n        int size();\n        double[] get();\n        double   get(int i);\n        void set(double ... p);\n        void set(int i, double p);\n        void set(Parameters p);\n        void reset(boolean asIdentity);\n        double getConstraintError();\n        void compose(Parameters p1, boolean inverse1, Parameters p2, boolean inverse2);\n        boolean preoptimize();\n        double[] getSubspace();\n        void setSubspace(double ... p);\n        Parameters clone();\n    }\n\n    Parameters createParameters();\n    void transform(Data[] data, CvRect roi, Parameters[] parameters, boolean[] inverses);\n    void transform(CvMat srcPts, CvMat dstPts, Parameters parameters, boolean inverse);\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@Controller\nclass TeamAdminController {\n\n    private final TeamService teamService;\n    private final TeamImporter teamImporter;\n    private final InMemoryUsersConnectionRepository usersConnectionRepository;\n\n    @Autowired\n    public TeamAdminController(TeamService teamService, TeamImporter teamImporter,\n                               InMemoryUsersConnectionRepository usersConnectionRepository) {\n        this.teamService = teamService;\n        this.teamImporter = teamImporter;\n        this.usersConnectionRepository = usersConnectionRepository;\n    }\n\n    @RequestMapping(value = \"/admin/team\", method = { GET, HEAD })\n    public String getTeamAdminPage(Model model) {\n        model.addAttribute(\"activeMembers\", teamService.fetchActiveMembers());\n        model.addAttribute(\"hiddenMembers\", teamService.fetchHiddenMembers());\n        return \"admin/team/index\";\n    }\n\n    @RequestMapping(value = \"/admin/profile\", method = { GET, HEAD })\n    public String editProfileForm(Principal principal, Model model) {\n        MemberProfile profile = teamService.fetchMemberProfile(new Long(principal.getName()));\n        model.addAttribute(\"profile\", profile);\n        model.addAttribute(\"formAction\", \"/admin/profile\");\n        return \"admin/team/edit\";\n    }\n\n    @RequestMapping(value = \"/admin/team/{username}\", method = { GET, HEAD })\n    public String editTeamMemberForm(@PathVariable(\"username\") String username, Model model) {\n        MemberProfile profile = teamService.fetchMemberProfileUsername(username);\n        if (profile == MemberProfile.NOT_FOUND) {\n            throw new MemberNotFoundException(username);\n        }\n        model.addAttribute(\"profile\", profile);\n        model.addAttribute(\"formAction\", \"/admin/team/\" + username);\n        return \"admin/team/edit\";\n    }\n\n    @RequestMapping(value = \"/admin/profile\", method = PUT)\n    public String saveProfile(Principal principal, MemberProfile profile) {\n        teamService.updateMemberProfile(new Long(principal.getName()), profile);\n        return \"redirect:/admin/profile\";\n    }\n\n    @RequestMapping(value = \"/admin/team/{username}\", method = PUT)\n    public String saveTeamMember(@PathVariable(\"username\") String username, MemberProfile profile) {\n        teamService.updateMemberProfile(username, profile);\n        return \"redirect:/admin/team/\" + username;\n    }\n\n    @RequestMapping(value = \"/admin/team/github_import\", method = POST)\n    public String importTeamMembersFromGithub(Principal principal) {\n        GitHub gitHub = getGitHub(principal);\n        teamImporter.importTeamMembers(gitHub);\n        return \"redirect:/admin/team\";\n    }\n\n    private GitHub getGitHub(Principal principal) {\n        MemberProfile profile = teamService.fetchMemberProfile(new Long(principal.getName()));\n        String githubId = profile.getGithubId().toString();\n        ConnectionRepository connectionRepository = usersConnectionRepository.createConnectionRepository(githubId);\n        Connection<GitHub> connection = connectionRepository.findPrimaryConnection(GitHub.class);\n        if (connection != null) {\n            return connection.getApi();\n        }\n        throw new RuntimeException(\"Unable to obtain GitHub connection\");\n    }\n}", "nl": "spring"}
{"code": "\n\n\npublic class ElasticSearchServiceInfo extends BaseServiceInfo {\n\n\tpublic static final String HTTP_SCHEME = \"http\";\n\tpublic static final String HTTPS_SCHEME = \"https\";\n\n\tprivate static UriInfoFactory uriFactory = new StandardUriInfoFactory();\n\n\tprivate UriInfo uriInfo;\n\tprivate UriInfo sslUriInfo;\n\n\tpublic ElasticSearchServiceInfo(String id, String uri, String sslUri) {\n\t\tsuper(id);\n\t\tthis.uriInfo = getUriInfoFactory().createUri(uri);\n\t\tthis.sslUriInfo = getUriInfoFactory().createUri(sslUri);\n\t}\n\n\tpublic UriInfoFactory getUriInfoFactory() {\n\t\treturn uriFactory;\n\t}\n\n\t@ServiceProperty(category = \"connection\")\n\tpublic String getUri() {\n\t\treturn uriInfo.toString();\n\t}\n\n\t@ServiceProperty(category = \"connection\")\n\tpublic String getSslUri() {\n\t\treturn sslUriInfo.toString();\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n@RunWith(SpringRunner.class)\n@WebMvcTest(HomeController.class)\npublic class WebLayerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void shouldReturnDefaultMessage() throws Exception {\n        this.mockMvc.perform(get(\"/\")).andDo(print()).andExpect(status().isOk())\n                .andExpect(content().string(containsString(\"Hello World\")));\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\n\n\npublic class detectContours {\n\n    public static void main(String[] args) throws InterruptedException {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n        \n        Mat img1 = Highgui.imread(\"files/cctv_example1.png\");\n        Mat img2 = Highgui.imread(\"files/cctv_example2.png\");\n        \n        \n        Mat diff_img = new Mat();\n        \n        \n        Core.absdiff(img1, img2, diff_img);\n       \n        \n        Mat grey = new Mat();\n        Imgproc.cvtColor(diff_img, grey, Imgproc.COLOR_BGR2GRAY);\n       \n        Imgproc.adaptiveThreshold(grey, diff_img, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C, \n        \t\t\t\t\t\t\tImgproc.THRESH_BINARY_INV, 7, 10);\n        \n        \n        Size ksize = new Size(15,15);\n        Mat kernel =  Imgproc.getStructuringElement(Imgproc.MORPH_ELLIPSE, ksize);\n        \n        Imgproc.morphologyEx(diff_img, diff_img, Imgproc.MORPH_CLOSE, kernel);\n        \n        \n        List<MatOfPoint> contours = new Vector<MatOfPoint>();\n        \n        Imgproc.findContours(diff_img, contours, new Mat(), Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE);\n         \n        \n        Imgproc.drawContours(img2, contours, -1, new Scalar(0,0,255));\n        \n        \n        double maxArea = 0;\n        int maxAreaIndex = 0;\n        \n        for (int i = 0; i < contours.size(); i++) {\n        \t\n        \tdouble area = Imgproc.contourArea(contours.get(i), false);\n            \n        \tif ( area > maxArea )\n        \t{\n        \t\tmaxArea = area;\n        \t\tmaxAreaIndex = i;\n        \t}\n        }\n        \n        \n        Imgproc.drawContours(img2, contours, maxAreaIndex, new Scalar(0,255,0));\n        \n            \n        Imshow ims1 = new Imshow(\"Image 1\");\n        Imshow ims2 = new Imshow(\"Image 2\");\n        Imshow ims_diff = new Imshow(\"Difference\");\n        \t\n\n        ims1.showImage(img1);\n        ims2.showImage(img2);\n        ims_diff.showImage(diff_img);\n         \n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\npublic class FaceDetection{\n\n\tpublic static final String XML_FILE = \n\t\t\t\"resources/haarcascade_frontalface_default.xml\";\n\n\tpublic static void main(String[] args){\n\n\t\tIplImage img = cvLoadImage(\"resources/lena.jpg\");\t\t\n\t\tdetect(img);\t\t\n\t}\t\n\n\tpublic static void detect(IplImage src){\n\n\t\tCvHaarClassifierCascade cascade = new \n\t\t\t\tCvHaarClassifierCascade(cvLoad(XML_FILE));\n\t\tCvMemStorage storage = CvMemStorage.create();\n\t\tCvSeq sign = cvHaarDetectObjects(\n\t\t\t\tsrc,\n\t\t\t\tcascade,\n\t\t\t\tstorage,\n\t\t\t\t1.5,\n\t\t\t\t3,\n\t\t\t\tCV_HAAR_DO_CANNY_PRUNING);\n\n\t\tcvClearMemStorage(storage);\n\n\t\tint total_Faces = sign.total();\t\t\n\n\t\tfor(int i = 0; i < total_Faces; i++){\n\t\t\tCvRect r = new CvRect(cvGetSeqElem(sign, i));\n\t\t\tcvRectangle (\n\t\t\t\t\tsrc,\n\t\t\t\t\tcvPoint(r.x(), r.y()),\n\t\t\t\t\tcvPoint(r.width() + r.x(), r.height() + r.y()),\n\t\t\t\t\tCvScalar.RED,\n\t\t\t\t\t2,\n\t\t\t\t\tCV_AA,\n\t\t\t\t\t0);\n\n\t\t}\n\n\t\tcvShowImage(\"Result\", src);\n\t\tcvWaitKey(0);\n\n\t}\t\t\t\n}", "nl": "opencv"}
{"code": "\n\n\n\n@Component\npublic class GreetingHandler {\n\n\tpublic Mono<ServerResponse> hello(ServerRequest request) {\n\t\treturn ServerResponse.ok().contentType(MediaType.TEXT_PLAIN)\n\t\t\t.body(BodyInserters.fromObject(\"Hello, Spring!\"));\n\t}\n}", "nl": "spring"}
{"code": "\n\n\npublic class ScharrTest {\n\n   public static void main( String[] args ) {\n\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap16/sobel_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Imgproc.Scharr(src, dst, Imgproc.CV_SCHARR, 0, 1);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap16/scharr_output.jpg\", dst);\n\n      System.out.println(\"Image processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n@RestController\nclass EmployeeController {\n\n  private final EmployeeRepository repository;\n\n  EmployeeController(EmployeeRepository repository) {\n    this.repository = repository;\n  }\n\n\n  @GetMapping(\"/employees\")\n  List<Employee> all() {\n    return repository.findAll();\n  }\n\n  @PostMapping(\"/employees\")\n  Employee newEmployee(@RequestBody Employee newEmployee) {\n    return repository.save(newEmployee);\n  }\n\n\n  @GetMapping(\"/employees/{id}\")\n  Employee one(@PathVariable Long id) {\n\n    return repository.findById(id)\n      .orElseThrow(() -> new EmployeeNotFoundException(id));\n  }\n\n  @PutMapping(\"/employees/{id}\")\n  Employee replaceEmployee(@RequestBody Employee newEmployee, @PathVariable Long id) {\n\n    return repository.findById(id)\n      .map(employee -> {\n        employee.setName(newEmployee.getName());\n        employee.setRole(newEmployee.getRole());\n        return repository.save(employee);\n      })\n      .orElseGet(() -> {\n        newEmployee.setId(id);\n        return repository.save(newEmployee);\n      });\n  }\n\n  @DeleteMapping(\"/employees/{id}\")\n  void deleteEmployee(@PathVariable Long id) {\n    repository.deleteById(id);\n  }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n@Controller\nclass AtomFeedController {\n\n    private final BlogService blogService;\n    private final AtomFeedView atomFeedView;\n\n    @Autowired\n    public AtomFeedController(BlogService blogService, SiteUrl siteUrl, DateFactory dateFactory) {\n        this.blogService = blogService;\n        this.atomFeedView = new AtomFeedView(siteUrl, dateFactory);\n    }\n\n    @RequestMapping(value = \"/blog.atom\", method = { GET, HEAD })\n    public AtomFeedView listPublishedPosts(Model model, HttpServletResponse response) {\n        Page<Post> page = blogService.getPublishedPosts(PageableFactory.forFeeds());\n        prepareResponse(model, response, page, \"\", \"\");\n        return atomFeedView;\n    }\n\n    @RequestMapping(value = \"/blog/category/{category}.atom\", method = { GET, HEAD })\n    public AtomFeedView listPublishedPostsForCategory(@PathVariable PostCategory category, Model model,\n                                                      HttpServletResponse response) {\n        Page<Post> page = blogService.getPublishedPosts(category, PageableFactory.forFeeds());\n        prepareResponse(model, response, page, category.getDisplayName(), \"/category/\" + category.getUrlSlug());\n        return atomFeedView;\n    }\n\n    @RequestMapping(value = \"/blog/broadcasts.atom\", method = { GET, HEAD })\n    public AtomFeedView listPublishedBroadcastPosts(Model model, HttpServletResponse response) {\n        Page<Post> page = blogService.getPublishedBroadcastPosts(PageableFactory.forFeeds());\n        prepareResponse(model, response, page, \"Broadcasts\", \"/broadcasts\");\n        return atomFeedView;\n    }\n\n    private void prepareResponse(Model model, HttpServletResponse response, Page<Post> page,\n                                 String category, String subPath) {\n        response.setCharacterEncoding(\"utf-8\");\n        model.addAttribute(\"posts\", page.getContent());\n        model.addAttribute(\"feed-title\", (\"Spring \" + category).trim());\n        String blogPath = \"/blog\" + subPath;\n        model.addAttribute(\"blog-path\", blogPath);\n        model.addAttribute(\"feed-path\", blogPath + \".atom\");\n    }\n}", "nl": "spring"}
{"code": "\n\n\n@RestController\npublic class CoffeeController {\n    private final ReactiveRedisOperations<String, Coffee> coffeeOps;\n\n    CoffeeController(ReactiveRedisOperations<String, Coffee> coffeeOps) {\n        this.coffeeOps = coffeeOps;\n    }\n\n    @GetMapping(\"/coffees\")\n    public Flux<Coffee> all() {\n        return coffeeOps.keys(\"*\")\n                .flatMap(coffeeOps.opsForValue()::get);\n    }\n}", "nl": "spring"}
{"code": "\n\n\npublic class FeatureDetector {\n\n    protected final long nativeObj;\n    protected FeatureDetector(long addr) { nativeObj = addr; }\n\n\n    private static final int\n            GRIDDETECTOR = 1000,\n            PYRAMIDDETECTOR = 2000,\n            DYNAMICDETECTOR = 3000;\n\n\n    public static final int\n            FAST = 1,\n            STAR = 2,\n            SIFT = 3,\n            SURF = 4,\n            ORB = 5,\n            MSER = 6,\n            GFTT = 7,\n            HARRIS = 8,\n            SIMPLEBLOB = 9,\n            DENSE = 10,\n            BRISK = 11,\n            AKAZE = 12,\n            GRID_FAST = GRIDDETECTOR + FAST,\n            GRID_STAR = GRIDDETECTOR + STAR,\n            GRID_SIFT = GRIDDETECTOR + SIFT,\n            GRID_SURF = GRIDDETECTOR + SURF,\n            GRID_ORB = GRIDDETECTOR + ORB,\n            GRID_MSER = GRIDDETECTOR + MSER,\n            GRID_GFTT = GRIDDETECTOR + GFTT,\n            GRID_HARRIS = GRIDDETECTOR + HARRIS,\n            GRID_SIMPLEBLOB = GRIDDETECTOR + SIMPLEBLOB,\n            GRID_DENSE = GRIDDETECTOR + DENSE,\n            GRID_BRISK = GRIDDETECTOR + BRISK,\n            GRID_AKAZE = GRIDDETECTOR + AKAZE,\n            PYRAMID_FAST = PYRAMIDDETECTOR + FAST,\n            PYRAMID_STAR = PYRAMIDDETECTOR + STAR,\n            PYRAMID_SIFT = PYRAMIDDETECTOR + SIFT,\n            PYRAMID_SURF = PYRAMIDDETECTOR + SURF,\n            PYRAMID_ORB = PYRAMIDDETECTOR + ORB,\n            PYRAMID_MSER = PYRAMIDDETECTOR + MSER,\n            PYRAMID_GFTT = PYRAMIDDETECTOR + GFTT,\n            PYRAMID_HARRIS = PYRAMIDDETECTOR + HARRIS,\n            PYRAMID_SIMPLEBLOB = PYRAMIDDETECTOR + SIMPLEBLOB,\n            PYRAMID_DENSE = PYRAMIDDETECTOR + DENSE,\n            PYRAMID_BRISK = PYRAMIDDETECTOR + BRISK,\n            PYRAMID_AKAZE = PYRAMIDDETECTOR + AKAZE,\n            DYNAMIC_FAST = DYNAMICDETECTOR + FAST,\n            DYNAMIC_STAR = DYNAMICDETECTOR + STAR,\n            DYNAMIC_SIFT = DYNAMICDETECTOR + SIFT,\n            DYNAMIC_SURF = DYNAMICDETECTOR + SURF,\n            DYNAMIC_ORB = DYNAMICDETECTOR + ORB,\n            DYNAMIC_MSER = DYNAMICDETECTOR + MSER,\n            DYNAMIC_GFTT = DYNAMICDETECTOR + GFTT,\n            DYNAMIC_HARRIS = DYNAMICDETECTOR + HARRIS,\n            DYNAMIC_SIMPLEBLOB = DYNAMICDETECTOR + SIMPLEBLOB,\n            DYNAMIC_DENSE = DYNAMICDETECTOR + DENSE,\n            DYNAMIC_BRISK = DYNAMICDETECTOR + BRISK,\n            DYNAMIC_AKAZE = DYNAMICDETECTOR + AKAZE;\n\n\n\n    public  void detect(Mat image, MatOfKeyPoint keypoints, Mat mask)\n    {\n        Mat keypoints_mat = keypoints;\n        detect_0(nativeObj, image.nativeObj, keypoints_mat.nativeObj, mask.nativeObj);\n        \n        return;\n    }\n\n    public  void detect(Mat image, MatOfKeyPoint keypoints)\n    {\n        Mat keypoints_mat = keypoints;\n        detect_1(nativeObj, image.nativeObj, keypoints_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void detect(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> masks)\n    {\n        Mat images_mat = Converters.vector_Mat_to_Mat(images);\n        Mat keypoints_mat = new Mat();\n        Mat masks_mat = Converters.vector_Mat_to_Mat(masks);\n        detect_2(nativeObj, images_mat.nativeObj, keypoints_mat.nativeObj, masks_mat.nativeObj);\n        Converters.Mat_to_vector_vector_KeyPoint(keypoints_mat, keypoints);\n        keypoints_mat.release();\n        return;\n    }\n\n    public  void detect(List<Mat> images, List<MatOfKeyPoint> keypoints)\n    {\n        Mat images_mat = Converters.vector_Mat_to_Mat(images);\n        Mat keypoints_mat = new Mat();\n        detect_3(nativeObj, images_mat.nativeObj, keypoints_mat.nativeObj);\n        Converters.Mat_to_vector_vector_KeyPoint(keypoints_mat, keypoints);\n        keypoints_mat.release();\n        return;\n    }\n\n\n\n    public  boolean empty()\n    {\n        \n        boolean retVal = empty_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public static FeatureDetector create(int detectorType)\n    {\n        \n        FeatureDetector retVal = new FeatureDetector(create_0(detectorType));\n        \n        return retVal;\n    }\n\n\n\n    public  void write(String fileName)\n    {\n        \n        write_0(nativeObj, fileName);\n        \n        return;\n    }\n\n\n\n    public  void read(String fileName)\n    {\n        \n        read_0(nativeObj, fileName);\n        \n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n    private static native void detect_0(long nativeObj, long image_nativeObj, long keypoints_mat_nativeObj, long mask_nativeObj);\n    private static native void detect_1(long nativeObj, long image_nativeObj, long keypoints_mat_nativeObj);\n\n    private static native void detect_2(long nativeObj, long images_mat_nativeObj, long keypoints_mat_nativeObj, long masks_mat_nativeObj);\n    private static native void detect_3(long nativeObj, long images_mat_nativeObj, long keypoints_mat_nativeObj);\n\n    private static native boolean empty_0(long nativeObj);\n\n    private static native long create_0(int detectorType);\n\n    private static native void write_0(long nativeObj, String fileName);\n\n    private static native void read_0(long nativeObj, String fileName);\n\n    private static native void delete(long nativeObj);\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n@SpringBootApplication\n@EnableMessageHistory\npublic class DynamicTcpClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tConfigurableApplicationContext context = SpringApplication.run(DynamicTcpClientApplication.class, args);\n\t\tToTCP toTcp = context.getBean(ToTCP.class);\n\t\ttoTcp.send(\"foo\", \"localhost\", 1234);\n\t\ttoTcp.send(\"foo\", \"localhost\", 5678);\n\t\tQueueChannel outputChannel = context.getBean(\"outputChannel\", QueueChannel.class);\n\t\tSystem.out.println(outputChannel.receive(10000));\n\t\tSystem.out.println(outputChannel.receive(10000));\n\t\tcontext.close();\n\t}\n\n\n\t@MessagingGateway(defaultRequestChannel = \"toTcp.input\")\n\tpublic interface ToTCP {\n\n\t\tpublic void send(String data, @Header(\"host\") String host, @Header(\"port\") int port);\n\n\t}\n\n\t@Bean\n\tpublic IntegrationFlow toTcp() {\n\t\treturn f -> f.route(new TcpRouter());\n\t}\n\n\n\t@Bean\n\tpublic TcpNetServerConnectionFactory cfOne() {\n\t\treturn new TcpNetServerConnectionFactory(1234);\n\t}\n\n\t@Bean\n\tpublic TcpReceivingChannelAdapter inOne(TcpNetServerConnectionFactory cfOne) {\n\t\tTcpReceivingChannelAdapter adapter = new TcpReceivingChannelAdapter();\n\t\tadapter.setConnectionFactory(cfOne);\n\t\tadapter.setOutputChannel(outputChannel());\n\t\treturn adapter;\n\t}\n\n\t@Bean\n\tpublic TcpNetServerConnectionFactory cfTwo() {\n\t\treturn new TcpNetServerConnectionFactory(5678);\n\t}\n\n\t@Bean\n\tpublic TcpReceivingChannelAdapter inTwo(TcpNetServerConnectionFactory cfTwo) {\n\t\tTcpReceivingChannelAdapter adapter = new TcpReceivingChannelAdapter();\n\t\tadapter.setConnectionFactory(cfTwo);\n\t\tadapter.setOutputChannel(outputChannel());\n\t\treturn adapter;\n\t}\n\n\t@Bean\n\tpublic QueueChannel outputChannel() {\n\t\treturn new QueueChannel();\n\t}\n\n\tpublic static class TcpRouter extends AbstractMessageRouter {\n\n\t\tprivate final static int MAX_CACHED = 10; // When this is exceeded, we remove the LRU.\n\n\t\t@SuppressWarnings(\"serial\")\n\t\tprivate final LinkedHashMap<String, MessageChannel> subFlows =\n\t\t\t\tnew LinkedHashMap<String, MessageChannel>(MAX_CACHED, .75f, true) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected boolean removeEldestEntry(Entry<String, MessageChannel> eldest) {\n\t\t\t\t\t\tif (size() > MAX_CACHED) {\n\t\t\t\t\t\t\tremoveSubFlow(eldest);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t@Autowired\n\t\tprivate IntegrationFlowContext flowContext;\n\n\t\t@Override\n\t\tprotected synchronized Collection<MessageChannel> determineTargetChannels(Message<?> message) {\n\t\t\tMessageChannel channel = this.subFlows\n\t\t\t\t\t.get(message.getHeaders().get(\"host\", String.class) + message.getHeaders().get(\"port\"));\n\t\t\tif (channel == null) {\n\t\t\t\tchannel = createNewSubflow(message);\n\t\t\t}\n\t\t\treturn Collections.singletonList(channel);\n\t\t}\n\n\t\tprivate MessageChannel createNewSubflow(Message<?> message) {\n\t\t\tString host = (String) message.getHeaders().get(\"host\");\n\t\t\tInteger port = (Integer) message.getHeaders().get(\"port\");\n\t\t\tAssert.state(host != null && port != null, \"host and/or port header missing\");\n\t\t\tString hostPort = host + port;\n\n\t\t\tTcpNetClientConnectionFactory cf = new TcpNetClientConnectionFactory(host, port);\n\t\t\tTcpSendingMessageHandler handler = new TcpSendingMessageHandler();\n\t\t\thandler.setConnectionFactory(cf);\n\t\t\tIntegrationFlow flow = f -> f.handle(handler);\n\t\t\tIntegrationFlowContext.IntegrationFlowRegistration flowRegistration =\n\t\t\t\t\tthis.flowContext.registration(flow)\n\t\t\t\t\t\t\t.addBean(cf)\n\t\t\t\t\t\t\t.id(hostPort + \".flow\")\n\t\t\t\t\t\t\t.register();\n\t\t\tMessageChannel inputChannel = flowRegistration.getInputChannel();\n\t\t\tthis.subFlows.put(hostPort, inputChannel);\n\t\t\treturn inputChannel;\n\t\t}\n\n\t\tprivate void removeSubFlow(Entry<String, MessageChannel> eldest) {\n\t\t\tString hostPort = eldest.getKey();\n\t\t\tthis.flowContext.remove(hostPort + \".flow\");\n\t\t}\n\n\t}\n\n}", "nl": "spring"}
{"code": "\n\npublic class Sepia \n{ \n\tpublic static void main(String args[])throws IOException \n\t{ \n\t\tBufferedImage img = null; \n\t\tFile f = null; \n\n\t\ttry\n\t\t{ \n\t\t\tf = new File(\"G:\\\\Inp.jpg\"); \n\t\t\timg = ImageIO.read(f); \n\t\t} \n\t\tcatch(IOException e) \n\t\t{ \n\t\t\tSystem.out.println(e); \n\t\t} \n\n\t\tint width = img.getWidth(); \n\t\tint height = img.getHeight(); \n\n\t\tfor(int y = 0; y < height; y++) \n\t\t{ \n\t\t\tfor(int x = 0; x < width; x++) \n\t\t\t{ \n\t\t\t\tint p = img.getRGB(x,y); \n\n\t\t\t\tint a = (p>>24)&0xff; \n\t\t\t\tint R = (p>>16)&0xff; \n\t\t\t\tint G = (p>>8)&0xff; \n\t\t\t\tint B = p&0xff; \n\n\t\t\t\tint newRed = (int)(0.393*R + 0.769*G + 0.189*B); \n\t\t\t\tint newGreen = (int)(0.349*R + 0.686*G + 0.168*B); \n\t\t\t\tint newBlue = (int)(0.272*R + 0.534*G + 0.131*B); \n\n\t\t\t\tif (newRed > 255) \n\t\t\t\t\tR = 255; \n\t\t\t\telse\n\t\t\t\t\tR = newRed; \n\n\t\t\t\tif (newGreen > 255) \n\t\t\t\t\tG = 255; \n\t\t\t\telse\n\t\t\t\t\tG = newGreen; \n\n\t\t\t\tif (newBlue > 255) \n\t\t\t\t\tB = 255; \n\t\t\t\telse\n\t\t\t\t\tB = newBlue; \n\n\t\t\t\tp = (a<<24) | (R<<16) | (G<<8) | B; \n\n\t\t\t\timg.setRGB(x, y, p); \n\t\t\t} \n\t\t} \n\n\t\ttry\n\t\t{ \n\t\t\tf = new File(\"G:\\\\Out.jpg\"); \n\t\t\tImageIO.write(img, \"jpg\", f); \n\t\t} \n\t\tcatch(IOException e) \n\t\t{ \n\t\t\tSystem.out.println(e); \n\t\t} \n\t} \n} \n", "nl": "opencv"}
{"code": "\n\n\n@Controller    // This means that this class is a Controller\n@RequestMapping(path=\"/demo\") // This means URL's start with /demo (after Application path)\npublic class MainController {\n\t@Autowired // This means to get the bean called userRepository\n\tprivate UserRepository userRepository;\n\t\n\t@PostMapping(path=\"/add\") // Map ONLY POST Requests\n\tpublic @ResponseBody String addNewUser (@RequestParam String name\n\t\t\t, @RequestParam String email) {\n\t\t\n\t\tUser n = new User();\n\t\tn.setName(name);\n\t\tn.setEmail(email);\n\t\tuserRepository.save(n);\n\t\treturn \"Saved\";\n\t}\n\t\n\t@GetMapping(path=\"/all\")\n\tpublic @ResponseBody Iterable<User> getAllUsers() {\n\t\treturn userRepository.findAll();\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class XrayEffect extends Effect {\n\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat(frame.size(), frame.type());\n\t\tImgproc.cvtColor(frame, newFrame, Imgproc.COLOR_RGBA2GRAY);\n\t\tImgproc.cvtColor(newFrame, newFrame, Imgproc.COLOR_GRAY2RGBA);\n\t\tImgproc.cvtColor(frame, newFrame, Imgproc.COLOR_RGBA2RGB);\n\t\tCore.bitwise_not(newFrame, newFrame);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"X-ray\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\npublic class AdaptiveThresh {\n   public static void main(String args[]) throws Exception {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap14/thresh_input.jpg\";\n      \n      Mat src = Imgcodecs.imread(file,0);\n\n      Mat dst = new Mat();\n\n      Imgproc.adaptiveThreshold(src, dst, 125, Imgproc.ADAPTIVE_THRESH_MEAN_C,\n         Imgproc.THRESH_BINARY, 11, 12);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap14/Adaptivemean_thresh_binary.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   } \n}", "nl": "opencv"}
{"code": "\n \npublic class circleDetection{\n public static void main(String[] args){\n  IplImage src = cvLoadImage(\"img2.png\");\n  IplImage gray = cvCreateImage(cvGetSize(src), 8, 1);\n   \n  cvCvtColor(src, gray, CV_BGR2GRAY);  \n  cvSmooth(gray, gray, CV_GAUSSIAN, 3);\n   \n  CvMemStorage mem = CvMemStorage.create();\n   \n  CvSeq circles = cvHoughCircles( \n    gray, //Input image\n    mem, //Memory Storage\n    CV_HOUGH_GRADIENT, //Detection method\n    1, //Inverse ratio\n    100, //Minimum distance between the centers of the detected circles\n    100, //Higher threshold for canny edge detector\n    100, //Threshold at the center detection stage\n    15, //min radius\n    500 //max radius\n    );\n   \n  for(int i = 0; i < circles.total(); i++){\n      CvPoint3D32f circle = new CvPoint3D32f(cvGetSeqElem(circles, i));\n      CvPoint center = cvPointFrom32f(new CvPoint2D32f(circle.x(), circle.y()));\n      int radius = Math.round(circle.z());      \n      cvCircle(src, center, radius, CvScalar.GREEN, 6, CV_AA, 0);    \n     }\n   \n  cvShowImage(\"Result\",src);  \n  cvWaitKey(0);\n   \n }\n}", "nl": "opencv"}
{"code": "    \n\n\n\nclass PostSearchEntryMapper implements SearchEntryMapper<Post> {\n\n    @Override\n    public BlogPost map(Post post) {\n        BlogPost entry = new BlogPost();\n        entry.setTitle(post.getTitle());\n        entry.setSubTitle(\"Blog Post\");\n\n        String summary = Jsoup.parse(post.getRenderedSummary()).text();\n        String content = Jsoup.parse(post.getRenderedContent()).text();\n\n        entry.setSummary(summary);\n        entry.setRawContent(content);\n        entry.addFacetPaths(\"Blog\", \"Blog/\" + post.getCategory().getDisplayName());\n        entry.setPath(\"/blog/\" + post.getPublicSlug());\n        entry.setPublishAt(post.getPublishAt());\n        entry.setAuthor(post.getAuthor().getFullName());\n        return entry;\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class DescriptorExtractor {\n\n    protected final long nativeObj;\n    protected DescriptorExtractor(long addr) { nativeObj = addr; }\n\n\n    private static final int\n            OPPONENTEXTRACTOR = 1000;\n\n\n    public static final int\n            SIFT = 1,\n            SURF = 2,\n            ORB = 3,\n            BRIEF = 4,\n            BRISK = 5,\n            FREAK = 6,\n            AKAZE = 7,\n            OPPONENT_SIFT = OPPONENTEXTRACTOR + SIFT,\n            OPPONENT_SURF = OPPONENTEXTRACTOR + SURF,\n            OPPONENT_ORB = OPPONENTEXTRACTOR + ORB,\n            OPPONENT_BRIEF = OPPONENTEXTRACTOR + BRIEF,\n            OPPONENT_BRISK = OPPONENTEXTRACTOR + BRISK,\n            OPPONENT_FREAK = OPPONENTEXTRACTOR + FREAK,\n            OPPONENT_AKAZE = OPPONENTEXTRACTOR + AKAZE;\n\n\n\n    public  void compute(Mat image, MatOfKeyPoint keypoints, Mat descriptors)\n    {\n        Mat keypoints_mat = keypoints;\n        compute_0(nativeObj, image.nativeObj, keypoints_mat.nativeObj, descriptors.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void compute(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> descriptors)\n    {\n        Mat images_mat = Converters.vector_Mat_to_Mat(images);\n        List<Mat> keypoints_tmplm = new ArrayList<Mat>((keypoints != null) ? keypoints.size() : 0);\n        Mat keypoints_mat = Converters.vector_vector_KeyPoint_to_Mat(keypoints, keypoints_tmplm);\n        Mat descriptors_mat = new Mat();\n        compute_1(nativeObj, images_mat.nativeObj, keypoints_mat.nativeObj, descriptors_mat.nativeObj);\n        Converters.Mat_to_vector_vector_KeyPoint(keypoints_mat, keypoints);\n        keypoints_mat.release();\n        Converters.Mat_to_vector_Mat(descriptors_mat, descriptors);\n        descriptors_mat.release();\n        return;\n    }\n\n\n\n    public  int descriptorSize()\n    {\n        \n        int retVal = descriptorSize_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  int descriptorType()\n    {\n        \n        int retVal = descriptorType_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  boolean empty()\n    {\n        \n        boolean retVal = empty_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public static DescriptorExtractor create(int extractorType)\n    {\n        \n        DescriptorExtractor retVal = new DescriptorExtractor(create_0(extractorType));\n        \n        return retVal;\n    }\n\n\n\n    public  void write(String fileName)\n    {\n        \n        write_0(nativeObj, fileName);\n        \n        return;\n    }\n\n\n\n    public  void read(String fileName)\n    {\n        \n        read_0(nativeObj, fileName);\n        \n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n    private static native void compute_0(long nativeObj, long image_nativeObj, long keypoints_mat_nativeObj, long descriptors_nativeObj);\n\n    private static native void compute_1(long nativeObj, long images_mat_nativeObj, long keypoints_mat_nativeObj, long descriptors_mat_nativeObj);\n\n    private static native int descriptorSize_0(long nativeObj);\n\n    private static native int descriptorType_0(long nativeObj);\n\n    private static native boolean empty_0(long nativeObj);\n\n    private static native long create_0(int extractorType);\n\n    private static native void write_0(long nativeObj, String fileName);\n\n    private static native void read_0(long nativeObj, String fileName);\n\n    private static native void delete(long nativeObj);\n\n}", "nl": "opencv"}
{"code": "\n\n\n@EnableWs\n@Configuration\npublic class WebServiceConfig extends WsConfigurerAdapter {\n\t@Bean\n\tpublic ServletRegistrationBean messageDispatcherServlet(ApplicationContext applicationContext) {\n\t\tMessageDispatcherServlet servlet = new MessageDispatcherServlet();\n\t\tservlet.setApplicationContext(applicationContext);\n\t\tservlet.setTransformWsdlLocations(true);\n\t\treturn new ServletRegistrationBean(servlet, \"/ws/*\");\n\t}\n\n\t@Bean(name = \"countries\")\n\tpublic DefaultWsdl11Definition defaultWsdl11Definition(XsdSchema countriesSchema) {\n\t\tDefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();\n\t\twsdl11Definition.setPortTypeName(\"CountriesPort\");\n\t\twsdl11Definition.setLocationUri(\"/ws\");\n\t\twsdl11Definition.setTargetNamespace(\"http://spring.io/guides/gs-producing-web-service\");\n\t\twsdl11Definition.setSchema(countriesSchema);\n\t\treturn wsdl11Definition;\n\t}\n\n\t@Bean\n\tpublic XsdSchema countriesSchema() {\n\t\treturn new SimpleXsdSchema(new ClassPathResource(\"countries.xsd\"));\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\n@Controller\npublic class CartItemController {\n\n\t@Autowired\n\tprivate CartService cartService;\n\n\t@Autowired\n\tprivate CartItemService cartItemService;\n\n\t@Autowired\n\tprivate CustomerService customerService;\n\n\t@Autowired\n\tprivate ProductService productService;\n\n\t\n\tpublic CustomerService getCustomerService() {\n\t\treturn customerService;\n\t}\n\n\tpublic void setCustomerService(CustomerService customerService) {\n\t\tthis.customerService = customerService;\n\t}\n\n\tpublic ProductService getProductService() {\n\t\treturn productService;\n\t}\n\n\tpublic void setProductService(ProductService productService) {\n\t\tthis.productService = productService;\n\t}\n\n\tpublic CartService getCartService() {\n\t\treturn cartService;\n\t}\n\n\tpublic void setCartService(CartService cartService) {\n\t\tthis.cartService = cartService;\n\t}\n\n\tpublic CartItemService getCartItemService() {\n\t\treturn cartItemService;\n\t}\n\n\tpublic void setCartItemService(CartItemService cartItemService) {\n\t\tthis.cartItemService = cartItemService;\n\t}\n\n\t@RequestMapping(\"/cart/add/{productId}\")\n\t@ResponseStatus(value = HttpStatus.NO_CONTENT)\n\tpublic void addCartItem(@PathVariable(value = \"productId\") String productId) {\n\t\tUser user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n\t\tString emailId = user.getUsername();\n\t\tCustomer customer = customerService.getCustomerByemailId(emailId);\n\t\tSystem.out.println(\"Customer : \" + customer.getUsers().getEmailId());\n\t\tCart cart = customer.getCart();\n\t\tSystem.out.println(cart);\n\t\tList<CartItem> cartItems = cart.getCartItem();\n\t\tProduct product = productService.getProductById(productId);\n\t\tfor (int i = 0; i < cartItems.size(); i++) {\n\t\t\tCartItem cartItem = cartItems.get(i);\n\t\t\tif (product.getProductId().equals(cartItem.getProduct().getProductId())) {\n\t\t\t\tcartItem.setQuality(cartItem.getQuality() + 1);\n\t\t\t\tcartItem.setPrice(cartItem.getQuality() * cartItem.getProduct().getProductPrice());\n\t\t\t\tcartItemService.addCartItem(cartItem);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tCartItem cartItem = new CartItem();\n\t\tcartItem.setQuality(1);\n\t\tcartItem.setProduct(product);\n\t\tcartItem.setPrice(product.getProductPrice() * 1);\n\t\tcartItem.setCart(cart);\n\t\tcartItemService.addCartItem(cartItem);\n\t}\n\n\t@RequestMapping(\"/cart/removeCartItem/{cartItemId}\")\n\t@ResponseStatus(value = HttpStatus.NO_CONTENT)\n\tpublic void removeCartItem(@PathVariable(value = \"cartItemId\") String cartItemId) {\n\t\tcartItemService.removeCartItem(cartItemId);\n\t}\n\n\t@RequestMapping(\"/cart/removeAllItems/{cartId}\")\n\t@ResponseStatus(value = HttpStatus.NO_CONTENT)\n\tpublic void removeAllCartItems(@PathVariable(value = \"cartId\") String cartId) {\n\t\tCart cart = cartService.getCartByCartId(cartId);\n\t\tcartItemService.removeAllCartItems(cart);\n\t}\n\n}\n", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\n\n\n\npublic class LoopImageFiles {\n\t\n    public static void main(String[] args) throws InterruptedException {\n\n    \t\n        \n        String IMAGE_FILES_DIRECTORY_PATH = \"files/\";\n    \t\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n    \t\n\n        Imshow ims = new Imshow(\"Next Image ...\");\n\n        \n        File dir = new File(IMAGE_FILES_DIRECTORY_PATH);\n        File[] directoryListing = dir.listFiles();\n        if (directoryListing != null) {\n            for (File imgFile : directoryListing) {\n            \t\n\n            \tif ((imgFile.getName().endsWith(\".png\")) || (imgFile.getName().endsWith(\".jpg\")))\n            \t{\n\n            \t\tMat inputImage = Highgui.imread(IMAGE_FILES_DIRECTORY_PATH + \"/\" + imgFile.getName());\n\n        \t\t\n\n            \t\tims.showImage(inputImage);\n            \t\tThread.sleep(500);\n            \t}\n            }\n          } else {\n            \n        \t  System.out.println( \"Could not get listing for directory: \" + IMAGE_FILES_DIRECTORY_PATH);\n          }\n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\npublic class RandomImage \n{ \n\tpublic static void main(String args[])throws IOException \n\t{ \n\t\tint width = 640, height = 320; \n\n\t\tBufferedImage img = null; \n\t\timg = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); \n\n\t\tFile f = null; \n\n\t\tfor (int y = 0; y < height; y++) \n\t\t{ \n\t\t\tfor (int x = 0; x < width; x++) \n\t\t\t{ \n\t\t\t\tint a = (int)(Math.random()*256); //generating \n\t\t\t\tint r = (int)(Math.random()*256); //values \n\t\t\t\tint g = (int)(Math.random()*256); //less than \n\t\t\t\tint b = (int)(Math.random()*256); //256 \n\n\t\t\t\tint p = (a<<24) | (r<<16) | (g<<8) | b; //pixel \n\n\t\t\t\timg.setRGB(x, y, p); \n\t\t\t} \n\t\t} \n\n\t\ttry\n\t\t{ \n\t\t\tf = new File(\"G:\\\\Out.jpg\"); \n\t\t\tImageIO.write(img, \"jpg\", f); \n\t\t} \n\t\tcatch(IOException e) \n\t\t{ \n\t\t\tSystem.out.println(\"Error: \" + e); \n\t\t} \n\t} \n} \n", "nl": "opencv"}
{"code": "\n\n\n\n@Configuration\npublic class UrlRewriterFilterConfig {\n\n\tpublic static final String REWRITE_FILTER_NAME = \"rewriteFilter\";\n\tpublic static final String REWRITE_FILTER_CONF_PATH = \"urlrewrite.xml\";\n\n\t\n\t@Bean\n\tpublic FilterRegistrationBean rewriteFilterConfig() {\n\t\tFilterRegistrationBean reg = new FilterRegistrationBean();\n\t\treg.setName(REWRITE_FILTER_NAME);\n\t\treg.setFilter(new TuckeyRewriteFilter());\n\t\treg.addInitParameter(\"confPath\", REWRITE_FILTER_CONF_PATH);\n\t\treg.addInitParameter(\"confReloadCheckInterval\", \"-1\");\n\t\treg.addInitParameter(\"statusPath\", \"/redirect\");\n\t\treg.addInitParameter(\"statusEnabledOnHosts\", \"*\");\n\t\treg.addInitParameter(\"logLevel\", \"WARN\");\n\t\treturn reg;\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n@Endpoint\npublic class CountryEndpoint {\n\tprivate static final String NAMESPACE_URI = \"http://spring.io/guides/gs-producing-web-service\";\n\n\tprivate CountryRepository countryRepository;\n\n\t@Autowired\n\tpublic CountryEndpoint(CountryRepository countryRepository) {\n\t\tthis.countryRepository = countryRepository;\n\t}\n\n\t@PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getCountryRequest\")\n\t@ResponsePayload\n\tpublic GetCountryResponse getCountry(@RequestPayload GetCountryRequest request) {\n\t\tGetCountryResponse response = new GetCountryResponse();\n\t\tresponse.setCountry(countryRepository.findCountry(request.getName()));\n\n\t\treturn response;\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\npublic class AndroidFrameConverter extends FrameConverter<Bitmap> {\n    Bitmap bitmap;\n    ByteBuffer buffer;\n    byte[] row;\n\n    \n    public Frame convert(byte[] data, int width, int height) {\n        if (frame == null || frame.imageWidth != width\n                || frame.imageHeight != height || frame.imageChannels != 3) {\n            frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n        }\n        ByteBuffer out = (ByteBuffer)frame.image[0];\n        int stride = frame.imageStride;\n\n        int offset = height * width;\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                int Y = data[i * width + j] & 0xFF;\n                int V = data[offset + (i/2) * width + 2 * (j/2)    ] & 0xFF;\n                int U = data[offset + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n\n                Y -= 16;\n                U -= 128;\n                V -= 128;\n\n                if (Y < 0)\n                    Y = 0;\n\n\n                int B = (int)(1192 * Y + 2066 * U);\n                int G = (int)(1192 * Y - 833 * V - 400 * U);\n                int R = (int)(1192 * Y + 1634 * V);\n\n                R = Math.min(262143, Math.max(0, R));\n                G = Math.min(262143, Math.max(0, G));\n                B = Math.min(262143, Math.max(0, B));\n\n                R >>= 10; R &= 0xff;\n                G >>= 10; G &= 0xff;\n                B >>= 10; B &= 0xff;\n\n                out.put(i * stride + 3 * j,     (byte)B);\n                out.put(i * stride + 3 * j + 1, (byte)G);\n                out.put(i * stride + 3 * j + 2, (byte)R);\n            }\n        }\n        return frame;\n    }\n\n    @Override public Frame convert(Bitmap bitmap) {\n        if (bitmap == null) {\n            return null;\n        }\n\n        int channels = 0;\n        switch (bitmap.getConfig()) {\n            case ALPHA_8:   channels = 1; break;\n            case RGB_565:\n            case ARGB_4444: channels = 2; break;\n            case ARGB_8888: channels = 4; break;\n            default: assert false;\n        }\n\n        if (frame == null || frame.imageWidth != bitmap.getWidth() || frame.imageStride != bitmap.getRowBytes()\n                || frame.imageHeight != bitmap.getHeight() || frame.imageChannels != channels) {\n            frame = new Frame(bitmap.getWidth(), bitmap.getHeight(), Frame.DEPTH_UBYTE, channels, bitmap.getRowBytes());\n        }\n\n        bitmap.copyPixelsToBuffer(frame.image[0].position(0));\n\n        return frame;\n    }\n\n    ByteBuffer gray2rgba(ByteBuffer in, int width, int height, int stride, int rowBytes) {\n        if (buffer == null || buffer.capacity() < height * rowBytes) {\n            buffer = ByteBuffer.allocate(height * rowBytes);\n        }\n        if (row == null || row.length != stride)\n            row = new byte[stride];\n        for (int y = 0; y < height; y++) {\n            in.position(y * stride);\n            in.get(row);\n            for (int x = 0; x < width; x++) {\n                byte B = row[x];\n                int rgba = (B & 0xff) << 24 |\n                           (B & 0xff) << 16 |\n                           (B & 0xff) <<  8 | 0xff;\n                buffer.putInt(y * rowBytes + 4 * x, rgba);\n            }\n        }\n        return buffer;\n    }\n\n    ByteBuffer bgr2rgba(ByteBuffer in, int width, int height, int stride, int rowBytes) {\n        if (!in.order().equals(ByteOrder.LITTLE_ENDIAN)) {\n            in = in.order(ByteOrder.LITTLE_ENDIAN);\n        }\n        if (buffer == null || buffer.capacity() < height * rowBytes) {\n            buffer = ByteBuffer.allocate(height * rowBytes);\n        }\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                int rgb;\n                if (x < width - 1 || y < height - 1) {\n                    rgb = in.getInt(y * stride + 3 * x);\n                } else {\n                    int b = in.get(y * stride + 3 * x    ) & 0xff;\n                    int g = in.get(y * stride + 3 * x + 1) & 0xff;\n                    int r = in.get(y * stride + 3 * x + 2) & 0xff;\n                    rgb = (r << 16) | (g << 8) | b;\n                }\n                buffer.putInt(y * rowBytes + 4 * x, (rgb << 8) | 0xff);\n            }\n        }\n        return buffer;\n    }\n\n    @Override public Bitmap convert(Frame frame) {\n        if (frame == null || frame.image == null) {\n            return null;\n        }\n\n        Bitmap.Config config = null;\n        switch (frame.imageChannels) {\n            case 2: config = Bitmap.Config.RGB_565; break;\n            case 1:\n            case 3:\n            case 4: config = Bitmap.Config.ARGB_8888; break;\n            default: assert false;\n        }\n\n        if (bitmap == null || bitmap.getWidth() != frame.imageWidth\n                || bitmap.getHeight() != frame.imageHeight || bitmap.getConfig() != config) {\n            bitmap = Bitmap.createBitmap(frame.imageWidth, frame.imageHeight, config);\n        }\n\n        ByteBuffer in = (ByteBuffer)frame.image[0];\n        int width = frame.imageWidth;\n        int height = frame.imageHeight;\n        int stride = frame.imageStride;\n        int rowBytes = bitmap.getRowBytes();\n        if (frame.imageChannels == 1) {\n            gray2rgba(in, width, height, stride, rowBytes);\n            bitmap.copyPixelsFromBuffer(buffer.position(0));\n        } else if (frame.imageChannels == 3) {\n            bgr2rgba(in, width, height, stride, rowBytes);\n            bitmap.copyPixelsFromBuffer(buffer.position(0));\n        } else {\n            bitmap.copyPixelsFromBuffer(in.position(0));\n        }\n        return bitmap;\n    }\n}", "nl": "opencv"}
{"code": "\n\npublic class Main \n{ \n\tpublic static void main( String[] args ) \n\t{ \n\t\ttry\n\t\t{ \n\t\t\tSystem.loadLibrary( Core.NATIVE_LIBRARY_NAME ); \n\n\t\t\tMat source = Imgcodecs.imread(\"E:\\\\input.jpg\", \n\t\t\t\t\t\tImgcodecs.CV_LOAD_IMAGE_GRAYSCALE); \n\t\t\tMat destination = new Mat(source.rows(), \n\t\t\t\t\t\t\tsource.cols(), source.type()); \n\n\t\t\tImgproc.equalizeHist(source, destination); \n\n\t\t\tImgcodecs.imwrite(\"E:\\\\output.jpg\", destination); \n\t\t} \n\t\tcatch (Exception e) \n\t\t{ \n\t\t\tSystem.out.println(\"error: \" + e.getMessage()); \n\t\t} \n\t} \n} \n", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\n\npublic class hogPeopleDetection {\n\n    public static void main(String[] args) throws InterruptedException {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n\n        VideoCapture cap = new VideoCapture();\n\n        \n        int CAM_TO_USE = 0;\n        \n        \n        Mat matFrame = new Mat();\n        \n        \n        try {\n        \tcap.open(CAM_TO_USE);\n        } catch (Exception e1) {\n            System.out.println(\"No webcam attached\");\n        \n            \n            try{\n            \tcap.open(\"files/video.mp4\");\n            } catch (Exception e2) {\n            \tSystem.out.println(\"No video file found\");\n            }\n        }\n        \n        \n        if (cap.isOpened())\n        {\n\n            \n            Imshow ims = new Imshow(\"HOG People Detection\");\n        \t\n        \tboolean keepProcessing = true;\n\n        \t\n        \tHOGDescriptor HOG = new HOGDescriptor();\n        \tHOG.setSVMDetector(HOGDescriptor.getDefaultPeopleDetector());\n        \t\n        \t\n        \tMatOfRect foundLocations = new MatOfRect();\n        \tMatOfDouble foundWeights = new MatOfDouble();\n        \t\n        \twhile (keepProcessing)\n        \t{\t\n\n        \t\tcap.grab();\n\n\n            \tcap.retrieve(matFrame);\n\n            \t\n            \tif (!(matFrame.empty()))\n            \t{\n\n\t\t\t\t\tHOG.detectMultiScale(matFrame, foundLocations, foundWeights,\n                            0,\n                            new Size(8,8),\n                            new Size(32,32),\n                            1.05,\n                            8,\n                            false);\n            \t\t\n\t\t\t\t\tList<Rect> rectangles = foundLocations.toList();\n\t\t\t\t\t\n\t\t\t\t\tfor (int i = 0; i < rectangles.size(); i++) {\n\t\t\t        \t\n\t\t\t\t\t\tCore.rectangle(matFrame,\n\t\t\t\t\t             new Point(rectangles.get(i).x,rectangles.get(i).y),\n\t\t\t\t\t             new Point(rectangles.get(i).x + rectangles.get(i).width,\n\t\t\t\t\t            \t\t   rectangles.get(i).y + rectangles.get(i).height),\n\t\t\t\t\t             new Scalar (255,0,0), 2, 1, 0);\n\t\t\t        }\n\t\t\t\t\t\n\n            \t\tims.showImage(matFrame);\n            \t\tThread.sleep(40);\n            \t} else { \n            \t\tkeepProcessing = false;\n        \t\t}\n        \t}\n\n        } else {\n            System.out.println(\"error cannot open any capture source - exiting\");\n        }\n\n\n        cap.release();\n        \n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\n@RestController\npublic class GreetingController {\n\n    private static final String TEMPLATE = \"Hello, %s!\";\n\n    @RequestMapping(\"/greeting\")\n    public HttpEntity<Greeting> greeting(\n            @RequestParam(value = \"name\", required = false, defaultValue = \"World\") String name) {\n\n        Greeting greeting = new Greeting(String.format(TEMPLATE, name));\n        greeting.add(linkTo(methodOn(GreetingController.class).greeting(name)).withSelfRel());\n\n        return new ResponseEntity<>(greeting, HttpStatus.OK);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@SpringBootApplication\npublic class Application {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(Application.class);\n\n\t@Bean\n\tRedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,\n\t\t\tMessageListenerAdapter listenerAdapter) {\n\n\t\tRedisMessageListenerContainer container = new RedisMessageListenerContainer();\n\t\tcontainer.setConnectionFactory(connectionFactory);\n\t\tcontainer.addMessageListener(listenerAdapter, new PatternTopic(\"chat\"));\n\n\t\treturn container;\n\t}\n\n\t@Bean\n\tMessageListenerAdapter listenerAdapter(Receiver receiver) {\n\t\treturn new MessageListenerAdapter(receiver, \"receiveMessage\");\n\t}\n\n\t@Bean\n\tReceiver receiver(CountDownLatch latch) {\n\t\treturn new Receiver(latch);\n\t}\n\n\t@Bean\n\tCountDownLatch latch() {\n\t\treturn new CountDownLatch(1);\n\t}\n\n\t@Bean\n\tStringRedisTemplate template(RedisConnectionFactory connectionFactory) {\n\t\treturn new StringRedisTemplate(connectionFactory);\n\t}\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\n\t\tApplicationContext ctx = SpringApplication.run(Application.class, args);\n\n\t\tStringRedisTemplate template = ctx.getBean(StringRedisTemplate.class);\n\t\tCountDownLatch latch = ctx.getBean(CountDownLatch.class);\n\n\t\tLOGGER.info(\"Sending message...\");\n\t\ttemplate.convertAndSend(\"chat\", \"Hello from Redis!\");\n\n\t\tlatch.await();\n\n\t\tSystem.exit(0);\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\n@Service\npublic class PostContentRenderer {\n\n\tprivate final SaganRendererClient client;\n\n\tpublic PostContentRenderer(SaganRendererClient client) {\n\t\tthis.client = client;\n\t}\n\n\tpublic String render(String content, PostFormat format) {\n\t\tif(StringUtils.isEmpty(content)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tswitch (format) {\n\t\t\tcase MARKDOWN:\n\t\t\t\tString renderedMarkdown = this.client.renderMarkdown(content);\n\t\t\t\treturn renderCallouts(decode(renderedMarkdown));\n\n\t\t\tcase ASCIIDOC:\n\t\t\t\treturn this.client.renderAsciidoc(content);\n\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported post format: \" + format);\n\t\t}\n\t}\n\n\tprivate String decode(String html) {\n\t\tMatcher matcher = Pattern.compile(\"<pre>!(.*)</pre>\").matcher(html);\n\n\t\tStringBuffer sb = new StringBuffer();\n\t\twhile (matcher.find()) {\n\t\t\tmatcher.appendReplacement(sb, matcher.group(1).replace('{', '<').replace('}', '>'));\n\t\t}\n\t\tmatcher.appendTail(sb);\n\t\treturn sb.toString();\n\t}\n\n\tprivate String renderCallouts(String html) {\n\t\tPattern calloutPattern = Pattern.compile(\"\\\\[callout title=([^\\\\]]+)\\\\]([^\\\\[]*)\\\\[\\\\/callout\\\\]\");\n\t\tMatcher matcher = calloutPattern.matcher(html);\n\n\t\tStringBuffer sb = new StringBuffer();\n\t\twhile (matcher.find()) {\n\t\t\tmatcher.appendReplacement(sb,\n\t\t\t\t\tString.format(\"<div class=\\\"callout\\\">\\n\" + \"<div class=\\\"callout-title\\\">%s</div>\\n\" + \"%s\\n\"\n\t\t\t\t\t\t\t+ \"</div>\", matcher.group(1), matcher.group(2)));\n\t\t}\n\t\tmatcher.appendTail(sb);\n\t\treturn sb.toString();\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n@ServletComponentScan\n@SpringBootApplication(scanBasePackages = \"com.baeldung\")\n@EnableJpaRepositories(\"com.baeldung.persistence.repo\")\n@EntityScan(\"com.baeldung.persistence.model\")\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n@SpringBootApplication\npublic class Application {\n\n    static final String topicExchangeName = \"spring-boot-exchange\";\n\n    static final String queueName = \"spring-boot\";\n\n    @Bean\n    Queue queue() {\n        return new Queue(queueName, false);\n    }\n\n    @Bean\n    TopicExchange exchange() {\n        return new TopicExchange(topicExchangeName);\n    }\n\n    @Bean\n    Binding binding(Queue queue, TopicExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"foo.bar.#\");\n    }\n\n    @Bean\n    SimpleMessageListenerContainer container(ConnectionFactory connectionFactory,\n            MessageListenerAdapter listenerAdapter) {\n        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();\n        container.setConnectionFactory(connectionFactory);\n        container.setQueueNames(queueName);\n        container.setMessageListener(listenerAdapter);\n        return container;\n    }\n\n    @Bean\n    MessageListenerAdapter listenerAdapter(Receiver receiver) {\n        return new MessageListenerAdapter(receiver, \"receiveMessage\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SpringApplication.run(Application.class, args).close();\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n@Controller\npublic class UserController {\n\n\t@Autowired\n\tprivate CustomerService customerService;\n\n\tpublic CustomerService getCustomerService() {\n\t\treturn customerService;\n\t}\n\n\tpublic void setCustomerService(CustomerService customerService) {\n\t\tthis.customerService = customerService;\n\t}\n\n\t@RequestMapping(value = \"/customer/registration\")\n\tpublic ModelAndView getRegistrationForm() {\n\t\tCustomer customer = new Customer();\n\t\tUser user = new User();\n\t\tBillingAddress ba = new BillingAddress();\n\t\tShippingAddress sa = new ShippingAddress();\n\t\tcustomer.setShippingAddress(sa);\n\t\tcustomer.setBillingAddress(ba);\n\t\tcustomer.setUsers(user);\n\n\t\treturn new ModelAndView(\"register\", \"customer\", customer);\n\t}\n\n\t@RequestMapping(value = \"/customer/registration\", method = RequestMethod.POST)\n\tpublic String registerCustomer(@Valid @ModelAttribute(value = \"customer\") Customer customer, Model model,\n\t\t\tBindingResult result) {\n\t\tif (result.hasErrors())\n\t\t\treturn \"register\";\n\t\tcustomerService.addCustomer(customer);\n\t\tmodel.addAttribute(\"registrationSuccess\", \"Registered Successfully. Login using username and password\");\n\t\treturn \"login\";\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class ResIdentify {\n\n    private static final String PATH = \"res/img/resistor/identify/\";\n    private static int threshold = 170;  \n    private static int erodeSizeX = 3;\n    private static int erodeSizeY = 30;   \n\n    private static Scalar[] colorCode = {\n    };\n\n\n    public int resIdentify(Mat src) {\n\n        src = src.submat(src.rows() / 4, 3 * src.rows() / 4, src.cols() / 6, 5 * src.cols() / 6);\n\n        Mat src_blur = new Mat();\n        Imgproc.GaussianBlur(src, src_blur, new Size(5, 5), 0, 0, 4);\n\n        Mat src_gray = new Mat();\n        Imgproc.cvtColor(src, src_gray, Imgproc.COLOR_BGR2GRAY);\n\n        Mat img_threshold = new Mat();\n        Imgproc.threshold(src_gray, img_threshold, threshold, 255, Imgproc.THRESH_OTSU);\n\n        Mat element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(erodeSizeX, erodeSizeY));\n        Imgproc.erode(img_threshold, img_threshold, element, new Point(-1, -1), 2);\n\n        Core.bitwise_not(img_threshold, img_threshold);\n\n        Mat hierarchy = new Mat();\n        List<MatOfPoint> contours = new ArrayList<MatOfPoint>();\n        Imgproc.findContours(img_threshold, contours, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_NONE);\n\n        Imgproc.drawContours(img_threshold, contours, -1, new Scalar(255, 0, 255, 255));\n\n        List<RotatedRect> rects = new ArrayList<RotatedRect>();\n        for (int i = 0; i < contours.size(); i++) {\n            System.out.println(Imgproc.contourArea(contours.get(i)));\n            MatOfPoint2f mtx = new MatOfPoint2f(contours.get(i).toArray());\n            RotatedRect mr = Imgproc.minAreaRect(mtx);\n            rects.add(mr);\n        }\n\n        for (int i = 0; i < contours.size(); i++) {\n            RotatedRect minRect = rects.get(i);\n            Point[] rect_points = new Point[4];\n            minRect.points(rect_points);\n\n            for (int j = 0; j < 4; j++) {\n                Point pt1 = new Point(rect_points[j].x, rect_points[j].y);\n                Point pt2 = new Point(rect_points[(j + 1) % 4].x, rect_points[(j + 1) % 4].y);\n\n                Imgproc.line(img_threshold, pt1, pt2, new Scalar(255, 0, 255, 255), 4, 8, 0);\n            }\n\n            double r = minRect.size.width / minRect.size.height;\n            double angle = minRect.angle;\n            Size size = new Size(minRect.size.width, minRect.size.height);\n            if (r < 1) {\n                angle = angle + 90;\n                size = new Size(minRect.size.height, minRect.size.width);\n            }\n            Mat rotMat = Imgproc.getRotationMatrix2D(minRect.center, angle, 1);\n            Mat img_rotated = new Mat();\n            Imgproc.warpAffine(src, img_rotated, rotMat, src.size());\n\n            Mat colorBandMat = showResultMat(img_rotated, size, minRect.center, i);\n        }\n        return 0;\n    }\n\n    private Mat showResultMat(Mat src, Size rect_size, Point center, int index) {\n        Mat img_crop = new Mat();\n        Imgproc.getRectSubPix(src, rect_size, center, img_crop);\n        Imgcodecs.imwrite(PATH + \"debug_crop_\" + index + \".jpg\", img_crop);\n        return img_crop;\n    }\n\n    \n    private void getColor(Mat src) {\n        Imgproc.cvtColor(src, src, Imgproc.COLOR_BGR2HSV);\n        for (int i = 0; i < src.rows(); i++) {\n            for (int j = 0; j < src.cols(); j++) {\n                double[] hsv_value = src.get(i, j);\n            }\n        }\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\nclass EclipseDownloadsBuilder {\n    private final Map<String, EclipsePlatform> platforms = new HashMap<>();\n    private final Map<String, EclipsePackage> packages = new HashMap<>();\n    private final Map<String, EclipseRelease> releases = new HashMap<>();\n    private final Map<String, Architecture> architectureMap = new LinkedHashMap<>();\n\n    private final DownloadLinkExtractor downloadLinkExtractor = new DownloadLinkExtractor();\n\n    public void addDownload(EclipseXmlDownload eclipseXmlDownload, EclipseXmlPackage eclipseXmlPackage,\n                            EclipseXmlProduct eclipseXmlProduct) {\n        String os = eclipseXmlDownload.getOs();\n        EclipsePlatform platform = getEclipsePlatform(os);\n        EclipseRelease release = getEclipseRelease(eclipseXmlProduct, platform);\n        EclipsePackage eclipsePackage = getEclipsePackage(eclipseXmlPackage, os, release);\n        Architecture architecture = getArchitecture(eclipseXmlDownload, os, release, eclipsePackage);\n        architecture.getDownloadLinks().add(downloadLinkExtractor.createDownloadLink(eclipseXmlDownload));\n        platforms.put(os, platform);\n    }\n\n    private Architecture getArchitecture(EclipseXmlDownload eclipseXmlDownload, String os, EclipseRelease release,\n                                         EclipsePackage eclipsePackage) {\n        String key = os + release.getName() + eclipsePackage.getName() + eclipseXmlDownload.getDescription();\n        Architecture architecture = architectureMap.get(key);\n        if (architecture == null) {\n            String name = eclipseXmlDownload.getDescription();\n            architecture = new Architecture(name, new ArrayList<>());\n\n            architectureMap.put(key, architecture);\n            eclipsePackage.getArchitectures().add(architecture);\n        }\n\n        return architecture;\n    }\n\n    private EclipsePlatform getEclipsePlatform(String os) {\n        String key = os;\n        EclipsePlatform platform = platforms.get(key);\n        if (platform == null) {\n            platform = new EclipsePlatform(StringUtils.capitalize(os), new ArrayList<>());\n            platforms.put(key, platform);\n        }\n        return platform;\n    }\n\n    private EclipseRelease getEclipseRelease(EclipseXmlProduct eclipseXmlProduct, EclipsePlatform platform) {\n        String key = platform.getName() + eclipseXmlProduct.getName();\n        EclipseRelease release = releases.get(key);\n        if (release == null) {\n            String name = new String(eclipseXmlProduct.getName()).replaceAll(\"(.+) Package Downloads.*\", \"$1\");\n            String version = new String(eclipseXmlProduct.getName()).replaceAll(\".*\\\\(based on (.*)\\\\)\", \"$1\");\n            release = new EclipseRelease(name, version, new ArrayList<>());\n            releases.put(key, release);\n            platform.getReleases().add(release);\n        }\n        return release;\n    }\n\n    private EclipsePackage getEclipsePackage(EclipseXmlPackage eclipseXmlPackage, String os, EclipseRelease release) {\n        String key = os + release.getName() + eclipseXmlPackage.getName();\n        EclipsePackage eclipsePackage = packages.get(key);\n        if (eclipsePackage == null) {\n            String name = new String(eclipseXmlPackage.getName()).replaceAll(\" \\\\(.*\\\\)\", \"\");\n            eclipsePackage = new EclipsePackage(name, new ArrayList<>());\n            packages.put(key, eclipsePackage);\n            release.getPackages().add(eclipsePackage);\n        }\n\n        return eclipsePackage;\n    }\n\n    public EclipseDownloads build() {\n        return new EclipseDownloads(platforms);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@Configuration\npublic class CoffeeConfiguration {\n    @Bean\n    ReactiveRedisOperations<String, Coffee> redisOperations(ReactiveRedisConnectionFactory factory) {\n        Jackson2JsonRedisSerializer<Coffee> serializer = new Jackson2JsonRedisSerializer<>(Coffee.class);\n\n        RedisSerializationContext.RedisSerializationContextBuilder<String, Coffee> builder =\n                RedisSerializationContext.newSerializationContext(new StringRedisSerializer());\n\n        RedisSerializationContext<String, Coffee> context = builder.value(serializer).build();\n\n        return new ReactiveRedisTemplate<>(factory, context);\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class DetectFaceDemo {\n    public void run() {\n        System.out.println(\"\\nRunning DetectFaceDemo\");\n\n        CascadeClassifier faceDetector = new CascadeClassifier(getClass()\n                .getResource(\"/lbpcascade_frontalface.xml\").getPath());\n        Mat image = Imgcodecs.imread(getClass().getResource(\n                \"/AverageMaleFace.jpg\").getPath());\n\n        MatOfRect faceDetections = new MatOfRect();\n        faceDetector.detectMultiScale(image, faceDetections);\n\n        System.out.println(String.format(\"Detected %s faces\",\n                faceDetections.toArray().length));\n\n        for (Rect rect : faceDetections.toArray()) {\n            Imgproc.rectangle(image, new Point(rect.x, rect.y), new Point(rect.x\n                    + rect.width, rect.y + rect.height), new Scalar(0, 255, 0));\n        }\n\n        String filename = \"faceDetection.png\";\n        System.out.println(String.format(\"Writing %s\", filename));\n        Imgcodecs.imwrite(filename, image);\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Service\npublic class ProjectMetadataService {\n\n\tprivate static final Sort sortByDisplayOrderAndId = new Sort(\"displayOrder\", \"id\");\n\n    private ProjectMetadataRepository repository;\n\n    @Autowired\n    public ProjectMetadataService(ProjectMetadataRepository repository) {\n        this.repository = repository;\n    }\n\n    public List<Project> getProjectsForCategory(String category) {\n        return repository.findByCategory(category, sortByDisplayOrderAndId);\n    }\n\n    public List<Project> getActiveTopLevelProjects() {\n    \treturn repository.findDistinctByCategoryAndParentProjectIsNull(\"active\", sortByDisplayOrderAndId);\n\t}\n\n    public List<Project> getProjects() {\n        return repository.findAll(sortByDisplayOrderAndId);\n    }\n\n    public List<Project> getProjectsWithReleases() {\n        return repository.findAllWithReleases(sortByDisplayOrderAndId);\n    }\n\n    public Project getProject(String id) {\n        return repository.findOne(id);\n    }\n\n    public Project save(Project project) {\n        return repository.save(project);\n    }\n\n    public void delete(String id) {\n        repository.delete(id);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\npublic class MaskEffect extends Effect {\n    private byte[] byteArray;\n\n    @Override\n    public Mat applyTo(Mat frame) {\n\n        Bitmap bmp = Storage.getbmp();\n        Mat newFrame = new Mat(bmp.getWidth(), bmp.getHeight(), CvType.CV_8UC4);\n        Utils.bitmapToMat(bmp, newFrame);\n\n        Size size = new Size(frame.cols() * 0.2, frame.rows() * 0.2);\n        resize(newFrame, newFrame, size);\n\n        Mat grayscaleImage = new Mat(frame.cols(), frame.rows(), CvType.CV_8UC4);\n\n        Imgproc.cvtColor(frame, grayscaleImage, Imgproc.COLOR_RGBA2RGB);\n\n        MatOfRect faces = new MatOfRect();\n\n        int absoluteFaceSize = (int) (height * 0.2);\n\n        CascadeClassifier cascadeClassifier = Storage.getCascadeClassifier();\n\n        if (cascadeClassifier != null) {\n            cascadeClassifier.detectMultiScale(grayscaleImage, faces, 1.1, 2, 2,\n                    new Size(absoluteFaceSize, absoluteFaceSize), new Size());\n        }\n\n        Rect[] facesArray = faces.toArray();\n        for (int i = 0; i < facesArray.length; i++) {\n            int x = (int) Math.round(facesArray[i].tl().x);\n            int y = (int) Math.round(facesArray[i].tl().y);\n            newFrame.copyTo(frame.rowRange(x, newFrame.rows() + x).colRange(y, newFrame.cols() + y));\n\n        }\n\n        return frame;\n    }\n\n    public String toString() {\n        return \"MaskEffect\";\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@JsonPController\n@RequestMapping(\"/project_metadata\")\nclass ProjectMetadataController {\n\n    private final ProjectMetadataService service;\n    private final ProjectPatchingService projectPatchingService;\n\n    @Autowired\n    public ProjectMetadataController(ProjectMetadataService service,\n            ProjectPatchingService projectPatchingService) {\n        this.service = service;\n        this.projectPatchingService = projectPatchingService;\n    }\n\n    @RequestMapping(value = \"/{projectId}\", method = { GET, HEAD })\n    public Project projectMetadata(@PathVariable(\"projectId\") String projectId) throws IOException {\n        Project project = service.getProject(projectId);\n        return project;\n    }\n\n    @RequestMapping(value = \"/{projectId}/releases/{version:.*}\", method = GET)\n    public ProjectRelease releaseMetadata(@PathVariable(\"projectId\") String projectId,\n                                          @PathVariable(\"version\") String version) throws IOException {\n        Project project = service.getProject(projectId);\n        if (project == null) {\n            throw new MetadataNotFoundException(\"Cannot find project \" + projectId);\n        }\n        ProjectRelease release = project.getProjectRelease(version);\n        if (release == null) {\n            throw new MetadataNotFoundException(\"Could not find \" + version + \" for \" + projectId);\n        }\n        return release.createWithVersionPattern();\n    }\n\n    @RequestMapping(value = \"/{projectId}/releases\", method = GET)\n    public List<ProjectRelease> releaseMetadata(@PathVariable(\"projectId\") String projectId) throws IOException {\n        Project project = service.getProject(projectId);\n        if (project == null) {\n            throw new MetadataNotFoundException(\"Cannot find project \" + projectId);\n        }\n        List<ProjectRelease> releases = new ArrayList<>();\n        for (ProjectRelease release : project.getProjectReleases()) {\n            releases.add(release.createWithVersionPattern());\n        }\n        return releases;\n    }\n\n    @RequestMapping(value = \"/{projectId}/releases\", method = PUT)\n    public Project updateProjectMetadata(@PathVariable(\"projectId\") String projectId,\n                                         @RequestBody List<ProjectRelease> releases)\n            throws IOException {\n        Project project = service.getProject(projectId);\n        for (ProjectRelease release : releases) {\n            project.updateProjectRelease(release);\n        }\n        service.save(project);\n        return project;\n    }\n\n    @RequestMapping(value = \"/{projectId}/releases\", method = POST)\n    public ProjectRelease updateReleaseMetadata(@PathVariable(\"projectId\") String projectId,\n                                                @RequestBody ProjectRelease release) throws IOException {\n        Project project = service.getProject(projectId);\n        if (project == null) {\n            throw new MetadataNotFoundException(\"Cannot find project \" + projectId);\n        }\n        boolean found = project.updateProjectRelease(release);\n        if (found) {\n            service.save(project);\n        }\n        return release;\n    }\n\n    @RequestMapping(value = \"/{projectId}/releases/{version:.*}\", method = DELETE)\n    public ProjectRelease removeReleaseMetadata(@PathVariable(\"projectId\") String projectId,\n                                                @PathVariable(\"version\") String version) throws IOException {\n        Project project = service.getProject(projectId);\n        if (project == null) {\n            throw new MetadataNotFoundException(\"Cannot find project \" + projectId);\n        }\n        ProjectRelease found = project.removeProjectRelease(version);\n        if (found == null) {\n            throw new MetadataNotFoundException(\"Could not find \" + version + \" for \" + projectId);\n        }\n        service.save(project);\n        return found;\n    }\n\n    @RequestMapping(value = \"/{projectId}\", method = PATCH)\n    public Project updateProject(@PathVariable(\"projectId\") String projectId,\n            @RequestBody Project projectWithPatches) throws IOException {\n        Project project = service.getProject(projectId);\n        if (project == null) {\n            throw new MetadataNotFoundException(\"Cannot find project \" + projectId);\n        }\n        Project patchedProject = projectPatchingService.patch(projectWithPatches, project);\n        return service.save(patchedProject);\n    }\n\n    @ExceptionHandler(MetadataNotFoundException.class)\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    public void handle() {\n    }\n\n    static class MetadataNotFoundException extends RuntimeException {\n\n        public MetadataNotFoundException(String string) {\n            super(string);\n        }\n\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\npublic class DisplayImage {\n\n    public static void main(String[] args) {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n\n        Mat inputImage = Highgui.imread(\"files/lena.jpg\");\n\n\n        Imshow ims1 = new Imshow(\"My Image\");\n\n\n        ims1.showImage(inputImage);\n\n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\n@Service\npublic class FileSystemStorageService implements StorageService {\n\n    private final Path rootLocation;\n\n    @Autowired\n    public FileSystemStorageService(StorageProperties properties) {\n        this.rootLocation = Paths.get(properties.getLocation());\n    }\n\n    @Override\n    public void store(MultipartFile file) {\n        String filename = StringUtils.cleanPath(file.getOriginalFilename());\n        try {\n            if (file.isEmpty()) {\n                throw new StorageException(\"Failed to store empty file \" + filename);\n            }\n            if (filename.contains(\"..\")) {\n                throw new StorageException(\n                        \"Cannot store file with relative path outside current directory \"\n                                + filename);\n            }\n            try (InputStream inputStream = file.getInputStream()) {\n                Files.copy(inputStream, this.rootLocation.resolve(filename),\n                    StandardCopyOption.REPLACE_EXISTING);\n            }\n        }\n        catch (IOException e) {\n            throw new StorageException(\"Failed to store file \" + filename, e);\n        }\n    }\n\n    @Override\n    public Stream<Path> loadAll() {\n        try {\n            return Files.walk(this.rootLocation, 1)\n                .filter(path -> !path.equals(this.rootLocation))\n                .map(this.rootLocation::relativize);\n        }\n        catch (IOException e) {\n            throw new StorageException(\"Failed to read stored files\", e);\n        }\n\n    }\n\n    @Override\n    public Path load(String filename) {\n        return rootLocation.resolve(filename);\n    }\n\n    @Override\n    public Resource loadAsResource(String filename) {\n        try {\n            Path file = load(filename);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            }\n            else {\n                throw new StorageFileNotFoundException(\n                        \"Could not read file: \" + filename);\n\n            }\n        }\n        catch (MalformedURLException e) {\n            throw new StorageFileNotFoundException(\"Could not read file: \" + filename, e);\n        }\n    }\n\n    @Override\n    public void deleteAll() {\n        FileSystemUtils.deleteRecursively(rootLocation.toFile());\n    }\n\n    @Override\n    public void init() {\n        try {\n            Files.createDirectories(rootLocation);\n        }\n        catch (IOException e) {\n            throw new StorageException(\"Could not initialize storage\", e);\n        }\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class GreetingControllerTests {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void noParamGreetingShouldReturnDefaultMessage() throws Exception {\n\n        this.mockMvc.perform(get(\"/greeting\")).andDo(print()).andExpect(status().isOk())\n                .andExpect(jsonPath(\"$.content\").value(\"Hello, World!\"));\n    }\n\n    @Test\n    public void paramGreetingShouldReturnTailoredMessage() throws Exception {\n\n        this.mockMvc.perform(get(\"/greeting\").param(\"name\", \"Spring Community\"))\n                .andDo(print()).andExpect(status().isOk())\n                .andExpect(jsonPath(\"$.content\").value(\"Hello, Spring Community!\"));\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class HelloCV\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tSystem.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\t\t\n\t\tSystem.out.println(\"Create a 3x3 identity matrix...\");\n\t\tMat mat = Mat.eye(3, 3, CvType.CV_8UC1);\n\t\tSystem.out.println(\"mat = \" + mat.dump());\n\t\t\n\t\tString location = \"resources/Poli.jpg\";\n\t\tSystem.out.print(\"Convert the image at \" + location + \" in gray scale... \");\n\t\tMat image = Imgcodecs.imread(location);\n\t\tImgproc.cvtColor(image, image, Imgproc.COLOR_BGR2GRAY);\n\t\tImgcodecs.imwrite(\"resources/Poli-gray.jpg\", image);\n\t\tSystem.out.println(\"Done!\");\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class Features2d {\n\n    public static final int\n            DRAW_OVER_OUTIMG = 1,\n            NOT_DRAW_SINGLE_POINTS = 2,\n            DRAW_RICH_KEYPOINTS = 4;\n\n\n\n    public static void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage, Scalar color, int flags)\n    {\n        Mat keypoints_mat = keypoints;\n        drawKeypoints_0(image.nativeObj, keypoints_mat.nativeObj, outImage.nativeObj, color.val[0], color.val[1], color.val[2], color.val[3], flags);\n        \n        return;\n    }\n\n    public static void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage)\n    {\n        Mat keypoints_mat = keypoints;\n        drawKeypoints_1(image.nativeObj, keypoints_mat.nativeObj, outImage.nativeObj);\n        \n        return;\n    }\n\n\n\n    public static void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask, int flags)\n    {\n        Mat keypoints1_mat = keypoints1;\n        Mat keypoints2_mat = keypoints2;\n        Mat matches1to2_mat = matches1to2;\n        Mat matchesMask_mat = matchesMask;\n        drawMatches_0(img1.nativeObj, keypoints1_mat.nativeObj, img2.nativeObj, keypoints2_mat.nativeObj, matches1to2_mat.nativeObj, outImg.nativeObj, matchColor.val[0], matchColor.val[1], matchColor.val[2], matchColor.val[3], singlePointColor.val[0], singlePointColor.val[1], singlePointColor.val[2], singlePointColor.val[3], matchesMask_mat.nativeObj, flags);\n        \n        return;\n    }\n\n    public static void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg)\n    {\n        Mat keypoints1_mat = keypoints1;\n        Mat keypoints2_mat = keypoints2;\n        Mat matches1to2_mat = matches1to2;\n        drawMatches_1(img1.nativeObj, keypoints1_mat.nativeObj, img2.nativeObj, keypoints2_mat.nativeObj, matches1to2_mat.nativeObj, outImg.nativeObj);\n        \n        return;\n    }\n\n\n\n    public static void drawMatches2(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, List<MatOfByte> matchesMask, int flags)\n    {\n        Mat keypoints1_mat = keypoints1;\n        Mat keypoints2_mat = keypoints2;\n        List<Mat> matches1to2_tmplm = new ArrayList<Mat>((matches1to2 != null) ? matches1to2.size() : 0);\n        Mat matches1to2_mat = Converters.vector_vector_DMatch_to_Mat(matches1to2, matches1to2_tmplm);\n        List<Mat> matchesMask_tmplm = new ArrayList<Mat>((matchesMask != null) ? matchesMask.size() : 0);\n        Mat matchesMask_mat = Converters.vector_vector_char_to_Mat(matchesMask, matchesMask_tmplm);\n        drawMatches2_0(img1.nativeObj, keypoints1_mat.nativeObj, img2.nativeObj, keypoints2_mat.nativeObj, matches1to2_mat.nativeObj, outImg.nativeObj, matchColor.val[0], matchColor.val[1], matchColor.val[2], matchColor.val[3], singlePointColor.val[0], singlePointColor.val[1], singlePointColor.val[2], singlePointColor.val[3], matchesMask_mat.nativeObj, flags);\n        \n        return;\n    }\n\n    public static void drawMatches2(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg)\n    {\n        Mat keypoints1_mat = keypoints1;\n        Mat keypoints2_mat = keypoints2;\n        List<Mat> matches1to2_tmplm = new ArrayList<Mat>((matches1to2 != null) ? matches1to2.size() : 0);\n        Mat matches1to2_mat = Converters.vector_vector_DMatch_to_Mat(matches1to2, matches1to2_tmplm);\n        drawMatches2_1(img1.nativeObj, keypoints1_mat.nativeObj, img2.nativeObj, keypoints2_mat.nativeObj, matches1to2_mat.nativeObj, outImg.nativeObj);\n        \n        return;\n    }\n\n\n\n\n    private static native void drawKeypoints_0(long image_nativeObj, long keypoints_mat_nativeObj, long outImage_nativeObj, double color_val0, double color_val1, double color_val2, double color_val3, int flags);\n    private static native void drawKeypoints_1(long image_nativeObj, long keypoints_mat_nativeObj, long outImage_nativeObj);\n\n    private static native void drawMatches_0(long img1_nativeObj, long keypoints1_mat_nativeObj, long img2_nativeObj, long keypoints2_mat_nativeObj, long matches1to2_mat_nativeObj, long outImg_nativeObj, double matchColor_val0, double matchColor_val1, double matchColor_val2, double matchColor_val3, double singlePointColor_val0, double singlePointColor_val1, double singlePointColor_val2, double singlePointColor_val3, long matchesMask_mat_nativeObj, int flags);\n    private static native void drawMatches_1(long img1_nativeObj, long keypoints1_mat_nativeObj, long img2_nativeObj, long keypoints2_mat_nativeObj, long matches1to2_mat_nativeObj, long outImg_nativeObj);\n\n    private static native void drawMatches2_0(long img1_nativeObj, long keypoints1_mat_nativeObj, long img2_nativeObj, long keypoints2_mat_nativeObj, long matches1to2_mat_nativeObj, long outImg_nativeObj, double matchColor_val0, double matchColor_val1, double matchColor_val2, double matchColor_val3, double singlePointColor_val0, double singlePointColor_val1, double singlePointColor_val2, double singlePointColor_val3, long matchesMask_mat_nativeObj, int flags);\n    private static native void drawMatches2_1(long img1_nativeObj, long keypoints1_mat_nativeObj, long img2_nativeObj, long keypoints2_mat_nativeObj, long matches1to2_mat_nativeObj, long outImg_nativeObj);\n\n}", "nl": "opencv"}
{"code": "\n\npublic class ErodeTest {\n   public static void main( String[] args ) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"C:/EXAMPLES/OpenCV/sample.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, \n         new  Size((2*2) + 1, (2*2)+1));\n\n      Imgproc.erode(src, dst, kernel);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap10/Erosion.jpg\", dst);\n\n      System.out.println(\"Image processed\");\n   }\n}\n", "nl": "opencv"}
{"code": "\n\n\n\npublic class ResLocate {\n\n    private static final String PATH = \"res/img/resistor\";\n    private static int threshold = 0;           //\n    private static int morphOpenSizeX = 20;     //\n    private static int morphOpenSizeY = 20;     //\n    private static int morphDilateSizeX = 17;   //\n    private static int morphDilateSizeY = 17;   //\n    private static int verifyArea = 8000;       //\n\n\n    \n    public List<Mat> resLocate(Mat src) {\n        List<Mat> resultList = new ArrayList<Mat>();\n\n        Mat src_blur = new Mat();\n        Mat src_gray = new Mat();\n\n        Imgproc.GaussianBlur(src, src_blur, new Size(5, 5), 0, 0, 4);\n\n        Imgcodecs.imwrite(PATH + \"src_blur.jpg\", src_blur);\n\n        Imgproc.cvtColor(src, src_gray, Imgproc.COLOR_BGR2GRAY);\n\n        Imgcodecs.imwrite(PATH + \"src_gray.jpg\", src_gray);\n\n        Mat img_threshold = new Mat();\n        Imgproc.threshold(src_gray, img_threshold, threshold, 255, Imgproc.THRESH_OTSU);\n\n        Imgcodecs.imwrite(PATH + \"img_threshold.jpg\", img_threshold);\n\n        Mat element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(morphOpenSizeX, morphOpenSizeY));\n        Imgproc.morphologyEx(img_threshold, img_threshold, Imgproc.MORPH_OPEN, element);\n\n        Imgcodecs.imwrite(PATH + \"morphology_open.jpg\", img_threshold);\n\n        element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(morphDilateSizeX, morphDilateSizeY));\n        Imgproc.morphologyEx(img_threshold, img_threshold, Imgproc.MORPH_DILATE, element);\n\n        Imgcodecs.imwrite(PATH + \"morphology_dilate.jpg\", img_threshold);\n\n        Mat hierarchy = new Mat();\n        List<MatOfPoint> contours = new ArrayList<MatOfPoint>();\n        Imgproc.findContours(img_threshold, contours, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_NONE);\n\n        Mat result = new Mat();\n        src.copyTo(result);\n        Imgproc.drawContours(img_threshold, contours, -1, new Scalar(255, 0, 255, 255));\n        Imgcodecs.imwrite(PATH + \"draw_Contours.jpg\", img_threshold);\n\n        List<RotatedRect> rects = new ArrayList<RotatedRect>();\n        for (int i = 0; i < contours.size(); i++) {\n            MatOfPoint2f mtx = new MatOfPoint2f(contours.get(i).toArray());\n            RotatedRect mr = Imgproc.minAreaRect(mtx);\n            if (verifySize(mr))\n                rects.add(mr);\n        }\n\n        for (int i = 0; i < rects.size(); i++) {\n            RotatedRect minRect = rects.get(i);\n            Point[] rect_points = new Point[4];\n            minRect.points(rect_points);\n\n            for (int j = 0; j < 4; j++) {\n                Point pt1 = new Point(rect_points[j].x, rect_points[j].y);\n                Point pt2 = new Point(rect_points[(j + 1) % 4].x, rect_points[(j + 1) % 4].y);\n\n                Imgproc.line(img_threshold, pt1, pt2, new Scalar(255, 0, 255, 255), 4, 8, 0);\n            }\n\n            double r = minRect.size.width / minRect.size.height;\n            double angle = minRect.angle;\n            Size size = new Size(minRect.size.width, minRect.size.height);\n            if (r < 1) {\n                angle = angle + 90;\n                size = new Size(minRect.size.height, minRect.size.width);\n            }\n            Mat rotMat = Imgproc.getRotationMatrix2D(minRect.center, angle, 1);\n            Mat img_rotated = new Mat();\n            Imgproc.warpAffine(src, img_rotated, rotMat, src.size());\n            Mat resultMat = showResultMat(img_rotated, size, minRect.center, i);\n            resultList.add(resultMat);\n\n        }\n\n        Imgcodecs.imwrite(PATH + \"result.jpg\", img_threshold);\n\n        return resultList;\n    }\n\n    \n    public boolean verifySize(RotatedRect mr) {\n        int area = (int) (mr.size.height * mr.size.width);\n        int ratio;\n        if (mr.size.height > mr.size.width) {\n            ratio = (int) (mr.size.height / mr.size.width);\n        } else {\n            ratio = (int) (mr.size.width / mr.size.height);\n        }\n        if (ratio >= 2 && ratio <= 3 && area >= verifyArea)\n            return true;\n        return false;\n    }\n\n    \n    private Mat showResultMat(Mat src, Size rect_size, Point center, int index) {\n        Mat img_crop = new Mat();\n        Imgproc.getRectSubPix(src, rect_size, center, img_crop);\n        Imgcodecs.imwrite(PATH + \"debug_crop_\" + index + \".jpg\", img_crop);\n        return img_crop;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n@Controller\npublic class WebController implements WebMvcConfigurer {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/results\").setViewName(\"results\");\n    }\n\n    @GetMapping(\"/\")\n    public String showForm(PersonForm personForm) {\n        return \"form\";\n    }\n\n    @PostMapping(\"/\")\n    public String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) {\n\n        if (bindingResult.hasErrors()) {\n            return \"form\";\n        }\n\n        return \"redirect:/results\";\n    }\n}", "nl": "spring"}
{"code": "\n\n\npublic class FaceDetector {\n\tpublic void run(){\n\t\tMat image= Imgcodecs.imread(\"data/SimilarFaceSearching.png\");\n\t\tMat moustache=Imgcodecs.imread(\"data/moustache.png\",-1);\n\t\t\n\t\tCascadeClassifier faceCascade=new CascadeClassifier(\"data/haarcascades/haarcascade_frontalface_alt2.xml\");\n\t\tCascadeClassifier noseCascade= new CascadeClassifier(\"data/otherCascades/haarcascade_mcs_nose.xml\");\n\t\t\n\t\tMat grayImage=new Mat();\n\t\tImgproc.cvtColor(image, grayImage, Imgproc.COLOR_BGR2GRAY);\n\t\tImgproc.equalizeHist(grayImage, grayImage);\n\t\t\n\t\tMatOfRect faces= new MatOfRect();\n\t\tfaceCascade.detectMultiScale(grayImage, faces);\n\t\t\n\t\tfor(Rect face: faces.toArray())\n\t\t{\n\t\t\tSystem.out.println(\"face found!\");\n\t\t\tMat roi_color=image.submat(face);\n\t\t\tMat roi_gray=grayImage.submat(face);\n\t\t\t\n\t\t\tMatOfRect noses=new MatOfRect();\n\t\t\tnoseCascade.detectMultiScale(roi_gray, noses);\n\t\t\t\n\t\t\tfor(Rect noseOne: noses.toArray()){\n\t\t\t\tSystem.out.println(\"nose found!\");\n\t\t\t\tdouble brX=noseOne.br().x;\n\t\t\t\tdouble brY=noseOne.br().y;\n\t\t\t\t\n\t\t\t\tdouble nw=noseOne.width;\n\t\t\t\tdouble mw=nw*3;\n\t\t\t\tdouble mh=mw/moustache.width()*moustache.height();\n\t\t\t\t\n\t\t\t\tdouble x1=brX-nw-mw/4;\n\t\t\t\tdouble x2=brX+mw/4;\n\t\t\t\tdouble y1=brY-mh/4;\n\t\t\t\tdouble y2=brY+mh/4;\n\t\t\t\t\n\t\t\t\tmw=x2-x1;\n\t\t\t\tmh=y2-y1;\n\t\t\t\t\n\t\t\t\tSize sz=new Size((int)mw,(int)mh);\n\t\t\t\tMat resizedMoustache=new Mat();\n\t\t\t\tImgproc.resize(moustache, resizedMoustache, sz);\n\t\t\t\t\n\t\t\t\tList<Mat> rgba=new ArrayList<Mat>();\n\t\t\t\tCore.split(resizedMoustache, rgba);\n\t\t\t\t\n\t\t\t\tMat mask=rgba.get(3);\n\t\t\t\tMat mask_inv=new Mat();\n\t\t\t\tCore.bitwise_not(mask, mask_inv);\n\t\t\t\trgba.remove(3);\n\t\t\t\tMat rgbMoustache=new Mat();\n\t\t\t\tCore.merge(rgba, rgbMoustache);\n\t\t\t\t\n\t\t\t\tMat fg=new Mat();\n\t\t\t\tCore.bitwise_and(rgbMoustache, rgbMoustache, fg, mask);\n\t\t\t\tMat bg=new Mat();\n\t\t\t\tMat roi=roi_color.submat(new Rect((int)x1,(int)y1,(int)mw,(int)mh));\n\t\t\t\tCore.bitwise_and(roi, roi, bg, mask_inv);\n\t\t\t\tCore.add(fg, bg, roi);\n\t\t\t}\n\t\t}\n\t\tString fileName=\"result/faceswithMous.jpeg\";\n\t\tSystem.out.println(String.format(\"Writing %s\", fileName));\n\t\tImgcodecs.imwrite(fileName, image);\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n@Controller\npublic class SimpleController {\n\n    @Value(\"${spring.application.name}\")\n    String appName;\n\n    @RequestMapping(\"/\")\n    public String homePage(Model model) {\n        model.addAttribute(\"appName\", appName);\n        return \"home\";\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@SuppressWarnings(\"all\")\npublic class ImgDecompose {\n\t\n\tpublic static Mat[] illuRefDecompose(Mat img) {\n\t\tList<Mat> AList = new ArrayList<>();\n\t\tList<Mat> RList = new ArrayList<>();\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(img, bgr);\n\t\tfor (Mat cnl : bgr) {\n\t\t\tMat alCnl = cnl.clone();\n\t\t\tMat rlcnl = cnl.clone();\n\t\t\tdouble maxVal = Core.minMaxLoc(cnl).maxVal;\n\t\t\tMat k = new Mat();\n\t\t\tCore.multiply(cnl, new Scalar(0.5 / maxVal), k);\n\t\t\trlcnl = k.mul(rlcnl);\n\t\t\tCore.subtract(alCnl, rlcnl, alCnl);\n\t\t\tAList.add(alCnl);\n\t\t\tRList.add(rlcnl);\n\t\t}\n\t\tMat Al = new Mat();\n\t\tCore.merge(AList, Al);\n\t\tMat Rl = new Mat();\n\t\tCore.merge(RList, Rl);\n\t\treturn new Mat[]{Al, Rl};\n\t}\n\n\tpublic static Mat[] buildGaussianPyramid(Mat img, int level) {\n\t\tMat[] gaussPyr = new Mat[level];\n\t\tMat mask = filterMask(img);\n\t\tMat tmp = new Mat();\n\t\tImgproc.filter2D(img, tmp, -1, mask);\n\t\tgaussPyr[0] = tmp.clone();\n\t\tMat tmpImg = img.clone();\n\t\tfor (int i = 1; i < level; i++) {\n\t\t\tImgproc.resize(tmpImg, tmpImg, new Size(), 0.5, 0.5, Imgproc.INTER_LINEAR);\n\t\t\ttmp = new Mat();\n\t\t\tImgproc.filter2D(tmpImg, tmp, -1, mask);\n\t\t\tgaussPyr[i] = tmp.clone();\n\t\t}\n\t\treturn gaussPyr;\n\t}\n\n\tpublic static Mat[] buildLaplacianPyramid(Mat img, int level) {\n\t\tMat[] lapPyr = new Mat[level];\n\t\tlapPyr[0] = img.clone();\n\t\tMat tmpImg = img.clone();\n\t\tfor (int i = 1; i < level; i++) {\n\t\t\tImgproc.resize(tmpImg, tmpImg, new Size(), 0.5, 0.5, Imgproc.INTER_LINEAR);\n\t\t\tlapPyr[i] = tmpImg.clone();\n\t\t}\n\t\tfor (int i = 0; i < level - 1; i++) {\n\t\t\tMat tmpPyr = new Mat();\n\t\t\tImgproc.resize(lapPyr[i + 1], tmpPyr, lapPyr[i].size(), 0, 0, Imgproc.INTER_LINEAR);\n\t\t\tCore.subtract(lapPyr[i], tmpPyr, lapPyr[i]);\n\t\t}\n\t\treturn lapPyr;\n\t}\n\n\tpublic static Mat reconstructLaplacianPyramid(Mat[] pyramid) {\n\t\tint level = pyramid.length;\n\t\tfor (int i = level - 1; i > 0; i--) {\n\t\t\tMat tmpPyr = new Mat();\n\t\t\tImgproc.resize(pyramid[i], tmpPyr, pyramid[i - 1].size(), 0, 0, Imgproc.INTER_LINEAR);\n\t\t\tCore.add(pyramid[i - 1], tmpPyr, pyramid[i - 1]);\n\t\t}\n\t\treturn pyramid[0];\n\t}\n\n\tprivate static Mat filterMask(Mat img) {\n\t\tdouble[] h = { 1.0 / 16.0, 4.0 / 16.0, 6.0 / 16.0, 4.0 / 16.0, 1.0 / 16.0 };\n\t\tMat mask = new Mat(h.length, h.length, img.type());\n\t\tfor (int i = 0; i < h.length; i++) {\n\t\t\tfor (int j = 0; j < h.length; j++) {\n\t\t\t\tmask.put(i, j, h[i] * h[j]);\n\t\t\t}\n\t\t}\n\t\treturn mask;\n\t}\n\n\tpublic static Mat fuseTwoImage (Mat w1, Mat img1, Mat w2, Mat img2, int level) {\n\t\tMat[] weight1 = ImgDecompose.buildGaussianPyramid(w1, level);\n\t\tMat[] weight2 = ImgDecompose.buildGaussianPyramid(w2, level);\n\t\timg1.convertTo(img1, CvType.CV_32F);\n\t\timg2.convertTo(img2, CvType.CV_32F);\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(img1, bgr);\n\t\tMat[] bCnl1 = ImgDecompose.buildLaplacianPyramid(bgr.get(0), level);\n\t\tMat[] gCnl1 = ImgDecompose.buildLaplacianPyramid(bgr.get(1), level);\n\t\tMat[] rCnl1 = ImgDecompose.buildLaplacianPyramid(bgr.get(2), level);\n\t\tbgr.clear();\n\t\tCore.split(img2, bgr);\n\t\tMat[] bCnl2 = ImgDecompose.buildLaplacianPyramid(bgr.get(0), level);\n\t\tMat[] gCnl2 = ImgDecompose.buildLaplacianPyramid(bgr.get(1), level);\n\t\tMat[] rCnl2 = ImgDecompose.buildLaplacianPyramid(bgr.get(2), level);\n\t\tMat[] bCnl = new Mat[level];\n\t\tMat[] gCnl = new Mat[level];\n\t\tMat[] rCnl = new Mat[level];\n\t\tfor (int i = 0; i < level; i++) {\n\t\t\tMat cn = new Mat();\n\t\t\tCore.add(bCnl1[i].mul(weight1[i]), bCnl2[i].mul(weight2[i]), cn);\n\t\t\tbCnl[i] = cn.clone();\n\t\t\tCore.add(gCnl1[i].mul(weight1[i]), gCnl2[i].mul(weight2[i]), cn);\n\t\t\tgCnl[i] = cn.clone();\n\t\t\tCore.add(rCnl1[i].mul(weight1[i]), rCnl2[i].mul(weight2[i]), cn);\n\t\t\trCnl[i] = cn.clone();\n\t\t}\n\t\tMat bChannel = ImgDecompose.reconstructLaplacianPyramid(bCnl);\n\t\tMat gChannel = ImgDecompose.reconstructLaplacianPyramid(gCnl);\n\t\tMat rChannel = ImgDecompose.reconstructLaplacianPyramid(rCnl);\n\t\tMat fusion = new Mat();\n\t\tCore.merge(new ArrayList<>(Arrays.asList(bChannel, gChannel, rChannel)), fusion);\n\t\treturn fusion;\n\t}\n\t\n}", "nl": "opencv"}
{"code": "\n\n\npublic class LaplacianTest {\n   public static void main(String args[]) {\n      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n      String file =\"E:/OpenCV/chap18/laplacian_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Imgproc.Laplacian(src, dst, 10);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap18/laplacian.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@SpringBootApplication(exclude = SocialWebAutoConfiguration.class)\n@EnableConfigurationProperties(SiteProperties.class)\npublic class SiteApplication {\n\n    public static void main(String[] args) {\n        new SaganApplication(SiteApplication.class).run(args);\n    }\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate(new HttpComponentsClientHttpRequestFactory(HttpClientBuilder.create().build()));\n    }\n\n    @Bean\n    @Primary\n    public ObjectMapper objectMapper() {\n        return new ObjectMapper();\n    }\n\n    @Bean\n    public XmlMapper xmlMapper() {\n        return new XmlMapper();\n    }\n\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class RubixDetector {\n\n    private static final org.slf4j.Logger log = LoggerFactory.getLogger(RubixDetector.class);\n    private static final OpenCVFrameConverter.ToIplImage converter = new OpenCVFrameConverter.ToIplImage();\n    private static final int IMAGE_INPUT_W = 416;\n    private static final int IMAGE_INPUT_H = 416;\n\n    public static void main(String[] args) {\n\n        YoloModel detector = new YoloModel();\n\n        final AtomicReference<opencv_videoio.VideoCapture> capture = new AtomicReference<>(new opencv_videoio.VideoCapture());\n        capture.get().set(CV_CAP_PROP_FRAME_WIDTH, 1280);\n        capture.get().set(CV_CAP_PROP_FRAME_HEIGHT, 720);\n\n        if (!capture.get().open(0)) {\n            log.error(\"Can not open the cam !!!\");\n        }\n\n        opencv_core.Mat colorimg = new opencv_core.Mat();\n\n        CanvasFrame mainframe = new CanvasFrame(\"Real-time Rubik's Cube Detector - Emaraic\", CanvasFrame.getDefaultGamma() / 2.2);\n        mainframe.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n        mainframe.setCanvasSize(600, 600);\n        mainframe.setLocationRelativeTo(null);\n        mainframe.setVisible(true);\n\n        while (true) {\n            while (capture.get().read(colorimg) && mainframe.isVisible()) {\n                long st = System.currentTimeMillis();\n                opencv_imgproc.resize(colorimg, colorimg, new opencv_core.Size(IMAGE_INPUT_W, IMAGE_INPUT_H));\n                detector.detectRubixCube(colorimg, .4);\n                double per = (System.currentTimeMillis() - st) / 1000.0;\n                log.info(\"It takes \" + per + \"Seconds to make detection\");\n                putText(colorimg, \"Detection Time : \" + per + \" ms\", new opencv_core.Point(10, 25), 2,.9, opencv_core.Scalar.YELLOW);\n\n                mainframe.showImage(converter.convert(colorimg));\n                try {\n                    Thread.sleep(20);\n                } catch (InterruptedException ex) {\n                    log.error(ex.getMessage());\n                }\n            }\n        }\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\npublic class CameraDevice extends ProjectiveDevice {\n    public CameraDevice(String name) {\n        super(name);\n    }\n    public CameraDevice(String name, String filename) throws Exception {\n        super(name, filename);\n        settings.setImageWidth(imageWidth);\n        settings.setImageHeight(imageHeight);\n    }\n    public CameraDevice(String name, FileStorage fs) throws Exception {\n        super(name, fs);\n        settings.setImageWidth(imageWidth);\n        settings.setImageHeight(imageHeight);\n    }\n    public CameraDevice(Settings settings) throws Exception {\n        super((ProjectiveDevice.Settings)settings);\n    }\n\n    public interface Settings {\n        String getName();\n        void setName(String name);\n        double getResponseGamma();\n        void setResponseGamma(double gamma);\n\n        Integer getDeviceNumber();\n        void setDeviceNumber(Integer deviceNumber) throws PropertyVetoException;\n        File getDeviceFile();\n        void setDeviceFile(File deviceFile) throws PropertyVetoException;\n        String getDeviceFilename();\n        void setDeviceFilename(String deviceFilename) throws PropertyVetoException;\n        String getDevicePath();\n        void setDevicePath(String devicePath) throws PropertyVetoException;\n        Class<? extends FrameGrabber> getFrameGrabber();\n        void setFrameGrabber(Class<? extends FrameGrabber> frameGrabber);\n        String getDescription();\n\n        String getFormat();\n        void setFormat(String format);\n        int getImageWidth();\n        void setImageWidth(int imageWidth);\n        int getImageHeight();\n        void setImageHeight(int imageHeight);\n        double getFrameRate();\n        void setFrameRate(double frameRate);\n        boolean isTriggerMode();\n        void setTriggerMode(boolean triggerMode);\n        int getBitsPerPixel();\n        void setBitsPerPixel(int bitsPerPixel);\n        FrameGrabber.ImageMode getImageMode();\n        void setImageMode(FrameGrabber.ImageMode imageMode);\n        int getTimeout();\n        void setTimeout(int timeout);\n        int getNumBuffers();\n        void setNumBuffers(int numBuffers);\n        boolean isDeinterlace();\n        void setDeinterlace(boolean deinterlace);\n\n        void addPropertyChangeListener(PropertyChangeListener listener);\n        void removePropertyChangeListener(PropertyChangeListener listener);\n    }\n\n    public static class SettingsImplementation extends ProjectiveDevice.Settings implements Settings {\n        public SettingsImplementation() { name = \"Camera  0\"; }\n        public SettingsImplementation(ProjectiveDevice.Settings settings) {\n            super(settings);\n            if (settings instanceof SettingsImplementation) {\n                SettingsImplementation s = (SettingsImplementation)settings;\n                this.deviceNumber = s.deviceNumber;\n                this.deviceFile   = s.deviceFile;\n                this.devicePath   = s.devicePath;\n                this.frameGrabber = s.frameGrabber;\n                this.format       = s.format;\n                this.imageWidth   = s.imageWidth;\n                this.imageHeight  = s.imageHeight;\n                this.frameRate    = s.frameRate;\n                this.triggerMode  = s.triggerMode;\n                this.bpp          = s.bpp;\n                this.imageMode    = s.imageMode;\n                this.timeout      = s.timeout;\n                this.numBuffers   = s.numBuffers;\n                this.deinterlace  = s.deinterlace;\n            }\n        }\n\n        Integer deviceNumber = null;\n        File deviceFile = null;\n        String devicePath = null;\n        Class<? extends FrameGrabber> frameGrabber = null;\n\n        public Integer getDeviceNumber() {\n            return deviceNumber;\n        }\n        public void setDeviceNumber(Integer deviceNumber) throws PropertyVetoException {\n            if (deviceNumber != null) {\n                try {\n                    if (frameGrabber != null) {\n                        try {\n                            frameGrabber.getConstructor(int.class);\n                        } catch (NoSuchMethodException e) {\n                            frameGrabber.getConstructor(Integer.class);\n                        }\n                    }\n                    setDevicePath(null);\n                    setDeviceFile(null);\n                } catch (NoSuchMethodException e) {\n                    throw new PropertyVetoExceptionThatNetBeansLikes(frameGrabber.getSimpleName() + \" does not accept a deviceNumber.\",\n                            new PropertyChangeEvent(this, \"deviceNumber\", this.deviceNumber, this.deviceNumber = null));\n                }\n            }\n            String oldDescription = getDescription();\n            firePropertyChange(\"deviceNumber\", this.deviceNumber, this.deviceNumber = deviceNumber);\n            firePropertyChange(\"description\", oldDescription, getDescription());\n        }\n\n        public File getDeviceFile() {\n            return deviceFile;\n        }\n        public void setDeviceFile(File deviceFile) throws PropertyVetoException {\n            if (deviceFile != null) {\n                try {\n                    if (frameGrabber != null) {\n                        frameGrabber.getConstructor(File.class);\n                    }\n                    setDeviceNumber(null);\n                    setDevicePath(null);\n                } catch (NoSuchMethodException e) {\n                    deviceFile = null;\n                    throw new PropertyVetoExceptionThatNetBeansLikes(frameGrabber.getSimpleName() + \" does not accept a deviceFile.\",\n                            new PropertyChangeEvent(this, \"deviceFile\", this.deviceFile, this.deviceFile = null));\n                }\n            }\n            String oldDescription = getDescription();\n            firePropertyChange(\"deviceFile\", this.deviceFile, this.deviceFile = deviceFile);\n            firePropertyChange(\"description\", oldDescription, getDescription());\n        }\n        public String getDeviceFilename() {\n            return getDeviceFile() == null ? \"\" : getDeviceFile().getPath();\n        }\n        public void setDeviceFilename(String deviceFilename) throws PropertyVetoException {\n            setDeviceFile(deviceFilename == null || deviceFilename.length() == 0 ?\n                null : new File(deviceFilename));\n        }\n\n        public String getDevicePath() {\n            return devicePath;\n        }\n        public void setDevicePath(String devicePath) throws PropertyVetoException {\n            if (devicePath != null) {\n                try {\n                    if (frameGrabber != null) {\n                        frameGrabber.getConstructor(String.class);\n                    }\n                    setDeviceNumber(null);\n                    setDeviceFile(null);\n                } catch (NoSuchMethodException e) {\n                    devicePath = \"\";\n                    throw new PropertyVetoExceptionThatNetBeansLikes(frameGrabber.getSimpleName() + \" does not accept a devicePath.\",\n                            new PropertyChangeEvent(this, \"devicePath\", this.devicePath, this.devicePath = null));\n                }\n            }\n            String oldDescription = getDescription();\n            firePropertyChange(\"devicePath\", this.devicePath, this.devicePath = devicePath);\n            firePropertyChange(\"description\", oldDescription, getDescription());\n        }\n\n        public Class<? extends FrameGrabber> getFrameGrabber() {\n            return frameGrabber;\n        }\n        public void setFrameGrabber(Class<? extends FrameGrabber> frameGrabber) {\n            String oldDescription = getDescription();\n            firePropertyChange(\"frameGrabber\", this.frameGrabber, this.frameGrabber = frameGrabber);\n            firePropertyChange(\"description\", oldDescription, getDescription());\n\n            if (frameGrabber == null) {\n                firePropertyChange(\"deviceNumber\", this.deviceNumber, this.deviceNumber = null);\n                firePropertyChange(\"deviceFile\", this.deviceFile, this.deviceFile = null);\n                firePropertyChange(\"devicePath\", this.devicePath, this.devicePath = null);\n                return;\n            }\n\n            boolean hasDeviceNumber = false;\n            try {\n                frameGrabber.getConstructor(int.class);\n                hasDeviceNumber = true;\n            } catch (NoSuchMethodException e) {\n                try {\n                    frameGrabber.getConstructor(Integer.class);\n                    hasDeviceNumber = true;\n                } catch (NoSuchMethodException e2) {\n                    firePropertyChange(\"deviceNumber\", this.deviceNumber, this.deviceNumber = null);\n                }\n            }\n            try {\n                frameGrabber.getConstructor(File.class);\n            } catch (NoSuchMethodException e) {\n                firePropertyChange(\"deviceFile\", this.deviceFile, this.deviceFile = null);\n            }\n            try {\n                frameGrabber.getConstructor(String.class);\n            } catch (NoSuchMethodException e) {\n                firePropertyChange(\"devicePath\", this.devicePath, this.devicePath = null);\n            }\n\n            if (hasDeviceNumber && deviceNumber == null && deviceFile == null && devicePath == null) {\n                try {\n                    setDeviceNumber(0);\n                } catch (PropertyVetoException e) { }\n            }\n        }\n\n        public String getDescription() {\n            String[] descriptions = null;\n            try {\n                Method m = frameGrabber.getMethod(\"getDeviceDescriptions\");\n                descriptions = (String[])m.invoke(null);\n            } catch (java.lang.Exception ex) { }\n\n            if (descriptions != null && deviceNumber != null && deviceNumber < descriptions.length) {\n                return descriptions[deviceNumber];\n            } else {\n                return \"\";\n            }\n        }\n\n        String format = \"\";\n        int imageWidth = 0, imageHeight = 0;\n        double frameRate = 0;\n        boolean triggerMode = false;\n        int bpp = 0;\n        FrameGrabber.ImageMode imageMode = FrameGrabber.ImageMode.COLOR;\n        int timeout = 10000;\n        int numBuffers = 4;\n        boolean deinterlace = false;\n\n        public String getFormat() {\n            return format;\n        }\n        public void setFormat(String format) {\n            this.format = format;\n        }\n\n        public int getImageWidth() {\n            return imageWidth;\n        }\n        public void setImageWidth(int imageWidth) {\n            this.imageWidth = imageWidth;\n        }\n\n        public int getImageHeight() {\n            return imageHeight;\n        }\n        public void setImageHeight(int imageHeight) {\n            this.imageHeight = imageHeight;\n        }\n\n        public double getFrameRate() {\n            return frameRate;\n        }\n        public void setFrameRate(double frameRate) {\n            this.frameRate = frameRate;\n        }\n\n        public boolean isTriggerMode() {\n            return triggerMode;\n        }\n        public void setTriggerMode(boolean triggerMode) {\n            this.triggerMode = triggerMode;\n        }\n\n        public int getBitsPerPixel() {\n            return bpp;\n        }\n        public void setBitsPerPixel(int bitsPerPixel) {\n            this.bpp = bitsPerPixel;\n        }\n\n        public FrameGrabber.ImageMode getImageMode() {\n            return imageMode;\n        }\n        public void setImageMode(FrameGrabber.ImageMode imageMode) {\n            this.imageMode = imageMode;\n        }\n\n        public int getTimeout() {\n            return timeout;\n        }\n        public void setTimeout(int timeout) {\n            this.timeout = timeout;\n        }\n\n        public int getNumBuffers() {\n            return numBuffers;\n        }\n        public void setNumBuffers(int numBuffers) {\n            this.numBuffers = numBuffers;\n        }\n\n        public boolean isDeinterlace() {\n            return deinterlace;\n        }\n        public void setDeinterlace(boolean deinterlace) {\n            this.deinterlace = deinterlace;\n        }\n    }\n\n    public static class CalibrationSettings extends ProjectiveDevice.CalibrationSettings implements Settings {\n        public CalibrationSettings() { }\n        public CalibrationSettings(ProjectiveDevice.CalibrationSettings settings) {\n            super(settings);\n            if (settings instanceof CalibrationSettings) {\n                si = new SettingsImplementation(((CalibrationSettings)settings).si);\n            }\n        }\n        SettingsImplementation si = new SettingsImplementation() {\n            @Override public void firePropertyChange(String propertyName, Object oldValue, Object newValue) {\n                CalibrationSettings.this.firePropertyChange(propertyName, oldValue, newValue);\n            }\n        };\n\n        @Override public String getName() { return si.getName(); }\n        @Override public void setName(String name) { si.setName(name); }\n        @Override public double getResponseGamma() { return si.getResponseGamma(); }\n        @Override public void setResponseGamma(double responseGamma) { si.setResponseGamma(responseGamma); }\n\n        public Integer getDeviceNumber() { return si.getDeviceNumber(); }\n        public void setDeviceNumber(Integer deviceNumber) throws PropertyVetoException { si.setDeviceNumber(deviceNumber); }\n        public File getDeviceFile() { return si.getDeviceFile(); }\n        public void setDeviceFile(File deviceFile) throws PropertyVetoException { si.setDeviceFile(deviceFile); }\n        public String getDeviceFilename() { return si.getDeviceFilename(); }\n        public void setDeviceFilename(String deviceFilename) throws PropertyVetoException { si.setDeviceFilename(deviceFilename); }\n        public String getDevicePath() { return si.getDevicePath(); }\n        public void setDevicePath(String devicePath) throws PropertyVetoException { si.setDevicePath(devicePath); }\n        public Class<? extends FrameGrabber> getFrameGrabber() { return si.getFrameGrabber(); }\n        public void setFrameGrabber(Class<? extends FrameGrabber> frameGrabber) { si.setFrameGrabber(frameGrabber); }\n        public String getDescription() { return si.getDescription(); }\n\n        public String getFormat() { return si.getFormat(); }\n        public void setFormat(String format) { si.setFormat(format); }\n        public int getImageWidth() { return si.getImageWidth(); }\n        public void setImageWidth(int imageWidth) { si.setImageWidth(imageWidth); }\n        public int getImageHeight() { return si.getImageHeight(); }\n        public void setImageHeight(int imageHeight) { si.setImageHeight(imageHeight); }\n        public double getFrameRate() { return si.getFrameRate(); }\n        public void setFrameRate(double frameRate) { si.setFrameRate(frameRate); }\n        public boolean isTriggerMode() { return si.isTriggerMode(); }\n        public void setTriggerMode(boolean triggerMode) { si.setTriggerMode(triggerMode); }\n        public int getBitsPerPixel() { return si.getBitsPerPixel(); }\n        public void setBitsPerPixel(int bitsPerPixel) { si.setBitsPerPixel(bitsPerPixel); }\n        public FrameGrabber.ImageMode getImageMode() { return si.getImageMode(); }\n        public void setImageMode(FrameGrabber.ImageMode imageMode) { si.setImageMode(imageMode); }\n        public int getTimeout() { return si.getTimeout(); }\n        public void setTimeout(int timeout) { si.setTimeout(timeout); }\n        public int getNumBuffers() { return si.getNumBuffers(); }\n        public void setNumBuffers(int numBuffers) { si.setNumBuffers(numBuffers); }\n        public boolean isDeinterlace() { return si.isDeinterlace(); }\n        public void setDeinterlace(boolean deinterlace) { si.setDeinterlace(deinterlace); }\n    }\n\n    public static class CalibratedSettings extends ProjectiveDevice.CalibratedSettings implements Settings {\n        public CalibratedSettings() { }\n        public CalibratedSettings(ProjectiveDevice.CalibratedSettings settings) {\n            super(settings);\n            if (settings instanceof CalibratedSettings) {\n                si = new SettingsImplementation(((CalibratedSettings)settings).si);\n            }\n        }\n        SettingsImplementation si = new SettingsImplementation() {\n            @Override public void firePropertyChange(String propertyName, Object oldValue, Object newValue) {\n                CalibratedSettings.this.firePropertyChange(propertyName, oldValue, newValue);\n            }\n        };\n\n        @Override public String getName() { return si.getName(); }\n        @Override public void setName(String name) { si.setName(name); }\n        @Override public double getResponseGamma() { return si.getResponseGamma(); }\n        @Override public void setResponseGamma(double responseGamma) { si.setResponseGamma(responseGamma); }\n\n        public Integer getDeviceNumber() { return si.getDeviceNumber(); }\n        public void setDeviceNumber(Integer deviceNumber) throws PropertyVetoException { si.setDeviceNumber(deviceNumber); }\n        public File getDeviceFile() { return si.getDeviceFile(); }\n        public void setDeviceFile(File deviceFile) throws PropertyVetoException { si.setDeviceFile(deviceFile); }\n        public String getDeviceFilename() { return si.getDeviceFilename(); }\n        public void setDeviceFilename(String deviceFilename) throws PropertyVetoException { si.setDeviceFilename(deviceFilename); }\n        public String getDevicePath() { return si.getDevicePath(); }\n        public void setDevicePath(String devicePath) throws PropertyVetoException { si.setDevicePath(devicePath); }\n        public Class<? extends FrameGrabber> getFrameGrabber() { return si.getFrameGrabber(); }\n        public void setFrameGrabber(Class<? extends FrameGrabber> frameGrabber) { si.setFrameGrabber(frameGrabber); }\n        public String getDescription() { return si.getDescription(); }\n\n        public String getFormat() { return si.getFormat(); }\n        public void setFormat(String format) { si.setFormat(format); }\n        public int getImageWidth() { return si.getImageWidth(); }\n        public void setImageWidth(int imageWidth) { si.setImageWidth(imageWidth); }\n        public int getImageHeight() { return si.getImageHeight(); }\n        public void setImageHeight(int imageHeight) { si.setImageHeight(imageHeight); }\n        public double getFrameRate() { return si.getFrameRate(); }\n        public void setFrameRate(double frameRate) { si.setFrameRate(frameRate); }\n        public boolean isTriggerMode() { return si.isTriggerMode(); }\n        public void setTriggerMode(boolean triggerMode) { si.setTriggerMode(triggerMode); }\n        public int getBitsPerPixel() { return si.getBitsPerPixel(); }\n        public void setBitsPerPixel(int bitsPerPixel) { si.setBitsPerPixel(bitsPerPixel); }\n        public FrameGrabber.ImageMode getImageMode() { return si.getImageMode(); }\n        public void setImageMode(FrameGrabber.ImageMode imageMode) { si.setImageMode(imageMode); }\n        public int getTimeout() { return si.getTimeout(); }\n        public void setTimeout(int timeout) { si.setTimeout(timeout); }\n        public int getNumBuffers() { return si.getNumBuffers(); }\n        public void setNumBuffers(int numBuffers) { si.setNumBuffers(numBuffers); }\n        public boolean isDeinterlace() { return si.isDeinterlace(); }\n        public void setDeinterlace(boolean deinterlace) { si.setDeinterlace(deinterlace); }\n    }\n\n    private Settings settings;\n    @Override public ProjectiveDevice.Settings getSettings() {\n        return (ProjectiveDevice.Settings)settings;\n    }\n    public void setSettings(Settings settings) {\n        setSettings((ProjectiveDevice.Settings)settings);\n    }\n    @Override public void setSettings(ProjectiveDevice.Settings settings) {\n        super.setSettings(settings);\n        if (settings instanceof ProjectiveDevice.CalibrationSettings) {\n            this.settings = new CalibrationSettings((ProjectiveDevice.CalibrationSettings)settings);\n        } else if (settings instanceof ProjectiveDevice.CalibratedSettings) {\n            this.settings = new CalibratedSettings((ProjectiveDevice.CalibratedSettings)settings);\n        } else {\n            this.settings = new SettingsImplementation((ProjectiveDevice.Settings)settings);\n        }\n        if (this.settings.getName() == null || this.settings.getName().length() == 0) {\n            this.settings.setName(\"Camera \" + String.format(\"%2d\", this.settings.getDeviceNumber()));\n        }\n    }\n\n    public FrameGrabber createFrameGrabber() throws FrameGrabber.Exception {\n        try {\n            settings.getFrameGrabber().getMethod(\"tryLoad\").invoke(null);\n            FrameGrabber f;\n            if (settings.getDeviceFile() != null) {\n                f = settings.getFrameGrabber().getConstructor(File.class).newInstance(settings.getDeviceFile());\n            } else if (settings.getDevicePath() != null && settings.getDevicePath().length() > 0) {\n                f = settings.getFrameGrabber().getConstructor(String.class).newInstance(settings.getDevicePath());\n            } else {\n                int number = settings.getDeviceNumber() == null ? 0 : settings.getDeviceNumber();\n                try {\n                    f = settings.getFrameGrabber().getConstructor(int.class).newInstance(number);\n                } catch (NoSuchMethodException e) {\n                    f = settings.getFrameGrabber().getConstructor(Integer.class).newInstance(number);\n                }\n            }\n            f.setFormat(settings.getFormat());\n            f.setImageWidth(settings.getImageWidth());\n            f.setImageHeight(settings.getImageHeight());\n            f.setFrameRate(settings.getFrameRate());\n            f.setTriggerMode(settings.isTriggerMode());\n            f.setBitsPerPixel(settings.getBitsPerPixel());\n            f.setImageMode(settings.getImageMode());\n            f.setTimeout(settings.getTimeout());\n            f.setNumBuffers(settings.getNumBuffers());\n            f.setGamma(settings.getResponseGamma());\n            f.setDeinterlace(settings.isDeinterlace());\n            return f;\n        } catch (Throwable t) {\n            if (t instanceof InvocationTargetException) {\n                t = ((InvocationTargetException)t).getCause();\n            }\n            if (t instanceof FrameGrabber.Exception) {\n                throw (FrameGrabber.Exception)t;\n            } else {\n                throw new FrameGrabber.Exception(\"Failed to create \" + settings.getFrameGrabber(), t);\n            }\n        }\n    }\n\n    public static CameraDevice[] read(String filename) throws Exception {\n        FileStorage fs = new FileStorage(filename, FileStorage.READ);\n        CameraDevice[] devices = read(fs);\n        fs.release();\n        return devices;\n    }\n    public static CameraDevice[] read(FileStorage fs) throws Exception {\n        FileNode node = fs.get(\"Cameras\");\n        FileNodeIterator seq = node.begin();\n        int count = (int)seq.remaining();\n\n        CameraDevice[] devices = new CameraDevice[count];\n        for (int i = 0; i < count; i++, seq.increment()) {\n            FileNode n = seq.multiply();\n            if (n.empty()) continue;\n            String name = n.asBytePointer().getString();\n            devices[i] = new CameraDevice(name, fs);\n        }\n        return devices;\n    }\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\npublic class CaptureCamera {\n\n    public static void main(String[] args) {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n\n        VideoCapture cap = new VideoCapture(0);\n\n        if (!cap.isOpened())\n            System.out.println(\"error cannot any open camera\");\n        else\n            System.out.println(\"found webcam: \" + cap.toString());\n\n        Mat matFrame = new Mat();\n\n\n        cap.grab(); // First frame maybe empty frame so skip it\n        cap.grab();\n\n\n        cap.retrieve(matFrame);\n\n\n        Imshow ims = new Imshow(\"From Camera ....\");\n        ims.showImage(matFrame);\n\n\n        cap.release();\n\n    }\n}\n", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\npublic class Marker implements Cloneable {\n    public Marker(int id, double[] corners, double confidence) {\n        this.id = id;\n        this.corners = corners;\n        this.confidence = confidence;\n    }\n    public Marker(int id, double ... corners) {\n        this(id, corners, 1.0);\n    }\n    @Override public Marker clone() {\n        return new Marker(id, corners.clone(), confidence);\n    }\n    public int id;\n    public double[] corners;\n    public double confidence;\n\n    @Override public int hashCode() {\n        int hash = 7;\n        hash = 37 * hash + this.id;\n        hash = 37 * hash + (this.corners != null ? this.corners.hashCode() : 0);\n        return hash;\n    }\n    @Override public boolean equals(Object o) {\n        if (o instanceof Marker) {\n            Marker m = (Marker)o;\n            return m.id == id && Arrays.equals(m.corners, corners);\n        }\n        return false;\n    }\n\n    public double[] getCenter() {\n        double x = 0, y = 0;\nif (true) {\n        for (int i = 0; i < 4; i++) {\n            x += corners[2*i  ];\n            y += corners[2*i+1];\n        }\n        x /= 4;\n        y /= 4;\n} else {\n        double x1 = corners[0]; double y1 = corners[1];\n        double x2 = corners[4]; double y2 = corners[5];\n        double x3 = corners[2]; double y3 = corners[3];\n        double x4 = corners[6]; double y4 = corners[7];\n\n        double u = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3))/\n                   ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));\n        x = x1 + u*(x2-x1);\n        y = y1 + u*(y2-y1);\n}\n        return new double[] { x, y };\n    }\n\n    public IplImage getImage() {\n        return getImage(id);\n    }\n\n    private static IplImage imageCache[] = new IplImage[4096];\n    public static IplImage getImage(int id) {\n        if (imageCache[id] == null) {\n            imageCache[id] = IplImage.create(8, 8, IPL_DEPTH_8U, 1);\n            createImagePatternBCH(id, imageCache[id].getByteBuffer());\n        }\n        return imageCache[id];\n    }\n\n    private static final double[] src = { 0, 0, 8, 0, 8, 8, 0, 8 };\n    public void draw(IplImage image) {\n        draw(image, CvScalar.BLACK, 1, null);\n    }\n    public void draw(IplImage image, CvScalar color, double scale, CvMat prewarp) {\n        draw(image, color, scale, scale, prewarp);\n    }\n    private static ThreadLocal<CvMat>\n            H3x3      = CvMat.createThreadLocal(3, 3),\n            srcPts4x1 = CvMat.createThreadLocal(4, 1, CV_64F, 2),\n            dstPts4x1 = CvMat.createThreadLocal(4, 1, CV_64F, 2);\n    public void draw(IplImage image, CvScalar color, double scaleX, double scaleY, CvMat prewarp) {\n        CvMat H = H3x3.get();\n        JavaCV.getPerspectiveTransform(src, corners, H);\n        if (prewarp != null) {\n            cvGEMM(prewarp, H, 1, null, 0, H, 0);\n        }\n        IplImage  marker = getImage();\n        ByteBuffer  mbuf = marker.getByteBuffer();\n        CvMat     srcPts = srcPts4x1.get();\n        CvMat     dstPts = dstPts4x1.get();\n        CvPoint  tempPts = new CvPoint(4);\n\n        int h = marker.height();\n        int w = marker.width();\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (mbuf.get(y*w + x) == 0) {\n                    srcPts.put((double)x, y,  x+1, y,  x+1, y+1,  x, y+1);\n                    cvPerspectiveTransform(srcPts, dstPts, H);\n\n                    double centerx = 0, centery = 0;\n                    for (int i = 0; i < 4; i++) {\n                      centerx += dstPts.get(i*2  );\n                      centery += dstPts.get(i*2+1);\n                    }\n                    centerx /= 4;\n                    centery /= 4;\n                    for (int i = 0; i < 4; i++) {\n                        double a = dstPts.get(i*2  );\n                        double b = dstPts.get(i*2+1);\n                        double dx = centerx - a;\n                        double dy = centery - b;\n                        dx = dx < 0 ? -1 : 0;\n                        dy = dy < 0 ? -1 : 0;\n                        tempPts.position(i).x((int)Math.round((a*scaleX + dx) * (1<<16)));\n                        tempPts.position(i).y((int)Math.round((b*scaleY + dy) * (1<<16)));\n                    }\n                    cvFillConvexPoly(image, tempPts.position(0), 4, color, 8, 16);\n                }\n            }\n        }\n    }\n\n    public static class ArraySettings extends BaseChildSettings {\n        int rows = 8, columns = 12;\n        double sizeX = 200, sizeY = 200, spacingX = 300, spacingY = 300;\n        boolean checkered = true;\n\n        public int getRows() {\n            return rows;\n        }\n        public void setRows(int rows) {\n            firePropertyChange(\"rows\", this.rows, this.rows = rows);\n        }\n\n        public int getColumns() {\n            return columns;\n        }\n        public void setColumns(int columns) {\n            firePropertyChange(\"columns\", this.columns, this.columns = columns);\n        }\n\n        public double getSizeX() {\n            return sizeX;\n        }\n        public void setSizeX(double sizeX) {\n            firePropertyChange(\"sizeX\", this.sizeX, this.sizeX = sizeX);\n        }\n        public double getSizeY() {\n            return sizeY;\n        }\n        public void setSizeY(double sizeY) {\n            firePropertyChange(\"sizeY\", this.sizeY, this.sizeY = sizeY);\n        }\n\n        public double getSpacingX() {\n            return spacingX;\n        }\n        public void setSpacingX(double spacingX) {\n            firePropertyChange(\"spacingX\", this.spacingX, this.spacingX = spacingX);\n        }\n        public double getSpacingY() {\n            return spacingY;\n        }\n        public void setSpacingY(double spacingY) {\n            firePropertyChange(\"spacingY\", this.spacingY, this.spacingY = spacingY);\n        }\n\n        public boolean isCheckered() {\n            return checkered;\n        }\n        public void setCheckered(boolean checkered) {\n            firePropertyChange(\"checkered\", this.checkered, this.checkered = checkered);\n        }\n    }\n    public static Marker[][] createArray(ArraySettings settings) {\n        return createArray(settings, 0, 0);\n    }\n    public static Marker[][] createArray(ArraySettings settings, double marginx, double marginy) {\n        Marker[] markers = new Marker[settings.rows*settings.columns];\n        int id = 0;\n        for (int y = 0; y < settings.rows; y++) {\n            for (int x = 0; x < settings.columns; x++) {\n                double sx =   settings.sizeX/2;\n                double sy =   settings.sizeY/2;\n                double cx = x*settings.spacingX + sx + marginx;\n                double cy = y*settings.spacingY + sy + marginy;\n                markers[id] = new Marker(id, new double[] {\n                    cx-sx, cy-sy,  cx+sx, cy-sy,  cx+sx, cy+sy,  cx-sx, cy+sy }, 1);\n                id++;\n            }\n        }\n        if (!settings.checkered) {\n            return new Marker[][] { markers };\n        } else {\n            Marker[] markers1 = new Marker[markers.length/2];\n            Marker[] markers2 = new Marker[markers.length/2];\n            for (int i = 0; i < markers.length; i++) {\n                int x = i%settings.columns;\n                int y = i/settings.columns;\n                if (x%2==0 ^ y%2==0) {\n                    markers2[i/2] = markers[i];\n                } else {\n                    markers1[i/2] = markers[i];\n                }\n            }\n            return new Marker[][] { markers2, markers1 };\n        }\n    }\n    public static Marker[][] createArray(int rows, int columns, double sizeX, double sizeY,\n            double spacingX, double spacingY, boolean checkered, double marginx, double marginy) {\n        ArraySettings s = new ArraySettings();\n        s.rows      = rows;      s.columns  = columns;\n        s.sizeX     = sizeX;     s.sizeY    = sizeY;\n        s.spacingX  = spacingX;  s.spacingY = spacingY;\n        s.checkered = checkered;\n        return createArray(s, marginx, marginy);\n    }\n\n    public static void applyWarp(Marker[] markers, CvMat warp) {\n        CvMat pts = srcPts4x1.get();\n\n        for (Marker m : markers) {\n            cvPerspectiveTransform(pts.put(m.corners), pts, warp);\n            pts.get(m.corners);\n        }\n    }\n\n    @Override public String toString() {\n        String s = \"[\" + id + \": \" +\n                \"(\" + corners[0] + \", \" + corners[1] + \") \" +\n                \"(\" + corners[2] + \", \" + corners[3] + \") \" +\n                \"(\" + corners[4] + \", \" + corners[5] + \") \" +\n                \"(\" + corners[6] + \", \" + corners[7] + \")]\";\n        return s;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\npublic class CaptureVideo {\n\n    public static void main(String[] args) throws InterruptedException {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n\n        VideoCapture cap = new VideoCapture();\n\n        \n        int CAM_TO_USE = 0;\n        \n        \n        Mat matFrame = new Mat();\n        \n        \n        try {\n        \tcap.open(CAM_TO_USE);\n        } catch (Exception e1) {\n            System.out.println(\"No webcam attached\");\n        \n            \n            try{\n            \tcap.open(\"files/video.mp4\");\n            } catch (Exception e2) {\n            \tSystem.out.println(\"No video file found\");\n            }\n        }\n        \n        \n        if (cap.isOpened())\n        {\n\n            \n            Imshow ims = new Imshow(\"From video source ... \");\n        \t\n        \tboolean keepProcessing = true;\n        \t\n        \twhile (keepProcessing)\n        \t{\t\n\n        \t\tcap.grab();\n\n\n            \tcap.retrieve(matFrame);\n\n            \t\n            \tif (!(matFrame.empty()))\n            \t{\n            \t\t\n\n            \t\tims.showImage(matFrame);\n            \t\tThread.sleep(40);\n            \t} else { \n            \t\tkeepProcessing = false;\n        \t\t}\n        \t}\n\n        } else {\n            System.out.println(\"error cannot open any capture source - exiting\");\n        }\n\n\n        cap.release();\n        \n    }\n}\n", "nl": "opencv"}
{"code": "\n\n\n\npublic class Filters {\n\n\t\n\tpublic static Mat SimplestColorBalance(Mat img, int percent) {\n\t\tif (percent <= 0)\n\t\t\tpercent = 5;\n\t\timg.convertTo(img, CvType.CV_32F);\n\t\tList<Mat> channels = new ArrayList<>();\n\t\tint rows = img.rows(); // number of rows of image\n\t\tint cols = img.cols(); // number of columns of image\n\t\tint chnls = img.channels(); //  number of channels of image\n\t\tdouble halfPercent = percent / 200.0;\n\t\tif (chnls == 3) Core.split(img, channels);\n\t\telse channels.add(img);\n\t\tList<Mat> results = new ArrayList<>();\n\t\tfor (int i = 0; i < chnls; i++) {\n\t\t\tMat flat = new Mat();\n\t\t\tchannels.get(i).reshape(1, 1).copyTo(flat);\n\t\t\tCore.sort(flat, flat, Core.SORT_ASCENDING);\n\t\t\tdouble lowVal = flat.get(0, (int) Math.floor(flat.cols() * halfPercent))[0];\n\t\t\tdouble topVal = flat.get(0, (int) Math.ceil(flat.cols() * (1.0 - halfPercent)))[0];\n\t\t\tMat channel = channels.get(i);\n\t\t\tfor (int m = 0; m < rows; m++) {\n\t\t\t\tfor (int n = 0; n < cols; n++) {\n\t\t\t\t\tif (channel.get(m, n)[0] < lowVal) channel.put(m, n, lowVal);\n\t\t\t\t\tif (channel.get(m, n)[0] > topVal) channel.put(m, n, topVal);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCore.normalize(channel, channel, 0.0, 255.0 / 2, Core.NORM_MINMAX);\n\t\t\tchannel.convertTo(channel, CvType.CV_32F);\n\t\t\tresults.add(channel);\n\t\t}\n\t\tMat outval = new Mat();\n\t\tCore.merge(results, outval);\n\t\treturn outval;\n\t}\n\n\t\n\tpublic static Mat GuidedImageFilter(Mat I, Mat p, int r, double eps) {\n\t\tI.convertTo(I, CvType.CV_64FC1);\n\t\tp.convertTo(p, CvType.CV_64FC1);\n\t\tint rows = I.rows();\n\t\tint cols = I.cols();\n\t\tMat N = new Mat();\n\t\tImgproc.boxFilter(Mat.ones(rows, cols, I.type()), N, -1, new Size(r, r));\n\t\tMat mean_I = new Mat();\n\t\tImgproc.boxFilter(I, mean_I, -1, new Size(r, r));\n\t\tMat mean_p = new Mat();\n\t\tImgproc.boxFilter(p, mean_p, -1, new Size(r, r));\n\t\tMat mean_Ip = new Mat();\n\t\tImgproc.boxFilter(I.mul(p), mean_Ip, -1, new Size(r, r));\n\t\tMat cov_Ip = new Mat();\n\t\tCore.subtract(mean_Ip, mean_I.mul(mean_p), cov_Ip);\n\t\tMat mean_II = new Mat();\n\t\tImgproc.boxFilter(I.mul(I), mean_II, -1, new Size(r, r));\n\t\tMat var_I = new Mat();\n\t\tCore.subtract(mean_II, mean_I.mul(mean_I), var_I);\n\t\tMat a = new Mat();\n\t\tCore.add(var_I, new Scalar(eps), a);\n\t\tCore.divide(cov_Ip, a, a);\n\t\tMat b = new Mat();\n\t\tCore.subtract(mean_p, a.mul(mean_I), b);\n\t\tMat mean_a = new Mat();\n\t\tImgproc.boxFilter(a, mean_a, -1, new Size(r, r));\n\t\tCore.divide(mean_a, N, mean_a);\n\t\tMat mean_b = new Mat();\n\t\tImgproc.boxFilter(b, mean_b, -1, new Size(r, r));\n\t\tCore.divide(mean_b, N, mean_b);\n\t\tMat q = new Mat();\n\t\tCore.add(mean_a.mul(I), mean_b, q);\n\t\tq.convertTo(q, CvType.CV_32F);\n\t\treturn q;\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unused\")\n\tpublic static Mat GuidedImageFilter_Color(Mat origI, Mat p, int r, double eps, double s, int depth) {\n\t\tArrayList<Mat> Ichannels = new ArrayList<>();\n\t\tArrayList<Mat> Isubchannels = new ArrayList<>();\n\t\tint Idepth;\n\t\tdouble r_sub;\n\t\tMat mean_I_r;\n\t\tMat mean_I_g;\n\t\tMat mean_I_b;\n\t\tMat invrr = new Mat();\n\t\tMat invrg = new Mat();\n\t\tMat invrb = new Mat();\n\t\tMat invgg = new Mat();\n\t\tMat invgb = new Mat();\n\t\tMat invbb = new Mat();\n\t\tMat I;\n\t\tif (origI.depth() == CvType.CV_32F || origI.depth() == CvType.CV_64F) {\n\t\t\tI = origI.clone();\n\t\t} else {\n\t\t\tI = convertTo(origI, CvType.CV_32F);\n\t\t}\n\t\tIdepth = I.depth();\n\t\tCore.split(I, Ichannels);\n\t\tMat I_sub = new Mat();\n\t\tImgproc.resize(I, I_sub, new Size(I.cols() / s, I.rows() / s), 0.0, 0.0, Imgproc.INTER_NEAREST);\n\t\tCore.split(I_sub, Isubchannels);\n\t\tr_sub = r / s;\n\t\tmean_I_r = boxfilter(Isubchannels.get(0), (int) r_sub);\n\t\tmean_I_g = boxfilter(Isubchannels.get(1), (int) r_sub);\n\t\tmean_I_b = boxfilter(Isubchannels.get(2), (int) r_sub);\n\n\t\tMat var_I_rr = new Mat();\n\t\tMat var_I_rg = new Mat();\n\t\tMat var_I_rb = new Mat();\n\t\tMat var_I_gg = new Mat();\n\t\tMat var_I_gb = new Mat();\n\t\tMat var_I_bb = new Mat();\n\t\tMat temp1 = new Mat();\n\n\t\tCore.subtract(boxfilter(Isubchannels.get(0).mul(Isubchannels.get(0)), (int) r_sub), \n\t\t\t\tmean_I_r.mul(mean_I_r), temp1);\n\t\tCore.add(temp1, new Scalar(eps), var_I_rr);\n\t\tCore.subtract(boxfilter(Isubchannels.get(0).mul(Isubchannels.get(1)), (int) r_sub), \n\t\t\t\tmean_I_r.mul(mean_I_g), var_I_rg);\n\t\tCore.subtract(boxfilter(Isubchannels.get(0).mul(Isubchannels.get(2)), (int) r_sub), \n\t\t\t\tmean_I_r.mul(mean_I_b), var_I_rb);\n\t\tCore.subtract(boxfilter(Isubchannels.get(1).mul(Isubchannels.get(1)), (int) r_sub), \n\t\t\t\tmean_I_g.mul(mean_I_g), temp1);\n\t\tCore.add(temp1, new Scalar(eps), var_I_gg);\n\t\tCore.subtract(boxfilter(Isubchannels.get(1).mul(Isubchannels.get(2)), (int) r_sub), \n\t\t\t\tmean_I_g.mul(mean_I_b), var_I_gb);\n\t\tCore.subtract(boxfilter(Isubchannels.get(2).mul(Isubchannels.get(2)), (int) r_sub), \n\t\t\t\tmean_I_b.mul(mean_I_b), temp1);\n\t\tCore.add(temp1, new Scalar(eps), var_I_bb);\n\n\t\tCore.subtract(var_I_gg.mul(var_I_bb), var_I_gb.mul(var_I_gb), invrr);\n\t\tCore.subtract(var_I_gb.mul(var_I_rb), var_I_rg.mul(var_I_bb), invrg);\n\t\tCore.subtract(var_I_rg.mul(var_I_gb), var_I_gg.mul(var_I_rb), invrb);\n\t\tCore.subtract(var_I_rr.mul(var_I_bb), var_I_rb.mul(var_I_rb), invgg);\n\t\tCore.subtract(var_I_rb.mul(var_I_rg), var_I_rr.mul(var_I_gb), invgb);\n\t\tCore.subtract(var_I_rr.mul(var_I_gg), var_I_rg.mul(var_I_rg), invbb);\n\n\t\tMat covDet = new Mat();\n\t\tCore.add(invrr.mul(var_I_rr), invrg.mul(var_I_rg), temp1);\n\t\tCore.add(temp1, invrb.mul(var_I_rb), covDet);\n\n\t\tCore.divide(invrr, covDet, invrr);\n\t\tCore.divide(invrg, covDet, invrg);\n\t\tCore.divide(invrb, covDet, invrb);\n\t\tCore.divide(invgg, covDet, invgg);\n\t\tCore.divide(invgb, covDet, invgb);\n\t\tCore.divide(invbb, covDet, invbb);\n\n\t\tMat p2 = convertTo(p, Idepth);\n\t\tMat result = new Mat();\n\t\tif (p.channels() == 1) {\n\t\t\tresult = filterSingleChannel(p2, s, Isubchannels, Ichannels, mean_I_r, mean_I_g, mean_I_b, invrr, invrg, \n\t\t\t\t\tinvrb, invgg, invgb, invbb, r_sub);\n\t\t} else {\n\t\t\tArrayList<Mat> pc = new ArrayList<>();\n\t\t\tCore.split(p2, pc);\n\t\t\tfor (int i = 0; i < pc.size(); i++) {\n\t\t\t\tpc.set(i, filterSingleChannel(pc.get(i), s, Isubchannels, Ichannels, mean_I_r, mean_I_g, mean_I_b, invrr, \n\t\t\t\t\t\tinvrg, invrb, invgg, invgb, invbb, r_sub));\n\t\t\t}\n\t\t\tCore.merge(pc, result);\n\t\t}\n\t\treturn convertTo(result, depth == -1 ? p.depth() : depth);\n\t}\n\t\n\tprivate static Mat boxfilter(Mat I, int r) {\n\t\tMat result = new Mat();\n\t\tImgproc.blur(I, result, new Size(r, r));\n\t\treturn result;\n\t}\n\n\tprivate static Mat convertTo(Mat mat, int depth) {\n\t\tif (mat.depth() == depth) {\n\t\t\treturn mat;\n\t\t}\n\t\tMat result = new Mat();\n\t\tmat.convertTo(result, depth);\n\t\treturn result;\n\t}\n\n\tprivate static Mat filterSingleChannel(Mat p, double s, ArrayList<Mat> Isubchannels, ArrayList<Mat> Ichannels, \n\t\t\tMat mean_I_r, Mat mean_I_g, Mat mean_I_b, Mat invrr, Mat invrg, Mat invrb, Mat invgg, Mat invgb, \n\t\t\tMat invbb, double r_sub) {\n\t\tMat p_sub = new Mat();\n\t\tImgproc.resize(p, p_sub, new Size(p.cols() / s, p.rows() / s), 0.0, 0.0, Imgproc.INTER_NEAREST);\n\n\t\tMat mean_p = boxfilter(p_sub, (int) r_sub);\n\n\t\tMat mean_Ip_r = boxfilter(Isubchannels.get(0).mul(p_sub), (int) r_sub);\n\t\tMat mean_Ip_g = boxfilter(Isubchannels.get(1).mul(p_sub), (int) r_sub);\n\t\tMat mean_Ip_b = boxfilter(Isubchannels.get(2).mul(p_sub), (int) r_sub);\n\n\t\tMat cov_Ip_r = new Mat();\n\t\tMat cov_Ip_g = new Mat();\n\t\tMat cov_Ip_b = new Mat();\n\t\tCore.subtract(mean_Ip_r, mean_I_r.mul(mean_p), cov_Ip_r);\n\t\tCore.subtract(mean_Ip_g, mean_I_g.mul(mean_p), cov_Ip_g);\n\t\tCore.subtract(mean_Ip_b, mean_I_b.mul(mean_p), cov_Ip_b);\n\n\t\tMat temp1 = new Mat();\n\t\tMat a_r = new Mat();\n\t\tMat a_g = new Mat();\n\t\tMat a_b = new Mat();\n\t\tCore.add(invrr.mul(cov_Ip_r), invrg.mul(cov_Ip_g), temp1);\n\t\tCore.add(temp1, invrb.mul(cov_Ip_b), a_r);\n\t\tCore.add(invrg.mul(cov_Ip_r), invgg.mul(cov_Ip_g), temp1);\n\t\tCore.add(temp1, invgb.mul(cov_Ip_b), a_g);\n\t\tCore.add(invrb.mul(cov_Ip_r), invgb.mul(cov_Ip_g), temp1);\n\t\tCore.add(temp1, invbb.mul(cov_Ip_b), a_b);\n\n\t\tMat b = new Mat();\n\t\tCore.subtract(mean_p, a_r.mul(mean_I_r), b);\n\t\tCore.subtract(b, a_g.mul(mean_I_g), b);\n\t\tCore.subtract(b, a_b.mul(mean_I_b), b);\n\n\t\tMat mean_a_r = boxfilter(a_r, (int) r_sub);\n\t\tMat mean_a_g = boxfilter(a_g, (int) r_sub);\n\t\tMat mean_a_b = boxfilter(a_b, (int) r_sub);\n\t\tMat mean_b = boxfilter(b, (int) r_sub);\n\n\t\tImgproc.resize(mean_a_r, mean_a_r, \n\t\t\t\tnew Size(Ichannels.get(0).cols(), Ichannels.get(0).rows()), 0.0, 0.0, Imgproc.INTER_LINEAR);\n\t\tImgproc.resize(mean_a_g, mean_a_g, \n\t\t\t\tnew Size(Ichannels.get(0).cols(), Ichannels.get(0).rows()), 0.0, 0.0, Imgproc.INTER_LINEAR);\n\t\tImgproc.resize(mean_a_b, mean_a_b, \n\t\t\t\tnew Size(Ichannels.get(0).cols(), Ichannels.get(0).rows()), 0.0, 0.0, Imgproc.INTER_LINEAR);\n\t\tImgproc.resize(mean_b, mean_b, \n\t\t\t\tnew Size(Ichannels.get(0).cols(), Ichannels.get(0).rows()), 0.0, 0.0, Imgproc.INTER_LINEAR);\n\n\t\tMat result = new Mat();\n\t\tCore.add(mean_a_r.mul(Ichannels.get(0)), mean_a_g.mul(Ichannels.get(1)), temp1);\n\t\tCore.add(temp1, mean_a_b.mul(Ichannels.get(2)), temp1);\n\t\tCore.add(temp1, mean_b, result);\n\t\treturn result;\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class ApplicationTests {\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void loginWithValidUserThenAuthenticated() throws Exception {\n        FormLoginRequestBuilder login = formLogin()\n            .user(\"user\")\n            .password(\"password\");\n\n        mockMvc.perform(login)\n            .andExpect(authenticated().withUsername(\"user\"));\n    }\n\n    @Test\n    public void loginWithInvalidUserThenUnauthenticated() throws Exception {\n        FormLoginRequestBuilder login = formLogin()\n            .user(\"invalid\")\n            .password(\"invalidpassword\");\n\n        mockMvc.perform(login)\n            .andExpect(unauthenticated());\n    }\n\n    @Test\n    public void accessUnsecuredResourceThenOk() throws Exception {\n        mockMvc.perform(get(\"/\"))\n            .andExpect(status().isOk());\n    }\n\n    @Test\n    public void accessSecuredResourceUnauthenticatedThenRedirectsToLogin() throws Exception {\n        mockMvc.perform(get(\"/hello\"))\n            .andExpect(status().is3xxRedirection())\n            .andExpect(redirectedUrlPattern(\"/login\"));\n    }\n\n    @Test\n    @WithMockUser\n    public void accessSecuredResourceAuthenticatedThenOk() throws Exception {\n        mockMvc.perform(get(\"/hello\"))\n                .andExpect(status().isOk());\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class GrayscaleEffect extends Effect {\n\n\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat();\n\t\tImgproc.cvtColor(frame, newFrame, Imgproc.COLOR_RGBA2GRAY);\n\t\tImgproc.cvtColor(newFrame, newFrame, Imgproc.COLOR_GRAY2RGBA);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Grayscale\";\n\t}\n}", "nl": "opencv"}
{"code": "    \n\n\n\n\n\n\n\n@Component\npublic class NoteResourceAssembler extends ResourceAssemblerSupport<Note, NoteResource> {\n\n\tpublic NoteResourceAssembler() {\n\t\tsuper(NotesController.class, NoteResource.class);\n\t}\n\n\t@Override\n\tpublic NoteResource toResource(Note note) {\n\t\tNoteResource resource = createResourceWithId(note.getId(), note);\n\t\tresource.add(linkTo(NotesController.class).slash(note.getId()).slash(\"tags\")\n\t\t\t\t.withRel(\"note-tags\"));\n\t\treturn resource;\n\t}\n\n\t@Override\n\tprotected NoteResource instantiateResource(Note entity) {\n\t\treturn new NoteResource(entity);\n\t}\n\n\tstatic class NoteResource extends Resource<Note> {\n\n\t\tpublic NoteResource(Note content) {\n\t\t\tsuper(content);\n\t\t}\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class AddingTextToImage extends Application {\n   Mat matrix = null;\n\n   @Override\n   public void start(Stage stage) throws Exception {\n      AddingTextToImage obj = new AddingTextToImage();\n      WritableImage writableImage = obj.LoadImage();\n\n      ImageView imageView = new ImageView(writableImage);\n\n      imageView.setFitHeight(600);\n      imageView.setFitWidth(600);\n\n      imageView.setPreserveRatio(true);\n\n      Group root = new Group(imageView);\n\n      Scene scene = new Scene(root, 600, 400);\n\n      stage.setTitle(\"Adding text to an image\");\n\n      stage.setScene(scene);\n\n      stage.show();\n   }\n   public WritableImage LoadImage() throws Exception {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap8/input.jpg\";\n      Mat matrix = Imgcodecs.imread(file);\n\n      Imgproc.putText (\n         matrix,                          // Matrix obj of the image\n         \"Ravivarma's Painting\",          // Text to be added\n         new Point(10, 50),               // point\n         Core.FONT_HERSHEY_SIMPLEX ,      // front face\n         1,                               // front scale\n         new Scalar(0, 0, 0),             // Scalar object for color\n         4                                // Thickness\n      );\n      \n      MatOfByte matOfByte = new MatOfByte();\n      Imgcodecs.imencode(\".jpg\", matrix, matOfByte);\n\n      byte[] byteArray = matOfByte.toArray();\n\n      InputStream in = new ByteArrayInputStream(byteArray);\n      BufferedImage bufImage = ImageIO.read(in);\n      this.matrix = matrix;\n\n      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);\n      return writableImage;\n   }\n   public static void main(String args[]) {\n      launch(args);\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class faceDetectionJavaFXX extends Application {\n   Mat matrix = null;\n\n   @Override\n   public void start(Stage stage) throws FileNotFoundException, IOException {\n      faceDetectionJavaFXX obj = new faceDetectionJavaFXX();\n      WritableImage writableImage = obj.capureFrame();\n\n      obj.saveImage();\n\n      ImageView imageView = new ImageView(writableImage);\n\n      imageView.setFitHeight(400);\n      imageView.setFitWidth(600);\n\n      imageView.setPreserveRatio(true);\n\n      Group root = new Group(imageView);\n\n      Scene scene = new Scene(root, 600, 400);\n\n      stage.setTitle(\"Capturing an image\");\n\n      stage.setScene(scene);\n\n      stage.show();\n   }\n   public WritableImage capureFrame() {\n      WritableImage writableImage = null;\n\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      VideoCapture capture = new VideoCapture(0);\n\n      Mat matrix = new Mat();\n      capture.read(matrix);\n\n      if(!capture.isOpened()) {\n         System.out.println(\"camera not detected\");\n      } else\n         System.out.println(\"Camera detected \");\n           \n      if (capture.read(matrix)) {\n         String file = \"E:/OpenCV/facedetect/lbpcascade_frontalface.xml\";\n         CascadeClassifier classifier = new CascadeClassifier(file);\n\n         MatOfRect faceDetections = new MatOfRect();\n         classifier.detectMultiScale(matrix, faceDetections);\n         System.out.println(String.format(\"Detected %s faces\",\n            faceDetections.toArray().length));\n\n         for (Rect rect : faceDetections.toArray()) {\n            Imgproc.rectangle(\n               matrix,                                   //where to draw the box\n               new Point(rect.x, rect.y),                            //bottom left\n               new Point(rect.x + rect.width, rect.y + rect.height), //top right\n               new Scalar(0, 0, 255)                                 //RGB colour\n            );\n         }\n         BufferedImage image = new BufferedImage(matrix.width(), matrix.height(),\n            BufferedImage.TYPE_3BYTE_BGR);\n         \n         WritableRaster raster = image.getRaster();\n         DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();\n         byte[] data = dataBuffer.getData();\n         matrix.get(0, 0, data);\n\n         this.matrix = matrix;\n           \n         writableImage = SwingFXUtils.toFXImage(image, null);\n      }\n      return writableImage;\n   }\n   public void saveImage() {\n      String file = \"E:/OpenCV/chap23/facedetected.jpg\";\n\n      Imgcodecs imageCodecs = new Imgcodecs();\n\n      imageCodecs.imwrite(file, matrix);\n   }\n   public static void main(String args[]) {\n      launch(args);\n   }\n}\n", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class MarkedPlane {\n\n    public MarkedPlane(int width, int height, Marker[] planeMarkers, double superScale) {\n        this(width, height, planeMarkers, false, CvScalar.BLACK, CvScalar.WHITE, superScale);\n    }\n    public MarkedPlane(int width, int height, Marker[] markers,\n            boolean initPrewarp, CvScalar foregroundColor, CvScalar backgroundColor, double superScale) {\n        this.markers = markers;\n        this.foregroundColor = foregroundColor;\n        this.backgroundColor = backgroundColor;\n\n\n        this.prewarp = null;\n\n        if (initPrewarp) {\n            prewarp = CvMat.create(3, 3);\n            double minx = Double.MAX_VALUE, miny = Double.MAX_VALUE,\n                   maxx = Double.MIN_VALUE, maxy = Double.MIN_VALUE;\n            for (Marker m : markers) {\n                double[] c = m.corners;\n                minx = Math.min(Math.min(Math.min(Math.min(minx, c[0]), c[2]), c[4]), c[6]);\n                miny = Math.min(Math.min(Math.min(Math.min(miny, c[1]), c[3]), c[5]), c[7]);\n                maxx = Math.max(Math.max(Math.max(Math.max(maxx, c[0]), c[2]), c[4]), c[6]);\n                maxy = Math.max(Math.max(Math.max(Math.max(maxy, c[1]), c[3]), c[5]), c[7]);\n            }\n            double aspect = (maxx-minx)/(maxy-miny);\n            if (aspect > (double)width/height) {\n                double h = (double)width/aspect;\n                JavaCV.getPerspectiveTransform(\n                        new double[] { minx, miny, maxx, miny, maxx, maxy, minx, maxy },\n                        new double[] { 0, height-h, width, height-h, width, height, 0, height }, prewarp);\n            } else {\n                double w = height*aspect;\n                JavaCV.getPerspectiveTransform(\n                        new double[] { minx, miny, maxx, miny, maxx, maxy, minx, maxy },\n                        new double[] { 0, 0, w, 0, w, height, 0, height }, prewarp);\n            }\n        }\n\n        if (width > 0 && height > 0) {\n            planeImage = IplImage.create(width, height, IPL_DEPTH_8U, 1);\n            if (superScale == 1.0) {\n                superPlaneImage = null;\n            } else {\n                superPlaneImage = IplImage.create((int)Math.ceil(width*superScale),\n                        (int)Math.ceil(height*superScale), IPL_DEPTH_8U, 1);\n            }\n            setPrewarp(prewarp);\n        }\n\n        localSrcPts = CvMat.createThreadLocal(markers.length*4, 2);\n        localDstPts = CvMat.createThreadLocal(markers.length*4, 2);\n    }\n\n    private Marker[] markers = null;\n    private CvMat prewarp;//, totalWarp, tempWarp;\n\n    private IplImage planeImage = null, superPlaneImage = null;\n    private CvScalar foregroundColor, backgroundColor;\n\n    private ThreadLocal<CvMat> localSrcPts, localDstPts;\n\n    public CvScalar getForegroundColor() {\n        return foregroundColor;\n    }\n    public void setForegroundColor(CvScalar foregroundColor) {\n        this.foregroundColor = foregroundColor;\n        setPrewarp(prewarp);\n    }\n\n    public CvScalar getBackgroundColor() {\n        return backgroundColor;\n    }\n    public void setBackgroundColor(CvScalar backgroundColor) {\n        this.backgroundColor = backgroundColor;\n        setPrewarp(prewarp);\n    }\n\n    public Marker[] getMarkers() {\n        return markers;\n    }\n    public void setColors(CvScalar foregroundColor, CvScalar backgroundColor) {\n        this.foregroundColor = foregroundColor;\n        this.backgroundColor = backgroundColor;\n        setPrewarp(prewarp);\n    }\n\n    public CvMat getPrewarp() {\n        return prewarp;\n    }\n    public void setPrewarp(CvMat prewarp) {\n        this.prewarp = prewarp;\n        if (superPlaneImage == null) {\n            cvSet(planeImage, backgroundColor);\n        } else {\n            cvSet(superPlaneImage, backgroundColor);\n        }\n        for (int i = 0; i < markers.length; i++) {\n            if (superPlaneImage == null) {\n                markers[i].draw(planeImage, foregroundColor, 1.0, prewarp);\n            } else {\n                markers[i].draw(superPlaneImage, foregroundColor, (double)\n                        superPlaneImage.width()/planeImage.width(), prewarp);\n            }\n        }\n        if (superPlaneImage != null) {\n            cvResize(superPlaneImage, planeImage, CV_INTER_AREA);\n        }\n    }\n\n    public IplImage getImage() {\n        return planeImage;\n    }\n    public int getWidth() {\n        return planeImage.width();\n    }\n    public int getHeight() {\n        return planeImage.height();\n    }\n\n    public double getTotalWarp(Marker[] imagedMarkers, CvMat totalWarp) {\n        return getTotalWarp(imagedMarkers, totalWarp, false);\n    }\n    private static ThreadLocal<CvMat>\n            tempWarp3x3 = CvMat.createThreadLocal(3, 3);\n    public double getTotalWarp(Marker[] imagedMarkers, CvMat totalWarp, boolean useCenters) {\n        double rmse = Double.POSITIVE_INFINITY;\n        int pointsPerMarker = useCenters ? 1 : 4;\n\n        CvMat srcPts = localSrcPts.get(); srcPts.rows(markers.length*pointsPerMarker);\n        CvMat dstPts = localDstPts.get(); dstPts.rows(markers.length*pointsPerMarker);\n\n        int numPoints = 0;\n        for (Marker m1 : markers) {\n            for (Marker m2 : imagedMarkers) {\n                if (m1.id == m2.id) {\n                    if (useCenters) {\n                        srcPts.put(numPoints*2, m1.getCenter());\n                        dstPts.put(numPoints*2, m2.getCenter());\n                    } else {\n                        srcPts.put(numPoints*2, m1.corners);\n                        dstPts.put(numPoints*2, m2.corners);\n                    }\n                    numPoints += pointsPerMarker;\n                    break;\n                }\n            }\n        }\n\n        if (numPoints > 4 || (srcPts.rows() == 4 && numPoints == 4)) {\n            srcPts.rows(numPoints); dstPts.rows(numPoints);\n            if (numPoints == 4) {\n                JavaCV.getPerspectiveTransform(srcPts.get(), dstPts.get(), totalWarp);\n            } else {\n                cvCopy(cvMat(findHomography(cvarrToMat(srcPts), cvarrToMat(dstPts))), totalWarp);\n            }\n\n            srcPts.cols(1); srcPts.type(CV_64F, 2);\n            dstPts.cols(1); dstPts.type(CV_64F, 2);\n            cvPerspectiveTransform(srcPts, srcPts, totalWarp);\n            srcPts.cols(2); srcPts.type(CV_64F, 1);\n            dstPts.cols(2); dstPts.type(CV_64F, 1);\n\n            rmse = 0;\n            for (int i = 0; i < numPoints; i++) {\n                double dx = dstPts.get(i*2  )-srcPts.get(i*2  );\n                double dy = dstPts.get(i*2+1)-srcPts.get(i*2+1);\n                rmse += dx*dx+dy*dy;\n            }\n            rmse = Math.sqrt(rmse/numPoints);\n\n            if (prewarp != null) {\n                CvMat tempWarp = tempWarp3x3.get();\n                cvInvert(prewarp, tempWarp);\n                cvMatMul(totalWarp, tempWarp, totalWarp);\n            }\n        }\n        return rmse;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@SuppressWarnings(\"all\")\npublic class ImShow {\n\n\tpublic JFrame Window;\n\tprivate ImageIcon image;\n\tprivate JLabel label;\n\tprivate Boolean SizeCustom;\n\tprivate int Height, Width;\n\n\tpublic ImShow(String title) {\n\t\tWindow = new JFrame();\n\t\timage = new ImageIcon();\n\t\tlabel = new JLabel();\n\t\tlabel.setIcon(image);\n\t\tWindow.getContentPane().add(label);\n\t\tWindow.setResizable(false);\n\t\tWindow.setTitle(title);\n\t\tSizeCustom = false;\n\t\tsetCloseOption(0);\n\t}\n\n\tpublic ImShow(String title, int height, int width) {\n\t\tSizeCustom = true;\n\t\tHeight = height;\n\t\tWidth = width;\n\t\tWindow = new JFrame();\n\t\timage = new ImageIcon();\n\t\tlabel = new JLabel();\n\t\tlabel.setIcon(image);\n\t\tWindow.getContentPane().add(label);\n\t\tWindow.setResizable(false);\n\t\tWindow.setTitle(title);\n\t\tsetCloseOption(0);\n\n\t}\n\n\tpublic void showImage(Mat img) {\n\t\tif (SizeCustom) {\n\t\t\tImgproc.resize(img, img, new Size(Height, Width));\n\t\t}\n\t\tBufferedImage bufImage = null;\n\t\ttry {\n\t\t\tbufImage = toBufferedImage(img);\n\t\t\timage.setImage(bufImage);\n\t\t\tWindow.pack();\n\t\t\tlabel.updateUI();\n\t\t\tWindow.setVisible(true);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\n\tpublic BufferedImage toBufferedImage(Mat m) {\n\t\tint type = BufferedImage.TYPE_BYTE_GRAY;\n\t\tif (m.channels() > 1) type = BufferedImage.TYPE_3BYTE_BGR;\n\t\tint bufferSize = m.channels() * m.cols() * m.rows();\n\t\tbyte[] b = new byte[bufferSize];\n\t\tm.get(0, 0, b); // get all the pixels\n\t\tBufferedImage image = new BufferedImage(m.cols(), m.rows(), type);\n\t\tfinal byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n\t\tSystem.arraycopy(b, 0, targetPixels, 0, b.length);\n\t\treturn image;\n\t}\n\n\n\tpublic void setCloseOption(int option) {\n\t\tswitch (option) {\n\t\tcase 0: Window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); break;\n\t\tcase 1: Window.setDefaultCloseOperation(WindowConstants.HIDE_ON_CLOSE); break;\n\t\tdefault: Window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\t\t}\n\t}\n\n\t\n\tpublic void setResizable(boolean resizable) {\n\t\tWindow.setResizable(resizable);\n\t}\n\n\n\t\n\tpublic static void show(Mat mat) {\n\t\tshow(mat, new Dimension(mat.rows(), mat.cols()), \"\", false, WindowConstants.EXIT_ON_CLOSE);\n\t}\n\n\t\n\tpublic static void show(Mat mat, String frameTitle) {\n\t\tshow(mat, new Dimension(mat.rows(), mat.cols()), frameTitle, false, WindowConstants.EXIT_ON_CLOSE);\n\t}\n\n\t\n\tpublic static void show(Mat mat, String frameTitle, boolean resizable) {\n\t\tshow(mat, new Dimension(mat.rows(), mat.cols()), frameTitle, resizable, WindowConstants.EXIT_ON_CLOSE);\n\t}\n\n\t\n\tpublic static void show(Mat mat, Dimension frameSize) {\n\t\tshow(mat, frameSize, \"\", false, WindowConstants.EXIT_ON_CLOSE);\n\t}\n\n\t\n\tpublic static void show(Mat mat, Dimension frameSize, String frameTitle) {\n\t\tshow(mat, frameSize, frameTitle, false, WindowConstants.EXIT_ON_CLOSE);\n\t}\n\n\t\n\tpublic static void show(Mat mat, Dimension frameSize, String frameTitle, boolean resizable) {\n\t\tshow(mat, frameSize, frameTitle, resizable, WindowConstants.EXIT_ON_CLOSE);\n\t}\n\n\t\n\tpublic static void show(Mat mat, Dimension frameSize, String frameTitle, boolean resizable, int closeOperation) {\n\t\tImShow frame = new ImShow(frameTitle, frameSize.height, frameSize.width);\n\t\tframe.setResizable(resizable);\n\t\t\n\t\tframe.Window.setDefaultCloseOperation(closeOperation);\n\t\tframe.showImage(mat);\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@RestClientTest({GithubClient.class, RendererProperties.class})\n@TestPropertySource(properties = \"sagan.renderer.github.token=testtoken\")\npublic class GithubClientTests {\n\n\tprivate static final MediaType GITHUB_PREVIEW = MediaType.parseMediaType(\"application/vnd.github.mercy-preview+json\");\n\n\tprivate static final MediaType APPLICATION_ZIP = MediaType.parseMediaType(\"application/zip\");\n\n\t@Autowired\n\tprivate GithubClient client;\n\n\t@Autowired\n\tprivate MockRestServiceServer server;\n\n\t@Test\n\tpublic void downloadRepositoryInfo() {\n\t\tString org = \"spring-guides\";\n\t\tString repo = \"gs-rest-service\";\n\t\tString expectedUrl = String.format(\"/repos/%s/%s\", org, repo);\n\t\tString authorization = getAuthorizationHeader();\n\t\tthis.server.expect(requestTo(expectedUrl))\n\t\t\t\t.andExpect(header(HttpHeaders.AUTHORIZATION, authorization))\n\t\t\t\t.andExpect(header(HttpHeaders.ACCEPT, GITHUB_PREVIEW.toString()))\n\t\t\t\t.andRespond(withSuccess(getClassPathResource(\"gs-rest-service.json\"), GITHUB_PREVIEW));\n\t\tRepository repository = this.client.fetchOrgRepository(org, repo);\n\t\tassertThat(repository).extracting(\"name\").containsOnly(\"gs-rest-service\");\n\t}\n\n\t@Test\n\tpublic void downloadRepositoryAsZipBall() throws Exception {\n\t\tString org = \"spring-guides\";\n\t\tString repo = \"gs-rest-service\";\n\t\tString expectedUrl = String.format(\"/repos/%s/%s/zipball\", org, repo);\n\t\tString authorization = getAuthorizationHeader();\n\t\tthis.server.expect(requestTo(expectedUrl))\n\t\t\t\t.andExpect(header(HttpHeaders.AUTHORIZATION, authorization))\n\t\t\t\t.andExpect(header(HttpHeaders.ACCEPT, GITHUB_PREVIEW.toString()))\n\t\t\t\t.andRespond(withSuccess(getClassPathResource(\"gs-rest-service.zip\"), APPLICATION_ZIP));\n\t\tbyte[] result = this.client.downloadRepositoryAsZipball(org, repo);\n\t\tClassPathResource resource = getClassPathResource(\"gs-rest-service.zip\");\n\t\tassertThat(result).isEqualTo(StreamUtils.copyToByteArray(resource.getInputStream()));\n\t}\n\n\t@Test\n\tpublic void fetchRepositoriesMultiplePages() {\n\t\tString org = \"spring-guides\";\n\t\tString authorization = getAuthorizationHeader();\n\t\tHttpHeaders firstPageHeaders = new HttpHeaders();\n\t\tfirstPageHeaders.add(\"Link\",\n\t\t\t\t\"<https://api.github.com/organizations/4161866/repos?per_page=100&page=2>; rel=\\\"next\\\",\" +\n\t\t\t\t\t\t\" <https://api.github.com/organizations/4161866/repos?per_page=100&page=2>; rel=\\\"last\\\"\");\n\t\tthis.server.expect(requestTo(\"/orgs/spring-guides/repos?per_page=100\"))\n\t\t\t\t.andExpect(header(HttpHeaders.AUTHORIZATION, authorization))\n\t\t\t\t.andExpect(header(HttpHeaders.ACCEPT, GITHUB_PREVIEW.toString()))\n\t\t\t\t.andRespond(withSuccess(getClassPathResource(\"spring-guides-repos-page1.json\"),\n\t\t\t\t\t\tMediaType.APPLICATION_JSON).headers(firstPageHeaders));\n\t\tthis.server.expect(requestTo(\"/organizations/4161866/repos?per_page=100&page=2\"))\n\t\t\t\t.andExpect(header(HttpHeaders.AUTHORIZATION, authorization))\n\t\t\t\t.andExpect(header(HttpHeaders.ACCEPT, GITHUB_PREVIEW.toString()))\n\t\t\t\t.andRespond(withSuccess(getClassPathResource(\"spring-guides-repos-page2.json\"),\n\t\t\t\t\t\tMediaType.APPLICATION_JSON));\n\n\t\tList<Repository> repositories = this.client.fetchOrgRepositories(org);\n\t\tassertThat(repositories).hasSize(5)\n\t\t\t\t.extracting(\"name\")\n\t\t\t\t.containsExactlyInAnyOrder(\"gs-rest-service\",\"gs-scheduling-tasks\",\n\t\t\t\t\t\t\"gs-consuming-rest\", \"gs-relational-data-access\", \"deprecate-gs-device-detection\");\n\n\t}\n\n\tprivate String getAuthorizationHeader() {\n\t\treturn \"Token testtoken\";\n\t}\n\n\tprivate ClassPathResource getClassPathResource(String path) {\n\t\treturn new ClassPathResource(path, getClass());\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n@Component\npublic class JobCompletionNotificationListener extends JobExecutionListenerSupport {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(JobCompletionNotificationListener.class);\n\n\tprivate final JdbcTemplate jdbcTemplate;\n\n\t@Autowired\n\tpublic JobCompletionNotificationListener(JdbcTemplate jdbcTemplate) {\n\t\tthis.jdbcTemplate = jdbcTemplate;\n\t}\n\n\t@Override\n\tpublic void afterJob(JobExecution jobExecution) {\n\t\tif(jobExecution.getStatus() == BatchStatus.COMPLETED) {\n\t\t\tlog.info(\"!!! JOB FINISHED! Time to verify the results\");\n\n\t\t\tjdbcTemplate.query(\"SELECT first_name, last_name FROM people\",\n\t\t\t\t(rs, row) -> new Person(\n\t\t\t\t\trs.getString(1),\n\t\t\t\t\trs.getString(2))\n\t\t\t).forEach(person -> log.info(\"Found <\" + person + \"> in the database.\"));\n\t\t}\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class Blobs\n{\n    static int BLOBROWCOUNT = 3500; // 11 inches * 8.5 inches standard page\n    static int BLOBCOLCOUNT = 2700; // with some added cushion to be safe\n    \n    static int BLOBTOTALCOUNT = (BLOBROWCOUNT + BLOBCOLCOUNT) * 5;\n\n    public static int BLOBLABEL = 0;\n    public static int BLOBPARENT = 1;\n    public static int BLOBCOLOR = 2;\n    public static int BLOBAREA = 3;\n    public static int BLOBPERIMETER = 4;\n    public static int BLOBSUMX = 5;\n    public static int BLOBSUMY = 6;\n    public static int BLOBSUMXX = 7;\n    public static int BLOBSUMYY = 8;\n    public static int BLOBSUMXY = 9;\n    public static int BLOBMINX = 10;\n    public static int BLOBMAXX = 11;\n    public static int BLOBMINY = 12;\n    public static int BLOBMAXY = 13;\n    public static int BLOBDATACOUNT = 14; \n\n    public static int [][] LabelMat = new int [BLOBROWCOUNT][BLOBCOLCOUNT];\n    public static double [][] RegionData = new double [BLOBTOTALCOUNT][BLOBDATACOUNT];\n    public static int MaxLabel; \n    \n    public int LabelA, LabelB, LabelC, LabelD;\n    public int ColorA, ColorB, ColorC, ColorD;\n    public int jrow, jcol;  // index within ROI\n    public static int [] SubsumedLabel = new int [BLOBTOTALCOUNT];\n    public static int [] CondensationMap = new int [BLOBTOTALCOUNT];\n    \n    public void PrintRegionData() { PrintRegionData(0, MaxLabel); }\n    public void PrintRegionData(int Label0, int Label1)\n    {\n        if(Label0 < 0) Label0 = 0;\n        if(Label1 > MaxLabel) Label1 = MaxLabel;\n        if(Label1 < Label0) return;\n        for(int Label = Label0; Label <= Label1; Label++)\n        {\n            double [] Property = RegionData[Label];\n            \n            int ThisLabel = (int)Property[BLOBLABEL];\n            int ThisParent = (int)Property[BLOBPARENT];\n            int ThisColor = (int)Property[BLOBCOLOR];\n            double ThisArea = Property[BLOBAREA];\n            double ThisPerimeter = Property[BLOBPERIMETER];\n            double ThisSumX = Property[BLOBSUMX];\n            double ThisSumY = Property[BLOBSUMY];\n            double ThisSumXX = Property[BLOBSUMXX];\n            double ThisSumYY = Property[BLOBSUMYY];\n            double ThisSumXY = Property[BLOBSUMXY];\n            int ThisMinX = (int)Property[BLOBMINX];\n            int ThisMaxX = (int)Property[BLOBMAXX];\n            int ThisMinY = (int)Property[BLOBMINY];\n            int ThisMaxY = (int)Property[BLOBMAXY];\n            \n            String Str1 = \" \" + Label + \": L[\" + ThisLabel + \"] P[\" + ThisParent + \"] C[\" + ThisColor + \"]\";\n            String Str2 = \" AP[\" + ThisArea + \", \" + ThisPerimeter + \"]\";\n            String Str3 = \" M1[\" + ThisSumX + \", \" + ThisSumY + \"] M2[\" + ThisSumXX + \", \" + ThisSumYY + \", \" + ThisSumXY + \"]\";\n            String Str4 = \" MINMAX[\" + ThisMinX + \", \" + ThisMaxX + \", \" + ThisMinY + \", \" + ThisMaxY + \"]\";\n            \n            String Str = Str1 + Str2 + Str3 + Str4;\n            System.out.println(Str);\n        }\n        System.out.println();\n    }\n\n    public static int NextRegion(int Parent, int Color, double MinArea, double MaxArea, int Label)\n    {\n        double DParent = (double) Parent; \n        double DColor = (double) Color; if(DColor > 0) DColor = 1;\n        \n        int i;\n        for(i = Label; i <= MaxLabel; i++)\n        {\n            double [] Region = RegionData[i];\n            double ThisParent = Region[BLOBPARENT];\n            double ThisColor = Region[BLOBCOLOR];\n            if(DParent >= 0 && DParent != ThisParent) continue;\n            if(DColor >= 0 && DColor != ThisColor) continue;\n            if(Region[BLOBAREA] < MinArea || Region[BLOBAREA] > MaxArea) continue;  \n            break;      // We have a match!\n        }\n        if(i > MaxLabel) i = -1;    // Use -1 to flag that there was no match\n        return i;\n    }\n\n    public static int PriorRegion(int Parent, int Color, double MinArea, double MaxArea, int Label)\n    {\n        double DParent = (double) Parent; \n        double DColor = (double) Color; if(DColor > 0) DColor = 1;\n        \n        int i;\n        for(i = Label; i >= 0; i--)\n        {\n            double [] Region = RegionData[i];\n            double ThisParent = Region[BLOBPARENT];\n            double ThisColor = Region[BLOBCOLOR];\n            if(DParent >= 0 && DParent != ThisParent) continue;\n            if(DColor >= 0 && DColor != ThisColor) continue;\n            if(Region[BLOBAREA] < MinArea || Region[BLOBAREA] > MaxArea) continue;  \n            break;      // We have a match!\n        }\n        if(i < 0) i = -1;   // Use -1 to flag that there was no match\n        return i;\n    }\n    \n    public void ResetRegion(int Label)\n    {\n        double [] RegionD = RegionData[Label];\n        RegionD[BLOBLABEL] = \n        RegionD[BLOBPARENT] = \n        RegionD[BLOBCOLOR] =\n        RegionD[BLOBAREA] =\n        RegionD[BLOBPERIMETER] =\n        RegionD[BLOBSUMX] =\n        RegionD[BLOBSUMY] = \n        RegionD[BLOBSUMXX] = \n        RegionD[BLOBSUMYY] = \n        RegionD[BLOBSUMXY] = \n        RegionD[BLOBMINX] = \n        RegionD[BLOBMAXX] = \n        RegionD[BLOBMINY] = \n        RegionD[BLOBMAXY] = 0.0;\n        System.arraycopy(RegionD,0,RegionData[Label],0,BLOBDATACOUNT);  // RegionData[Label] <- RegionD;\n    }\n    \n    public void OldRegion(\n            int NewLabelD,  // 3rd update this (may be the same as Label1 or Label2)\n            int Label1,     // 1st increment this by 1 \n            int Label2)     // 2nd increment this by 1\n    {\n        int DeltaPerimeter = 0;\n        \n        if(Label1 >= 0 && Label1 != NewLabelD)\n        {\n            DeltaPerimeter++;\n            double [] Region1 = RegionData[Label1];\n            Region1[BLOBPERIMETER]++;\n            System.arraycopy(Region1,0,RegionData[Label1],0,BLOBDATACOUNT); // RegionData[Label1] <- Region1;\n        }\n        \n        if(Label2 >= 0 && Label2 != NewLabelD)\n        {\n            DeltaPerimeter++;\n            double [] Region2 = RegionData[Label2];\n            Region2[BLOBPERIMETER]++;\n            System.arraycopy(Region2,0,RegionData[Label2],0,BLOBDATACOUNT); // RegionData[Label2] <- Region2;\n        }\n        \n        LabelD = NewLabelD;\n        double [] RegionD = RegionData[LabelD];\n        RegionD[BLOBLABEL] = LabelD;\n        RegionD[BLOBPARENT] += 0.0;     // no change\n        RegionD[BLOBCOLOR] += 0.0;      // no change\n        RegionD[BLOBAREA] += 1.0;\n        RegionD[BLOBPERIMETER] += DeltaPerimeter;\n        RegionD[BLOBSUMX] += jcol;\n        RegionD[BLOBSUMY] += jrow;\n        RegionD[BLOBSUMXX] += jcol*jcol;\n        RegionD[BLOBSUMYY] += jrow*jrow;\n        RegionD[BLOBSUMXY] += jcol*jrow;\n        RegionD[BLOBMINX] = Math.min(RegionD[BLOBMINX], jcol);\n        RegionD[BLOBMAXX] = Math.max(RegionD[BLOBMAXX], jcol);\n        RegionD[BLOBMINY] = Math.min(RegionD[BLOBMINY], jrow);\n        RegionD[BLOBMAXY] = Math.max(RegionD[BLOBMAXY], jrow);\n        System.arraycopy(RegionD,0,RegionData[LabelD],0,BLOBDATACOUNT); // RegionData[LabelD] <- RegionD;\n   }\n    \n    public void NewRegion(int ParentLabel)\n    {\n        LabelD = ++MaxLabel;\n        double [] RegionD = RegionData[LabelD];\n        RegionD[BLOBLABEL] = LabelD;\n        RegionD[BLOBPARENT] = (double) ParentLabel;\n        RegionD[BLOBCOLOR] = ColorD;\n        RegionD[BLOBAREA] = 1.0;\n        RegionD[BLOBPERIMETER] = 2.0;\n        RegionD[BLOBSUMX] = jcol;\n        RegionD[BLOBSUMY] = jrow;\n        RegionD[BLOBSUMXX] = jcol*jcol;\n        RegionD[BLOBSUMYY] = jrow*jrow;\n        RegionD[BLOBSUMXY] = jcol*jrow;\n        RegionD[BLOBMINX] = jcol;\n        RegionD[BLOBMAXX] = jcol;\n        RegionD[BLOBMINY] = jrow;\n        RegionD[BLOBMAXY] = jrow;\n\n        System.arraycopy(RegionD,0,RegionData[LabelD],0,BLOBDATACOUNT); // RegionData[LabelD] <- RegionD;\n        SubsumedLabel[LabelD] = -1;     // Flag label as not subsumed\n\n        double [] RegionB = RegionData[LabelB];\n        RegionB[BLOBPERIMETER]++;\n        System.arraycopy(RegionB,0,RegionData[LabelB],0,BLOBDATACOUNT); // RegionData[LabelB] <- RegionB;\n        \n        double [] RegionC = RegionData[LabelC];\n        RegionC[BLOBPERIMETER]++;\n\n        System.arraycopy(RegionC,0,RegionData[LabelC],0,BLOBDATACOUNT); // RegionData[LabelC] <- RegionC;\n    }\n    \n    public void Subsume(int GoodLabel, int BadLabel, int PSign) // Combine data with parent\n    {\n        LabelD = GoodLabel;\n        double [] GoodRegion = RegionData[GoodLabel];   \n        double [] BadRegion = RegionData[BadLabel];\n    \n        GoodRegion[BLOBLABEL] = GoodRegion[BLOBLABEL];      // no change\n        GoodRegion[BLOBPARENT] = GoodRegion[BLOBPARENT];    // no change\n        GoodRegion[BLOBCOLOR] = GoodRegion[BLOBCOLOR];      // no change\n        GoodRegion[BLOBAREA] += BadRegion[BLOBAREA];\n        GoodRegion[BLOBPERIMETER] += BadRegion[BLOBPERIMETER] * PSign;  // + external or - internal perimeter\n        GoodRegion[BLOBSUMX] += BadRegion[BLOBSUMX];\n        GoodRegion[BLOBSUMY] += BadRegion[BLOBSUMY];\n        GoodRegion[BLOBSUMXX] += BadRegion[BLOBSUMXX];\n        GoodRegion[BLOBSUMYY] += BadRegion[BLOBSUMYY];\n        GoodRegion[BLOBSUMXY] += BadRegion[BLOBSUMXY];\n        GoodRegion[BLOBMINX] = Math.min(GoodRegion[BLOBMINX], BadRegion[BLOBMINX]);\n        GoodRegion[BLOBMAXX] = Math.max(GoodRegion[BLOBMAXX], BadRegion[BLOBMAXX]);\n        GoodRegion[BLOBMINY] = Math.min(GoodRegion[BLOBMINY], BadRegion[BLOBMINY]);\n        GoodRegion[BLOBMAXY] = Math.max(GoodRegion[BLOBMAXY], BadRegion[BLOBMAXY]);\n        \n        System.arraycopy(GoodRegion,0,RegionData[GoodLabel],0,BLOBDATACOUNT);   // RegionData[GoodLabel] <- GoodRegion;\n    }\n\n    public static int SubsumptionChain(int x) { return SubsumptionChain(x, 0); }\n    public static int SubsumptionChain(int x, int Print)\n    {\n        String Str = \"\";\n        if(Print > 0) Str = \"Subsumption chain for \" + x + \": \";\n        int Lastx = x;\n        while(x > -1)\n        {\n            Lastx = x;\n            if(Print > 0) Str += \" \" + x;\n            if(x == 0) break;\n            x = SubsumedLabel[x];\n        }\n        if(Print > 0) System.out.println(Str);\n        return Lastx;\n    }\n\n\n    public int BlobAnalysis(IplImage Src,           // input image\n                int Col0, int Row0,                 // start of ROI\n                int Cols, int Rows,                 // size of ROI\n                int Border,                         // border color (0 = black; 1 = white)\n                int MinArea)                        // minimum region area\n    {\n        CvMat SrcMat = Src.asCvMat();\n        int SrcCols = SrcMat.cols();\n        int SrcRows = SrcMat.rows();\n        \n        if(Col0 < 0) Col0 = 0;\n        if(Row0 < 0) Row0 = 0;\n        if(Cols < 0) Cols = SrcCols;\n        if(Rows < 0) Rows = SrcRows;\n        if(Col0 + Cols > SrcCols) Cols = SrcCols - Col0;\n        if(Row0 + Rows > SrcRows) Rows = SrcRows - Row0;\n\n        if(Cols > BLOBCOLCOUNT || Rows > BLOBROWCOUNT )\n        {\n            System.out.println(\"Error in Class Blobs: Image too large: Edit Blobs.java\");\n            System.exit(666);\n            return 0;\n        }\n        \n        int FillLabel = 0;\n        int FillColor = 0; if(Border > 0) { FillColor = 1; }\n        LabelA = LabelB = LabelC = LabelD = 0;\n        ColorA = ColorB = ColorC = ColorD = FillColor;\n        for(int k = 0; k < BLOBTOTALCOUNT; k++) SubsumedLabel[k] = -1;\n        \n        MaxLabel = 0;\n        double [] BorderRegion = RegionData[0];\n        BorderRegion[BLOBLABEL] = 0.0;\n        BorderRegion[BLOBPARENT] = -1.0;\n        BorderRegion[BLOBAREA] = Rows + Cols + 4;   // Top, left, and 4 corners\n        BorderRegion[BLOBCOLOR] = FillColor;\n        BorderRegion[BLOBSUMX] = 0.5 * ( (2.0 + Cols) * (Cols - 1.0) ) - Rows - 1 ;\n        BorderRegion[BLOBSUMY] = 0.5 * ( (2.0 + Rows) * (Rows - 1.0) ) - Cols - 1 ;\n        BorderRegion[BLOBMINX] = -1;\n        BorderRegion[BLOBMINY] = -1;\n        BorderRegion[BLOBMAXX] = Cols + 1.0;\n        BorderRegion[BLOBMAXY] = Rows + 1.0;\n        System.arraycopy(BorderRegion,0,RegionData[0],0,BLOBDATACOUNT); // RegionData[0] <- BorderRegion;\n        \n                    \n        for(int irow = Row0; irow < Row0+Rows; irow++)  // index within Src\n        {\n            jrow = irow - Row0; // index within ROI. 0 is first row. Rows is last row.\n            \n            for(int icol = Col0; icol < Col0+Cols; icol++)  // index within Src\n            {\n                jcol = icol - Col0; // index within ROI\n \n                ColorA = ColorB = ColorC = FillColor;\n                LabelA = LabelB = LabelC = LabelD = 0;\n                ColorD = (int) SrcMat.get(jrow,jcol);       // fetch color of cell\n            \n                if(jrow == 0 || jcol == 0)  // first column or row\n                {\n                    if(jcol > 0)\n                    {\n                        ColorC = (int) SrcMat.get(jrow,jcol-1);\n                        LabelC = LabelMat[jrow][jcol-1];\n                    }\n                    if(jrow > 0)\n                    {\n                        ColorB = (int) SrcMat.get(jrow-1,jcol);\n                        LabelB = LabelMat[jrow-1][jcol];\n                    }\n                }\n                else\n                {\n                    ColorA = (int) SrcMat.get(jrow-1,jcol-1); if(ColorA > 0) ColorA = 1;\n                    ColorB = (int) SrcMat.get(jrow-1,jcol); if(ColorB > 0) ColorB = 1;\n                    ColorC = (int) SrcMat.get(jrow,jcol-1); if(ColorC > 0) ColorC = 1;\n                    LabelA = LabelMat[jrow-1][jcol-1];\n                    LabelB = LabelMat[jrow-1][jcol];\n                    LabelC = LabelMat[jrow][jcol-1];\n                }   \n                if(ColorA > 0) ColorA = 1;\n                if(ColorB > 0) ColorB = 1;\n                if(ColorC > 0) ColorC = 1;\n                if(ColorD > 0) ColorD = 1;\n                    \n                int Case = 0;\n                if(ColorA == ColorB)\n                {\n                    if(ColorC == ColorD) { if(ColorA == ColorC) Case = 1; else Case = 2; }\n                    else { if(ColorA == ColorC) Case = 5; else Case = 6; }\n                }\n                else\n                {\n                    if(ColorC == ColorD) { if(ColorA == ColorC) Case = 3; else Case = 4; }\n                    else { if(ColorA == ColorC) Case = 7; else Case = 8; }\n                }\n\n                if(Case == 1) { OldRegion(LabelC, -1, -1); }\n                else if(Case == 2 || Case == 3) { OldRegion(LabelC, LabelB, LabelC); }\n                else if(Case == 5 || Case == 8) // Isolated\n                {\n                    if((jrow == Rows || jcol == Cols) && ColorD == FillColor) { OldRegion(0, -1, -1); } // attached to border region 0\n                    else NewRegion(LabelB);\n                }\n                else if(Case == 6 || Case == 7) { OldRegion(LabelB, LabelB, LabelC); }\n                else            // Case 4 - The complicated situation\n                {\n                    int LabelBRoot = SubsumptionChain(LabelB); \n                    int LabelCRoot = SubsumptionChain(LabelC);\n                    int LabelRoot = Math.min(LabelBRoot, LabelCRoot);\n                    int LabelX;\n                    if(LabelBRoot < LabelCRoot) { OldRegion(LabelB, -1, -1); LabelX = LabelC; }\n                    else { OldRegion(LabelC, -1, -1); LabelX = LabelB; }\n                    int NextLabelX = LabelX;\n                    while(LabelRoot < LabelX)\n                    {\n                        NextLabelX = SubsumedLabel[LabelX];\n                        SubsumedLabel[LabelX] = LabelRoot;\n                        LabelX = NextLabelX;\n                    }\n                }\n                    \n                if((jrow == Rows || jcol == Cols) && ColorD == FillColor)\n                {\n                    if(jcol < Cols)         // bottom row   \n                    {\n                        if(ColorC != FillColor)     // Subsume B chain to border region 0\n                        {\n                            int LabelRoot = SubsumptionChain(LabelB);\n                            SubsumedLabel[LabelRoot] = 0;\n                        }\n                    }\n                    else if(jrow < Rows)    // right column\n                    {\n                        if(ColorB != FillColor)     // Subsume C chain to border region 0\n                        {\n                            int LabelRoot = SubsumptionChain(LabelC);\n                            SubsumedLabel[LabelRoot] = 0;\n                        }\n                    }\n                    OldRegion(0, -1, -1);   // attached to border region 0\n                }\n\n                LabelMat[jrow][jcol] = LabelD;\n                    \n            }\n        }\n\n        int Offset = 0;\n        for(int Label = 1; Label <= MaxLabel; Label++)\n        {\n            if(SubsumedLabel[Label] > -1) Offset++;\n            CondensationMap[Label] = Label - Offset;\n        }\n\n        for(int Label = 1; Label <= MaxLabel; Label++)\n        {\n            int BetterLabel = SubsumptionChain(Label);\n            if(BetterLabel != Label) Subsume(BetterLabel, Label, 1);\n        }   \n\n        int NewMaxLabel = 0;\n        for(int OldLabel = 1; OldLabel <= MaxLabel; OldLabel++)\n        {\n            if(SubsumedLabel[OldLabel] < 0) // Renumber valid regions only\n            {\n                double [] OldRegion = RegionData[OldLabel];\n                int OldParent = (int) OldRegion[BLOBPARENT];\n                int NewLabel = CondensationMap[OldLabel];\n                int NewParent = SubsumptionChain(OldParent);\n                NewParent = CondensationMap[NewParent];\n                OldRegion[BLOBLABEL] = (double) NewLabel;\n                OldRegion[BLOBPARENT] = (double) NewParent;\n                System.arraycopy(OldRegion,0,RegionData[NewLabel],0,BLOBDATACOUNT); //RegionData[NewLabel] <- ThisRegion;\n                NewMaxLabel = NewLabel;\n            }\n        }\n    \n        for(int Label = NewMaxLabel+1; Label <= MaxLabel; Label++) ResetRegion(Label);\n        MaxLabel = NewMaxLabel;\n        \n        for(int Label = MaxLabel; Label > 0; Label--)\n        {\n            double [] ThisRegion = RegionData[Label];\n            int ThisArea = (int) ThisRegion[BLOBAREA];\n            if(ThisArea < MinArea)\n            {\n                int ThisParent = (int) ThisRegion[BLOBPARENT];\n                SubsumedLabel[Label] =  ThisParent;             // Flag this label as having been subsumed\n            }\n            else SubsumedLabel[Label] =  -1;\n        }\n        \n        Offset = 0;\n        for(int Label = 1; Label <= MaxLabel; Label++)\n        {\n            if(SubsumedLabel[Label] > -1) Offset++;\n            CondensationMap[Label] = Label - Offset;      \n        }\n\n        for(int Label = 1; Label <= MaxLabel; Label++)\n        {\n            int BetterLabel = SubsumptionChain(Label);\n            if(BetterLabel != Label) Subsume(BetterLabel, Label, -1);\n        }   \n    \n        for(int OldLabel = 1; OldLabel <= MaxLabel; OldLabel++)\n        {\n            if(SubsumedLabel[OldLabel] < 0) // Renumber valid regions only\n            {\n                double [] OldRegion = RegionData[OldLabel];\n                int OldParent = (int) OldRegion[BLOBPARENT];\n                int NewLabel = CondensationMap[OldLabel];\n                int NewParent = SubsumptionChain(OldParent);\n                NewParent = CondensationMap[NewParent];\n                OldRegion[BLOBLABEL] = (double) NewLabel;\n                OldRegion[BLOBPARENT] = (double) NewParent;\n                System.arraycopy(OldRegion,0,RegionData[NewLabel],0,BLOBDATACOUNT); //RegionData[NewLabel] <- ThisRegion;\n                NewMaxLabel = NewLabel;\n            }\n        }\n        \n        for(int Label = NewMaxLabel+1; Label <= MaxLabel; Label++) ResetRegion(Label);\n        MaxLabel = NewMaxLabel;\n\n        for(int Label = 0; Label <= MaxLabel; Label++)\n        {\n            double [] ThisRegion = RegionData[Label];\n            \n            double Area = ThisRegion[BLOBAREA];\n            double SumX = ThisRegion[BLOBSUMX];\n            double SumY = ThisRegion[BLOBSUMY];\n            double SumXX = ThisRegion[BLOBSUMXX];\n            double SumYY = ThisRegion[BLOBSUMYY];\n            double SumXY = ThisRegion[BLOBSUMXY];\n            \n            SumX /= Area;\n            SumY /= Area;\n            SumXX /= Area;\n            SumYY /= Area;\n            SumXY /= Area;\n            \n            SumXX -= SumX * SumX;\n            SumYY -= SumY * SumY;\n            SumXY -= SumX * SumY;\n            if(SumXY > -1.0E-14 && SumXY < 1.0E-14) SumXY = (float) 0.0; // Eliminate roundoff error\n\n            ThisRegion[BLOBSUMX] = SumX;\n            ThisRegion[BLOBSUMY] = SumY;\n            ThisRegion[BLOBSUMXX] = SumXX;\n            ThisRegion[BLOBSUMYY] = SumYY;\n            ThisRegion[BLOBSUMXY] = SumXY;\n\n            System.arraycopy(ThisRegion,0,RegionData[Label],0,BLOBDATACOUNT);   // RegionData[Label] <- ThisRegion;\n        }\n    \n        BorderRegion = RegionData[0];\n        BorderRegion[BLOBSUMXX] = BorderRegion[BLOBSUMYY] = BorderRegion[BLOBSUMXY] = 0;    // Mark invalid fields\n        System.arraycopy(BorderRegion,0,RegionData[0],0,BLOBDATACOUNT); // RegionData[0] <- BorderRegion;\n        \n        return MaxLabel;\n    }\n    \n    static double iField, jField;\n    static double [] iProperty, jProperty;\n    public static void SortRegions(int Col)\n    {\n        for(int i = 0; i < MaxLabel; i++)\n        {\n            for(int j = i+1; j <= Blobs.MaxLabel; j++)\n            {\n                iProperty = RegionData[i];\n                jProperty = RegionData[j];\n                iField = iProperty[Col];\n                jField = jProperty[Col];\n                if(iField > jField)\n                {\n                    RegionData[i] = jProperty;\n                    RegionData[j] = iProperty;\n                }\n            }\n        }\n    }\n}\n", "nl": "opencv"}
{"code": "\n\n\n\n@Configuration\n@Profile(\"cloud\")\npublic class CloudDataSourceConfig extends AbstractCloudConfig {\n\n    @Bean\n    public DataSource dataSource() {\n        return connectionFactory().dataSource();\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class SayHelloConfiguration {\n\n  @Autowired\n  IClientConfig ribbonClientConfig;\n\n  @Bean\n  public IPing ribbonPing(IClientConfig config) {\n    return new PingUrl();\n  }\n\n  @Bean\n  public IRule ribbonRule(IClientConfig config) {\n    return new AvailabilityFilteringRule();\n  }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class ScheduledTasksTest {\n\n    @SpyBean\n    ScheduledTasks tasks;\n\n    @Test\n    public void reportCurrentTime() {\n        await().atMost(Duration.TEN_SECONDS).untilAsserted(() -> {\n            verify(tasks, atLeast(2)).reportCurrentTime();\n        });\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class FusionEnhance {\n\n\tpublic static Mat enhance (Mat image, int level) {\n\t\tMat img1 = Filters.SimplestColorBalance(image, 5);\n\t\timg1.convertTo(img1, CvType.CV_8UC1);\n\t\tMat LabIm1 = new Mat();\n\t\tImgproc.cvtColor(img1, LabIm1, Imgproc.COLOR_BGR2Lab);\n\t\tMat L1 = new Mat();\n\t\tCore.extractChannel(LabIm1, L1, 0);\n\t\tMat[] result = applyCLAHE(LabIm1, L1);\n\t\tMat img2 = result[0];\n\t\tMat L2 = result[1];\n\t\tMat w1 = calWeight(img1, L1);\n\t\tMat w2 = calWeight(img2, L2);\n\t\tMat sumW = new Mat();\n\t\tCore.add(w1, w2, sumW);\n\t\tCore.divide(w1, sumW, w1);\n\t\tCore.divide(w2, sumW, w2);\n\t\treturn ImgDecompose.fuseTwoImage(w1, img1, w2, img2, level);\n\t}\n\n\tprivate static Mat[] applyCLAHE(Mat img, Mat L) {\n\t\tMat[] result = new Mat[2];\n\t\tCLAHE clahe = Imgproc.createCLAHE();\n\t\tclahe.setClipLimit(2.0);\n\t\tMat L2 = new Mat();\n\t\tclahe.apply(L, L2);\n\t\tMat LabIm2 = new Mat();\n\t\tList<Mat> lab = new ArrayList<>();\n\t\tCore.split(img, lab);\n\t\tCore.merge(new ArrayList<>(Arrays.asList(L2, lab.get(1), lab.get(2))), LabIm2);\n\t\tMat img2 = new Mat();\n\t\tImgproc.cvtColor(LabIm2, img2, Imgproc.COLOR_Lab2BGR);\n\t\tresult[0] = img2;\n\t\tresult[1] = L2;\n\t\treturn result;\n\t}\n\n\tprivate static Mat calWeight(Mat img, Mat L) {\n\t\tCore.divide(L, new Scalar(255.0), L);\n\t\tL.convertTo(L, CvType.CV_32F);\n\t\tMat WL = FeatureWeight.LaplacianContrast(L);\n\t\tWL.convertTo(WL, L.type());\n\t\tMat WC = FeatureWeight.LocalContrast(L);\n\t\tWC.convertTo(WC, L.type());\n\t\tMat WS = FeatureWeight.Saliency(img);\n\t\tWS.convertTo(WS, L.type());\n\t\tMat WE = FeatureWeight.Exposedness(L);\n\t\tWE.convertTo(WE, L.type());\n\t\tMat weight = WL.clone();\n\t\tCore.add(weight, WC, weight);\n\t\tCore.add(weight, WS, weight);\n\t\tCore.add(weight, WE, weight);\n\t\treturn weight;\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n@Component\n@Slf4j\n@ConfigurationProperties(\"integration.stores\")\n@RequiredArgsConstructor(onConstructor = @__(@Autowired))\npublic class StoreIntegration {\n\n\tprivate final LoadBalancerClient loadBalancer;\n\n\t@Getter\n\t@Setter\n\tprivate String uri = \"http://localhost:8081/stores\";\n\n\t@HystrixCommand(fallbackMethod = \"defaultLink\")\n\tpublic Link getStoresByLocationLink(Map<String, Object> parameters, String host) {\n\t\tURI storesUri = URI.create(uri);\n\n\t\tServiceInstance instance = null;\n\t\ttry {\n\t\t\tinstance = loadBalancer.choose(\"stores\");\n\t\t\tif (instance != null) {\n\t\t\t\tstoresUri = URI.create(String.format(\"http://%s:%s\", instance.getHost(),\n\t\t\t\t\t\tinstance.getPort()));\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t}\n\n\t\tlog.info(\"Trying to access the stores system at {}\u9225\", storesUri);\n\n\t\tTraverson traverson = new Traverson(storesUri, MediaTypes.HAL_JSON);\n\n\t\tLink link = traverson.follow(\"stores\", \"search\", \"by-location\")\n\t\t\t\t.withTemplateParameters(parameters).asLink();\n\n\t\tString href = link.getHref();\n \t\tif (host!=null && instance != null) {\n\t\t\thref = reconstructURI(host, href);\n\t\t}\n\t\tlog.info(\"Found stores-by-location link pointing to {}.\", href);\n\n\t\treturn new Link(href, link.getRel());\n\t}\n\n\tprivate String reconstructURI(String host, String href) {\n\t\tURI original;\n\t\ttry {\n\t\t\toriginal = new URI(href);\n\t\t}\n\t\tcatch (URISyntaxException e) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot create URI from: \" + href);\n\t\t}\n\t\tint port = 80;\n\t\tif (\"https\".equals(original.getScheme())) {\n\t\t\tport = 443;\n\t\t}\n\t\tif (host.contains(\":\")) {\n\t\t\tString[] pair = host.split(\":\");\n\t\t\thost = pair[0];\n\t\t\tport = Integer.valueOf(pair[1]);\n\t\t}\n\t\tif (host.equals(original.getHost()) && port == original.getPort()) {\n\t\t\treturn href;\n\t\t}\n\t\tString scheme = original.getScheme();\n\t\tif (scheme == null) {\n\t\t\tscheme = port == 443 ? \"https\" : \"http\";\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(scheme).append(\"://\");\n\t\tif (StringUtils.hasText(original.getRawUserInfo())) {\n\t\t\tsb.append(original.getRawUserInfo()).append(\"@\");\n\t\t}\n\t\tsb.append(host);\n\t\tif (port >= 0) {\n\t\t\tsb.append(\":\").append(port);\n\t\t}\n\t\tsb.append(original.getRawPath());\n\t\tif (StringUtils.hasText(original.getRawQuery())) {\n\t\t\tsb.append(\"?\").append(original.getRawQuery());\n\t\t}\n\t\tif (StringUtils.hasText(original.getRawFragment())) {\n\t\t\tsb.append(\"#\").append(original.getRawFragment());\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic Link defaultLink(Map<String, Object> parameters, String host) {\n\t\treturn null;\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class FaceDetection extends Application\n{\n\t@Override\n\tpublic void start(Stage primaryStage)\n\t{\n\t\ttry\n\t\t{\n\t\t\tFXMLLoader loader = new FXMLLoader(getClass().getResource(\"FaceDetection.fxml\"));\n\t\t\tBorderPane root = (BorderPane) loader.load();\n\t\t\troot.setStyle(\"-fx-background-color: whitesmoke;\");\n\t\t\tScene scene = new Scene(root, 800, 600);\n\t\t\tscene.getStylesheets().add(getClass().getResource(\"application.css\").toExternalForm());\n\t\t\tprimaryStage.setTitle(\"Face Detection and Tracking\");\n\t\t\tprimaryStage.setScene(scene);\n\t\t\tprimaryStage.show();\n\t\t\t\n\t\t\tFaceDetectionController controller = loader.getController();\n\t\t\tcontroller.init();\n\t\t\t\n\t\t\tprimaryStage.setOnCloseRequest((new EventHandler<WindowEvent>() {\n\t\t\t\tpublic void handle(WindowEvent we)\n\t\t\t\t{\n\t\t\t\t\tcontroller.setClosed();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tSystem.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\t\t\n\t\tlaunch(args);\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class GradientMagnitudeEffect extends Effect {\n\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat grayScale = new Mat();\n\t\tImgproc.cvtColor(frame, grayScale, Imgproc.COLOR_RGBA2GRAY);\n\t\t\n\t\tMat drv = new Mat(grayScale.size(), CvType.CV_16SC1);\n\t\tMat drv32f = new Mat(grayScale.size(), CvType.CV_32FC1);\n\t\tMat mag = Mat.zeros(grayScale.size(), CvType.CV_32FC1);\n\n\t\tImgproc.Sobel(grayScale, drv, CvType.CV_16SC1, 1, 0);\n\t\tdrv.convertTo(drv32f, CvType.CV_32FC1);\n\t\tImgproc.accumulateSquare(drv32f, mag);\n\n\t\tImgproc.Sobel(grayScale, drv, CvType.CV_16SC1, 0, 1);\n\t\tdrv.convertTo(drv32f, CvType.CV_32FC1);\n\t\tImgproc.accumulateSquare(drv32f, mag);\n\n\t\tCore.sqrt(mag, mag);\n\t\t\n\t\tmag.convertTo(mag, CvType.CV_8U);\n\t\tImgproc.cvtColor(mag, mag, Imgproc.COLOR_GRAY2RGBA);\n\n\t\tdrv.release();\n\t\tdrv32f.release();\n\t\tgrayScale.release();\n\t\tframe.release();\n\t\treturn mag;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Gradient Magnitude\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class CartoonEffect extends Effect {\n\n    @Override\n    public Mat applyTo(Mat frame) {\n\n        Imgproc.cvtColor(frame, frame, Imgproc.COLOR_RGBA2RGB);\n\n        Mat dstMat = frame.clone();\n\n        Imgproc.bilateralFilter(frame, dstMat, 9, 9, 7);\n        Imgproc.cvtColor(dstMat, dstMat, Imgproc.COLOR_RGB2RGBA);\n\n\n        Mat imgGray = new Mat();\n        Imgproc.cvtColor(frame, imgGray, Imgproc.COLOR_RGBA2GRAY);\n\n        Mat dstBlur = imgGray.clone();\n        Imgproc.medianBlur(imgGray, dstBlur, 7);\n\n        Mat imgEdge = dstBlur.clone();\n\n        Imgproc.adaptiveThreshold(dstBlur,imgEdge, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C,Imgproc.THRESH_BINARY,9,2);\n\n        Imgproc.cvtColor(imgEdge, imgEdge, Imgproc.COLOR_GRAY2RGBA);\n\n        Mat res = dstMat.clone();\n\n        Core.bitwise_and(dstMat, imgEdge, res);\n        Imgproc.cvtColor(res, res, Imgproc.COLOR_RGB2RGBA);\n        return res;\n    }\n\n    public String toString() {\n        return \"Cartoon Effect\";\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\npublic class DrawingCircle extends Application {\n   Mat matrix = null;\n   \n   @Override\n   public void start(Stage stage) throws Exception {\n      DrawingCircle obj = new DrawingCircle();\n      WritableImage writableImage = obj.LoadImage();\n\n      ImageView imageView = new ImageView(writableImage);\n\n      imageView.setFitHeight(600);\n      imageView.setFitWidth(600);\n\n      imageView.setPreserveRatio(true);\n\n      Group root = new Group(imageView);\n\n      Scene scene = new Scene(root, 600, 400);\n\n      stage.setTitle(\"Drawing Circle on the image\");\n      \n      stage.setScene(scene);\n\n      stage.show();\n   }      \n   public WritableImage LoadImage() throws Exception {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap8/input.jpg\";\n      Mat matrix = Imgcodecs.imread(file);\n\n      Imgproc.circle (\n         matrix,                 //Matrix obj of the image\n         new Point(230, 160),    //Center of the circle\n         100,                    //Radius\n         new Scalar(0, 0, 255),  //Scalar object for color\n         10                      //Thickness of the circle\n      );\n      \n      MatOfByte matOfByte = new MatOfByte();\n      Imgcodecs.imencode(\".jpg\", matrix, matOfByte);\n\n      byte[] byteArray = matOfByte.toArray();\n\n      InputStream in = new ByteArrayInputStream(byteArray);\n      BufferedImage bufImage = ImageIO.read(in);\n      this.matrix = matrix;\n      \n      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);\n\n      return writableImage;\n   }\n   public static void main(String args[]) {\n      launch(args);\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class Frame \n{\n\tprivate Bitmap bmp;\n\tprivate Mat enc_mat;\n\tprivate byte[] byteArray;\n\n\tpublic Frame(Mat m)\n\t{\n\t\tenc_mat = m;\n\t\tImgproc.cvtColor(m, m, Imgproc.COLOR_RGB2BGRA);\n\t\tbmp = Bitmap.createBitmap(m.cols(), m.rows(), Bitmap.Config.ARGB_8888);\n\t\tUtils.matToBitmap(m, bmp);\n\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n\t\tbmp.compress(Bitmap.CompressFormat.PNG, 100, stream);\n\t\tbyteArray = stream.toByteArray();\n\t}\n\n\tpublic Frame(ByteBuffer pixels)\n\t{\n\t\tbyteArray = pixels.array();\n\t\tMatOfByte m = new MatOfByte(pixels.array());\n\t\tenc_mat = Imgcodecs.imdecode(m, -1);\n\t\tbmp = Bitmap.createBitmap(m.cols(), m.rows(), Bitmap.Config.ARGB_8888);\n\t\tUtils.matToBitmap(m, bmp);\n\t}\n\n\tpublic ByteBuffer getAsByteBuffer()\n\t{\n\t\treturn ByteBuffer.wrap(byteArray);\n\t}\n\n\tpublic ByteBuffer getAsPngByteBuffer()\n\t{\n\t\tMatOfByte m = new MatOfByte();\n\t\tImgcodecs.imencode(\".png\", enc_mat, m);\n\t\treturn ByteBuffer.wrap(m.toArray());\n\t}\n\n\tpublic Bitmap getBitMap()\n\t{\n\t\treturn bmp;\n\t}\n\n\tpublic byte[] getByteArr()\n\t{\n\t\treturn byteArray;\n\t}\n\n\tpublic Mat getMat()\n\t{\n\t\treturn enc_mat;\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@RestController\n@RequestMapping(path = \"/guides\", produces = MediaTypes.HAL_JSON_VALUE)\npublic class GuidesController {\n\n\tprivate final GuideRenderer guideRenderer;\n\n\tprivate final GithubClient githubClient;\n\n\tprivate final RendererProperties properties;\n\n\tprivate final GuideResourceAssembler guideAssembler = new GuideResourceAssembler();\n\n\tpublic GuidesController(GuideRenderer guideRenderer, GithubClient github,\n\t\t\tRendererProperties properties) {\n\t\tthis.guideRenderer = guideRenderer;\n\t\tthis.githubClient = github;\n\t\tthis.properties = properties;\n\t}\n\n\t@ExceptionHandler(GithubResourceNotFoundException.class)\n\tpublic ResponseEntity resourceNotFound() {\n\t\treturn ResponseEntity.notFound().build();\n\t}\n\n\t@GetMapping(\"/\")\n\tpublic Resources<GuideResource> listGuides() {\n\t\tList<GuideResource> guideResources = this.guideAssembler\n\t\t\t\t.toResources(this.githubClient.fetchOrgRepositories(properties.getGuides().getOrganization()))\n\t\t\t\t.stream().filter(guide -> !guide.getType().equals(GuideType.UNKNOWN))\n\t\t\t\t.collect(Collectors.toList());\n\t\tResources<GuideResource> resources = new Resources<>(guideResources);\n\n\t\tfor (GuideType type : GuideType.values()) {\n\t\t\tif (!GuideType.UNKNOWN.equals(type)) {\n\t\t\t\tresources.add(linkTo(methodOn(GuidesController.class).showGuide(type.getSlug(), null))\n\t\t\t\t\t\t.withRel(type.getSlug()));\n\t\t\t}\n\t\t}\n\t\treturn resources;\n\t}\n\n\t@GetMapping(\"/{type}/{guide}\")\n\tpublic ResponseEntity<GuideResource> showGuide(@PathVariable String type, @PathVariable String guide) {\n\t\tGuideType guideType = GuideType.fromSlug(type);\n\t\tif (GuideType.UNKNOWN.equals(guideType)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\tRepository repository = this.githubClient.fetchOrgRepository(properties.getGuides().getOrganization(),\n\t\t\t\tguideType.getPrefix() + guide);\n\t\tGuideResource guideResource = this.guideAssembler.toResource(repository);\n\t\tif (guideResource.getType().equals(GuideType.UNKNOWN)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\treturn ResponseEntity.ok(guideResource);\n\t}\n\n\t@GetMapping(\"/{type}/{guide}/content\")\n\tpublic ResponseEntity<GuideContentResource> renderGuide(@PathVariable String type, @PathVariable String guide) {\n\t\tGuideType guideType = GuideType.fromSlug(type);\n\t\tif (GuideType.UNKNOWN.equals(guideType)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\tGuideContentResource guideContentResource = this.guideRenderer.render(guideType, guide);\n\t\tguideContentResource.add(linkTo(methodOn(GuidesController.class).renderGuide(guideType.getSlug(), guide)).withSelfRel());\n\t\tguideContentResource.add(linkTo(methodOn(GuidesController.class).showGuide(guideType.getSlug(), guide)).withRel(\"guide\"));\n\t\treturn ResponseEntity.ok(guideContentResource);\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class CameraSettingsProvider {\n\n    private final static Logger LOGGER = Logger.getLogger(CameraSettingsProvider.class.getName());\n\n    private VideoCapture videoCapture;\n\n    private final List<Size> allResolutions = Arrays.asList(\n            new Size(640, 480),\n            new Size(800, 600),\n            new Size(1024, 576),\n            new Size(1280, 720));\n\n    private List<Size> supportedResolutions;\n    private Size maxResolution;\n\n    private Double fps;\n\n    public CameraSettingsProvider(VideoCapture videoCapture) {\n        this.videoCapture = videoCapture;\n    }\n\n    public List<Size> getSupportedResolutions() {\n        if (Objects.isNull(supportedResolutions)) {\n            searchForSupportedResolutions();\n        }\n        return supportedResolutions;\n    }\n\n    public Size getMaxResolution() {\n        if (Objects.isNull(maxResolution)) {\n            if (Objects.isNull(supportedResolutions)) {\n                searchForSupportedResolutions();\n            }\n            maxResolution = supportedResolutions.stream()\n                    .max(Comparator.comparingDouble(size -> size.width))\n                    .orElse(new Size(videoCapture.get(Videoio.CAP_PROP_FRAME_WIDTH),\n                            videoCapture.get(Videoio.CAP_PROP_FRAME_HEIGHT)));\n        }\n        return maxResolution;\n    }\n\n    private void searchForSupportedResolutions() {\n        supportedResolutions = new ArrayList<>();\n        for (Size resolution : allResolutions) {\n            videoCapture.set(Videoio.CAP_PROP_FRAME_WIDTH, resolution.width);\n            videoCapture.set(Videoio.CAP_PROP_FRAME_HEIGHT, resolution.height);\n            if ((videoCapture.get(Videoio.CAP_PROP_FRAME_WIDTH) == resolution.width) &&\n                    (videoCapture.get(Videoio.CAP_PROP_FRAME_HEIGHT) == resolution.height)) {\n                supportedResolutions.add(resolution);\n            }\n        }\n    }\n\n    public double getFps() {\n        if (Objects.isNull(fps)) {\n            fps = videoCapture.get(Videoio.CAP_PROP_FPS);\n        }\n        return fps;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\npublic class SmoothImage { \n\t\n\tpublic static void main(String[] args) {\n\n\n    System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\t\n\t\n\n    Imshow window1 = new Imshow(\"My Image\");\n\n\n    Mat inputImg = Highgui.imread(\"files/lena.jpg\");\n    \n    \n    Mat outputImg = new Mat();\n    \n    \n    Size filter = new Size(5,5);\n    Imgproc.GaussianBlur(inputImg, outputImg, filter, 0, 0, Imgproc.BORDER_DEFAULT); \n       \n\n     window1.showImage(outputImg);\n\n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class FaceDetectionEffect extends Effect {\n\n    public Mat applyTo(Mat aInputFrame) {\n        Mat grayscaleImage = new Mat(aInputFrame.cols(), aInputFrame.rows(), CvType.CV_8UC4);\n\n        Imgproc.cvtColor(aInputFrame, grayscaleImage, Imgproc.COLOR_RGBA2RGB);\n\n        MatOfRect faces = new MatOfRect();\n\n        int absoluteFaceSize = (int) (aInputFrame.rows() * 0.2);\n\n        CascadeClassifier cascadeClassifier = Storage.getCascadeClassifier();\n\n        if (cascadeClassifier != null) {\n            cascadeClassifier.detectMultiScale(grayscaleImage, faces, 1.1, 2, 2,\n                    new Size(absoluteFaceSize, absoluteFaceSize), new Size());\n        }\n\n        Rect[] facesArray = faces.toArray();\n        for (int i = 0; i < facesArray.length; i++) {\n            Imgproc.rectangle(aInputFrame, facesArray[i].tl(), facesArray[i].br(), new Scalar(0, 255, 0, 255), 3);\n        }\n\n        return aInputFrame;\n    }\n\n    public String toString() {\n        return \"Face Detection\";\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Controller\npublic class MarkupController {\n\n\tprivate final List<MarkupRenderer> converters;\n\n\n\tpublic MarkupController(List<MarkupRenderer> converters) {\n\t\tthis.converters = converters;\n\t}\n\n\t@PostMapping(path = \"/documents\", produces = \"text/html\")\n\tpublic ResponseEntity<String> renderMarkup(@RequestHeader(\"Content-Type\") MediaType contentType,\n\t\t\t@RequestBody String markup) {\n\t\treturn converters.stream()\n\t\t\t\t.filter(converter -> converter.canRender(contentType))\n\t\t\t\t.findFirst()\n\t\t\t\t.map(converter -> ResponseEntity.ok(converter.renderToHtml(markup)\n\t\t\t\t\t\t+ \"\\n<!-- rendered by Sagan Renderer Service -->\"))\n\t\t\t\t.orElse(ResponseEntity.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE).build());\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\n\n\npublic class PointInPolygonTest {\n\n    public static void main(String[] args) {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n\n        Mat img = Mat.zeros(400, 400, CvType.CV_8SC3);\n        \n        \n        Point[] contourPoints = new Point[6];\n        \n        contourPoints[0] = new Point(50,50);\n        contourPoints[1] = new Point(300,50);\n        contourPoints[2] = new Point(350,200);\n        contourPoints[3] = new Point(300,150);\n        contourPoints[4] = new Point(150,350);\n        contourPoints[5] = new Point(100,100);\n        \n        \n        MatOfPoint contour1 = new MatOfPoint(contourPoints);\n        List<MatOfPoint> contourList = new ArrayList<MatOfPoint>();\n        contourList.add(contour1);\n        \n        \n        Imgproc.drawContours(img, contourList, -1, new Scalar(0,255,0), 2);\n        \n        \n        Point p1 = new Point(150,75);\n        Core.rectangle(img, p1, p1, new Scalar(0, 0, 255), 3, 8, 0); // RED point\n        \n        Point p2 = new Point(50,350);\n        Core.rectangle(img, p2, p2, new Scalar(255, 0, 0), 3, 8, 0); // BLuE point\n        \n        \n        MatOfPoint2f contourPoint2f = new MatOfPoint2f(contourPoints);\n        \n        if (Imgproc.pointPolygonTest(contourPoint2f,p1, false) > 0)\n        {\n        \tSystem.out.println( \"RED point \" + p1.toString() + \" is inside the polygon\");\n        }\n        \n        if (Imgproc.pointPolygonTest(contourPoint2f,p2, false) < 0)\n        {\n        \tSystem.out.println( \"BLUE point \" + p2.toString() + \" is outside the polygon\");\n        }\n        \n\n        Imshow ims1 = new Imshow(\"Ploygon Test\");\n\n\n        ims1.showImage(img);\n\n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\n\npublic class FaceDetection extends javax.swing.JFrame {\n    private DaemonThread myThread = null;\n    int count = 0;\n    VideoCapture webSource = null;\n    Mat frame = new Mat();\n    MatOfByte mem = new MatOfByte();\n    CascadeClassifier faceDetector = new CascadeClassifier(FaceDetection.class.getResource(\"haarcascade_frontalface_alt.xml\").getPath().substring(1));\n    MatOfRect faceDetections = new MatOfRect();\n\n    class DaemonThread implements Runnable {\n\n        protected volatile boolean runnable = false;\n\n        @Override\n        public void run() {\n            synchronized (this) {\n                while (runnable) {\n                    if (webSource.grab()) {\n                        try {\n                            webSource.retrieve(frame);\n                            Graphics g = jPanel1.getGraphics();\n                            faceDetector.detectMultiScale(frame, faceDetections);\n                            for (Rect rect : faceDetections.toArray()) {\n                                Core.rectangle(frame, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y + rect.height),\n                                        new Scalar(0, 255,0));\n                            }\n                            Highgui.imencode(\".bmp\", frame, mem);\n                            Image im = ImageIO.read(new ByteArrayInputStream(mem.toArray()));\n                            BufferedImage buff = (BufferedImage) im;\n                            if (g.drawImage(buff, 0, 0, getWidth(), getHeight()-150 , 0, 0, buff.getWidth(), buff.getHeight(), null)) {\n                                if (runnable == false) {\n                                    System.out.println(\"Paused ..... \");\n                                    this.wait();\n                                }\n                            }\n                        } catch (Exception ex) {\n                            System.out.println(\"Error!!\");\n                            ex.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    \n    public FaceDetection() {\n        initComponents();\n        System.out.println(FaceDetection.class.getResource(\"haarcascade_frontalface_alt.xml\").getPath().substring(1));\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    private void initComponents() {\n\n        jPanel1 = new javax.swing.JPanel();\n        jButton1 = new javax.swing.JButton();\n        jButton2 = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 0, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 376, Short.MAX_VALUE)\n        );\n\n        jButton1.setText(\"Start\");\n        jButton1.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButton1ActionPerformed(evt);\n            }\n        });\n\n        jButton2.setText(\"Pause\");\n        jButton2.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButton2ActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(24, 24, 24)\n                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addContainerGap())\n            .addGroup(layout.createSequentialGroup()\n                .addGap(255, 255, 255)\n                .addComponent(jButton1)\n                .addGap(86, 86, 86)\n                .addComponent(jButton2)\n                .addContainerGap(258, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jButton1)\n                    .addComponent(jButton2))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed\n        myThread.runnable = false;            // stop thread\n        jButton2.setEnabled(false);   // activate start button \n        jButton1.setEnabled(true);     // deactivate stop button\n\n        webSource.release();  // stop caturing fron cam\n\n\n    }//GEN-LAST:event_jButton2ActionPerformed\n\n    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed\n\n        webSource = new VideoCapture(0); // video capture from default cam\n        myThread = new DaemonThread(); //create object of threat class\n        Thread t = new Thread(myThread);\n        t.setDaemon(true);\n        myThread.runnable = true;\n        t.start();                 //start thrad\n        jButton1.setEnabled(false);  // deactivate start button\n        jButton2.setEnabled(true);  //  activate stop button\n\n\n    }//GEN-LAST:event_jButton1ActionPerformed\n\n    \n    public static void main(String args[]) {\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"Nimbus\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(FaceDetection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(FaceDetection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(FaceDetection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(FaceDetection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new FaceDetection().setVisible(true);\n            }\n        });\n    }\n    private javax.swing.JButton jButton1;\n    private javax.swing.JButton jButton2;\n    private javax.swing.JPanel jPanel1;\n}", "nl": "opencv"}
{"code": "\n\n\n\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaClientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n\n@RestController\nclass ServiceInstanceRestController {\n\n    @Autowired\n    private DiscoveryClient discoveryClient;\n\n    @RequestMapping(\"/service-instances/{applicationName}\")\n    public List<ServiceInstance> serviceInstancesByApplicationName(\n            @PathVariable String applicationName) {\n        return this.discoveryClient.getInstances(applicationName);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@Configuration\n@EnableBatchProcessing\npublic class BatchConfiguration {\n\n    @Autowired\n    public JobBuilderFactory jobBuilderFactory;\n\n    @Autowired\n    public StepBuilderFactory stepBuilderFactory;\n\n    @Bean\n    public FlatFileItemReader<Person> reader() {\n        return new FlatFileItemReaderBuilder<Person>()\n            .name(\"personItemReader\")\n            .resource(new ClassPathResource(\"sample-data.csv\"))\n            .delimited()\n            .names(new String[]{\"firstName\", \"lastName\"})\n            .fieldSetMapper(new BeanWrapperFieldSetMapper<Person>() {{\n                setTargetType(Person.class);\n            }})\n            .build();\n    }\n\n    @Bean\n    public PersonItemProcessor processor() {\n        return new PersonItemProcessor();\n    }\n\n    @Bean\n    public JdbcBatchItemWriter<Person> writer(DataSource dataSource) {\n        return new JdbcBatchItemWriterBuilder<Person>()\n            .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())\n            .sql(\"INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)\")\n            .dataSource(dataSource)\n            .build();\n    }\n\n    @Bean\n    public Job importUserJob(JobCompletionNotificationListener listener, Step step1) {\n        return jobBuilderFactory.get(\"importUserJob\")\n            .incrementer(new RunIdIncrementer())\n            .listener(listener)\n            .flow(step1)\n            .end()\n            .build();\n    }\n\n    @Bean\n    public Step step1(JdbcBatchItemWriter<Person> writer) {\n        return stepBuilderFactory.get(\"step1\")\n            .<Person, Person> chunk(10)\n            .reader(reader())\n            .processor(processor())\n            .writer(writer)\n            .build();\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n@Controller\n@RequestMapping(\"/blog\")\n@Navigation(Section.BLOG)\nclass BlogController {\n\n    private final BlogService service;\n    private final DateFactory dateFactory;\n\n    @Autowired\n    public BlogController(BlogService service, DateFactory dateFactory) {\n        this.service = service;\n        this.dateFactory = dateFactory;\n    }\n\n    @RequestMapping(value = \"/{year:\\\\d+}/{month:\\\\d+}/{day:\\\\d+}/{slug}\", method = { GET, HEAD })\n    public String showPost(@PathVariable String year, @PathVariable String month, @PathVariable String day,\n                           @PathVariable String slug, Model model) {\n\n        String publicSlug = String.format(\"%s/%s/%s/%s\", year, month, day, slug);\n        Post post = service.getPublishedPost(publicSlug);\n        model.addAttribute(\"post\", PostView.of(post, dateFactory));\n        model.addAttribute(\"categories\", PostCategory.values());\n        model.addAttribute(\"activeCategory\", post.getCategory().getDisplayName());\n        model.addAttribute(\"disqusShortname\", service.getDisqusShortname());\n        return \"blog/show\";\n    }\n\n    @RequestMapping(value = \"\", method = { GET, HEAD })\n    public String listPublishedPosts(Model model, @RequestParam(defaultValue = \"1\") int page) {\n        Pageable pageRequest = PageableFactory.forLists(page);\n        Page<Post> result = service.getPublishedPosts(pageRequest);\n        return renderListOfPosts(result, model, \"All Posts\");\n    }\n\n    @RequestMapping(value = \"/category/{category}\", method = { GET, HEAD })\n    public String listPublishedPostsForCategory(@PathVariable(\"category\") PostCategory category, Model model,\n                                                @RequestParam(defaultValue = \"1\", value = \"page\") int page) {\n        Pageable pageRequest = PageableFactory.forLists(page);\n        Page<Post> result = service.getPublishedPosts(category, pageRequest);\n        return renderListOfPosts(result, model, category.getDisplayName());\n    }\n\n    @RequestMapping(value = \"/broadcasts\", method = { GET, HEAD })\n    public String listPublishedBroadcasts(Model model, @RequestParam(defaultValue = \"1\", value = \"page\") int page) {\n        Pageable pageRequest = PageableFactory.forLists(page);\n        Page<Post> result = service.getPublishedBroadcastPosts(pageRequest);\n        return renderListOfPosts(result, model, \"Broadcasts\");\n    }\n\n    @RequestMapping(value = \"/{year:\\\\d+}/{month:\\\\d+}/{day:\\\\d+}\", method = { GET, HEAD })\n    public String listPublishedPostsForDate(@PathVariable int year, @PathVariable int month, @PathVariable int day,\n                                            @RequestParam(defaultValue = \"1\", value = \"page\") int page, Model model) {\n\n        Pageable pageRequest = PageableFactory.forLists(page);\n        Page<Post> result = service.getPublishedPostsByDate(year, month, day, pageRequest);\n\n        LocalDate date = new LocalDate(year, month, day);\n        model.addAttribute(\"title\", \"Archive for \" + date.toString(\"MMMM dd, yyyy\"));\n\n        return renderListOfPosts(result, model, \"All Posts\");\n    }\n\n    @RequestMapping(value = \"/{year:\\\\d+}/{month:\\\\d+}\", method = { GET, HEAD })\n    public String listPublishedPostsForYearAndMonth(@PathVariable int year, @PathVariable int month,\n                                                    @RequestParam(defaultValue = \"1\", value = \"page\") int page,\n                                                    Model model) {\n\n        Pageable pageRequest = PageableFactory.forLists(page);\n        Page<Post> result = service.getPublishedPostsByDate(year, month, pageRequest);\n        YearMonth yearMonth = new YearMonth(year, month);\n        model.addAttribute(\"title\", \"Archive for \" + yearMonth.toString(\"MMMM yyyy\"));\n        return renderListOfPosts(result, model, \"All Posts\");\n    }\n\n    @RequestMapping(value = \"/{year:\\\\d+}\", method = { GET, HEAD })\n    public String listPublishedPostsForYear(@PathVariable int year,\n                                            @RequestParam(defaultValue = \"1\", value = \"page\") int page, Model model) {\n\n        Pageable pageRequest = PageableFactory.forLists(page);\n        Page<Post> result = service.getPublishedPostsByDate(year, pageRequest);\n        model.addAttribute(\"title\", String.format(\"Archive for %d\", year));\n        return renderListOfPosts(result, model, \"All Posts\");\n    }\n\n    @ExceptionHandler\n    public RedirectView handle(PostMovedException moved) {\n        RedirectView redirect = new RedirectView();\n        redirect.setStatusCode(HttpStatus.MOVED_PERMANENTLY);\n        redirect.setUrl(\"/blog/\" + moved.getPublicSlug());\n        return redirect;\n    }\n\n    private String renderListOfPosts(Page<Post> page, Model model, String activeCategory) {\n        Page<PostView> postViewPage = PostView.pageOf(page, dateFactory);\n        List<PostView> posts = postViewPage.getContent();\n        model.addAttribute(\"activeCategory\", activeCategory);\n        model.addAttribute(\"categories\", PostCategory.values());\n        model.addAttribute(\"posts\", posts);\n        model.addAttribute(\"paginationInfo\", new PaginationInfo(postViewPage));\n        model.addAttribute(\"disqusShortname\", service.getDisqusShortname());\n        return \"blog/index\";\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\npublic abstract class OpenCVFrameConverter<F> extends FrameConverter<F> {\n    static { Loader.load(org.bytedeco.opencv.global.opencv_core.class); }\n\n    IplImage img;\n    Mat mat;\n    org.opencv.core.Mat orgOpenCvCoreMat;\n\n    public static class ToIplImage extends OpenCVFrameConverter<IplImage> {\n        @Override public Frame convert(IplImage img) { return super.convert(img); }\n        @Override public IplImage convert(Frame frame) { return convertToIplImage(frame); }\n    }\n\n    public static class ToMat extends OpenCVFrameConverter<Mat> {\n        @Override public Frame convert(Mat mat) { return super.convert(mat); }\n        @Override public Mat convert(Frame frame) { return convertToMat(frame); }\n    }\n\n    public static class ToOrgOpenCvCoreMat extends OpenCVFrameConverter<org.opencv.core.Mat> {\n        @Override public Frame convert(org.opencv.core.Mat mat) { return super.convert(mat); }\n        @Override public org.opencv.core.Mat convert(Frame frame) { return convertToOrgOpenCvCoreMat(frame); }\n    }\n\n    public static int getFrameDepth(int depth) {\n        switch (depth) {\n            case IPL_DEPTH_8U:  case CV_8U:  return Frame.DEPTH_UBYTE;\n            case IPL_DEPTH_8S:  case CV_8S:  return Frame.DEPTH_BYTE;\n            case IPL_DEPTH_16U: case CV_16U: return Frame.DEPTH_USHORT;\n            case IPL_DEPTH_16S: case CV_16S: return Frame.DEPTH_SHORT;\n            case IPL_DEPTH_32F: case CV_32F: return Frame.DEPTH_FLOAT;\n            case IPL_DEPTH_32S: case CV_32S: return Frame.DEPTH_INT;\n            case IPL_DEPTH_64F: case CV_64F: return Frame.DEPTH_DOUBLE;\n            default: return -1;\n        }\n    }\n\n    public static int getIplImageDepth(int depth) {\n        switch (depth) {\n            case Frame.DEPTH_UBYTE:  return IPL_DEPTH_8U;\n            case Frame.DEPTH_BYTE:   return IPL_DEPTH_8S;\n            case Frame.DEPTH_USHORT: return IPL_DEPTH_16U;\n            case Frame.DEPTH_SHORT:  return IPL_DEPTH_16S;\n            case Frame.DEPTH_FLOAT:  return IPL_DEPTH_32F;\n            case Frame.DEPTH_INT:    return IPL_DEPTH_32S;\n            case Frame.DEPTH_DOUBLE: return IPL_DEPTH_64F;\n            default:  return -1;\n        }\n    }\n    static boolean isEqual(Frame frame, IplImage img) {\n        return img != null && frame != null && frame.image != null && frame.image.length > 0\n                && frame.imageWidth == img.width() && frame.imageHeight == img.height()\n                && frame.imageChannels == img.nChannels() && getIplImageDepth(frame.imageDepth) == img.depth()\n                && new Pointer(frame.image[0].position(0)).address() == img.imageData().address()\n                && frame.imageStride * Math.abs(frame.imageDepth) / 8 == img.widthStep();\n    }\n    public IplImage convertToIplImage(Frame frame) {\n        if (frame == null || frame.image == null) {\n            return null;\n        } else if (frame.opaque instanceof IplImage) {\n            return (IplImage)frame.opaque;\n        } else if (!isEqual(frame, img)) {\n            int depth = getIplImageDepth(frame.imageDepth);\n            img = depth < 0 ? null : IplImage.create(frame.imageWidth, frame.imageHeight, depth, frame.imageChannels, new Pointer(frame.image[0].position(0)))\n                    .widthStep(frame.imageStride * Math.abs(frame.imageDepth) / 8)\n                    .imageSize(frame.image[0].capacity() * Math.abs(frame.imageDepth) / 8);\n        }\n        return img;\n    }\n    public Frame convert(IplImage img) {\n        if (img == null) {\n            return null;\n        } else if (!isEqual(frame, img)) {\n            frame = new Frame();\n            frame.imageWidth = img.width();\n            frame.imageHeight = img.height();\n            frame.imageDepth = getFrameDepth(img.depth());\n            frame.imageChannels = img.nChannels();\n            frame.imageStride = img.widthStep() * 8 / Math.abs(frame.imageDepth);\n            frame.image = new Buffer[] { img.createBuffer() };\n        }\n        frame.opaque = img;\n        return frame;\n    }\n\n    public static int getMatDepth(int depth) {\n        switch (depth) {\n            case Frame.DEPTH_UBYTE:  return CV_8U;\n            case Frame.DEPTH_BYTE:   return CV_8S;\n            case Frame.DEPTH_USHORT: return CV_16U;\n            case Frame.DEPTH_SHORT:  return CV_16S;\n            case Frame.DEPTH_FLOAT:  return CV_32F;\n            case Frame.DEPTH_INT:    return CV_32S;\n            case Frame.DEPTH_DOUBLE: return CV_64F;\n            default:  return -1;\n        }\n    }\n    static boolean isEqual(Frame frame, Mat mat) {\n        return mat != null && frame != null && frame.image != null && frame.image.length > 0\n                && frame.imageWidth == mat.cols() && frame.imageHeight == mat.rows()\n                && frame.imageChannels == mat.channels() && getMatDepth(frame.imageDepth) == mat.depth()\n                && new Pointer(frame.image[0].position(0)).address() == mat.data().address()\n                && frame.imageStride * Math.abs(frame.imageDepth) / 8 == (int)mat.step();\n    }\n    public Mat convertToMat(Frame frame) {\n        if (frame == null || frame.image == null) {\n            return null;\n        } else if (frame.opaque instanceof Mat) {\n            return (Mat)frame.opaque;\n        } else if (!isEqual(frame, mat)) {\n            int depth = getMatDepth(frame.imageDepth);\n            mat = depth < 0 ? null : new Mat(frame.imageHeight, frame.imageWidth, CV_MAKETYPE(depth, frame.imageChannels),\n                    new Pointer(frame.image[0].position(0)), frame.imageStride * Math.abs(frame.imageDepth) / 8);\n        }\n        return mat;\n    }\n    public Frame convert(Mat mat) {\n        if (mat == null) {\n            return null;\n        } else if (!isEqual(frame, mat)) {\n            frame = new Frame();\n            frame.imageWidth = mat.cols();\n            frame.imageHeight = mat.rows();\n            frame.imageDepth = getFrameDepth(mat.depth());\n            frame.imageChannels = mat.channels();\n            frame.imageStride = (int)mat.step() * 8 / Math.abs(frame.imageDepth);\n            frame.image = new Buffer[] { mat.createBuffer() };\n        }\n        frame.opaque = mat;\n        return frame;\n    }\n\n    static boolean isEqual(Frame frame, org.opencv.core.Mat mat) {\n        return mat != null && frame != null && frame.image != null && frame.image.length > 0\n                && frame.imageWidth == mat.cols() && frame.imageHeight == mat.rows()\n                && frame.imageChannels == mat.channels() && getMatDepth(frame.imageDepth) == mat.depth()\n                && new Pointer(frame.image[0].position(0)).address() == mat.dataAddr();\n    }\n    public org.opencv.core.Mat convertToOrgOpenCvCoreMat(Frame frame) {\n        if (frame == null || frame.image == null) {\n            return null;\n        } else if (frame.opaque instanceof org.opencv.core.Mat) {\n            return (org.opencv.core.Mat)frame.opaque;\n        } else if (!isEqual(frame, mat)) {\n            int depth = getMatDepth(frame.imageDepth);\n            orgOpenCvCoreMat = depth < 0 ? null : new org.opencv.core.Mat(frame.imageHeight, frame.imageWidth,\n                    CV_MAKETYPE(depth, frame.imageChannels), new BytePointer(new Pointer(frame.image[0].position(0)))\n                            .capacity(frame.image[0].capacity() * Math.abs(frame.imageDepth) / 8).asByteBuffer());\n        }\n        return orgOpenCvCoreMat;\n    }\n    public Frame convert(final org.opencv.core.Mat mat) {\n        if (mat == null) {\n            return null;\n        } else if (!isEqual(frame, mat)) {\n            frame = new Frame();\n            frame.imageWidth = mat.cols();\n            frame.imageHeight = mat.rows();\n            frame.imageDepth = getFrameDepth(mat.depth());\n            frame.imageChannels = mat.channels();\n            frame.imageStride = (int)mat.step1();\n            ByteBuffer byteBuffer = new BytePointer() { { address = mat.dataAddr(); } }.capacity(mat.rows() * mat.step1() * mat.elemSize1()).asByteBuffer();\n            switch (mat.depth()) {\n                case CV_8U:\n                case CV_8S:\n                    frame.image = new Buffer[] { byteBuffer };\n                    break;\n                case CV_16U:\n                case CV_16S:\n                    frame.image = new Buffer[] { byteBuffer.asShortBuffer() };\n                    break;\n                case CV_32F:\n                    frame.image = new Buffer[] { byteBuffer.asFloatBuffer() };\n                    break;\n                case CV_32S:\n                    frame.image = new Buffer[] { byteBuffer.asIntBuffer() };\n                    break;\n                case CV_64F:\n                    frame.image = new Buffer[] { byteBuffer.asDoubleBuffer() };\n                    break;\n                default:\n                    frame.image = null;\n                    break;\n            }\n        }\n        frame.opaque = mat;\n        return frame;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\npublic class SobelTask extends AsyncTask<Bitmap, Bundle, Bitmap> {\n\n    private ImageView imageView;\n    private ProgressDialog progressDialog;\n    private Activity uiActivity;\n\n    public SobelTask(Activity ac, ImageView iv) {\n        super();\n        uiActivity = ac;\n        imageView = iv;\n    }\n\n    @Override\n    protected void onCancelled(Bitmap result) {\n        progressDialog.dismiss();\n    }\n\n    @Override\n    protected void onPreExecute() {\n        progressDialog = new ProgressDialog(uiActivity);\n        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n        progressDialog.setMessage(\"processing...\");\n        progressDialog.setIndeterminate(false);\n        progressDialog.setCanceledOnTouchOutside(false);\n        progressDialog.show();\n    }\n\n    @Override\n    protected Bitmap doInBackground(Bitmap... bitmaps) {\n\n        Bitmap bmpout = bitmaps[0].copy(Bitmap.Config.ARGB_8888, true);\n\n        return sobel(bmpout);\n    }\n\n    @Override\n    protected void onProgressUpdate(Bundle... values) {\n        super.onProgressUpdate(values);\n        Bundle bundle = values[0];\n        if (bundle.containsKey(\"Message\")) {\n            progressDialog.setMessage(bundle.getString(\"Message\"));\n        }\n        if (bundle.containsKey(\"Max\")) {\n            progressDialog.setMax(bundle.getInt(\"Max\"));\n        }\n        if (bundle.containsKey(\"Progress\")) {\n            progressDialog.setProgress(bundle.getInt(\"Progress\"));\n        }\n    }\n\n    \n    @Override\n    protected void onPostExecute(Bitmap result) {\n        progressDialog.dismiss();\n        if (result != null) {\n            imageView.setImageBitmap(result);\n        } else {\n            imageView = (ImageView) uiActivity.findViewById(R.id.imageView);\n        }\n    }\n\n    public void setProgressMessage(String message){\n        Bundle data = new Bundle();\n        data.putString(\"Message\", message);\n        publishProgress(data);\n    }\n    \n    public void setProgressMax(int max){\n        Bundle data = new Bundle();\n        data.putInt(\"Max\", max);\n        publishProgress(data);\n    }\n    \n    public void setProgress(int progress){\n        Bundle data = new Bundle();\n        data.putInt(\"Progress\", progress);\n        publishProgress(data);\n    }\n\n\n    private Bitmap sobel(Bitmap bitmap) {\n        bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n        Mat mat = new Mat();\n        Mat matR = new Mat();\n        Mat matG = new Mat();\n        Mat matB = new Mat();\n        Utils.bitmapToMat(bitmap, mat);\n\n        Core.extractChannel(mat, matR, 0);\n        myFiltering(matR);\n\n        Core.extractChannel(mat, matG, 1);\n        myFiltering(matG);\n\n        Core.extractChannel(mat, matB, 2);\n        myFiltering(matB);\n\n        matMax3(matB, matG, matR, matB);\n\n        Utils.matToBitmap(matB, bitmap);\n        return bitmap;\n    }\n\n    private void myFiltering(Mat src){\n        Mat matX = new Mat();\n        Mat matY = new Mat();\n\n        Imgproc.GaussianBlur(src, src, new Size(3, 3), 0, 0);\n        Imgproc.Sobel(src, matX, src.depth(), 0, 1);\n        Imgproc.Sobel(src, matY, src.depth(), 1, 0);\n        matRMS(matX, matY, src);\n    }\n\n    private void matRMS(Mat src1, Mat src2, Mat dst) {\n\n        int size = (int) (src1.total() * src1.channels());\n        byte[] temp1 = new byte[size];\n        byte[] temp2 = new byte[size];\n        byte[] temp3 = new byte[size];\n        src1.get(0, 0, temp1);\n        src2.get(0, 0, temp2);\n\n        for (int i = 0; i < size; i++) {\n            temp3[i] = (byte)Math.sqrt((temp1[i] * temp1[i] + temp2[i] * temp2[i]) / 2);\n        }\n\n        dst.put(0, 0, temp3);\n    }\n\n    private void matMax3(Mat src1, Mat src2, Mat src3, Mat dst) {\n\n        int size = (int) (src1.total() * src1.channels());\n        byte[] temp1 = new byte[size];\n        byte[] temp2 = new byte[size];\n        byte[] temp3 = new byte[size];\n        byte[] temp4 = new byte[size];\n        src1.get(0, 0, temp1);\n        src2.get(0, 0, temp2);\n        src3.get(0, 0, temp3);\n\n        for (int i = 0; i < size; i++) {\n            temp4[i] = chooseBig(chooseBig(temp1[i], temp2[i]), temp3[i]);\n        }\n\n        dst.put(0, 0, temp4);\n    }\n\n    private byte chooseBig(byte a, byte b) {\n        if(b > a) {\n            return b;\n        }else {\n            return a;\n        }\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic final class Example1 {\n\n    private static FLANDMARK_Model loadFLandmarkModel(final File file) throws IOException {\n        if (!file.exists()) {\n            throw new FileNotFoundException(\"FLandmark model file does not exist: \" + file.getAbsolutePath());\n        }\n\n        final FLANDMARK_Model model = flandmark_init(\"flandmark_model.dat\");\n        if (model == null) {\n            throw new IOException(\"Failed to load FLandmark model from file: \" + file.getAbsolutePath());\n        }\n\n        return model;\n    }\n\n    private static void show(final Mat image, final String title) {\n        CanvasFrame canvas = new CanvasFrame(title, 1);\n        canvas.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        final OpenCVFrameConverter.ToIplImage converter = new OpenCVFrameConverter.ToIplImage();\n\n        canvas.showImage(converter.convert(image));\n    }\n\n    private static void detectFaceInImage(final Mat orig,\n                                          final Mat input,\n                                          final CascadeClassifier faceCascade,\n                                          final FLANDMARK_Model model,\n                                          final int[] bbox,\n                                          final double[] landmarks) throws Exception {\n\n        RectVector faces = new RectVector();\n        faceCascade.detectMultiScale(input, faces);\n\n        long nFaces = faces.size();\n        System.out.println(\"Faces detected: \" + nFaces);\n        if (nFaces == 0) {\n            throw new Exception(\"No faces detected\");\n        }\n\n        for (int iface = 0; iface < nFaces; ++iface) {\n            Rect rect = faces.get(iface);\n\n            bbox[0] = rect.x();\n            bbox[1] = rect.y();\n            bbox[2] = rect.x() + rect.width();\n            bbox[3] = rect.y() + rect.height();\n\n            flandmark_detect(new IplImage(input), bbox, model, landmarks);\n\n            rectangle(orig, new Point(bbox[0], bbox[1]), new Point(bbox[2], bbox[3]), new Scalar(255, 0, 0, 128));\n            rectangle(orig,\n                    new Point((int) model.bb().get(0), (int) model.bb().get(1)),\n                    new Point((int) model.bb().get(2), (int) model.bb().get(3)), new Scalar(0, 0, 255, 128));\n            circle(orig,\n                    new Point((int) landmarks[0], (int) landmarks[1]), 3,\n                    new Scalar(0, 0, 255, 128), CV_FILLED, 8, 0);\n            for (int i = 2; i < 2 * model.data().options().M(); i += 2) {\n                circle(orig, new Point((int) (landmarks[i]), (int) (landmarks[i + 1])), 3,\n                        new Scalar(255, 0, 0, 128), CV_FILLED, 8, 0);\n            }\n        }\n    }\n\n\n    public static void main(String[] args) {\n\n        final File inputImage = new File(\"face.jpg\");\n        final File faceCascadeFile = new File(\"haarcascade_frontalface_alt.xml\");\n        final File flandmarkModelFile = new File(\"flandmark_model.dat\");\n\n        try {\n            CascadeClassifier faceCascade = new CascadeClassifier(faceCascadeFile.getCanonicalPath());\n\n            final FLANDMARK_Model model = loadFLandmarkModel(flandmarkModelFile);\n            System.out.println(\"Model w_cols: \" + model.W_COLS());\n            System.out.println(\"Model w_rows: \" + model.W_ROWS());\n\n            Mat image = imread(inputImage.getCanonicalPath());\n            show(image, \"Example 1 - original\");\n\n            Mat imageBW = new Mat();\n            cvtColor(image, imageBW, CV_BGR2GRAY);\n            show(imageBW, \"Example 1 - BW input\");\n\n            final int[] bbox = new int[4];\n            final double[] landmarks = new double[2 * model.data().options().M()];\n            detectFaceInImage(image, imageBW, faceCascade, model, bbox, landmarks);\n\n            show(image, \"Example 1 - output\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\nclass BasicLinearTransformRun{\n\n    double alpha;\n    int beta;\n\n    public void run() {\n\n        Scanner scan = new Scanner( System.in );\n\n        Mat image = Imgcodecs.imread(\"lena.jpg\");\n        Mat new_image = Mat.zeros( image.size(), image.type() );\n\n        System.out.println(\" Basic Linear Transforms \");\n        System.out.println(\"-------------------------\");\n        System.out.print(\"* Enter the alpha value [1.0-3.0]: \");\n        alpha = scan.nextDouble();\n        System.out.print(\"* Enter the beta value [0-100]: \");\n        beta = scan.nextInt();\n\n        for( int y = 0; y < image.rows(); y++ ) {\n            for( int x = 0; x < image.cols(); x++ ) {\n\n                double r = alpha * (image.get(y, x)[0]) + beta;\n                double g = alpha * (image.get(y, x)[1]) + beta;\n                double b = alpha * (image.get(y, x)[2]) + beta;\n\n                new_image.put(y, x, new double[]{r, g, b});\n            }\n        }\n\n        Image img = toBufferedImage( image );\n        displayImage( \"Original Image\", img, 0, 200 );\n\n        Image img2 = toBufferedImage( new_image );\n        displayImage( \"New Image\", img2, 400, 400 );\n\n    }\n\n    public Image toBufferedImage(Mat m) {\n        int type = BufferedImage.TYPE_BYTE_GRAY;\n        if ( m.channels() > 1 ) {\n            type = BufferedImage.TYPE_3BYTE_BGR;\n        }\n        int bufferSize = m.channels()*m.cols()*m.rows();\n        byte [] b = new byte[bufferSize];\n        m.get(0,0,b); // get all the pixels\n        BufferedImage image = new BufferedImage(m.cols(),m.rows(), type);\n        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n        System.arraycopy(b, 0, targetPixels, 0, b.length);\n        return image;\n    }\n\n    public void displayImage(String title, Image img, int x, int y)\n    {\n        ImageIcon icon=new ImageIcon(img);\n        JFrame frame=new JFrame(title);\n        JLabel lbl=new JLabel(icon);\n        frame.add(lbl);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.pack();\n        frame.setLocation(x, y);\n        frame.setVisible(true);\n    }\n\n}\n\npublic class BasicLinearTransform {\n    public static void main(String[] args) {\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n        new BasicLinearTransformRun().run();\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/home\").setViewName(\"home\");\n        registry.addViewController(\"/\").setViewName(\"home\");\n        registry.addViewController(\"/hello\").setViewName(\"hello\");\n        registry.addViewController(\"/login\").setViewName(\"login\");\n    }\n\n}", "nl": "spring"}
{"code": "\n\npublic class Thresh {\n   public static void main(String args[]) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap14/thresh_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n      Imgproc.threshold(src, dst, 50, 255, Imgproc.THRESH_BINARY);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap14/thresh_trunc.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class Controller {\n\n\tprivate final Double ROI_WIDTH = 120.0;\n\tprivate final Double ROI_HEIGHT = 35.0;\n\n\tprivate final int DEFAULT_BLUR = 3;\n\tprivate final int DEFAULT_CANNY_THRESHOLD = 29;\n\tprivate final int DEFAULT_CANNY_RATIO = 3;\n\tprivate final int DEFAULT_APERTURE_SIZE = 3;\n\n\tprivate final int DEFAULT_HOUGH_RHO = 1;\n\tprivate final int DEFAULT_HOUGH_THETA = 180;\n\tprivate final int DEFAULT_HOUGH_THRESHOLD = 26;\n\tprivate final int DEFAULT_MIN_LENGHT = 20;\n\tprivate final int DEFAULT_MAX_GAP = 5;\n\n\tprivate final int DEFAULT_MIN_SLOPE = 10;\n\tprivate final int DEFAULT_MAX_SLOPE = 90;\n\tprivate final int DEFAULT_CANDIDATES_NUMBER = 7;\n\tprivate final int DEFAULT_MIN_ALPHA = 65;\n\tprivate final int DEFAULT_MAX_ALPHA = 120;\n\tprivate final int DEFAULT_HORIZON_VARIANCE = 30;\n\tprivate final int DEFAULT_FRAMES_TO_SHOW = 9;\n\tprivate final int DEFAULT_FRAMES_TO_HIDE = 9;\n\n\t@FXML\n\tprivate CheckMenuItem menuItemShowDebug;\n\t@FXML\n\tprivate ImageView currentImage;\n\t@FXML\n\tprivate Label lblFileName;\n\t@FXML\n\tprivate Label lblTime;\n\t@FXML\n\tprivate Label lblFrame;\n\t@FXML\n\tprivate Slider sliROIWidth;\n\t@FXML\n\tprivate Slider sliROIHeight;\n\t@FXML\n\tprivate Slider sliROIHorizontalPosition;\n\t@FXML\n\tprivate Slider sliROIVerticalPosition;\n\t@FXML\n\tprivate StackPane stackpROI;\n\t@FXML\n\tprivate ImageView imgMoveROIUpDown;\n\t@FXML\n\tprivate ImageView imgMoveROILeftRight;\n\t@FXML\n\tprivate ImageView imgResizeROIHorizontally;\n\t@FXML\n\tprivate ImageView imgResizeROIVertically;\n\t@FXML\n\tprivate Rectangle rectROI;\n\t@FXML\n\tprivate SplitPane splitPaneDebug;\n\t@FXML\n\tprivate AnchorPane paneControls;\n\t@FXML\n\tprivate Button btnPlayPause;\n\t@FXML\n\tprivate ImageView imgPlayPause;\n\t@FXML\n\tprivate SplitPane mainSplitPane;\n\t@FXML\n\tprivate Label lblSpeed;\n\n\t@FXML\n\tprivate ScrollPane debugScrollPane;\n\n\t@FXML\n\tprivate Slider sliCannyThreshold;\n\t@FXML\n\tprivate TextField txtCannyThreshold;\n\t@FXML\n\tprivate Slider sliCannyRatio;\n\t@FXML\n\tprivate TextField txtCannyRatio;\n\t@FXML\n\tprivate Slider sliBlur;\n\t@FXML\n\tprivate TextField txtBlur;\n\t@FXML\n\tprivate ComboBox<Integer> cmbApertureSize;\n\n\t@FXML\n\tprivate Slider sliHoughRho;\n\t@FXML\n\tprivate TextField txtHoughRho;\n\t@FXML\n\tprivate Slider sliHoughTheta;\n\t@FXML\n\tprivate TextField txtHoughTheta;\n\t@FXML\n\tprivate Slider sliHoughThreshold;\n\t@FXML\n\tprivate TextField txtHoughThreshold;\n\t@FXML\n\tprivate Slider sliMinLenght;\n\t@FXML\n\tprivate TextField txtMinLenght;\n\t@FXML\n\tprivate Slider sliMaxGap;\n\t@FXML\n\tprivate TextField txtMaxGap;\n\n\t@FXML\n\tprivate Slider sliMinSlope;\n\t@FXML\n\tprivate TextField txtMinSlope;\n\t@FXML\n\tprivate Slider sliMaxSlope;\n\t@FXML\n\tprivate TextField txtMaxSlope;\n\t@FXML\n\tprivate Slider sliCandidatesNumber;\n\t@FXML\n\tprivate TextField txtCandidatesNumber;\n\t@FXML\n\tprivate Slider sliMinAlpha;\n\t@FXML\n\tprivate TextField txtMinAlpha;\n\t@FXML\n\tprivate Slider sliMaxAlpha;\n\t@FXML\n\tprivate TextField txtMaxAlpha;\n\t@FXML\n\tprivate Slider sliHorizonVariance;\n\t@FXML\n\tprivate TextField txtHorizonVariance;\n\t@FXML\n\tprivate Slider sliFramesToShow;\n\t@FXML\n\tprivate TextField txtFramesToShow;\n\t@FXML\n\tprivate Slider sliFramesToHide;\n\t@FXML\n\tprivate TextField txtFramesToHide;\n\t@FXML\n\tprivate CheckBox chkBorders;\n\t@FXML\n\tprivate CheckBox chkDetectedSegments;\n\t@FXML\n\tprivate CheckBox chkCandidateStripes;\n\t@FXML\n\tprivate CheckBox chkFinalStripes;\n\t@FXML\n\tprivate CheckBox chkLane;\n\t@FXML\n\tprivate CheckBox chkROI;\n\n\tprivate Stage stage;\n\tprivate Node debugPane;\n\tprivate Image playImg;\n\tprivate Image pauseImg;\n\n\tprivate Insets spROIPadding;\n\tprivate double hPaddingMax;\n\tprivate double vPaddingMax;\n\tprivate double curROIPaneWidth;\n\tprivate double curROIPaneHeight;\n\tprivate double frameWidth;\n\tprivate double frameHeight;\n\tprivate Point leftTopPointROI;\n\tprivate Point rightBottomPointROI;\n\tprivate Rect roi;\n\n\tprivate ScheduledExecutorService timer;\n\tprivate ScheduledFuture<?> future;\n\tprivate VideoCapture capture = new VideoCapture();\n\tprivate Runnable forwardFrameGrabber;\n\tprivate Runnable backwardFrameGrabber;\n\tprivate Mat currentFrame;\n\t\n\tprivate int framesToShowCounter;\n\tprivate int framesToHideCounter;\n\tprivate LinePair lastLane;\n\n\tprivate int frameCounter;\n\tprivate float speedMultiplier;\n\tprivate boolean rewind;\n\n\t\n\tprotected void initializeGUI(Stage stage) {\n\t\tthis.stage = stage;\n\t\tleftTopPointROI = new Point();\n\t\trightBottomPointROI = new Point();\n\t\troi = new Rect();\n\t\tsetGUIDisabled(true);\n\n\t\t\n\t\tdebugPane = mainSplitPane.getItems().get(1);\n\n\t\ttxtBlur.setText(String.valueOf(DEFAULT_BLUR));\n\t\tsliBlur.setValue(DEFAULT_BLUR);\n\t\ttxtCannyThreshold.setText(String.valueOf(DEFAULT_CANNY_THRESHOLD));\n\t\tsliCannyThreshold.setValue(DEFAULT_CANNY_THRESHOLD);\n\t\ttxtCannyRatio.setText(String.valueOf(DEFAULT_CANNY_RATIO));\n\t\tsliCannyRatio.setValue(DEFAULT_CANNY_RATIO);\n\t\tcmbApertureSize.getItems().addAll(3, 5, 7);\n\t\tcmbApertureSize.setValue(DEFAULT_APERTURE_SIZE);\n\n\t\ttxtHoughRho.setText(String.valueOf(DEFAULT_HOUGH_RHO));\n\t\tsliHoughRho.setValue(DEFAULT_HOUGH_RHO);\n\t\ttxtHoughTheta.setText(String.valueOf(DEFAULT_HOUGH_THETA));\n\t\tsliHoughTheta.setValue(DEFAULT_HOUGH_THETA);\n\t\ttxtHoughThreshold.setText(String.valueOf(DEFAULT_HOUGH_THRESHOLD));\n\t\tsliHoughThreshold.setValue(DEFAULT_HOUGH_THRESHOLD);\n\t\ttxtMinLenght.setText(String.valueOf(DEFAULT_MIN_LENGHT));\n\t\tsliMinLenght.setValue(DEFAULT_MIN_LENGHT);\n\t\ttxtMaxGap.setText(String.valueOf(DEFAULT_MAX_GAP));\n\t\tsliMaxGap.setValue(DEFAULT_MAX_GAP);\n\n\t\ttxtMinSlope.setText(String.valueOf(DEFAULT_MIN_SLOPE));\n\t\tsliMinSlope.setValue(DEFAULT_MIN_SLOPE);\n\t\ttxtMaxSlope.setText(String.valueOf(DEFAULT_MAX_SLOPE));\n\t\tsliMaxSlope.setValue(DEFAULT_MAX_SLOPE);\n\t\ttxtCandidatesNumber.setText(String.valueOf(DEFAULT_CANDIDATES_NUMBER));\n\t\tsliCandidatesNumber.setValue(DEFAULT_CANDIDATES_NUMBER);\n\t\ttxtMinAlpha.setText(String.valueOf(DEFAULT_MIN_ALPHA));\n\t\tsliMinAlpha.setValue(DEFAULT_MIN_ALPHA);\n\t\ttxtMaxAlpha.setText(String.valueOf(DEFAULT_MAX_ALPHA));\n\t\tsliMaxAlpha.setValue(DEFAULT_MAX_ALPHA);\n\t\ttxtHorizonVariance.setText(String.valueOf(DEFAULT_HORIZON_VARIANCE));\n\t\tsliHorizonVariance.setValue(DEFAULT_HORIZON_VARIANCE);\n\t\ttxtFramesToShow.setText(String.valueOf(DEFAULT_FRAMES_TO_SHOW));\n\t\tsliFramesToShow.setValue(DEFAULT_FRAMES_TO_SHOW);\n\t\ttxtFramesToHide.setText(String.valueOf(DEFAULT_FRAMES_TO_HIDE));\n\t\tsliFramesToHide.setValue(DEFAULT_FRAMES_TO_HIDE);\n\n\t\ttry {\n\t\t\tplayImg = new Image(getClass().getResourceAsStream(\"/play32x32.png\"));\n\t\t\tpauseImg = new Image(getClass().getResourceAsStream(\"/pause32x32.png\"));\n\t\t\timgPlayPause.setImage(playImg);\n\n\t\t} catch (IllegalArgumentException iae) {\n\t\t\tAlert alert = new Alert(AlertType.ERROR);\n\t\t\talert.setTitle(\"Illegal Argument Exception\");\n\t\t\talert.setHeaderText(iae.getMessage());\n\t\t\talert.showAndWait();\n\t\t}\n\t}\n\n\tprivate void initVideo() {\t\n\t\tframesToShowCounter = 0;\n\t\tframesToHideCounter = 0;\n\t\t\n\t\tlastLane = new LinePair(new Line(), new Line());\n\t\t\n\t\tframeCounter = 0;\n\t\tspeedMultiplier = 1;\n\t\trewind = false;\n\t}\n\t\n\tprivate void initScheduler() {\n\t\tforwardFrameGrabber = new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tcurrentFrame = grabFrame();\n\t\t\t\tprocessAndShowFrame();\n\t\t\t\tshowInfo();\n\t\t\t}\n\t\t};\n\n\t\tbackwardFrameGrabber = new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif (frameCounter > 1) {\n\t\t\t\t\tframeCounter -= 2;\n\t\t\t\t\tcapture.set(Videoio.CAP_PROP_POS_FRAMES, frameCounter);\n\t\n\t\t\t\t\tcurrentFrame = grabFrame();\n\t\t\t\t\tshowFrame(currentFrame);\n\t\t\t\t\tshowInfo();\n\t\t\t\t} else {\n\t\t\t\t\tsetStop();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\ttimer = Executors.newSingleThreadScheduledExecutor();\n\t}\n\n\t\n\t@FXML\n\tprivate void actionMenuOpen() {\n\n\t\tString userDir = System.getProperty(\"user.home\");\n\t\tFileChooser fileChooser = new FileChooser();\n\t\tfileChooser.setInitialDirectory(new File(userDir + \"/Videos\"));\n\t\tfileChooser.setTitle(\"Open File\");\n\t\tfileChooser.getExtensionFilters().addAll(new ExtensionFilter(\"Video Files\", \"*.avi\", \"*.mp4\", \".mkv\", \".mov\"));\n\t\tFile video = fileChooser.showOpenDialog(null);\n\n\t\tif (video != null) {\n\t\t\tif (capture.isOpened()) {\n\t\t\t\tsetClosed();\n\t\t\t}\n\n\t\t\tcapture.open(video.getAbsolutePath());\n\n\t\t\tif (capture.isOpened()) {\n\t\t\t\tlblFileName.setText(video.getName());\n\t\t\t\tframeWidth = capture.get(Videoio.CAP_PROP_FRAME_WIDTH);\n\t\t\t\tframeHeight = capture.get(Videoio.CAP_PROP_FRAME_HEIGHT);\n\n\t\t\t\tsetGUIDisabled(false);\t\n\n\t\t\t\tcurrentFrame = null;\n\t\t\t\t\n\t\t\t\tinitVideo();\n\t\t\t\tinitScheduler();\n\t\t\t\tsetPlayPause();\n\t\t\t\t\n\t\t\t\tcomputeROIDimension();\n\t\t\t\tcomputePointsForROI();\n\t\t\t\tdragROIHeight();\n\t\t\t\tdragROIWidth();\n\t\t\t\tdragROIHorizontalPosition();\n\t\t\t\tdragROIVerticalPosition();\t\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tAlert alert = new Alert(AlertType.ERROR);\n\t\t\t\talert.setTitle(\"Error\");\n\t\t\t\talert.setHeaderText(\"The video cannot be opened\");\n\t\t\t\talert.showAndWait();\n\t\t\t}\n\t\t}\n\t}\n\n\t@FXML\n\tprivate void actionMenuClose() {\n\t\tsetClosed();\n\t}\n\n\t@FXML\n\tprivate void checkMenuItemDebug() {\n\t\tif (menuItemShowDebug.isSelected()) {\n\t\t\tmainSplitPane.getItems().add(1, debugPane);\n\t\t\tstage.setWidth(stage.getWidth() + 235);\n\n\t\t} else {\n\t\t\tmainSplitPane.getItems().remove(debugPane);\n\t\t\tstage.setWidth(stage.getWidth() - 235);\n\t\t}\n\t}\n\n\tprotected void setGUIDisabled(boolean value) {\n\t\tpaneControls.setDisable(value);\n\t\tsplitPaneDebug.setDisable(value);\n\t\tif (value) {\n\t\t\trectROI.setVisible(false);\n\t\t\tstackpROI.setStyle(\"-fx-border-color: lightgrey ;\");\n\t\t} else {\n\t\t\thPaddingMax = stackpROI.getWidth() - rectROI.getWidth();\n\t\t\tvPaddingMax = stackpROI.getHeight() - rectROI.getHeight();\n\t\t\tDouble padding = hPaddingMax / 2;\n\t\t\tspROIPadding = stackpROI.getPadding();\n\t\t\tstackpROI.setPadding(new Insets(spROIPadding.getTop(), spROIPadding.getRight(), 0.0, padding));\n\t\t\tcurROIPaneWidth = stackpROI.getWidth();\n\t\t\tcurROIPaneHeight = stackpROI.getHeight();\n\t\t\trectROI.setVisible(true);\n\t\t\tstackpROI.setStyle(\"-fx-border-color: grey ;\");\n\t\t}\n\t}\n\n\tprotected void setClosed() {\t\n\t\tif (this.timer != null && !this.timer.isShutdown()) {\n\t\t\t\n\t\t\tsetStop();\n\t\t\tsetGUIDisabled(true);\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.timer.shutdown();\n\t\t\t\tthis.timer.awaitTermination(33, TimeUnit.MILLISECONDS);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tAlert alert = new Alert(AlertType.ERROR);\n\t\t\t\talert.setTitle(\"Error while trying to close the video\");\n\t\t\t\talert.setHeaderText(e.getMessage());\n\t\t\t\talert.showAndWait();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\n\t\tif (capture != null && capture.isOpened()) {\n\t\t\tcapture.release();\n\t\t\tUtils.onFXThread(currentImage.imageProperty(), null);\n\t\t}\n\n\t}\n\n\t\n\tprivate Mat grabFrame() {\n\t\tif (frameCounter < 0) {\n\t\t\tsetStop();\n\t\t\treturn null;\n\t\t} else {\n\t\t\tMat frame = new Mat();\n\n\t\t\tif (this.capture.isOpened()) {\n\t\t\t\tthis.capture.read(frame);\n\n\t\t\t\tif (frame.empty()) {\n\t\t\t\t\tsetStop();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tframeCounter = (int) capture.get(Videoio.CAP_PROP_POS_FRAMES);\n\t\t\treturn frame;\n\t\t}\n\t}\n\n\t\n\t@FXML\n\tprivate void processAndShowFrame() {\n\t\tif (currentFrame != null) {\n\t\t\tMat frame = currentFrame.clone();\n\t\t\tMat imageROI = frame.submat(roi);\n\t\t\tMat workingROI = imageROI.clone();\n\n\t\t\tImgproc.cvtColor(imageROI, workingROI, Imgproc.COLOR_BGR2GRAY);\n\t\t\tImgproc.blur(workingROI, workingROI, new Size(sliBlur.getValue(), sliBlur.getValue()));\n\t\t\tImgproc.Canny(workingROI, workingROI, sliCannyThreshold.getValue(),\n\t\t\t\t\tsliCannyRatio.getValue() * sliCannyThreshold.getValue(), (int) cmbApertureSize.getValue(), false);\n\n\t\t\tMat lines = new Mat();\n\t\t\tImgproc.HoughLinesP(workingROI, lines, sliHoughRho.getValue(), Math.PI / sliHoughTheta.getValue(),\n\t\t\t\t\t(int) sliHoughThreshold.getValue(), sliMinLenght.getValue(), sliMaxGap.getValue());\n\n\t\t\tPoint lowerCenter = new Point(workingROI.cols() / 2, workingROI.rows());\n\t\t\tPoint upperCenter = new Point(workingROI.cols() / 2, 0);\n\n\t\t\tArrayList<Line> leftList = new ArrayList<Line>();\n\t\t\tArrayList<Line> rightList = new ArrayList<Line>();\n\n\t\t\tfor (int i = 0; i < lines.rows(); i++) {\n\t\t\t\tdouble[] val = lines.get(i, 0);\n\n\t\t\t\tPoint p1, p2;\n\t\t\t\tif (val[1] < val[3]) {\n\t\t\t\t\tp1 = new Point(val[0], val[1]);\n\t\t\t\t\tp2 = new Point(val[2], val[3]);\n\t\t\t\t} else {\n\t\t\t\t\tp1 = new Point(val[2], val[3]);\n\t\t\t\t\tp2 = new Point(val[0], val[1]);\n\t\t\t\t}\n\n\n\n\t\t\t\tRect clipping = new Rect(Integer.MIN_VALUE / 2, 0, Integer.MAX_VALUE, workingROI.rows());\n\t\t\t\tdouble slope = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\t\t\t\t\n\t\t\t\tif (p2.x <= lowerCenter.x \n\t\t\t\t\t\t&& slope > Math.toRadians(180 - sliMaxSlope.getValue())\n\t\t\t\t\t\t&& slope < Math.toRadians(180 - sliMinSlope.getValue())) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif (chkDetectedSegments.isSelected())\n\t\t\t\t\t\tImgproc.line(imageROI, p1, p2, new Scalar(255, 0, 255), 2);\n\t\t\t\t\t\n\t\t\t\t\tleftList.add(new Line(p1, p2, slope, clipping));\n\t\t\t\t} else if (p2.x > lowerCenter.x \n\t\t\t\t\t\t&& slope > Math.toRadians(sliMinSlope.getValue())\n\t\t\t\t\t\t&& slope < Math.toRadians(sliMaxSlope.getValue())) {\n\t\t\t\t\t\n\t\t\t\t\tif (chkDetectedSegments.isSelected())\n\t\t\t\t\t\tImgproc.line(imageROI, p1, p2, new Scalar(255, 0, 255), 2);\n\n\t\t\t\t\trightList.add(new Line(p1, p2, slope, clipping));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tleftList.sort((Line l1, Line l2) -> (int) l2.getLower().x - (int) l1.getLower().x);\n\t\t\trightList.sort((Line l1, Line l2) -> (int) l1.getLower().x - (int) l2.getLower().x);\n\n\t\t\tleftList = new ArrayList<Line>(leftList.subList(0, Math.min(leftList.size(), (int) sliCandidatesNumber.getValue())));\n\t\t\trightList = new ArrayList<Line>(rightList.subList(0, Math.min(rightList.size(), (int) sliCandidatesNumber.getValue())));\n\n\t\t\tArrayList<LinePair> pairList = new ArrayList<LinePair>();\n\t\t\tfor (Line leftLine : leftList) {\n\t\t\t\t\n\t\t\t\tif (chkCandidateStripes.isSelected())\n\t\t\t\t\tImgproc.line(imageROI, leftLine.getUpper(), leftLine.getLower(), new Scalar(255, 255, 0), 4);\n\t\t\t\t\n\t\t\t\tfor (Line rightLine : rightList) {\n\t\t\t\t\t\n\t\t\t\t\tif (chkCandidateStripes.isSelected())\n\t\t\t\t\t\tImgproc.line(imageROI, rightLine.getUpper(), rightLine.getLower(), new Scalar(255, 255, 0), 4);\n\t\t\t\t\t\n\t\t\t\t\tLinePair pair = new LinePair(leftLine, rightLine);\n\t\t\t\t\tif (pair.getAlpha() > Math.toRadians(sliMinAlpha.getValue()) && pair.getAlpha() < Math.toRadians(sliMaxAlpha.getValue())\n\t\t\t\t\t\t\t&& Utils.EuclideanDistance(upperCenter, pair.getIntersection()) < sliHorizonVariance.getValue()) {\t\n\t\t\t\t\t\tpairList.add(pair);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t\tif (!pairList.isEmpty()) {\n\t\t\t\t\n\t\t\t\tframesToShowCounter++;\n\t\t\t\tframesToHideCounter = 0;\n\t\t\t\t\n\t\t\t\tpairList.sort((LinePair lp1, LinePair lp2) -> {\n\t\t\t\t\tdouble d1 = Math.abs(lastLane.getAlpha() - lp1.getAlpha());\n\t\t\t\t\tdouble d2 = Math.abs(lastLane.getAlpha() - lp2.getAlpha());\n\t\t\t\t\t\n\t\t\t\t\tif (d1 < d2)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\telse if (d2 > d1)\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tlastLane = pairList.get(0);\n\t\t\t\t\n\t\t\t} else {\t\t\t\t\n\t\t\t\tframesToHideCounter++;\n\t\t\t\tif (framesToHideCounter > sliFramesToHide.getValue())\n\t\t\t\t\tframesToShowCounter = 0;\n\t\t\t}\n\t\t\t\n\t\t\tif (framesToShowCounter > sliFramesToShow.getValue()) {\n\t\t\t\t\n\t\t\t\tLine left = lastLane.getLeft();\n\t\t\t\tLine right = lastLane.getRight();\n\t\t\t\tPoint intersection = lastLane.getIntersection();\n\n\t\t\t\tdouble leftDelta = lowerCenter.x - left.getLower().x;\n\t\t\t\tdouble rightDelta = right.getLower().x - lowerCenter.x;\n\n\t\t\t\tScalar laneColor = (leftDelta < rightDelta) ? new Scalar(0, leftDelta, 255 - leftDelta)\n\t\t\t\t\t\t: new Scalar(0, rightDelta, 255 - rightDelta);\n\n\t\t\t\tif (chkFinalStripes.isSelected()) {\n\t\t\t\t\tMat stripesROI = imageROI.clone();\n\t\t\t\t\tImgproc.line(stripesROI, intersection, left.getLower(), new Scalar(0, leftDelta, 255 - leftDelta), 6);\n\t\t\t\t\tImgproc.line(stripesROI, intersection, right.getLower(), new Scalar(0, rightDelta, 255 - rightDelta), 6);\n\t\t\t\t\tCore.addWeighted(imageROI, 1.0 - 0.7, stripesROI, 0.7, 0.0, imageROI);\n\t\t\t\t}\n\n\t\t\t\tif (chkLane.isSelected()) {\n\t\t\t\t\tMat laneROI = imageROI.clone();\n\t\t\t\t\tMatOfPoint lane = new MatOfPoint(intersection, left.getLower(), right.getLower(), intersection);\n\t\t\t\t\tImgproc.fillConvexPoly(laneROI, lane, laneColor);\n\t\t\t\t\tCore.addWeighted(imageROI, 1.0 - 0.4, laneROI, 0.4, 0.0, imageROI);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chkBorders.isSelected()) {\n\t\t\t\tImgproc.cvtColor(workingROI, workingROI, Imgproc.COLOR_GRAY2BGR);\n\t\t\t\tCore.addWeighted(imageROI, 1.0, workingROI, 0.7, 0.0, imageROI);\n\t\t\t}\n\n\t\t\tif (chkROI.isSelected()) {\n\t\t\t\tImgproc.rectangle(frame, leftTopPointROI, rightBottomPointROI, new Scalar(255, 255, 255), 2);\n\t\t\t\tImgproc.line(imageROI, lowerCenter, new Point(lowerCenter.x, 0), new Scalar(255, 255, 255), 2);\n\t\t\t}\n\n\t\t\tshowFrame(frame);\n\t\t}\n\t}\n\n\t\n\tprivate void showFrame(Mat frame) {\n\t\tImage imageToShow = Utils.mat2Image(frame);\n\t\tUtils.onFXThread(currentImage.imageProperty(), imageToShow);\n\t}\n\n\t\n\tprivate void showInfo() {\n\t\tint millis = (frameCounter - 1) * 33;\n\t\tint seconds = millis / 1000;\n\t\tint minutes = (seconds / 60) % 60;\n\t\tseconds %= 60;\n\t\tmillis %= 1000;\n\t\tString time = String.format(\"%02d\", minutes) + \":\" + String.format(\"%02d\", seconds) + \":\"\n\t\t\t\t+ String.format(\"%04d\", millis);\n\n\t\tPlatform.runLater(() -> {\n\t\t\tlblFrame.setText(Integer.toString(frameCounter));\n\t\t\tlblTime.setText(time);\n\t\t\tif (speedMultiplier > 0.9 && speedMultiplier < 1.1) {\n\t\t\t\tlblSpeed.setVisible(false);\n\t\t\t} else {\n\t\t\t\tlblSpeed.setText(\n\t\t\t\t\t\tnew BigDecimal(speedMultiplier).setScale(3, RoundingMode.DOWN).stripTrailingZeros().toString()\n\t\t\t\t\t\t\t\t+ \"x\");\n\t\t\t}\n\t\t});\n\t}\n\n\n\t\n\t@FXML\n\tprivate void setStop() {\n\t\trewind = false;\n\t\tspeedMultiplier = 1;\n\t\timgPlayPause.setImage(playImg);\n\t\tif (!future.isCancelled())\n\t\t\tfuture.cancel(false);\n\t\tlblSpeed.setVisible(false);\n\n\t\tcapture.set(Videoio.CAP_PROP_POS_FRAMES, 0);\n\t\tinitVideo();\n\n\t\tcurrentFrame = grabFrame();\n\t\tprocessAndShowFrame();\n\t\tshowInfo();\n\t}\n\n\t\n\t@FXML\n\tprivate void setPlayPause() {\n\t\tif (imgPlayPause.getImage().equals(playImg)) {\n\t\t\tif (rewind) {\n\t\t\t\tif (!future.isCancelled())\n\t\t\t\t\tfuture.cancel(false);\n\t\t\t\trewind = false;\n\t\t\t\tspeedMultiplier = 1;\n\t\t\t}\n\n\t\t\tlblSpeed.setVisible(true);\n\t\t\timgPlayPause.setImage(pauseImg);\n\t\t\tfuture = timer.scheduleAtFixedRate(forwardFrameGrabber, 0, (long) (33 / speedMultiplier),\n\t\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t} else {\n\t\t\timgPlayPause.setImage(playImg);\n\t\t\tif (!future.isCancelled())\n\t\t\t\tfuture.cancel(false);\n\t\t\tlblSpeed.setVisible(false);\n\t\t}\n\t}\n\n\t\n\t@FXML\n\tprivate void setPreviousFrame() {\n\t\tif (imgPlayPause.getImage().equals(pauseImg) || rewind) {\n\t\t\trewind = false;\n\t\t\timgPlayPause.setImage(playImg);\n\t\t\tif (!future.isCancelled())\n\t\t\t\tfuture.cancel(false);\n\t\t\tlblSpeed.setVisible(false);\n\t\t}\n\n\t\tframeCounter -= 2;\n\t\tcapture.set(Videoio.CAP_PROP_POS_FRAMES, frameCounter);\n\n\t\tcurrentFrame = grabFrame();\n\t\tprocessAndShowFrame();\n\t\tshowInfo();\n\t}\n\n\t\n\t@FXML\n\tprivate void setNextFrame() {\n\t\tif (imgPlayPause.getImage().equals(pauseImg) || rewind) {\n\t\t\trewind = false;\n\t\t\timgPlayPause.setImage(playImg);\n\t\t\tif (!future.isCancelled())\n\t\t\t\tfuture.cancel(false);\n\t\t\tlblSpeed.setVisible(false);\n\t\t}\n\n\t\tcurrentFrame = grabFrame();\n\t\tprocessAndShowFrame();\n\t\tshowInfo();\n\t}\n\n\t\n\t@FXML\n\tprivate void setRewind() {\n\t\tif (!rewind) {\n\t\t\tspeedMultiplier = 1;\n\t\t\timgPlayPause.setImage(playImg);\n\t\t\trewind = true;\n\t\t}\n\n\t\tif (speedMultiplier < 32) {\n\t\t\tspeedMultiplier *= 2;\n\t\t}\n\n\t\tlblSpeed.setVisible(true);\n\n\t\tif (!future.isCancelled())\n\t\t\tfuture.cancel(false);\n\t\tfuture = timer.scheduleAtFixedRate(backwardFrameGrabber, 0, (long) (33 / speedMultiplier),\n\t\t\t\tTimeUnit.MILLISECONDS);\n\t}\n\n\t\n\t@FXML\n\tprivate void setSlow() {\n\t\tif (imgPlayPause.getImage().equals(playImg))\n\t\t\timgPlayPause.setImage(pauseImg);\n\n\t\tif (speedMultiplier > (float) 1 / 8)\n\t\t\tspeedMultiplier /= 2;\n\n\t\tlblSpeed.setVisible(true);\n\t\trewind = false;\n\n\t\tif (!future.isCancelled())\n\t\t\tfuture.cancel(false);\n\t\tfuture = timer.scheduleAtFixedRate(forwardFrameGrabber, 0, (long) (33 / speedMultiplier),\n\t\t\t\tTimeUnit.MILLISECONDS);\n\t}\n\n\t\n\t@FXML\n\tprivate void setFastForward() {\n\t\tif (imgPlayPause.getImage().equals(playImg))\n\t\t\timgPlayPause.setImage(pauseImg);\n\n\t\tif (speedMultiplier < 32)\n\t\t\tspeedMultiplier *= 2;\n\n\t\tlblSpeed.setVisible(true);\n\t\trewind = false;\n\n\t\tif (!future.isCancelled())\n\t\t\tfuture.cancel(false);\n\t\tfuture = timer.scheduleAtFixedRate(forwardFrameGrabber, 0, (long) (33 / speedMultiplier),\n\t\t\t\tTimeUnit.MILLISECONDS);\n\t}\n\n\n\t\n\tprivate void computeROIDimension() {\n\t\tint dim = (int) Math.round(stackpROI.getWidth() * frameHeight / frameWidth);\n\t\tstackpROI.setPrefHeight(dim);\n\t\tstackpROI.setMaxHeight(dim);\n\t}\n\n\t\n\tprivate void computePointsForROI() {\n\t\tint x = (int) Math.round(stackpROI.getPadding().getLeft() * frameWidth / stackpROI.getWidth());\n\t\tint y = (int) Math\n\t\t\t\t.round(frameHeight - (stackpROI.getPadding().getBottom() * frameHeight / stackpROI.getHeight()));\n\t\tleftTopPointROI.x = x;\n\t\tleftTopPointROI.y = y - Math.round(frameHeight * rectROI.getHeight() / stackpROI.getHeight());\n\t\trightBottomPointROI.x = x + Math.round(frameWidth * rectROI.getWidth() / stackpROI.getWidth());\n\t\trightBottomPointROI.y = y;\n\t\troi = new Rect(leftTopPointROI, rightBottomPointROI);\n\n\t\tprocessAndShowFrame();\n\t}\n\n\t\n\t@FXML\n\tprivate void dragROIWidth() {\n\t\tDouble width = ROI_WIDTH + (sliROIWidth.getValue() * (stackpROI.getWidth() - ROI_WIDTH)) / 100;\n\t\tif (width >= curROIPaneWidth) {\n\t\t\twidth = curROIPaneWidth;\n\t\t\tsliROIHorizontalPosition.setDisable(true);\n\t\t} else {\n\t\t\tsliROIHorizontalPosition.setDisable(false);\n\t\t}\n\t\timgResizeROIHorizontally.setVisible(false);\n\t\trectROI.setVisible(true);\n\t\trectROI.setWidth(width);\n\n\t\thPaddingMax = stackpROI.getWidth() - rectROI.getWidth();\n\n\t\tspROIPadding = stackpROI.getPadding();\n\t\tDouble padding = sliROIHorizontalPosition.getValue() * hPaddingMax / 100;\n\t\tstackpROI.setPadding(\n\t\t\t\tnew Insets(spROIPadding.getTop(), spROIPadding.getRight(), spROIPadding.getBottom(), padding));\n\t\tcomputePointsForROI();\n\t}\n\n\t@FXML\n\tprivate void mouseEnteredResizeROIWidth() {\n\t\timgResizeROIHorizontally.setVisible(true);\n\t\trectROI.setVisible(false);\n\t}\n\n\t@FXML\n\tprivate void mouseExitedResizeROIWidth() {\n\t\timgResizeROIHorizontally.setVisible(false);\n\t\trectROI.setVisible(true);\n\t}\n\n\t\n\t@FXML\n\tprivate void dragROIHeight() {\n\t\tDouble height = ROI_HEIGHT + (sliROIHeight.getValue() * (stackpROI.getHeight() - ROI_HEIGHT)) / 100;\n\t\tif (height >= curROIPaneHeight) {\n\t\t\theight = curROIPaneHeight;\n\t\t\tsliROIVerticalPosition.setDisable(true);\n\t\t} else\n\t\t\tsliROIVerticalPosition.setDisable(false);\n\t\timgResizeROIVertically.setVisible(false);\n\t\trectROI.setVisible(true);\n\t\trectROI.setHeight(height);\n\n\t\tvPaddingMax = stackpROI.getHeight() - rectROI.getHeight();\n\n\t\tspROIPadding = stackpROI.getPadding();\n\t\tDouble padding = sliROIVerticalPosition.getValue() * vPaddingMax / 100;\n\t\tstackpROI.setPadding(\n\t\t\t\tnew Insets(spROIPadding.getTop(), spROIPadding.getRight(), padding, spROIPadding.getLeft()));\n\t\tcomputePointsForROI();\n\t}\n\n\t@FXML\n\tprivate void mouseEnteredResizeROIHeight() {\n\t\timgResizeROIVertically.setVisible(true);\n\t\trectROI.setVisible(false);\n\t}\n\n\t@FXML\n\tprivate void mouseExitedResizeROIHeight() {\n\t\timgResizeROIVertically.setVisible(false);\n\t\trectROI.setVisible(true);\n\t}\n\n\t\n\t@FXML\n\tprivate void dragROIHorizontalPosition() {\n\t\tDouble padding = sliROIHorizontalPosition.getValue() * hPaddingMax / 100;\n\t\trectROI.setVisible(true);\n\t\timgMoveROILeftRight.setVisible(false);\n\t\tspROIPadding = stackpROI.getPadding();\n\t\tstackpROI.setPadding(\n\t\t\t\tnew Insets(spROIPadding.getTop(), spROIPadding.getRight(), spROIPadding.getBottom(), padding));\n\t\tcomputePointsForROI();\n\t}\n\n\t@FXML\n\tprivate void mouseEnteredMoveROILeftRight() {\n\t\timgMoveROILeftRight.setVisible(true);\n\t\trectROI.setVisible(false);\n\t}\n\n\t@FXML\n\tprivate void mouseExitedMoveROILeftRight() {\n\t\timgMoveROILeftRight.setVisible(false);\n\t\trectROI.setVisible(true);\n\t}\n\n\t\n\t@FXML\n\tprivate void dragROIVerticalPosition() {\n\t\tDouble padding = sliROIVerticalPosition.getValue() * vPaddingMax / 100;\n\t\tspROIPadding = stackpROI.getPadding();\n\t\timgMoveROIUpDown.setVisible(false);\n\t\trectROI.setVisible(true);\n\t\tstackpROI.setPadding(\n\t\t\t\tnew Insets(spROIPadding.getTop(), spROIPadding.getRight(), padding, spROIPadding.getLeft()));\n\t\tcomputePointsForROI();\n\t}\n\n\t@FXML\n\tprivate void mouseEnteredMoveROIUpDown() {\n\t\timgMoveROIUpDown.setVisible(true);\n\t\trectROI.setVisible(false);\n\t}\n\n\t@FXML\n\tprivate void mouseExitedMoveROIUpDown() {\n\t\timgMoveROIUpDown.setVisible(false);\n\t\trectROI.setVisible(true);\n\t}\n\n\n\t@FXML\n\tprivate void dragBlur() {\n\t\tint value = (int) sliBlur.getValue();\n\t\ttxtBlur.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setBlur() {\n\t\tString text = txtBlur.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliBlur.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtBlur.setText(String.valueOf((int) sliBlur.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragCannyThreshold() {\n\t\tint value = (int) sliCannyThreshold.getValue();\n\t\ttxtCannyThreshold.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setCannyThreshold() {\n\t\tString text = txtCannyThreshold.getText();\n\t\tif (text.matches(\"\\\\d*\")) {\n\t\t\tsliCannyThreshold.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtCannyThreshold.setText(String.valueOf((int) sliCannyThreshold.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragCannyRatio() {\n\t\tint value = (int) sliCannyRatio.getValue();\n\t\ttxtCannyRatio.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setCannyRatio() {\n\t\tString text = txtCannyRatio.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliCannyRatio.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtCannyRatio.setText(String.valueOf((int) sliCannyRatio.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\n\t@FXML\n\tprivate void dragHoughRho() {\n\t\tint value = (int) sliHoughRho.getValue();\n\t\ttxtHoughRho.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setHoughRho() {\n\t\tString text = txtHoughRho.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliHoughRho.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtHoughRho.setText(String.valueOf((int) sliHoughRho.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragHoughTheta() {\n\t\tint value = (int) sliHoughTheta.getValue();\n\t\ttxtHoughTheta.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setHoughTheta() {\n\t\tString text = txtHoughTheta.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliHoughTheta.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtHoughTheta.setText(String.valueOf((int) sliHoughTheta.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragHoughThreshold() {\n\t\tint value = (int) sliHoughThreshold.getValue();\n\t\ttxtHoughThreshold.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setHoughThreshold() {\n\t\tString text = txtHoughThreshold.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliHoughThreshold.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtHoughThreshold.setText(String.valueOf((int) sliHoughThreshold.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragMinLenght() {\n\t\tint value = (int) sliMinLenght.getValue();\n\t\ttxtMinLenght.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setMinLenght() {\n\t\tString text = txtMinLenght.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliMinLenght.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtMinLenght.setText(String.valueOf((int) sliMinLenght.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragMaxGap() {\n\t\tint value = (int) sliMaxGap.getValue();\n\t\ttxtMaxGap.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setMaxGap() {\n\t\tString text = txtMaxGap.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliMaxGap.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtMaxGap.setText(String.valueOf((int) sliMaxGap.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragMinSlope() {\n\t\tint value = (int) sliMinSlope.getValue();\n\t\ttxtMinSlope.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setMinSlope() {\n\t\tString text = txtMinSlope.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliMinSlope.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtMinSlope.setText(String.valueOf((int) sliMinSlope.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragMaxSlope() {\n\t\tint value = (int) sliMaxSlope.getValue();\n\t\ttxtMaxSlope.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setMaxSlope() {\n\t\tString text = txtMaxSlope.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliMaxSlope.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtMaxSlope.setText(String.valueOf((int) sliMaxSlope.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\t\n\t@FXML\n\tprivate void dragCandidatesNumber() {\n\t\tint value = (int) sliCandidatesNumber.getValue();\n\t\ttxtCandidatesNumber.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setCandidatesNumber() {\n\t\tString text = txtCandidatesNumber.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliCandidatesNumber.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtCandidatesNumber.setText(String.valueOf((int) sliCandidatesNumber.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragMinAlpha() {\n\t\tint value = (int) sliMinAlpha.getValue();\n\t\ttxtMinAlpha.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setMinAlpha() {\n\t\tString text = txtMinAlpha.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliMinAlpha.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtMinAlpha.setText(String.valueOf((int) sliMinAlpha.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragMaxAlpha() {\n\t\tint value = (int) sliMaxAlpha.getValue();\n\t\ttxtMaxAlpha.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setMaxAlpha() {\n\t\tString text = txtMaxAlpha.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliMaxAlpha.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtMaxAlpha.setText(String.valueOf((int) sliMaxAlpha.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragHorizonVariance() {\n\t\tint value = (int) sliHorizonVariance.getValue();\n\t\ttxtHorizonVariance.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setHorizonVariance() {\n\t\tString text = txtHorizonVariance.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliHorizonVariance.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtHorizonVariance.setText(String.valueOf((int) sliHorizonVariance.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragFramesToShow() {\n\t\tint value = (int) sliFramesToShow.getValue();\n\t\ttxtFramesToShow.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setFramesToShow() {\n\t\tString text = txtFramesToShow.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliFramesToShow.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtFramesToShow.setText(String.valueOf((int) sliFramesToShow.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void dragFramesToHide() {\n\t\tint value = (int) sliFramesToHide.getValue();\n\t\ttxtFramesToHide.setText(String.valueOf(value));\n\t\tprocessAndShowFrame();\n\t}\n\n\t@FXML\n\tprivate void setFramesToHide() {\n\t\tString text = txtFramesToHide.getText();\n\t\tif (text.matches(\"\\\\d*|\\\\d*\\\\.\\\\d\")) {\n\t\t\tsliFramesToHide.setValue(Integer.valueOf(text));\n\t\t}\n\t\ttxtFramesToHide.setText(String.valueOf((int) sliFramesToHide.getValue()));\n\t\tprocessAndShowFrame();\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class Start {\n\n    \n    public static final String IMAGE_PATH = \"/home/tobias/work/computervision/input.png\";\n\n    \n    public static final int WINDOW_HEIGHT = 800;\n    public static final int WINDOW_WIDTH = 1600;\n\n    public static void main(String[] args) {\n\n        \n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n        ImageHelper helper = new ImageHelper();\n\n        \n        Mat input = Imgcodecs.imread(IMAGE_PATH);\n\n        \n        Mat processedImage = processImage(input);\n\n        \n        helper.addImage(input);\n        helper.addImage(processedImage);\n\n    }\n\n\n    \n    public static Mat processImage(Mat input) {\n\n        Mat processed = new Mat();\n\n        \n\n        Imgproc.cvtColor(input, processed, Imgproc.COLOR_BGR2GRAY);\n\n\n        return processed;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\npublic class ImageDiff {\n\n    public static void main(String[] args) throws InterruptedException {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n        \n        Mat img1 = Highgui.imread(\"files/toycars1.png\");\n        Mat img2 = Highgui.imread(\"files/toycars2.png\");\n        \n        \n        Mat diff_img = new Mat();\n        \n        \n        \n        Core.absdiff(img1, img2, diff_img);\n       \n        \n        \n       \n        \n        \n        \n        \n         \n            \n        Imshow ims1 = new Imshow(\"Image 1\");\n        Imshow ims2 = new Imshow(\"Image 2\");\n        Imshow ims_diff = new Imshow(\"Difference\");\n        \t\n\n        ims1.showImage(img1);\n        ims2.showImage(img2);\n        ims_diff.showImage(diff_img);\n         \n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class FaceDetection {\n\n\tpublic static String basePath=System.getProperty(\"user.dir\");\n\tpublic static String classifierPath1=basePath+\"\\\\src\\\\resources\\\\FaceDetection\\\\haarcascade_frontalface_alt.xml\";\n\tpublic static String inpImgFilename=basePath+\"\\\\src\\\\resources\\\\FaceDetection\\\\input.jpg\";\n\tpublic static String opImgFilename=basePath+\"\\\\src\\\\resources\\\\FaceDetection\\\\output.jpg\";\n\n\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSystem.loadLibrary(\"libopencv_java342\");\n\t\t\tSystem.out.println(\"Library loaded..\");\n\t\t\tMat frame=Imgcodecs.imread(inpImgFilename, 1);\n\t\t\tif (!frame.empty())\n\t\t\t{\n\t\t\t\tdetectAndDisplay(frame);\n\t\t\t\tFile outputfile = new File(opImgFilename);\n\t\t\t    ImageIO.write(Utils.matToBufferedImage(frame), \"jpg\", outputfile);\n\t\t\t    System.out.println(\"Done!!\");\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Exception IO\");\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void detectAndDisplay(Mat frame) throws IOException\n\t{\n\t\tMatOfRect faces = new MatOfRect();\n\t\tMat grayFrame = new Mat();\n\t\tint absoluteFaceSize=0;\n\t\tCascadeClassifier faceCascade=new CascadeClassifier();\n\t\t\n\t\tfaceCascade.load(classifierPath1);\n\t\tImgproc.cvtColor(frame, grayFrame, Imgproc.COLOR_BGR2GRAY);\n\t\tImgproc.equalizeHist(grayFrame, grayFrame);\n\t\t\n\t\t\n\t\t\tint height = grayFrame.rows();\n\t\t\tif (Math.round(height * 0.2f) > 0)\n\t\t\t{\n\t\t\t\tabsoluteFaceSize = Math.round(height * 0.01f);\n\t\t\t}\n\t\t\t\t\n\t\tfaceCascade.detectMultiScale(grayFrame, faces, 1.1, 2, 0 | Objdetect.CASCADE_SCALE_IMAGE,\n\t\t\t\tnew Size(absoluteFaceSize, absoluteFaceSize), new Size(height,height));\n\t\t\t\t\n\t\tRect[] facesArray = faces.toArray();\n\t\tSystem.out.println(\"Number of faces detected = \"+facesArray.length);\n\t\tfor (int i = 0; i < facesArray.length; i++)\n\t\t\tImgproc.rectangle(frame, facesArray[i].tl(), facesArray[i].br(), new Scalar(0, 255, 0), 2);\n\t\t\t\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class DisplayingImagesJavaFX extends Application {\n   @Override \n   public void start(Stage stage) throws IOException {   \n      WritableImage writableImage = loadImage(); \n  \n      ImageView imageView = new ImageView(writableImage); \n        \n      imageView.setX(50); \n      imageView.setY(25); \n        \n      imageView.setFitHeight(400); \n      imageView.setFitWidth(500);\n      \n      imageView.setPreserveRatio(true);\n      \n      Group root = new Group(imageView);\n      \n      Scene scene = new Scene(root, 600, 400);\n      \n      stage.setTitle(\"Loading an image\");\n      \n      stage.setScene(scene);\n\n      stage.show();\n   } \n   public WritableImage loadImage() throws IOException {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n      \n      String file =\"C:/EXAMPLES/OpenCV/sample.jpg\";\n      Mat image = Imgcodecs.imread(file);\n      \n      MatOfByte matOfByte = new MatOfByte();\n      Imgcodecs.imencode(\".jpg\", image, matOfByte);\n\n      byte[] byteArray = matOfByte.toArray();\n      \n      InputStream in = new ByteArrayInputStream(byteArray); \n      BufferedImage bufImage = ImageIO.read(in);\n\n      System.out.println(\"Image Loaded\");\n      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);\n      return writableImage; \n   }\n   public static void main(String args[]) {\n      launch(args); \n   } \n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\n@Configuration(proxyBeanMethods = false)\npublic class SpringHttpSessionConfiguration implements ApplicationContextAware {\n\n\tprivate final Log logger = LogFactory.getLog(getClass());\n\n\tprivate CookieHttpSessionIdResolver defaultHttpSessionIdResolver = new CookieHttpSessionIdResolver();\n\n\tprivate boolean usesSpringSessionRememberMeServices;\n\n\tprivate ServletContext servletContext;\n\n\tprivate CookieSerializer cookieSerializer;\n\n\tprivate HttpSessionIdResolver httpSessionIdResolver = this.defaultHttpSessionIdResolver;\n\n\tprivate List<HttpSessionListener> httpSessionListeners = new ArrayList<>();\n\n\t@PostConstruct\n\tpublic void init() {\n\t\tCookieSerializer cookieSerializer = (this.cookieSerializer != null) ? this.cookieSerializer\n\t\t\t\t: createDefaultCookieSerializer();\n\t\tthis.defaultHttpSessionIdResolver.setCookieSerializer(cookieSerializer);\n\t}\n\n\t@Bean\n\tpublic SessionEventHttpSessionListenerAdapter sessionEventHttpSessionListenerAdapter() {\n\t\treturn new SessionEventHttpSessionListenerAdapter(this.httpSessionListeners);\n\t}\n\n\t@Bean\n\tpublic <S extends Session> SessionRepositoryFilter<? extends Session> springSessionRepositoryFilter(\n\t\t\tSessionRepository<S> sessionRepository) {\n\t\tSessionRepositoryFilter<S> sessionRepositoryFilter = new SessionRepositoryFilter<>(sessionRepository);\n\t\tsessionRepositoryFilter.setHttpSessionIdResolver(this.httpSessionIdResolver);\n\t\treturn sessionRepositoryFilter;\n\t}\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\t\tif (ClassUtils.isPresent(\"org.springframework.security.web.authentication.RememberMeServices\", null)) {\n\t\t\tthis.usesSpringSessionRememberMeServices = !ObjectUtils\n\t\t\t\t\t.isEmpty(applicationContext.getBeanNamesForType(SpringSessionRememberMeServices.class));\n\t\t}\n\t}\n\n\t@Autowired(required = false)\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}\n\n\t@Autowired(required = false)\n\tpublic void setCookieSerializer(CookieSerializer cookieSerializer) {\n\t\tthis.cookieSerializer = cookieSerializer;\n\t}\n\n\t@Autowired(required = false)\n\tpublic void setHttpSessionIdResolver(HttpSessionIdResolver httpSessionIdResolver) {\n\t\tthis.httpSessionIdResolver = httpSessionIdResolver;\n\t}\n\n\t@Autowired(required = false)\n\tpublic void setHttpSessionListeners(List<HttpSessionListener> listeners) {\n\t\tthis.httpSessionListeners = listeners;\n\t}\n\n\tprivate CookieSerializer createDefaultCookieSerializer() {\n\t\tDefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();\n\t\tif (this.servletContext != null) {\n\t\t\tSessionCookieConfig sessionCookieConfig = null;\n\t\t\ttry {\n\t\t\t\tsessionCookieConfig = this.servletContext.getSessionCookieConfig();\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\tthis.logger.warn(\"Unable to obtain SessionCookieConfig: \" + ex.getMessage());\n\t\t\t}\n\t\t\tif (sessionCookieConfig != null) {\n\t\t\t\tif (sessionCookieConfig.getName() != null) {\n\t\t\t\t\tcookieSerializer.setCookieName(sessionCookieConfig.getName());\n\t\t\t\t}\n\t\t\t\tif (sessionCookieConfig.getDomain() != null) {\n\t\t\t\t\tcookieSerializer.setDomainName(sessionCookieConfig.getDomain());\n\t\t\t\t}\n\t\t\t\tif (sessionCookieConfig.getPath() != null) {\n\t\t\t\t\tcookieSerializer.setCookiePath(sessionCookieConfig.getPath());\n\t\t\t\t}\n\t\t\t\tif (sessionCookieConfig.getMaxAge() != -1) {\n\t\t\t\t\tcookieSerializer.setCookieMaxAge(sessionCookieConfig.getMaxAge());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.usesSpringSessionRememberMeServices) {\n\t\t\tcookieSerializer.setRememberMeRequestAttribute(SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR);\n\t\t}\n\t\treturn cookieSerializer;\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class CapLocate {\n\n    private static final String PATH = \"res/img/capacity/\";\n    private static int threshold = 0;           \n    private static int morphOpenSizeX = 20;     \n    private static int morphOpenSizeY = 20;  \n    private static int morphDilateSizeX = 17; \n    private static int morphDilateSizeY = 17;   \n\n    public List<Mat> capLocate(Mat src) {\n        List<Mat> resultList = new ArrayList<Mat>();\n        Mat src_blur = new Mat();\n        Mat src_gray = new Mat();\n\n      \n        Imgproc.GaussianBlur(src, src_blur, new Size(5, 5), 0, 0, 4);\n\n    \n        Imgproc.cvtColor(src, src_gray, Imgproc.COLOR_BGR2GRAY);\n\n \n        Mat img_threshold = new Mat();\n        Imgproc.threshold(src_gray, img_threshold, threshold, 255, Imgproc.THRESH_OTSU);\n\n        Mat element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(morphOpenSizeX, morphOpenSizeY));\n        Imgproc.morphologyEx(img_threshold, img_threshold, Imgproc.MORPH_OPEN, element);\n\n        element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(morphDilateSizeX, morphDilateSizeY));\n        Imgproc.morphologyEx(img_threshold, img_threshold, Imgproc.MORPH_DILATE, element);\n\n\n        Mat hierarchy = new Mat();\n        List<MatOfPoint> contours = new ArrayList<MatOfPoint>();\n        Imgproc.findContours(img_threshold, contours, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_NONE);\n\n        for (int i = 0; i < contours.size(); i++) {\n            int S = (int) Imgproc.contourArea(contours.get(i));\n            if (S < 15000 || S > 23000) {\n                continue;\n            }\n            MatOfPoint2f mtx = new MatOfPoint2f(contours.get(i).toArray());\n            int L = (int) Imgproc.arcLength(mtx, true);\n\n            double epsilon = 0.01 * L;\n            MatOfPoint2f result = new MatOfPoint2f();\n            Imgproc.approxPolyDP(mtx, result, epsilon, true);\n\n            L = (int) Imgproc.arcLength(result, true);\n\n            double roundness = 4 * Math.PI * S / (L * L);\n            if (roundness < 0.7) {\n                continue;\n            }\n            System.out.println(S + \" \" + L + \" \" + roundness);\n            RotatedRect minRect = Imgproc.minAreaRect(mtx);\n            double r = minRect.size.width / minRect.size.height;\n            double angle = minRect.angle;\n            Size size = new Size(minRect.size.width + 250, minRect.size.height + 100);\n            if (r < 1) {\n                angle = angle + 90;\n                size = new Size(minRect.size.height + 250, minRect.size.width + 100);\n            }\n            Mat rotMat = Imgproc.getRotationMatrix2D(minRect.center, angle, 1);\n            Mat img_rotated = new Mat();\n            Imgproc.warpAffine(src, img_rotated, rotMat, src.size());\n            Mat resultMat = showResultMat(img_rotated, size, minRect.center, i);\n            resultList.add(resultMat);\n        }\n\n        return resultList;\n    }\n\n    private Mat showResultMat(Mat src, Size rect_size, Point center, int index) {\n        Mat img_crop = new Mat();\n        Imgproc.getRectSubPix(src, rect_size, center, img_crop);\n        Imgcodecs.imwrite(PATH + \"debug_crop_\" + index + \".jpg\", img_crop);\n        return img_crop;\n    }\n}\n", "nl": "opencv"}
{"code": "\n\n\n@SpringBootApplication\npublic class Application implements CommandLineRunner {\n\n    @Autowired\n    private VaultTemplate vaultTemplate;\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    public void run(String... strings) throws Exception {\n\n\t\tVaultResponse response = vaultTemplate.read(\"secret/github\");\n\t\tSystem.out.println(\"Value of github.oauth2.key\");\n        System.out.println(response.getData().get(\"github.oauth2.key\"));\n\n        VaultTransitOperations transitOperations = vaultTemplate.opsForTransit();\n\n        VaultSysOperations sysOperations = vaultTemplate.opsForSys();\n\n        if (!sysOperations.getMounts().containsKey(\"transit/\")) {\n\n            sysOperations.mount(\"transit\", VaultMount.create(\"transit\"));\n\n            transitOperations.createKey(\"foo-key\");\n        }\n\n        String ciphertext = transitOperations.encrypt(\"foo-key\", \"Secure message\");\n\n        System.out.println(ciphertext);\n\n\n        String plaintext = transitOperations.decrypt(\"foo-key\", ciphertext);\n\n        System.out.println(plaintext);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n@Service\npublic class ToolsService {\n    private final ToolXmlConverter toolXmlConverter = new ToolXmlConverter();\n    private final CachedRestClient restClient;\n    private final RestTemplate restTemplate;\n    private final XmlMapper serializer;\n\n    @Autowired\n    public ToolsService(CachedRestClient restClient, RestTemplate restTemplate, XmlMapper serializer) {\n        this.restClient = restClient;\n        this.restTemplate = restTemplate;\n        this.serializer = serializer;\n    }\n\n    public ToolSuiteDownloads getStsGaDownloads() throws Exception {\n        return getToolSuiteDownloads(\"Spring Tool Suite\", \"STS\");\n    }\n\n    public ToolSuiteDownloads getStsMilestoneDownloads() throws Exception {\n        return getToolSuiteDownloads(\"Milestone Version - Spring Tool Suite\", \"STS\");\n    }\n\n    public Collection<ToolSuiteDownloads> getStsLegacyDownloads() throws Exception {\n        List<ToolSuiteDownloads> previousStsDownloads = new ArrayList<>();\n\n        previousStsDownloads.addAll(getLegacyToolSuiteDownloads(\"Spring Tool Suite\", \"STS\"));\n        previousStsDownloads.addAll(getLegacyToolSuiteDownloads(\"Previous Version\", \"STS\"));\n        return previousStsDownloads;\n    }\n\n    private ToolSuiteDownloads getToolSuiteDownloads(String toolSuiteName, String shortName) throws Exception {\n        String responseXml =\n                restClient.get(restTemplate, \"http://dist.springsource.com/release/STS/index-new.xml\",\n                        String.class);\n        ToolSuiteXml toolSuiteXml = serializer.readValue(responseXml, ToolSuiteXml.class);\n        return toolXmlConverter.convert(toolSuiteXml, toolSuiteName, shortName);\n    }\n\n    private Collection<ToolSuiteDownloads> getLegacyToolSuiteDownloads(String toolSuiteName, String shortName) throws Exception {\n        String responseXml =\n                restClient.get(restTemplate, \"http://dist.springsource.com/release/STS/index-new.xml\",\n                        String.class);\n        ToolSuiteXml toolSuiteXml = serializer.readValue(responseXml, ToolSuiteXml.class);\n        return toolXmlConverter.convertLegacy(toolSuiteXml, toolSuiteName, shortName);\n    }\n\n    public EclipseDownloads getEclipseDownloads() throws Exception {\n        String responseXml =\n                restClient.get(restTemplate, \"http://dist.springsource.com/release/STS/eclipse.xml\",\n                        String.class);\n        EclipseXml eclipseXml = serializer.readValue(responseXml, EclipseXml.class);\n        return new EclipseDownloadsXmlConverter().convert(eclipseXml);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class RemoveBackScatter {\n\n\tprivate static final int colorBalanceRatio = 5;\n\n\tpublic static Mat enhance (Mat image, int blkSize, int patchSize, double lambda, double gamma, int r, double eps, int level) {\n\t\timage.convertTo(image, CvType.CV_32F);\n\t\tMat[] decomposed = ImgDecompose.illuRefDecompose(image);\n\t\tMat AL = decomposed[0];\n\t\tMat RL = decomposed[1];\n\t\tRL = Filters.SimplestColorBalance(RL, colorBalanceRatio);\n\t\tdouble[] airlight = AirlightEstimate.estimate(AL, blkSize);\n\t\tdouble fTrans = 0.6;\n\t\tMat trans = TransmissionEstimate.transEstimate(AL, patchSize, airlight, lambda, fTrans, r, eps, gamma);\n\t\tAL = dehazeProcess(AL, trans, airlight);\n\t\tMat w1 = calWeight(AL);\n\t\tMat w2 = calWeight(RL);\n\t\treturn pyramidFuse(w1, w2, AL, RL, level);\n\t}\n\t\n\tprivate static Mat pyramidFuse(Mat w1, Mat w2, Mat img1, Mat img2, int level) {\n\t\tMat sumW = new Mat();\n\t\tCore.add(w1, w2, sumW);\n\t\tCore.divide(w1, sumW, w1);\n\t\tCore.multiply(w1, new Scalar(2.0), w1);\n\t\tCore.divide(w2, sumW, w2);\n\t\tCore.multiply(w2, new Scalar(2.0), w2);\n\t\treturn ImgDecompose.fuseTwoImage(w1, img1, w2, img2, level);\n\t}\n\t\n\tprivate static Mat dehazeProcess(Mat img, Mat trans, double[] airlight) {\n\t\tMat balancedImg = Filters.SimplestColorBalance(img, 5);\n\t\tMat bCnl = new Mat();\n\t\tCore.extractChannel(balancedImg, bCnl, 0);\n\t\tMat gCnl = new Mat();\n\t\tCore.extractChannel(balancedImg, gCnl, 1);\n\t\tMat rCnl = new Mat();\n\t\tCore.extractChannel(balancedImg, rCnl, 2);\n\t\tdouble bMean = Core.mean(bCnl).val[0];\n\t\tdouble gMean = Core.mean(gCnl).val[0];\n\t\tdouble rMean = Core.mean(rCnl).val[0];\n\t\tMat Tb = trans.clone();\n\t\tCore.multiply(Tb, new Scalar(Math.max(bMean, Math.max(gMean, rMean)) / bMean * 0.8), Tb);\n\t\tMat Tg = trans.clone();\n\t\tCore.multiply(Tg, new Scalar(Math.max(bMean, Math.max(gMean, rMean)) / gMean * 0.9), Tg);\n\t\tMat Tr = trans.clone();\n\t\tCore.multiply(Tr, new Scalar(Math.max(bMean, Math.max(gMean, rMean)) / rMean * 0.8), Tr);\n\t\tMat bChannel = new Mat();\n\t\tCore.subtract(bCnl, new Scalar(airlight[0]), bChannel);\n\t\tCore.divide(bChannel, Tb, bChannel);\n\t\tCore.add(bChannel, new Scalar(airlight[0]), bChannel);\n\t\tMat gChannel = new Mat();\n\t\tCore.subtract(gCnl, new Scalar(airlight[1]), gChannel);\n\t\tCore.divide(gChannel, Tg, gChannel);\n\t\tCore.add(gChannel, new Scalar(airlight[1]), gChannel);\n\t\tMat rChannel = new Mat();\n\t\tCore.subtract(rCnl, new Scalar(airlight[2]), rChannel);\n\t\tCore.divide(rChannel, Tr, rChannel);\n\t\tCore.add(rChannel, new Scalar(airlight[2]), rChannel);\n\t\tMat dehazed = new Mat();\n\t\tCore.merge(new ArrayList<>(Arrays.asList(bChannel, gChannel, rChannel)), dehazed);\n\t\treturn dehazed;\n\t}\n\t\n\tprivate static Mat calWeight(Mat img) {\n\t\tMat L = new Mat();\n\t\timg.convertTo(img, CvType.CV_8UC1);\n\t\tImgproc.cvtColor(img, L, Imgproc.COLOR_BGR2GRAY);\n\t\tL.convertTo(L, CvType.CV_32F);\n\t\tCore.divide(L, new Scalar(255.0), L);\n\t\tMat WC = FeatureWeight.LuminanceWeight(img, L);\n\t\tWC.convertTo(WC, L.type());\n\t\tMat WS = FeatureWeight.Saliency(img);\n\t\tWS.convertTo(WS, L.type());\n\t\tMat WE = FeatureWeight.Exposedness(L);\n\t\tWE.convertTo(WE, L.type());\n\t\tMat weight = WC.clone();\n\t\tCore.add(weight, WS, weight);\n\t\tCore.add(weight, WE, weight);\n\t\treturn weight;\n\t}\n\n}", "nl": "opencv"}
{"code": "  \n\n\n\n\npublic class ColorToGrayscale extends Application {\n   @Override\n   public void start(Stage stage) throws Exception {\n      WritableImage writableImage = loadAndConvert();\n       \n      ImageView imageView = new ImageView(writableImage);\n\n      imageView.setX(10);\n      imageView.setY(10);\n\n      imageView.setFitHeight(400);\n      imageView.setFitWidth(600);\n\n      imageView.setPreserveRatio(true);\n\n      Group root = new Group(imageView);\n\n      Scene scene = new Scene(root, 600, 400);\n\n      stage.setTitle(\"Colored to grayscale image\");\n\n      stage.setScene(scene);\n\n      stage.show();\n   } \n   public WritableImage loadAndConvert() throws Exception {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String input = \"C:/EXAMPLES/OpenCV/sample.jpg\";\n\n      Mat src = Imgcodecs.imread(input);\n\n      Mat dst = new Mat();\n\n      Imgproc.cvtColor(src, dst, Imgproc.COLOR_RGB2GRAY);\n      \n      byte[] data1 = new byte[dst.rows() * dst.cols() * (int)(dst.elemSize())];\n      dst.get(0, 0, data1);\n\n      BufferedImage bufImage = new BufferedImage(dst.cols(),dst.rows(), \n         BufferedImage.TYPE_BYTE_GRAY);\n\n      bufImage.getRaster().setDataElements(0, 0, dst.cols(), dst.rows(), data1);\n\n      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);\n      System.out.println(\"Converted to Grayscale\");\n      return writableImage;\n   }\n   public static void main(String args[]) throws Exception {\n      launch(args);\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@WebMvcTest(MarkupController.class)\npublic class MarkupControllerTests {\n\n\t@Autowired\n\tprivate MockMvc mvc;\n\n\t@MockBean\n\tprivate AsciidoctorRenderer asciidoctor;\n\n\t@MockBean\n\tprivate MarkdownRenderer markdown;\n\n\n\t@Test\n\tpublic void noCompatibleRenderer() throws Exception {\n\t\tgiven(this.asciidoctor.canRender(any())).willReturn(false);\n\t\tgiven(this.markdown.canRender(any())).willReturn(false);\n\t\tthis.mvc.perform(post(\"/documents\").content(\"test\").contentType(MediaType.TEXT_PLAIN))\n\t\t\t\t.andExpect(status().isUnsupportedMediaType());\n\t}\n\n\t@Test\n\tpublic void renderMarkdown() throws Exception {\n\t\tgiven(this.asciidoctor.canRender(any())).willReturn(false);\n\t\tgiven(this.markdown.canRender(MediaType.TEXT_MARKDOWN)).willReturn(true);\n\t\tgiven(this.markdown.renderToHtml(\"test\")).willReturn(\"rendered\");\n\t\tthis.mvc.perform(post(\"/documents\").content(\"test\").contentType(MediaType.TEXT_MARKDOWN))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(content().string(\"rendered\\n<!-- rendered by Sagan Renderer Service -->\"));\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\npublic class ObjectFinder {\n    public ObjectFinder(IplImage objectImage) {\n        settings = new Settings();\n        settings.objectImage = objectImage;\n        setSettings(settings);\n    }\n    public ObjectFinder(Settings settings) {\n        setSettings(settings);\n    }\n\n    public static class Settings extends BaseChildSettings {\n        IplImage objectImage = null;\n        AKAZE detector = AKAZE.create();\n        double distanceThreshold = 0.75;\n        int matchesMin = 4;\n        double ransacReprojThreshold = 1.0;\n        boolean useFLANN = false;\n\n        public IplImage getObjectImage() {\n            return objectImage;\n        }\n        public void setObjectImage(IplImage objectImage) {\n            this.objectImage = objectImage;\n        }\n\n        public int getDescriptorType() {\n            return detector.getDescriptorType();\n        }\n        public void setDescriptorType(int dtype) {\n            detector.setDescriptorType(dtype);\n        }\n\n        public int getDescriptorSize() {\n            return detector.getDescriptorSize();\n        }\n        public void setDescriptorSize(int dsize) {\n            detector.setDescriptorSize(dsize);\n        }\n\n        public int getDescriptorChannels() {\n            return detector.getDescriptorChannels();\n        }\n        public void setDescriptorChannels(int dch) {\n            detector.setDescriptorChannels(dch);\n        }\n\n        public double getThreshold() {\n            return detector.getThreshold();\n        }\n        public void setThreshold(double threshold) {\n            detector.setThreshold(threshold);\n        }\n\n        public int getNOctaves() {\n            return detector.getNOctaves();\n        }\n        public void setNOctaves(int nOctaves) {\n            detector.setNOctaves(nOctaves);\n        }\n\n        public int getNOctaveLayers() {\n            return detector.getNOctaveLayers();\n        }\n        public void setNOctaveLayers(int nOctaveLayers) {\n            detector.setNOctaveLayers(nOctaveLayers);\n        }\n\n        public double getDistanceThreshold() {\n            return distanceThreshold;\n        }\n        public void setDistanceThreshold(double distanceThreshold) {\n            this.distanceThreshold = distanceThreshold;\n        }\n\n        public int getMatchesMin() {\n            return matchesMin;\n        }\n        public void setMatchesMin(int matchesMin) {\n            this.matchesMin = matchesMin;\n        }\n\n        public double getRansacReprojThreshold() {\n            return ransacReprojThreshold;\n        }\n        public void setRansacReprojThreshold(double ransacReprojThreshold) {\n            this.ransacReprojThreshold = ransacReprojThreshold;\n        }\n\n        public boolean isUseFLANN() {\n            return useFLANN;\n        }\n        public void setUseFLANN(boolean useFLANN) {\n            this.useFLANN = useFLANN;\n        }\n    }\n\n    Settings settings;\n    public Settings getSettings() {\n        return settings;\n    }\n    public void setSettings(Settings settings) {\n        this.settings = settings;\n\n        objectKeypoints = new KeyPointVector();\n        objectDescriptors = new Mat();\n        settings.detector.detectAndCompute(cvarrToMat(settings.objectImage),\n                new Mat(), objectKeypoints, objectDescriptors, false);\n\n        int total = (int)objectKeypoints.size();\n        if (settings.useFLANN) {\n            indicesMat = new Mat(total, 2, CV_32SC1);\n            distsMat   = new Mat(total, 2, CV_32FC1);\n            flannIndex = new Index();\n            indexParams = new LshIndexParams(12, 20, 2); // using LSH Hamming distance\n            searchParams = new SearchParams(64, 0, true); // maximum number of leafs checked\n            searchParams.deallocate(false); // for some reason FLANN seems to do it for us\n        }\n        pt1  = new Mat(total, 1, CV_32FC2);\n        pt2  = new Mat(total, 1, CV_32FC2);\n        mask = new Mat(total, 1, CV_8UC1);\n        H    = new Mat(3, 3, CV_64FC1);\n        ptpairs = new ArrayList<Integer>(2*objectDescriptors.rows());\n        logger.info(total + \" object descriptors\");\n    }\n\n    static final Logger logger = Logger.getLogger(ObjectFinder.class.getName());\n\n    KeyPointVector objectKeypoints = null, imageKeypoints = null;\n    Mat objectDescriptors = null, imageDescriptors = null;\n    Mat indicesMat, distsMat;\n    Index flannIndex = null;\n    IndexParams indexParams = null;\n    SearchParams searchParams = null;\n    Mat pt1 = null, pt2 = null, mask = null, H = null;\n    ArrayList<Integer> ptpairs = null;\n\n    public double[] find(IplImage image) {\n        if (objectDescriptors.rows() < settings.getMatchesMin()) {\n            return null;\n        }\n        imageKeypoints = new KeyPointVector();\n        imageDescriptors = new Mat();\n        settings.detector.detectAndCompute(cvarrToMat(image),\n                new Mat(), imageKeypoints, imageDescriptors, false);\n        if (imageDescriptors.rows() < settings.getMatchesMin()) {\n            return null;\n        }\n\n        int total = (int)imageKeypoints.size();\n        logger.info(total + \" image descriptors\");\n\n        int w = settings.objectImage.width();\n        int h = settings.objectImage.height();\n        double[] srcCorners = {0, 0,  w, 0,  w, h,  0, h};\n        double[] dstCorners = locatePlanarObject(objectKeypoints, objectDescriptors,\n                imageKeypoints, imageDescriptors, srcCorners);\n        return dstCorners;\n    }\n\n    static final int[] bits = new int[256];\n    static {\n        for (int i = 0; i < bits.length; i++) {\n            for (int j = i; j != 0; j >>= 1) {\n                bits[i] += j & 0x1;\n            }\n        }\n    }\n\n    int compareDescriptors(ByteBuffer d1, ByteBuffer d2, int best) {\n        int totalCost = 0;\n        assert d1.limit() - d1.position() == d2.limit() - d2.position();\n        while (d1.position() < d1.limit()) {\n            totalCost += bits[(d1.get() ^ d2.get()) & 0xFF];\n            if (totalCost > best)\n                break;\n        }\n        return totalCost;\n    }\n\n    int naiveNearestNeighbor(ByteBuffer vec, ByteBuffer modelDescriptors) {\n        int neighbor = -1;\n        int d, dist1 = Integer.MAX_VALUE, dist2 = Integer.MAX_VALUE;\n        int size = vec.limit() - vec.position();\n\n        for (int i = 0; i * size < modelDescriptors.capacity(); i++) {\n            ByteBuffer mvec = (ByteBuffer)modelDescriptors.position(i * size).limit((i + 1) * size);\n            d = compareDescriptors((ByteBuffer)vec.reset(), mvec, dist2);\n            if (d < dist1) {\n                dist2 = dist1;\n                dist1 = d;\n                neighbor = i;\n            } else if (d < dist2) {\n                dist2 = d;\n            }\n        }\n        if (dist1 < settings.distanceThreshold*dist2)\n            return neighbor;\n        return -1;\n    }\n\n    void findPairs(Mat objectDescriptors, Mat imageDescriptors) {\n        int size = imageDescriptors.cols();\n        ByteBuffer objectBuf = objectDescriptors.createBuffer();\n        ByteBuffer imageBuf = imageDescriptors.createBuffer();\n\n        for (int i = 0; i * size < objectBuf.capacity(); i++) {\n            ByteBuffer descriptor = (ByteBuffer)objectBuf.position(i * size).limit((i + 1) * size).mark();\n            int nearestNeighbor = naiveNearestNeighbor(descriptor, imageBuf);\n            if (nearestNeighbor >= 0) {\n                ptpairs.add(i);\n                ptpairs.add(nearestNeighbor);\n            }\n        }\n    }\n\n    void flannFindPairs(Mat objectDescriptors, Mat imageDescriptors) {\n        int length = objectDescriptors.rows();\n\n        flannIndex.build(imageDescriptors, indexParams, FLANN_DIST_HAMMING);\n        flannIndex.knnSearch(objectDescriptors, indicesMat, distsMat, 2, searchParams);\n\n        IntBuffer indicesBuf = indicesMat.createBuffer();\n        IntBuffer distsBuf = distsMat.createBuffer();\n        for (int i = 0; i < length; i++) {\n            if (distsBuf.get(2*i) < settings.distanceThreshold*distsBuf.get(2*i+1)) {\n                ptpairs.add(i);\n                ptpairs.add(indicesBuf.get(2*i));\n            }\n        }\n    }\n\n    \n    double[] locatePlanarObject(KeyPointVector objectKeypoints, Mat objectDescriptors,\n            KeyPointVector imageKeypoints, Mat imageDescriptors, double[] srcCorners) {\n        ptpairs.clear();\n        if (settings.useFLANN) {\n            flannFindPairs(objectDescriptors, imageDescriptors);\n        } else {\n            findPairs(objectDescriptors, imageDescriptors);\n        }\n        int n = ptpairs.size()/2;\n        logger.info(n + \" matching pairs found\");\n        if (n < settings.matchesMin) {\n            return null;\n        }\n\n        pt1 .resize(n);\n        pt2 .resize(n);\n        mask.resize(n);\n        FloatBuffer pt1Idx = pt1.createBuffer();\n        FloatBuffer pt2Idx = pt2.createBuffer();\n        for (int i = 0; i < n; i++) {\n            Point2f p1 = objectKeypoints.get(ptpairs.get(2*i)).pt();\n            pt1Idx.put(2*i, p1.x()); pt1Idx.put(2*i+1, p1.y());\n            Point2f p2 = imageKeypoints.get(ptpairs.get(2*i+1)).pt();\n            pt2Idx.put(2*i, p2.x()); pt2Idx.put(2*i+1, p2.y());\n        }\n\n        H = findHomography(pt1, pt2, CV_RANSAC, settings.ransacReprojThreshold, mask, 2000, 0.995);\n        if (H.empty() || countNonZero(mask) < settings.matchesMin) {\n            return null;\n        }\n\n        double[] h = (double[])H.createIndexer(false).array();\n        double[] dstCorners = new double[srcCorners.length];\n        for(int i = 0; i < srcCorners.length/2; i++) {\n            double x = srcCorners[2*i], y = srcCorners[2*i + 1];\n            double Z = 1/(h[6]*x + h[7]*y + h[8]);\n            double X = (h[0]*x + h[1]*y + h[2])*Z;\n            double Y = (h[3]*x + h[4]*y + h[5])*Z;\n            dstCorners[2*i    ] = X;\n            dstCorners[2*i + 1] = Y;\n        }\n        return dstCorners;\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        String objectFilename = args.length == 2 ? args[0] : \"/usr/local/share/OpenCV/samples/c/box.png\";\n        String sceneFilename  = args.length == 2 ? args[1] : \"/usr/local/share/OpenCV/samples/c/box_in_scene.png\";\n\n        IplImage object = cvLoadImage(objectFilename, IMREAD_GRAYSCALE);\n        IplImage image  = cvLoadImage(sceneFilename,  IMREAD_GRAYSCALE);\n        if (object == null || image == null) {\n            System.err.println(\"Can not load \" + objectFilename + \" and/or \" + sceneFilename);\n            System.exit(-1);\n        }\n\n        IplImage objectColor = IplImage.create(object.width(), object.height(), 8, 3);\n        cvCvtColor(object, objectColor, CV_GRAY2BGR);\n\n        IplImage correspond = IplImage.create(image.width(), object.height()+ image.height(), 8, 1);\n        cvSetImageROI(correspond, cvRect(0, 0, object.width(), object.height()));\n        cvCopy(object, correspond);\n        cvSetImageROI(correspond, cvRect(0, object.height(), correspond.width(), correspond.height()));\n        cvCopy(image, correspond);\n        cvResetImageROI(correspond);\n\n        ObjectFinder.Settings settings = new ObjectFinder.Settings();\n        settings.objectImage = object;\n        settings.useFLANN = true;\n        settings.ransacReprojThreshold = 5;\n        ObjectFinder finder = new ObjectFinder(settings);\n\n        long start = System.currentTimeMillis();\n        double[] dst_corners = finder.find(image);\n        System.out.println(\"Finding time = \" + (System.currentTimeMillis() - start) + \" ms\");\n\n        if (dst_corners !=  null) {\n            for (int i = 0; i < 4; i++) {\n                int j = (i+1)%4;\n                int x1 = (int)Math.round(dst_corners[2*i    ]);\n                int y1 = (int)Math.round(dst_corners[2*i + 1]);\n                int x2 = (int)Math.round(dst_corners[2*j    ]);\n                int y2 = (int)Math.round(dst_corners[2*j + 1]);\n                line(cvarrToMat(correspond), new Point(x1, y1 + object.height()),\n                        new Point(x2, y2 + object.height()),\n                        Scalar.WHITE, 1, 8, 0);\n            }\n        }\n\n        for (int i = 0; i < finder.ptpairs.size(); i += 2) {\n            Point2f pt1 = finder.objectKeypoints.get(finder.ptpairs.get(i)).pt();\n            Point2f pt2 = finder.imageKeypoints.get(finder.ptpairs.get(i + 1)).pt();\n            line(cvarrToMat(correspond), new Point(Math.round(pt1.x()), Math.round(pt1.y())),\n                    new Point(Math.round(pt2.x()), Math.round(pt2.y() + object.height())),\n                    Scalar.WHITE, 1, 8, 0);\n        }\n\n        CanvasFrame objectFrame = new CanvasFrame(\"Object\");\n        CanvasFrame correspondFrame = new CanvasFrame(\"Object Correspond\");\n        OpenCVFrameConverter converter = new OpenCVFrameConverter.ToIplImage();\n\n        correspondFrame.showImage(converter.convert(correspond));\n        for (int i = 0; i < finder.objectKeypoints.size(); i++) {\n            KeyPoint r = finder.objectKeypoints.get(i);\n            Point center = new Point(Math.round(r.pt().x()), Math.round(r.pt().y()));\n            int radius = Math.round(r.size() / 2);\n            circle(cvarrToMat(objectColor), center, radius, Scalar.RED, 1, 8, 0);\n        }\n        objectFrame.showImage(converter.convert(objectColor));\n\n        objectFrame.waitKey();\n\n        objectFrame.dispose();\n        correspondFrame.dispose();\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n@Controller\n@RequestMapping(\"/docs\")\nclass DocsController {\n\n    private ProjectMetadataService projectService;\n\n    @Autowired\n    public DocsController(ProjectMetadataService service) {\n        this.projectService = service;\n    }\n\n    @RequestMapping(value = \"\", method = { GET, HEAD })\n    public String listDocumentationTypes() {\n        return \"docs/index\";\n    }\n\n    @RequestMapping(value = \"/reference\", method = { GET, HEAD })\n    public String listProjects(Model model) {\n        model.addAttribute(\"activeProjects\", projectService.getProjectsForCategory(\"active\"));\n        model.addAttribute(\"atticProjects\", projectService.getProjectsForCategory(\"attic\"));\n        model.addAttribute(\"incubatorProjects\", projectService.getProjectsForCategory(\"incubator\"));\n        return \"docs/reference\";\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = UserApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class UserApplicationTests {\n\n    ConfigurableApplicationContext application1;\n    ConfigurableApplicationContext application2;\n    ConfigurableApplicationContext application3;\n\n    @Before\n    public void startApps() {\n        this.application1 = startApp(8090);\n        this.application2 = startApp(9092);\n        this.application3 = startApp(9999);\n    }\n\n    @After\n    public void closeApps() {\n        this.application1.close();\n        this.application2.close();\n        this.application3.close();\n    }\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate testRestTemplate;\n\n    @Test\n    public void shouldRoundRobinOverInstancesWhenCallingServicesViaRibbon() throws InterruptedException {\n        ResponseEntity<String> response1 = this.testRestTemplate.getForEntity(\"http://localhost:\" + this.port + \"/hi?name=foo\", String.class);\n        ResponseEntity<String> response2 = this.testRestTemplate.getForEntity(\"http://localhost:\" + this.port + \"/hi?name=foo\", String.class);\n        ResponseEntity<String> response3 = this.testRestTemplate.getForEntity(\"http://localhost:\" + this.port + \"/hi?name=foo\", String.class);\n\n        then(response1.getStatusCode()).isEqualTo(HttpStatus.OK);\n        then(response1.getBody()).isEqualTo(\"1, foo!\");\n        then(response2.getStatusCode()).isEqualTo(HttpStatus.OK);\n        then(response2.getBody()).isEqualTo(\"2, foo!\");\n        then(response3.getStatusCode()).isEqualTo(HttpStatus.OK);\n        then(response3.getBody()).isEqualTo(\"3, foo!\");\n    }\n\n    private ConfigurableApplicationContext startApp(int port) {\n        return SpringApplication.run(TestApplication.class,\n                \"--server.port=\" + port,\n                \"--spring.jmx.enabled=false\");\n    }\n\n    @Configuration\n    @EnableAutoConfiguration\n    @RestController\n    static class TestApplication {\n\n        static AtomicInteger atomicInteger = new AtomicInteger();\n\n        @RequestMapping(value = \"/greeting\")\n        public Integer greet() {\n            return atomicInteger.incrementAndGet();\n        }\n\n        @RequestMapping(value = \"/\")\n        public String health() {\n            return \"ok\";\n        }\n    }\n}", "nl": "spring"}
{"code": "\n\n\npublic class Main { \npublic static void main( String[] args ) \n{ \n\ttry{ \n\t\tSystem.loadLibrary( Core.NATIVE_LIBRARY_NAME ); \n\n\t\tMat source = \n\t\tImgcodecs.imread(\"E://input.jpg\", Imgcodecs.CV_LOAD_IMAGE_COLOR); \n\t\tMat destination = new Mat(source.rows(), source.cols(), source.type()); \n\n\t\tImgproc.GaussianBlur(source, destination, new Size(0, 0), 10); \n\t\tCore.addWeighted(source, 1.5, destination, -0.5, 0, destination); \n\n\t\tImgcodecs.imwrite(\"E://output.jpg\", destination); \n\t}catch (Exception e) { \n\t} \n} \n} \n", "nl": "opencv"}
{"code": "\n\n\n\npublic class Objdetect {\n\n    public static final int\n            CASCADE_DO_CANNY_PRUNING = 1,\n            CASCADE_SCALE_IMAGE = 2,\n            CASCADE_FIND_BIGGEST_OBJECT = 4,\n            CASCADE_DO_ROUGH_SEARCH = 8;\n\n\n\n    public static void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold, double eps)\n    {\n        Mat rectList_mat = rectList;\n        Mat weights_mat = weights;\n        groupRectangles_0(rectList_mat.nativeObj, weights_mat.nativeObj, groupThreshold, eps);\n        \n        return;\n    }\n\n    public static void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold)\n    {\n        Mat rectList_mat = rectList;\n        Mat weights_mat = weights;\n        groupRectangles_1(rectList_mat.nativeObj, weights_mat.nativeObj, groupThreshold);\n        \n        return;\n    }\n\n\n\n\n    private static native void groupRectangles_0(long rectList_mat_nativeObj, long weights_mat_nativeObj, int groupThreshold, double eps);\n    private static native void groupRectangles_1(long rectList_mat_nativeObj, long weights_mat_nativeObj, int groupThreshold);\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n@Configuration\n@ComponentScan\n@EnableAutoConfiguration\n@Controller\n@SessionAttributes(\"authorizationRequest\")\npublic class AuthserverApplication extends WebMvcConfigurerAdapter {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(AuthserverApplication.class, args);\n\t}\n\t\n\t@Override\n\tpublic void addViewControllers(ViewControllerRegistry registry) {\n\t\tregistry.addViewController(\"/login\").setViewName(\"login\");\n\t\tregistry.addViewController(\"/oauth/confirm_access\").setViewName(\"authorize\");\n\t}\n\n\t@Configuration\n\t@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)\n\tprotected static class LoginConfig extends WebSecurityConfigurerAdapter {\n\t\t\n\t\t@Autowired\n\t\tprivate AuthenticationManager authenticationManager;\n\t\t\n\t\t@Override\n\t\tprotected void configure(HttpSecurity http) throws Exception {\n\t\t\thttp.formLogin().loginPage(\"/login\").permitAll().and().authorizeRequests()\n\t\t\t\t\t.anyRequest().authenticated();\n\t\t}\n\t\t\n\t\t@Override\n\t\tprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\n\t\t\tauth.parentAuthenticationManager(authenticationManager);\n\t\t}\n\t}\n\n\t@Configuration\n\t@EnableAuthorizationServer\n\tprotected static class OAuth2Config extends AuthorizationServerConfigurerAdapter {\n\n\t\t@Autowired\n\t\tprivate AuthenticationManager authenticationManager;\n\n\t\t@Bean\n\t\tpublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n\t\t\tJwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n\t\t\tKeyPair keyPair = new KeyStoreKeyFactory(\n\t\t\t\t\tnew ClassPathResource(\"keystore.jks\"), \"foobar\".toCharArray())\n\t\t\t\t\t.getKeyPair(\"test\");\n\t\t\tconverter.setKeyPair(keyPair);\n\t\t\treturn converter;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n\t\t\tclients.inMemory()\n\t\t\t\t\t.withClient(\"acme\")\n\t\t\t\t\t.secret(\"acmesecret\")\n\t\t\t\t\t.authorizedGrantTypes(\"authorization_code\", \"refresh_token\",\n\t\t\t\t\t\t\t\"password\").scopes(\"openid\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(AuthorizationServerEndpointsConfigurer endpoints)\n\t\t\t\tthrows Exception {\n\t\t\tendpoints.authenticationManager(authenticationManager).accessTokenConverter(\n\t\t\t\t\tjwtAccessTokenConverter());\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(AuthorizationServerSecurityConfigurer oauthServer)\n\t\t\t\tthrows Exception {\n\t\t\toauthServer.tokenKeyAccess(\"permitAll()\").checkTokenAccess(\n\t\t\t\t\t\"isAuthenticated()\");\n\t\t}\n\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n@Component\npublic class CachedRestClient {\n\n    public static final String CACHE_NAME = \"cache.network\";\n    public static final String CACHE_TTL_KEY = \"cache.network.timetolive\";\n    public static final String CACHE_TTL = \"${cache.network.timetolive:300}\";\n\n    @Cacheable(value = CACHE_NAME, key = \"#url\")\n    public <T> T get(RestOperations operations, String url, Class<T> clazz) {\n        return operations.getForObject(url, clazz);\n    }\n\n    public <T> T post(RestOperations operations, String url, Class<T> clazz, String body) {\n        HttpEntity<String> requestEntity = new HttpEntity<>(body);\n        return operations.postForObject(url, requestEntity, clazz);\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\npublic class ColourQuery {\n\n    public static void main(String[] args) {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n\n        Mat inputImage = Highgui.imread(\"files/lena.jpg\");\n\n\n        Imshow ims1 = new Imshow(\"My Image\");\n        \n        \n        double[] bgr = inputImage.get(0, 0);\n        System.out.println( \"colour @ (0,0) = B: \" + bgr[0] + \" G: \" + bgr[1] + \" R: \" + bgr[2]);\n\n        bgr = inputImage.get(50, 50);\n        System.out.println( \"colour @ (50,50) = B: \" + bgr[0] + \" G: \" + bgr[1] + \" R: \" + bgr[2]);\n       \n        bgr = inputImage.get(100, 25);\n        System.out.println( \"colour @ (100,25) = B: \" + bgr[0] + \" G: \" + bgr[1] + \" R: \" + bgr[2]);\n\n        bgr = inputImage.get(17, 234);\n        System.out.println( \"colour @ (17,234) = B: \" + bgr[0] + \" G: \" + bgr[1] + \" R: \" + bgr[2]);\n        \n        \n        double[] colour = new double [3];\n        colour[0] = 255; colour[1] = 0; colour[2] = 0;\n        inputImage.put(25, 25, colour);\n        inputImage.put(25, 24, colour);\n        inputImage.put(25, 23, colour);\n        inputImage.put(25, 22, colour);\n        \n\n        ims1.showImage(inputImage);\n\n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@RestController\n@RequestMapping(\"tags\")\npublic class TagsController {\n\n\tprivate final TagRepository repository;\n\n\tprivate final NoteResourceAssembler noteResourceAssembler;\n\n\tprivate final TagResourceAssembler tagResourceAssembler;\n\n\t@Autowired\n\tpublic TagsController(TagRepository repository,\n\t\t\tNoteResourceAssembler noteResourceAssembler,\n\t\t\tTagResourceAssembler tagResourceAssembler) {\n\t\tthis.repository = repository;\n\t\tthis.noteResourceAssembler = noteResourceAssembler;\n\t\tthis.tagResourceAssembler = tagResourceAssembler;\n\t}\n\n\t@RequestMapping(method = RequestMethod.GET)\n\tNestedContentResource<TagResource> all() {\n\t\treturn new NestedContentResource<TagResource>(\n\t\t\t\tthis.tagResourceAssembler.toResources(this.repository.findAll()));\n\t}\n\n\t@ResponseStatus(HttpStatus.CREATED)\n\t@RequestMapping(method = RequestMethod.POST)\n\tHttpHeaders create(@RequestBody TagInput tagInput) {\n\t\tTag tag = new Tag();\n\t\ttag.setName(tagInput.getName());\n\n\t\tthis.repository.save(tag);\n\n\t\tHttpHeaders httpHeaders = new HttpHeaders();\n\t\thttpHeaders.setLocation(linkTo(TagsController.class).slash(tag.getId()).toUri());\n\n\t\treturn httpHeaders;\n\t}\n\n\t@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n\tvoid delete(@PathVariable(\"id\") long id) {\n\t\tthis.repository.deleteById(id);\n\t}\n\n\t@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n\tResource<Tag> tag(@PathVariable(\"id\") long id) {\n\t\tTag tag = findTagById(id);\n\t\treturn this.tagResourceAssembler.toResource(tag);\n\t}\n\n\t@RequestMapping(value = \"/{id}/notes\", method = RequestMethod.GET)\n\tResourceSupport tagNotes(@PathVariable(\"id\") long id) {\n\t\tTag tag = findTagById(id);\n\t\treturn new NestedContentResource<NoteResource>(\n\t\t\t\tthis.noteResourceAssembler.toResources(tag.getNotes()));\n\t}\n\n\tprivate Tag findTagById(long id) {\n\t\tTag tag = this.repository.findById(id);\n\t\tif (tag == null) {\n\t\t\tthrow new ResourceDoesNotExistException();\n\t\t}\n\t\treturn tag;\n\t}\n\n\t@RequestMapping(value = \"/{id}\", method = RequestMethod.PATCH)\n\t@ResponseStatus(HttpStatus.NO_CONTENT)\n\tvoid updateTag(@PathVariable(\"id\") long id, @RequestBody TagPatchInput tagInput) {\n\t\tTag tag = findTagById(id);\n\t\tif (tagInput.getName() != null) {\n\t\t\ttag.setName(tagInput.getName());\n\t\t}\n\t\tthis.repository.save(tag);\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\npublic class HandMouse {\n    public HandMouse() {\n        this(new Settings());\n    }\n    public HandMouse(Settings settings) {\n        setSettings(settings);\n    }\n\n    public static class Settings extends BaseChildSettings {\n        public Settings() { }\n        public Settings(Settings s) {\n            s.mopIterations   = mopIterations;\n            s.clickSteadySize = clickSteadySize;\n            s.clickSteadyTime = clickSteadyTime;\n            s.edgeAreaMin     = edgeAreaMin;\n            s.edgeAreaMax     = edgeAreaMax;\n            s.thresholdHigh   = thresholdHigh;\n            s.thresholdLow    = thresholdLow;\n            s.brightnessMin   = brightnessMin;\n            s.updateAlpha     = updateAlpha;\n        }\n\n        int    mopIterations   = 1;\n        double clickSteadySize = 0.05;\n        long   clickSteadyTime = 250;\n        double edgeAreaMin     = 0.001;\n        double edgeAreaMax     = 0.1;\n        double thresholdHigh   = 0.5;\n        double thresholdLow    = 0.25;\n        double brightnessMin   = 0.1;\n        double updateAlpha     = 0.5;\n\n        public int getMopIterations() {\n            return mopIterations;\n        }\n        public void setMopIterations(int mopIterations) {\n            this.mopIterations = mopIterations;\n        }\n\n        public double getClickSteadySize() {\n            return clickSteadySize;\n        }\n        public void setClickSteadySize(double clickSteadySize) {\n            this.clickSteadySize = clickSteadySize;\n        }\n\n        public long getClickSteadyTime() {\n            return clickSteadyTime;\n        }\n        public void setClickSteadyTime(long clickSteadyTime) {\n            this.clickSteadyTime = clickSteadyTime;\n        }\n\n        public double getEdgeAreaMin() {\n            return edgeAreaMin;\n        }\n        public void setEdgeAreaMin(double edgeAreaMin) {\n            this.edgeAreaMin = edgeAreaMin;\n        }\n\n        public double getEdgeAreaMax() {\n            return edgeAreaMax;\n        }\n        public void setEdgeAreaMax(double edgeAreaMax) {\n            this.edgeAreaMax = edgeAreaMax;\n        }\n\n        public double getThresholdHigh() {\n            return thresholdHigh;\n        }\n        public void setThresholdHigh(double thresholdHigh) {\n            this.thresholdHigh = thresholdHigh;\n        }\n\n        public double getThresholdLow() {\n            return thresholdLow;\n        }\n        public void setThresholdLow(double thresholdLow) {\n            this.thresholdLow = thresholdLow;\n        }\n\n        public double getBrightnessMin() {\n            return brightnessMin;\n        }\n        public void setBrightnessMin(double brightnessMin) {\n            this.brightnessMin = brightnessMin;\n        }\n\n        public double getUpdateAlpha() {\n            return updateAlpha;\n        }\n        public void setUpdateAlpha(double updateAlpha) {\n            this.updateAlpha = updateAlpha;\n        }\n    }\n\n    private Settings settings;\n    public Settings getSettings() {\n        return settings;\n    }\n    public void setSettings(Settings settings) {\n        this.settings = settings;\n    }\n\n    private IplImage relativeResidual = null, binaryImage = null;\n    private CvRect roi = null;\n    private CvMemStorage storage = CvMemStorage.create();\n    private int contourPointsSize = 0;\n    private IntPointer intPointer = new IntPointer(1);\n    private CvPoint contourPoints = null;\n    private IntBuffer contourPointsBuffer = null;\n    private CvMoments moments = new CvMoments();\n    private double edgeX = 0, edgeY = 0, centerX = 0, centerY = 0;\n    private double imageTipX = -1, tipX = -1, prevTipX = -1;\n    private double imageTipY = -1, tipY = -1, prevTipY = -1;\n    private long tipTime = 0, prevTipTime = 0;\n    private CvPoint pt1 = new CvPoint(), pt2 = new CvPoint();\n    private boolean imageUpdateNeeded = false;\n\n    public void reset() {\n        tipX = tipY = prevTipX = prevTipY = -1;\n    }\n\n    public void update(IplImage[] images, int pyramidLevel, CvRect roi, double[] roiPts) {\n        this.roi = roi;\n\n        IplImage target      = images[1];\n        IplImage transformed = images[2];\n        IplImage residual    = images[3];\n        IplImage mask        = images[4];\n        int width    = roi.width();\n        int height   = roi.height();\n        int channels = residual.nChannels();\n        relativeResidual = IplImage.createIfNotCompatible(relativeResidual, mask);\n        binaryImage      = IplImage.createIfNotCompatible(binaryImage,      mask);\n        cvResetImageROI(relativeResidual);\n        cvResetImageROI(binaryImage);\n\n        double brightnessMin = (channels > 3 ? 3 : channels)*settings.brightnessMin;\n        double contourEdgeAreaMax = (width+height)/2*width*height*settings.edgeAreaMax;\n        double contourEdgeAreaMin = (width+height)/2*width*height*settings.edgeAreaMin;\n        ByteBuffer maskBuf = mask.getByteBuffer();\n        FloatBuffer residualBuf = residual.getFloatBuffer();\n        FloatBuffer targetBuf = target.getFloatBuffer();\n        FloatBuffer transformedBuf = transformed.getFloatBuffer();\n        ByteBuffer relResBuf = relativeResidual.getByteBuffer();\n        while (maskBuf.hasRemaining() && residualBuf.hasRemaining() &&\n                targetBuf.hasRemaining() && transformedBuf.hasRemaining() &&\n                relResBuf.hasRemaining()) {\n            byte m = maskBuf.get();\n            if (m == 0) {\n                residualBuf.position(residualBuf.position() + channels);\n                targetBuf.position(targetBuf.position() + channels);\n                transformedBuf.position(transformedBuf.position() + channels);\n                relResBuf.put((byte)0);\n            } else {\n                double relativeNorm = 0;\n                double brightness = 0;\n                for (int z = 0; z < channels; z++) {\n                    float r = Math.abs(residualBuf.get());\n                    float c = targetBuf.get();\n                    float t = transformedBuf.get();\n                    if (z < 3) {\n                        float maxct = Math.max(c,t);\n                        brightness += maxct;\n                        relativeNorm = Math.max(r/maxct, relativeNorm);\n                    } // ignore alpha channel\n                }\n                if (brightness < brightnessMin) {\n                    relResBuf.put((byte)0);\n                } else {\n                    relResBuf.put((byte)Math.round(255 / settings.thresholdHigh *\n                            Math.min(relativeNorm, settings.thresholdHigh)));\n                }\n            }\n        }\n\n        JavaCV.hysteresisThreshold(relativeResidual, binaryImage,\n                255, 255*settings.thresholdLow/settings.thresholdHigh, 255);\n\n        int roiX = roi.x(), roiY = roi.y();\n        cvSetImageROI(binaryImage, roi);\n\n        if (settings.mopIterations > 0) {\n            cvMorphologyEx(binaryImage, binaryImage, null, null, CV_MOP_OPEN,  settings.mopIterations);\n            cvMorphologyEx(binaryImage, binaryImage, null, null, CV_MOP_CLOSE, settings.mopIterations);\n        }\n        CvSeq contour = new CvContour(null);\n        cvFindContours(binaryImage, storage, contour, Loader.sizeof(CvContour.class),\n                CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);\n        double largestContourEdgeArea = 0;\n        CvSeq largestContour = null;\n        while (contour != null && !contour.isNull()) {\n            contourPointsSize = contour.total();\n            if (contourPoints == null || contourPoints.capacity() < contourPointsSize) {\n                contourPoints = new CvPoint(contourPointsSize);\n                contourPointsBuffer = contourPoints.asByteBuffer().asIntBuffer();\n            }\n            cvCvtSeqToArray(contour, contourPoints.position(0));\n\n            double[] edgePts = new double[roiPts.length];\n            for (int i = 0; i < roiPts.length/2; i++) {\n                edgePts[2*i    ] = roiPts[2*i    ]/(1<<pyramidLevel) - roiX;\n                edgePts[2*i + 1] = roiPts[2*i + 1]/(1<<pyramidLevel) - roiY;\n            }\n\n            double m00 = 0, m10 = 0, m01 = 0;\n            for (int i = 0; i < contourPointsSize; i++) {\n                int x = contourPointsBuffer.get(2*i    ),\n                    y = contourPointsBuffer.get(2*i + 1);\n                for (int j = 0; j < roiPts.length/2; j++) {\n                    double x1 = edgePts[ 2*j                     ],\n                           y1 = edgePts[ 2*j + 1                 ],\n                           x2 = edgePts[(2*j + 2) % edgePts.length],\n                           y2 = edgePts[(2*j + 3) % edgePts.length];\n                    double dx = x2 - x1;\n                    double dy = y2 - y1;\n                    double d2 = dx*dx + dy*dy;\n                    double u = ((x - x1)*dx + (y - y1)*dy) / d2;\n\n                    double px = x1 + u*dx;\n                    double py = y1 + u*dy;\n\n                    dx = px - x;\n                    dy = py - y;\n                    d2 = dx*dx + dy*dy;\n                    if (d2 < 2) {\n                        m00 += 1;\n                        m10 += x;\n                        m01 += y;\n                        break;\n                    }\n                }\n            }\n            double contourEdgeArea = m00*Math.abs(cvContourArea(contour, CV_WHOLE_SEQ, 0));\n            if (contourEdgeArea > contourEdgeAreaMin && contourEdgeArea < contourEdgeAreaMax &&\n                    contourEdgeArea > largestContourEdgeArea) {\n                largestContourEdgeArea = contourEdgeArea;\n                largestContour = contour;\n\n                double inv_m00 = 1 / m00;\n                edgeX = m10 * inv_m00;\n                edgeY = m01 * inv_m00;\n            }\n            contour = contour.h_next();\n        }\n\n        if (isClick()) {\n            prevTipX = -1;\n            prevTipY = -1;\n            prevTipTime = 0;\n        } else if (!isSteady()) {\n            prevTipX = tipX;\n            prevTipY = tipY;\n            prevTipTime = System.currentTimeMillis();\n        }\n\n        if (largestContour == null) {\n            tipX = -1;\n            tipY = -1;\n            tipTime = 0;\n            imageUpdateNeeded = false;\n        } else {\n            cvMoments(largestContour, moments, 0);\n            double inv_m00 = 1 / moments.m00();\n            centerX = moments.m10() * inv_m00;\n            centerY = moments.m01() * inv_m00;\n\n            contourPointsSize = largestContour.total();\n            cvCvtSeqToArray(largestContour, contourPoints.position(0));\n\n            double tipDist2 = 0;\n            int tipIndex = 0;\n            for (int i = 0; i < contourPointsSize; i++) {\n                int x = contourPointsBuffer.get(2*i    ),\n                    y = contourPointsBuffer.get(2*i + 1);\n                double dx = centerX - edgeX;\n                double dy = centerY - edgeY;\n                double d2 = dx*dx + dy*dy;\n                double u = ((x - edgeX)*dx + (y - edgeY)*dy) / d2;\n\n                double px = edgeX + u*dx;\n                double py = edgeY + u*dy;\n\n                dx = px - edgeX;\n                dy = py - edgeY;\n                d2 = dx*dx + dy*dy;\n                if (d2 > tipDist2) {\n                    tipIndex = i;\n                    tipDist2 = d2;\n                }\n            }\n            double a = imageTipX < 0 || imageTipY < 0 ? 1.0 : settings.updateAlpha;\n            imageTipX = a*contourPointsBuffer.get(2*tipIndex    ) + (1-a)*imageTipX;\n            imageTipY = a*contourPointsBuffer.get(2*tipIndex + 1) + (1-a)*imageTipY;\n            tipX = (imageTipX+roiX)*(1<<pyramidLevel);\n            tipY = (imageTipY+roiY)*(1<<pyramidLevel);\n            tipTime = System.currentTimeMillis();\n            imageUpdateNeeded = true;\n        }\n\n        cvClearMemStorage(storage);\n    }\n\n    public IplImage getRelativeResidual() {\n        return relativeResidual;\n    }\n    public IplImage getResultImage() {\n        if (imageUpdateNeeded) {\n            cvSetZero(binaryImage);\n            cvFillPoly(binaryImage, contourPoints, intPointer.put(contourPointsSize), 1, CvScalar.WHITE, 8, 0);\n\n            pt1.put((byte)16, edgeX, edgeY);\n            cvCircle(binaryImage, pt1, 5<<16, CvScalar.GRAY, 2, 8, 16);\n\n            pt1.put((byte)16, centerX-5, centerY-5); pt2.put((byte)16, centerX+5, centerY+5);\n            cvRectangle(binaryImage, pt1, pt2, CvScalar.GRAY, 2, 8, 16);\n\n            pt1.put((byte)16, imageTipX-5, imageTipY-5); pt2.put((byte)16, imageTipX+5, imageTipY+5);\n            cvLine(binaryImage, pt1, pt2, CvScalar.GRAY, 2, 8, 16);\n            pt1.put((byte)16, imageTipX-5, imageTipY+5); pt2.put((byte)16, imageTipX+5, imageTipY-5);\n            cvLine(binaryImage, pt1, pt2, CvScalar.GRAY, 2, 8, 16);\n\n            cvResetImageROI(binaryImage);\n            imageUpdateNeeded = false;\n        }\n        return binaryImage;\n    }\n\n    public double getX() {\n        return tipX;\n    }\n    public double getY() {\n        return tipY;\n    }\n\n    public boolean isSteady() {\n        if (tipX >= 0 && tipY >= 0 && prevTipX >= 0 && prevTipY >= 0) {\n            double dx = tipX - prevTipX;\n            double dy = tipY - prevTipY;\n            int imageSize = (roi.width() + roi.height())/2;\n            double steadySize = settings.clickSteadySize*imageSize;\n            return dx*dx + dy*dy < steadySize*steadySize;\n        }\n        return false;\n    }\n    public boolean isClick() {\n        return isSteady() && tipTime - prevTipTime > settings.clickSteadyTime;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Configuration\n@EnableCaching(proxyTargetClass = true)\n@Profile(SaganProfiles.STANDALONE)\nclass StandaloneCacheConfig {\n\n\t@Bean\n\tpublic CacheManager simpleCacheManager() {\n\t\tSimpleCacheManager cacheManager = new SimpleCacheManager();\n\t\tcacheManager.setCaches(\n\t\t\t\tArrays.asList(CachedRestClient.CACHE_NAME,\n\t\t\t\t\t\tGettingStartedGuides.CACHE_GUIDE, GettingStartedGuides.CACHE_GUIDES,\n\t\t\t\t\t\tTutorials.CACHE_TUTORIAL, Tutorials.CACHE_TUTORIALS,\n\t\t\t\t\t\tTopicals.CACHE_TOPICAL, Topicals.CACHE_TOPICALS).stream()\n\t\t\t\t\t\t.map(name -> new ConcurrentMapCache(name))\n\t\t\t\t\t\t.collect(Collectors.toList()));\n\t\treturn cacheManager;\n\t}\n\n}\n\n@Configuration\n@EnableCaching(proxyTargetClass = true)\n@Profile(SaganProfiles.CLOUDFOUNDRY)\nclass CloudFoundryCacheConfig extends AbstractCloudConfig {\n\n\t@Value(CachedRestClient.CACHE_TTL)\n\tprotected Long cacheNetworkTimeToLive;\n\n\t@Bean\n\tpublic CacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory,\n\t\t\tObjectMapper objectMapper, SiteProperties properties) {\n\n\t\tRedisCacheManager cacheManager = new RedisCacheManager(redisConnectionFactory);\n\n\t\tcacheManager.withCache(CachedRestClient.CACHE_NAME, this.cacheNetworkTimeToLive);\n\n\t\tJsonRedisTemplate guideTemplate = new JsonRedisTemplate<>(redisConnectionFactory, objectMapper,\n\t\t\t\tGettingStartedGuides.CACHE_GUIDE_TYPE);\n\t\tcacheManager.withCache(GettingStartedGuides.CACHE_GUIDE, guideTemplate,\n\t\t\t\tproperties.getCache().getContentTimeToLive());\n\n\t\tJsonRedisTemplate guidesTemplate = new JsonRedisTemplate<>(redisConnectionFactory, objectMapper,\n\t\t\t\tGettingStartedGuides.CACHE_GUIDES_TYPE);\n\t\tcacheManager.withCache(GettingStartedGuides.CACHE_GUIDES, guidesTemplate,\n\t\t\t\tproperties.getCache().getListTimeToLive());\n\n\t\tJsonRedisTemplate tutorialTemplate = new JsonRedisTemplate<>(redisConnectionFactory, objectMapper,\n\t\t\t\tTutorials.CACHE_TUTORIAL_TYPE);\n\t\tcacheManager.withCache(Tutorials.CACHE_TUTORIAL, tutorialTemplate,\n\t\t\t\tproperties.getCache().getContentTimeToLive());\n\n\t\tJsonRedisTemplate tutorialsTemplate = new JsonRedisTemplate<>(redisConnectionFactory, objectMapper,\n\t\t\t\tTutorials.CACHE_TUTORIALS_TYPE);\n\t\tcacheManager.withCache(Tutorials.CACHE_TUTORIALS, tutorialsTemplate,\n\t\t\t\tproperties.getCache().getListTimeToLive());\n\n\t\tJsonRedisTemplate topicalTemplate = new JsonRedisTemplate<>(redisConnectionFactory, objectMapper,\n\t\t\t\tTopicals.CACHE_TOPICAL_TYPE);\n\t\tcacheManager.withCache(Topicals.CACHE_TOPICAL, topicalTemplate,\n\t\t\t\tproperties.getCache().getContentTimeToLive());\n\n\t\tJsonRedisTemplate topicalsTemplate = new JsonRedisTemplate<>(redisConnectionFactory, objectMapper,\n\t\t\t\tTopicals.CACHE_TOPICALS_TYPE);\n\t\tcacheManager.withCache(Topicals.CACHE_TOPICALS, topicalsTemplate,\n\t\t\t\tproperties.getCache().getListTimeToLive());\n\n\t\treturn cacheManager;\n\t}\n\n\t\n\n\t@Bean\n\tpublic RedisConnectionFactory redisConnectionFactory() {\n\t\treturn connectionFactory().redisConnectionFactory();\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class CountryClient extends WebServiceGatewaySupport {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(CountryClient.class);\n\n\tpublic GetCountryResponse getCountry(String country) {\n\n\t\tGetCountryRequest request = new GetCountryRequest();\n\t\trequest.setName(country);\n\n\t\tlog.info(\"Requesting location for \" + country);\n\n\t\tGetCountryResponse response = (GetCountryResponse) getWebServiceTemplate()\n\t\t\t\t.marshalSendAndReceive(\"http://localhost:8080/ws/countries\", request,\n\t\t\t\t\t\tnew SoapActionCallback(\n\t\t\t\t\t\t\t\t\"http://spring.io/guides/gs-producing-web-service/GetCountryRequest\"));\n\n\t\treturn response;\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\npublic class MapSessionRepository implements SessionRepository<MapSession> {\n\n\t\n\tprivate Integer defaultMaxInactiveInterval;\n\n\tprivate final Map<String, Session> sessions;\n\n\t\n\tpublic MapSessionRepository(Map<String, Session> sessions) {\n\t\tif (sessions == null) {\n\t\t\tthrow new IllegalArgumentException(\"sessions cannot be null\");\n\t\t}\n\t\tthis.sessions = sessions;\n\t}\n\n\t\n\tpublic void setDefaultMaxInactiveInterval(int defaultMaxInactiveInterval) {\n\t\tthis.defaultMaxInactiveInterval = defaultMaxInactiveInterval;\n\t}\n\n\t@Override\n\tpublic void save(MapSession session) {\n\t\tif (!session.getId().equals(session.getOriginalId())) {\n\t\t\tthis.sessions.remove(session.getOriginalId());\n\t\t}\n\t\tthis.sessions.put(session.getId(), new MapSession(session));\n\t}\n\n\t@Override\n\tpublic MapSession findById(String id) {\n\t\tSession saved = this.sessions.get(id);\n\t\tif (saved == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (saved.isExpired()) {\n\t\t\tdeleteById(saved.getId());\n\t\t\treturn null;\n\t\t}\n\t\treturn new MapSession(saved);\n\t}\n\n\t@Override\n\tpublic void deleteById(String id) {\n\t\tthis.sessions.remove(id);\n\t}\n\n\t@Override\n\tpublic MapSession createSession() {\n\t\tMapSession result = new MapSession();\n\t\tif (this.defaultMaxInactiveInterval != null) {\n\t\t\tresult.setMaxInactiveInterval(Duration.ofSeconds(this.defaultMaxInactiveInterval));\n\t\t}\n\t\treturn result;\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\npublic final class SessionRepositoryMessageInterceptor<S extends Session>\n\t\timplements ChannelInterceptor, HandshakeInterceptor {\n\n\tprivate static final String SPRING_SESSION_ID_ATTR_NAME = \"SPRING.SESSION.ID\";\n\n\tprivate final SessionRepository<S> sessionRepository;\n\n\tprivate Set<SimpMessageType> matchingMessageTypes;\n\n\t\n\tpublic SessionRepositoryMessageInterceptor(SessionRepository<S> sessionRepository) {\n\t\tAssert.notNull(sessionRepository, \"sessionRepository cannot be null\");\n\t\tthis.sessionRepository = sessionRepository;\n\t\tthis.matchingMessageTypes = EnumSet.of(SimpMessageType.CONNECT, SimpMessageType.MESSAGE,\n\t\t\t\tSimpMessageType.SUBSCRIBE, SimpMessageType.UNSUBSCRIBE);\n\t}\n\n\t\n\tpublic void setMatchingMessageTypes(Set<SimpMessageType> matchingMessageTypes) {\n\t\tAssert.notEmpty(matchingMessageTypes, \"matchingMessageTypes cannot be null or empty\");\n\t\tthis.matchingMessageTypes = matchingMessageTypes;\n\t}\n\n\t@Override\n\tpublic Message<?> preSend(Message<?> message, MessageChannel channel) {\n\t\tif (message == null) {\n\t\t\treturn message;\n\t\t}\n\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders());\n\t\tif (!this.matchingMessageTypes.contains(messageType)) {\n\t\t\treturn message;\n\t\t}\n\t\tMap<String, Object> sessionHeaders = SimpMessageHeaderAccessor.getSessionAttributes(message.getHeaders());\n\t\tString sessionId = (sessionHeaders != null) ? (String) sessionHeaders.get(SPRING_SESSION_ID_ATTR_NAME) : null;\n\t\tif (sessionId != null) {\n\t\t\tS session = this.sessionRepository.findById(sessionId);\n\t\t\tif (session != null) {\n\t\t\t\tsession.setLastAccessedTime(Instant.now());\n\t\t\t\tthis.sessionRepository.save(session);\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}\n\n\t@Override\n\tpublic boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,\n\t\t\tMap<String, Object> attributes) {\n\t\tif (request instanceof ServletServerHttpRequest) {\n\t\t\tServletServerHttpRequest servletRequest = (ServletServerHttpRequest) request;\n\t\t\tHttpSession session = servletRequest.getServletRequest().getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsetSessionId(attributes, session.getId());\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,\n\t\t\tException exception) {\n\t}\n\n\tpublic static String getSessionId(Map<String, Object> attributes) {\n\t\treturn (String) attributes.get(SPRING_SESSION_ID_ATTR_NAME);\n\t}\n\n\tpublic static void setSessionId(Map<String, Object> attributes, String sessionId) {\n\t\tattributes.put(SPRING_SESSION_ID_ATTR_NAME, sessionId);\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\npublic class backgroundModel {\n\n    public static void main(String[] args) throws InterruptedException {\n\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n\n        VideoCapture cap = new VideoCapture();\n\n        \n        int CAM_TO_USE = 0;\n        \n        \n        Mat frame = new Mat();\n        Mat foreground = new Mat();\n        Mat fg_mask = new Mat();\n        \n        \n        BackgroundSubtractorMOG MoG = new BackgroundSubtractorMOG();\n        \n        \n        try {\n        \tcap.open(CAM_TO_USE);\n        } catch (Exception e1) {\n            System.out.println(\"No webcam attached\");\n        \n            \n            try{\n            \tcap.open(\"files/video.mp4\");\n            } catch (Exception e2) {\n            \tSystem.out.println(\"No video file found\");\n            }\n        }\n        \n        \n        if (cap.isOpened())\n        {\n            \n            Imshow imsS = new Imshow(\"from video Source ... \");\n            Imshow imsF = new Imshow(\"Foreground\");\n      \n          \tboolean keepProcessing = true;\n        \t\n        \twhile (keepProcessing)\n        \t{\t\n\n        \t\tcap.grab();\n            \tcap.retrieve(frame);\n\n            \t\n            \tif (!(frame.empty()))\n            \t{\n            \t\n            \t\t\n            \t\tMoG.apply(frame, fg_mask, 0.1);\n            \t\t\n            \t\t\n            \t\tImgproc.cvtColor(fg_mask, fg_mask, Imgproc.COLOR_GRAY2BGR);\n            \t\t\n            \t\t\n            \t\tCore.bitwise_and(frame, fg_mask, foreground); \n            \t\t\n\n            \t\timsS.showImage(frame);\n            \t\timsF.showImage(foreground);\n            \t\tThread.sleep(40);\n            \t\n            \t} else { \n            \t\tkeepProcessing = false;\n        \t\t}\n        \t}\n\n        } else {\n            System.out.println(\"error cannot open any capture source - exiting\");\n        }\n\n\n        cap.release();\n        \n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\npublic class OptimizedContrastEnhance {\n\n\tpublic static Mat enhance(Mat image, int blkSize, int patchSize, double lambda, double eps, int krnlSize) {\n\t\timage.convertTo(image, CvType.CV_32F);\n\t\tdouble[] airlight = AirlightEstimate.estimate(image, blkSize);\n\t\tdouble fTrans = 0.5;\n\t\tMat T = TransmissionEstimate.transEstimate(image, patchSize, airlight, lambda, fTrans);\n\t\tMat gray = new Mat();\n\t\tImgproc.cvtColor(image, gray, Imgproc.COLOR_RGB2GRAY);\n\t\tCore.divide(gray, new Scalar(255.0), gray);\n\t\tT = Filters.GuidedImageFilter(gray, T, krnlSize, eps);\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(image, bgr);\n\t\tMat bChannel = dehaze(bgr.get(0), T, airlight[0]);\n\t\tMat gChannel = dehaze(bgr.get(1), T, airlight[1]);\n\t\tMat rChannel = dehaze(bgr.get(2), T, airlight[2]);\n\t\tMat dehazedImg = new Mat();\n\t\tCore.merge(new ArrayList<>(Arrays.asList(bChannel, gChannel, rChannel)), dehazedImg);\n\t\treturn dehazedImg;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tpublic static Mat enhanceEachChannel(Mat image, int blkSize, int patchSize, double lambda, double eps, int krnlSize) {\n\t\timage.convertTo(image, CvType.CV_32F);\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(image, bgr);\n\t\tMat bChannel = bgr.get(0);\n\t\tMat gChannel = bgr.get(1);\n\t\tMat rChannel = bgr.get(2);\n\t\tdouble[] airlight = AirlightEstimate.estimate(image, blkSize);\n\t\tdouble fTrans = 0.3;\n\t\tMat T = TransmissionEstimate.transEstimateEachChannel(bChannel, patchSize, airlight[0], lambda, fTrans);\n\t\tCore.subtract(T, new Scalar(1.0), T);\n\t\tCore.multiply(T, new Scalar(-1.0), T);\n\t\tMat Tb = Filters.GuidedImageFilter(bChannel, T, krnlSize, eps);\n\t\tT = TransmissionEstimate.transEstimateEachChannel(gChannel, patchSize, airlight[1], lambda, fTrans);\n\t\tCore.subtract(T, new Scalar(1.0), T);\n\t\tCore.multiply(T, new Scalar(-1.0), T);\n\t\tMat Tg = Filters.GuidedImageFilter(gChannel, T, krnlSize, eps);\n\t\tT = TransmissionEstimate.transEstimateEachChannel(rChannel, patchSize, airlight[2], lambda, fTrans);\n\t\tCore.subtract(T, new Scalar(1.0), T);\n\t\tCore.multiply(T, new Scalar(-1.0), T);\n\t\tMat Tr = Filters.GuidedImageFilter(rChannel, T, krnlSize, eps);\n\t\tbChannel = dehaze(bChannel, Tb, airlight[0]);\n\t\tgChannel = dehaze(gChannel, Tg, airlight[1]);\n\t\trChannel = dehaze(rChannel, Tr, airlight[2]);\n\t\tMat outval = new Mat();\n\t\tCore.merge(new ArrayList<>(Arrays.asList(bChannel, gChannel, rChannel)), outval);\n\t\treturn outval;\n\t}\n\n\tprivate static Mat dehaze(Mat img, Mat T, double airlight) {\n\t\tCore.subtract(img, new Scalar(airlight), img);\n\t\tCore.divide(img, T, img);\n\t\tCore.add(img, new Scalar(airlight), img);\n\t\treturn img;\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n@Configuration\npublic class GreetingRouter {\n\n\t@Bean\n\tpublic RouterFunction<ServerResponse> route(GreetingHandler greetingHandler) {\n\n\t\treturn RouterFunctions\n\t\t\t.route(RequestPredicates.GET(\"/hello\").and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), greetingHandler::hello);\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n@SuppressWarnings(\"all\")\npublic class BlkTransEstimate {\n\n\tpublic static double blkEstimate(Mat blkIm, double[] airlight, double lambda, double fTrans) {\n\t\tdouble Trans = 0.0;\n\t\tdouble nTrans = Math.floor(1.0 / fTrans * 128);\n\t\tdouble fMinCost = Double.MAX_VALUE;\n\t\tint numberOfPixels = blkIm.rows() * blkIm.cols() * blkIm.channels();\n\t\tdouble nCounter = 0.0;\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(blkIm, bgr);\n\t\twhile (nCounter < (1.0 - fTrans) * 10) {\n\t\t\tMat bChannel = bgr.get(0).clone();\n\t\t\tbChannel = preDehaze(bChannel, airlight[0], nTrans);\n\t\t\tMat gChannel = bgr.get(1).clone();\n\t\t\tgChannel = preDehaze(gChannel, airlight[1], nTrans);\n\t\t\tMat rChannel = bgr.get(2).clone();\n\t\t\trChannel = preDehaze(rChannel, airlight[2], nTrans);\n\t\t\tdouble nSumOfLoss = 0.0;\n\t\t\tfor (int i = 0; i < bChannel.rows(); i++) {\n\t\t\t\tfor (int j = 0; j < bChannel.cols(); j++) {\n\t\t\t\t\tif (bChannel.get(i, j)[0] > 255.0) nSumOfLoss += (bChannel.get(i, j)[0] - 255.0) * (bChannel.get(i, j)[0] - 255.0);\n\t\t\t\t\telse if (bChannel.get(i, j)[0] < 0.0) nSumOfLoss += bChannel.get(i, j)[0] * bChannel.get(i, j)[0];\n\t\t\t\t\tif (gChannel.get(i, j)[0] > 255.0) nSumOfLoss += (gChannel.get(i, j)[0] - 255.0) * (gChannel.get(i, j)[0] - 255.0);\n\t\t\t\t\telse if (gChannel.get(i, j)[0] < 0.0) nSumOfLoss += gChannel.get(i, j)[0] * gChannel.get(i, j)[0];\n\t\t\t\t\tif (rChannel.get(i, j)[0] > 255.0) nSumOfLoss += (rChannel.get(i, j)[0] - 255.0) * (rChannel.get(i, j)[0] - 255.0);\n\t\t\t\t\telse if (rChannel.get(i, j)[0] < 0.0) nSumOfLoss += rChannel.get(i, j)[0] * rChannel.get(i, j)[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble nSumOfSquareOuts = Core.sumElems(bChannel.mul(bChannel)).val[0] + Core.sumElems(gChannel.mul(gChannel)).val[0] + Core.sumElems(rChannel.mul(rChannel)).val[0];\n\t\t\tdouble nSumOfOuts = Core.sumElems(bChannel).val[0] + Core.sumElems(gChannel).val[0] + Core.sumElems(rChannel).val[0];\n\t\t\tdouble fMean = nSumOfOuts / numberOfPixels;\n\t\t\tdouble fCost = lambda * nSumOfLoss / numberOfPixels - (nSumOfSquareOuts / numberOfPixels - fMean * fMean);\n\t\t\tif (nCounter == 0 || fMinCost > fCost) {\n\t\t\t\tfMinCost = fCost;\n\t\t\t\tTrans = fTrans;\n\t\t\t}\n\t\t\tfTrans = fTrans + 0.1;\n\t\t\tnTrans = 1.0 / fTrans * 128.0;\n\t\t\tnCounter = nCounter + 1;\n\t\t}\n\t\treturn Trans;\n\t}\n\n\tpublic static double blkEstimateEachChannel(Mat blkIm, double airlight, double lambda, double fTrans) {\n\t\tdouble Trans = 0.0;\n\t\tdouble nTrans = Math.floor(1.0 / fTrans * 128);\n\t\tdouble fMinCost = Double.MAX_VALUE;\n\t\tint numberOfPixels = blkIm.rows() * blkIm.cols() * blkIm.channels();\n\t\tint nCounter = 0;\n\t\twhile (nCounter < (int) (1 - fTrans) * 10) {\n\t\t\tMat channel = blkIm.clone();\n\t\t\tchannel = preDehaze(channel, airlight, nTrans);\n\t\t\tdouble nSumOfLoss = 0.0;\n\t\t\tfor (int i = 0; i < channel.rows(); i++) {\n\t\t\t\tfor (int j = 0; j < channel.cols(); j++) {\n\t\t\t\t\tif (channel.get(i, j)[0] > 255.0) nSumOfLoss += (channel.get(i, j)[0] - 255.0) * (channel.get(i, j)[0] - 255.0);\n\t\t\t\t\telse if (channel.get(i, j)[0] < 0.0) nSumOfLoss += channel.get(i, j)[0] * channel.get(i, j)[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble nSumOfSquareOuts = Core.sumElems(channel.mul(channel)).val[0];\n\t\t\tdouble nSumOfOuts = Core.sumElems(channel).val[0];\n\t\t\tdouble fMean = nSumOfOuts / numberOfPixels;\n\t\t\tdouble fCost = lambda * nSumOfLoss / numberOfPixels - (nSumOfSquareOuts / numberOfPixels - fMean * fMean);\n\t\t\tif (nCounter == 0 || fMinCost > fCost) {\n\t\t\t\tfMinCost = fCost;\n\t\t\t\tTrans = fTrans;\n\t\t\t}\n\t\t\tfTrans = fTrans + 0.1;\n\t\t\tnTrans = 1.0 / fTrans * 128;\n\t\t\tnCounter = nCounter + 1;\n\t\t}\n\t\treturn Trans;\n\t}\n\n\tprivate static Mat preDehaze(Mat img, double a, double nTrans) {\n\t\tCore.subtract(img, new Scalar(a), img);\n\t\tCore.multiply(img, new Scalar(nTrans), img);\n\t\tCore.add(img, new Scalar(128.0 * a), img);\n\t\tCore.divide(img, new Scalar(128.0), img);\n\t\treturn img;\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\npublic class Filter2D {\n   public static void main( String[] args ) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap11/filter_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Mat kernel = Mat.ones(2,2, CvType.CV_32F);\n      \n      for(int i = 0; i<kernel.rows(); i++) {\n         for(int j = 0; j<kernel.cols(); j++) {\n            double[] m = kernel.get(i, j);\n\n            for(int k = 1; k<m.length; k++) {\n               m[k] = m[k]/(2 * 2);\n            }\n            kernel.put(i,j, m);\n         }\n      }\n      Imgproc.filter2D(src, dst, -1, kernel);\n      Imgcodecs.imwrite(\"E:/OpenCV/chap11/filter2d.jpg\", dst);\n      System.out.println(\"Image Processed\");\n   }\n}\n", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest({ \"auto.startup=false\",      // we don't want to start the real feed\n                  \"feed.file.name=Test\" })   // use a different file\npublic class FlowTests {\n\n\t@Autowired\n\tprivate SourcePollingChannelAdapter newsAdapter;\n\n\t@Autowired\n\tprivate MessageChannel news;\n\n\t@Test\n\tpublic void test() throws Exception {\n\t\tassertThat(this.newsAdapter.isRunning()).isFalse();\n\t\tSyndEntryImpl syndEntry = new SyndEntryImpl();\n\t\tsyndEntry.setTitle(\"Test Title\");\n\t\tsyndEntry.setLink(\"http://foo/bar\");\n\t\tFile out = new File(\"/tmp/si/Test\");\n\t\tout.delete();\n\t\tassertThat(out.exists()).isFalse();\n\t\tthis.news.send(MessageBuilder.withPayload(syndEntry).build());\n\t\tassertThat(out.exists()).isTrue();\n\t\tBufferedReader br = new BufferedReader(new FileReader(out));\n\t\tString line = br.readLine();\n\t\tassertThat(line).isEqualTo(\"Test Title @ http://foo/bar\");\n\t\tbr.close();\n\t\tout.delete();\n\t}\n\n}", "nl": "spring"}
{"code": "class OnCameraFrame {\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n\n        final int viewMode = mViewMode;\n   \n        switch (viewMode) {\n   \n        case VIEW_MODE_GRAY:\n             Imgproc.cvtColor( inputFrame.gray(), mRgba,\n                               Imgproc.COLOR_GRAY2RGBA, 4 );\n             break;\n   \n        case VIEW_MODE_RGBA:\n             mRgba = inputFrame.rgba();\n             break;\n   \n        case VIEW_MODE_CANNY:\n             mRgba = inputFrame.rgba();\n             Imgproc.Canny(inputFrame.gray(), mIntermediateMat, 80, 100);\n             Imgproc.cvtColor( mIntermediateMat, mRgba,\n                               Imgproc.COLOR_GRAY2RGBA, 4 );\n             break;\n   \n        case VIEW_MODE_FEATURES:\n             mRgba = inputFrame.rgba();\n             mGray = inputFrame.gray();\n             FindFeatures( mGray.getNativeObjAddr(),\n                           mRgba.getNativeObjAddr() );\n             break;\n   \n        }\n   \n        return mRgba;\n   \n   }\n   \n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class ALTMRetinex {\n\n\tprivate static final double rParam = 0.299;\n\tprivate static final double gParam = 0.587;\n\tprivate static final double bParam = 0.114;\n\n\tpublic static Mat enhance(Mat image, int r, double eps, double eta, double lambda, double krnlRatio) {\n\t\timage.convertTo(image, CvType.CV_32F);\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(image, bgr);\n\t\tMat bChannel = bgr.get(0);\n\t\tMat gChannel = bgr.get(1);\n\t\tMat rChannel = bgr.get(2);\n\t\tint m = rChannel.rows();\n\t\tint n = rChannel.cols();\n\t\tList<Mat> list = globalAdaptation(bChannel, gChannel, rChannel, m, n);\n\t\tMat Lw = list.get(0);\n\t\tMat Lg = list.get(1);\n\t\tMat Hg = localAdaptation(Lg, m, n, r, eps, krnlRatio);\n\t\tLg.convertTo(Lg, CvType.CV_32F);\n\t\tMat alpha = new Mat(m, n, rChannel.type());\n\t\tCore.divide(Lg, new Scalar(Core.minMaxLoc(Lg).maxVal / eta), alpha);\n\t\tCore.add(alpha, new Scalar(1.0), alpha);\n\t\tMat Lg_ = new Mat(m, n, rChannel.type());\n\t\tCore.add(Lg, new Scalar(1.0 / 255.0), Lg_);\n\t\tCore.log(Lg_, Lg_);\n\t\tdouble beta = Math.exp(Core.sumElems(Lg_).val[0] / (m * n)) * lambda;\n\t\tMat Lout = new Mat(m, n, rChannel.type());\n\t\tCore.divide(Lg, Hg, Lout);\n\t\tCore.add(Lout, new Scalar(beta), Lout);\n\t\tCore.log(Lout, Lout);\n\t\tCore.normalize(alpha.mul(Lout), Lout, 0, 255, Core.NORM_MINMAX);\n\t\tMat gain = obtainGain(Lout, Lw, m, n);\n\t\tCore.divide(rChannel.mul(gain), new Scalar(Core.minMaxLoc(rChannel).maxVal / 255.0), rChannel); // Red Channel\n\t\tCore.divide(gChannel.mul(gain), new Scalar(Core.minMaxLoc(gChannel).maxVal / 255.0), gChannel); // Green Channel\n\t\tCore.divide(bChannel.mul(gain), new Scalar(Core.minMaxLoc(bChannel).maxVal / 255.0), bChannel); // Blue Channel\n\t\tMat outval = new Mat();\n\t\tCore.merge(new ArrayList<>(Arrays.asList(bChannel, gChannel, rChannel)), outval);\n\t\toutval.convertTo(outval, CvType.CV_8UC1);\n\t\treturn outval;\n\t}\n\n\tprivate static Mat localAdaptation(Mat Lg, int rows, int cols, int r, double eps, double krnlRatio) {\n\t\tint krnlSz = Stream.of(3.0, rows * krnlRatio, cols * krnlRatio).max(Double::compare).orElse(3.0).intValue();\n\t\tMat Lg_ = new Mat();\n\t\tMat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(krnlSz, krnlSz), new Point(-1, -1));\n\t\tImgproc.dilate(Lg, Lg_, kernel);\n\t\treturn Filters.GuidedImageFilter(Lg, Lg_, r, eps);\n\t}\n\n\tprivate static List<Mat> globalAdaptation(Mat b, Mat g, Mat r, int rows, int cols) {\n\t\tMat Lw = new Mat(rows, cols, r.type());\n\t\tCore.multiply(r, new Scalar(rParam), r);\n\t\tCore.multiply(g, new Scalar(gParam), g);\n\t\tCore.multiply(b, new Scalar(bParam), b);\n\t\tCore.add(r, g, Lw);\n\t\tCore.add(Lw, b, Lw);\n\t\tdouble LwMax = Core.minMaxLoc(Lw).maxVal; // the maximum luminance value\n\t\tMat Lw_ = Lw.clone();\n\t\tCore.add(Lw_, new Scalar(0.001), Lw_);\n\t\tCore.log(Lw_, Lw_);\n\t\tdouble LwAver = Math.exp(Core.sumElems(Lw_).val[0] / (rows * cols));\n\t\tMat Lg = Lw.clone();\n\t\tCore.divide(Lg, new Scalar(LwAver), Lg);\n\t\tCore.add(Lg, new Scalar(1.0), Lg);\n\t\tCore.log(Lg, Lg);\n\t\tCore.divide(Lg, new Scalar(Math.log(LwMax / LwAver + 1.0)), Lg); // Lg is the global adaptation\n\t\tList<Mat> list = new ArrayList<>();\n\t\tlist.add(Lw);\n\t\tlist.add(Lg);\n\t\treturn list;\n\t}\n\n\tprivate static Mat obtainGain(Mat Lout, Mat Lw, int rows, int cols) {\n\t\tMat gain = new Mat(rows, cols, Lout.type());\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tif (Lw.get(i, j)[0] == 0) gain.put(i, j, Lout.get(i, j)[0]);\n\t\t\t\telse gain.put(i, j, Lout.get(i, j)[0] / Lw.get(i, j)[0]);\n\t\t\t}\n\t\t}\n\t\treturn gain;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static Mat adjustment(Mat alpha, double a) {\n\t\tdouble b = Core.minMaxLoc(alpha).maxVal;\n\t\tint rows = alpha.rows();\n\t\tint cols = alpha.cols();\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\talpha.put(i, j, (2 * Math.atan(a * alpha.get(i, j)[0] / b) / Math.PI * b));\n\t\t\t}\n\t\t}\n\t\treturn alpha;\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class GreetingWebClient {\n\tprivate WebClient client = WebClient.create(\"http://localhost:8080\");\n\n\tprivate Mono<ClientResponse> result = client.get()\n\t\t\t.uri(\"/hello\")\n\t\t\t.accept(MediaType.TEXT_PLAIN)\n\t\t\t.exchange();\n\n\tpublic String getResult() {\n\t\treturn \">> result = \" + result.flatMap(res -> res.bodyToMono(String.class)).block();\n\t}\n}", "nl": "spring"}
{"code": "    \n\n\n\n\n@Service\npublic class GitHubLookupService {\n\n    private static final Logger logger = LoggerFactory.getLogger(GitHubLookupService.class);\n\n    private final RestTemplate restTemplate;\n\n    public GitHubLookupService(RestTemplateBuilder restTemplateBuilder) {\n        this.restTemplate = restTemplateBuilder.build();\n    }\n\n    @Async\n    public CompletableFuture<User> findUser(String user) throws InterruptedException {\n        logger.info(\"Looking up \" + user);\n        String url = String.format(\"https://api.github.com/users/%s\", user);\n        User results = restTemplate.getForObject(url, User.class);\n        Thread.sleep(1000L);\n        return CompletableFuture.completedFuture(results);\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n@RestController\npublic class IndexController {\n\n\t@GetMapping(path = \"/\", produces = MediaTypes.HAL_JSON_VALUE)\n\tpublic ResourceSupport index() {\n\t\tResourceSupport resource = new ResourceSupport();\n\t\tresource.add(linkTo(methodOn(MarkupController.class).renderMarkup(MediaType.TEXT_MARKDOWN, \"\"))\n\t\t\t\t.withRel(\"markup\"));\n\t\tresource.add(linkTo(methodOn(GuidesController.class).listGuides()).withRel(\"guides\"));\n\t\treturn resource;\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class StaticPagePathFinder {\n    private ResourcePatternResolver resourceResolver;\n\n    public static class PagePaths {\n        private String filePath;\n        private String urlPath;\n\n        public PagePaths(String filePath, String urlPath) {\n            this.filePath = filePath;\n            this.urlPath = urlPath;\n        }\n\n        public String getFilePath() {\n            return filePath;\n        }\n\n        public String getUrlPath() {\n            return urlPath;\n        }\n    }\n\n    public StaticPagePathFinder(ResourcePatternResolver resourceResolver) {\n        this.resourceResolver = resourceResolver;\n    }\n\n    public List<PagePaths> findPaths() throws IOException {\n        Resource baseResource = resourceResolver.getResource(\"classpath:/templates/pages\");\n        String basePath = baseResource.getURL().getPath();\n        Resource[] resources = resourceResolver.getResources(\"classpath:/templates/pages*.html\");\n        List<PagePaths> paths = new ArrayList<>();\n        for (Resource resource : resources) {\n            String filePath = relativeFilePath(basePath, resource);\n            paths.add(new PagePaths(filePath, buildRequestMapping(filePath)));\n        }\n        return paths;\n    }\n\n    private String relativeFilePath(String basePath, Resource resource) throws IOException {\n        return resource.getURL().getPath().substring(basePath.length()).replace(\".html\", \"\");\n    }\n\n    private String buildRequestMapping(String filePath) {\n        String requestMapping = filePath;\n        if (requestMapping.endsWith(\"/index\")) {\n            requestMapping = requestMapping.replace(\"/index\", \"\");\n            if (requestMapping.equals(\"\")) {\n                requestMapping = \"/\";\n            }\n        }\n        return requestMapping;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\npublic class Java2DFrameConverter extends FrameConverter<BufferedImage> {\n\n    @Override public Frame convert(BufferedImage img) {\n        return getFrame(img);\n    }\n\n    @Override public BufferedImage convert(Frame frame) {\n        return getBufferedImage(frame);\n    }\n\n    \n    public static BufferedImage cloneBufferedImage(BufferedImage source) {\n        if (source == null) {\n            return null;\n        }\n        int type = source.getType();\n        if (type == BufferedImage.TYPE_CUSTOM) {\n            return new BufferedImage(\n                    source.getColorModel(),\n                    source.copyData(null),\n                    source.isAlphaPremultiplied(),\n                    null\n            );\n        } else {\n            BufferedImage copy = new BufferedImage(source.getWidth(), source.getHeight(), type);\n            Graphics g = copy.getGraphics();\n            g.drawImage(source, 0, 0, null);\n            g.dispose();\n            return copy;\n        }\n    }\n\n    public static final byte[]\n            gamma22    = new byte[256],\n            gamma22inv = new byte[256];\n    static {\n        for (int i = 0; i < 256; i++) {\n            gamma22[i]    = (byte)Math.round(Math.pow(i/255.0,   2.2)*255.0);\n            gamma22inv[i] = (byte)Math.round(Math.pow(i/255.0, 1/2.2)*255.0);\n        }\n    }\n    public static int decodeGamma22(int value) {\n        return gamma22[value & 0xFF] & 0xFF;\n    }\n    public static int encodeGamma22(int value) {\n        return gamma22inv[value & 0xFF] & 0xFF;\n    }\n    public static void flipCopyWithGamma(ByteBuffer srcBuf, int srcBufferIndex, int srcStep,\n                                         ByteBuffer dstBuf, int dstBufferIndex, int dstStep,\n                                         boolean signed, double gamma, boolean flip, int channels) {\n        assert srcBuf != dstBuf;\n        int w = Math.min(srcStep, dstStep);\n        int srcLine = srcBufferIndex, dstLine = dstBufferIndex;\n        byte[] buffer = new byte[channels];\n        while (srcLine < srcBuf.capacity() && dstLine < dstBuf.capacity()) {\n            if (flip) {\n                srcBufferIndex = srcBuf.capacity() - srcLine - srcStep;\n            } else {\n                srcBufferIndex = srcLine;\n            }\n            dstBufferIndex = dstLine;\n            w = Math.min(Math.min(w, srcBuf.capacity() - srcBufferIndex), dstBuf.capacity() - dstBufferIndex);\n            if (signed) {\n                if (channels > 1) {\n                    for (int x = 0; x < w; x+=channels) {\n                        for (int z = 0; z < channels; z++) {\n                            int in = srcBuf.get(srcBufferIndex++);\n                            byte out;\n                            if (gamma == 1.0) {\n                                out = (byte)in;\n                            } else {\n                                out = (byte)Math.round(Math.pow((double)in/Byte.MAX_VALUE, gamma)*Byte.MAX_VALUE);\n                            }\n                            buffer[z] = out;\n                        }\n                        for (int z = channels-1; z >= 0; z--) {\n                            dstBuf.put(dstBufferIndex++, buffer[z]);\n                        }\n                    }\n                } else {\n                    for (int x = 0; x < w; x++) {\n                        int in = srcBuf.get(srcBufferIndex++);\n                        byte out;\n                        if (gamma == 1.0) {\n                            out = (byte)in;\n                        } else {\n                            out = (byte)Math.round(Math.pow((double)in/Byte.MAX_VALUE, gamma)*Byte.MAX_VALUE);\n                        }\n                        dstBuf.put(dstBufferIndex++, out);\n                    }\n                }\n            } else {\n                if (channels > 1) {\n                    for (int x = 0; x < w; x+=channels) {\n                        for (int z = 0; z < channels; z++) {\n                            byte out;\n                            int in = srcBuf.get(srcBufferIndex++) & 0xFF;\n                            if (gamma == 1.0) {\n                                out = (byte)in;\n                            } else if (gamma == 2.2) {\n                                out = gamma22[in];\n                            } else if (gamma == 1/2.2) {\n                                out = gamma22inv[in];\n                            } else {\n                                out = (byte)Math.round(Math.pow((double)in/0xFF, gamma)*0xFF);\n                            }\n                            buffer[z] = out;\n                        }\n                        for (int z = channels-1; z >= 0; z--) {\n                            dstBuf.put(dstBufferIndex++, buffer[z]);\n                        }\n                    }\n                } else {\n                    for (int x = 0; x < w; x++) {\n                        byte out;\n                        int in = srcBuf.get(srcBufferIndex++) & 0xFF;\n                        if (gamma == 1.0) {\n                            out = (byte)in;\n                        } else if (gamma == 2.2) {\n                            out = gamma22[in];\n                        } else if (gamma == 1/2.2) {\n                            out = gamma22inv[in];\n                        } else {\n                            out = (byte)Math.round(Math.pow((double)in/0xFF, gamma)*0xFF);\n                        }\n                        dstBuf.put(dstBufferIndex++, out);\n                    }\n                }\n            }\n            srcLine += srcStep;\n            dstLine += dstStep;\n        }\n    }\n    public static void flipCopyWithGamma(ShortBuffer srcBuf, int srcBufferIndex, int srcStep,\n                                         ShortBuffer dstBuf, int dstBufferIndex, int dstStep,\n                                         boolean signed, double gamma, boolean flip, int channels) {\n        assert srcBuf != dstBuf;\n        int w = Math.min(srcStep, dstStep);\n        int srcLine = srcBufferIndex, dstLine = dstBufferIndex;\n        short[] buffer = new short[channels];\n        while (srcLine < srcBuf.capacity() && dstLine < dstBuf.capacity()) {\n            if (flip) {\n                srcBufferIndex = srcBuf.capacity() - srcLine - srcStep;\n            } else {\n                srcBufferIndex = srcLine;\n            }\n            dstBufferIndex = dstLine;\n            w = Math.min(Math.min(w, srcBuf.capacity() - srcBufferIndex), dstBuf.capacity() - dstBufferIndex);\n            if (signed) {\n                if (channels > 1) {\n                    for (int x = 0; x < w; x+=channels) {\n                        for (int z = 0; z < channels; z++) {\n                            int in = srcBuf.get(srcBufferIndex++);\n                            short out;\n                            if (gamma == 1.0) {\n                                out = (short)in;\n                            } else {\n                                out = (short)Math.round(Math.pow((double)in/Short.MAX_VALUE, gamma)*Short.MAX_VALUE);\n                            }\n                            buffer[z] = out;\n                        }\n                        for (int z = channels-1; z >= 0; z--) {\n                            dstBuf.put(dstBufferIndex++, buffer[z]);\n                        }\n                    }\n                } else {\n                    for (int x = 0; x < w; x++) {\n                        int in = srcBuf.get(srcBufferIndex++);\n                        short out;\n                        if (gamma == 1.0) {\n                            out = (short)in;\n                        } else {\n                            out = (short)Math.round(Math.pow((double)in/Short.MAX_VALUE, gamma)*Short.MAX_VALUE);\n                        }\n                        dstBuf.put(dstBufferIndex++, out);\n                    }\n                }\n            } else {\n                if (channels > 1) {\n                    for (int x = 0; x < w; x+=channels) {\n                        for (int z = 0; z < channels; z++) {\n                            int in = srcBuf.get(srcBufferIndex++);\n                            short out;\n                            if (gamma == 1.0) {\n                                out = (short)in;\n                            } else {\n                                out = (short)Math.round(Math.pow((double)in/0xFFFF, gamma)*0xFFFF);\n                            }\n                            buffer[z] = out;\n                        }\n                        for (int z = channels-1; z >= 0; z--) {\n                            dstBuf.put(dstBufferIndex++, buffer[z]);\n                        }\n                    }\n                } else {\n                    for (int x = 0; x < w; x++) {\n                        int in = srcBuf.get(srcBufferIndex++) & 0xFFFF;\n                        short out;\n                        if (gamma == 1.0) {\n                            out = (short)in;\n                        } else {\n                            out = (short)Math.round(Math.pow((double)in/0xFFFF, gamma)*0xFFFF);\n                        }\n                        dstBuf.put(dstBufferIndex++, out);\n                    }\n                }\n            }\n            srcLine += srcStep;\n            dstLine += dstStep;\n        }\n    }\n    public static void flipCopyWithGamma(IntBuffer srcBuf, int srcBufferIndex, int srcStep,\n                                         IntBuffer dstBuf, int dstBufferIndex, int dstStep,\n                                         double gamma, boolean flip, int channels) {\n        assert srcBuf != dstBuf;\n        int w = Math.min(srcStep, dstStep);\n        int srcLine = srcBufferIndex, dstLine = dstBufferIndex;\n        int[] buffer = new int[channels];\n        while (srcLine < srcBuf.capacity() && dstLine < dstBuf.capacity()) {\n            if (flip) {\n                srcBufferIndex = srcBuf.capacity() - srcLine - srcStep;\n            } else {\n                srcBufferIndex = srcLine;\n            }\n            dstBufferIndex = dstLine;\n            w = Math.min(Math.min(w, srcBuf.capacity() - srcBufferIndex), dstBuf.capacity() - dstBufferIndex);\n            if (channels > 1) {\n                for (int x = 0; x < w; x+=channels) {\n                    for (int z = 0; z < channels; z++) {\n                        int in = srcBuf.get(srcBufferIndex++);\n                        int out;\n                        if (gamma == 1.0) {\n                            out = (int)in;\n                        } else {\n                            out = (int)Math.round(Math.pow((double)in/Integer.MAX_VALUE, gamma)*Integer.MAX_VALUE);\n                        }\n                        buffer[z] = out;\n                    }\n                    for (int z = channels-1; z >= 0; z--) {\n                        dstBuf.put(dstBufferIndex++, buffer[z]);\n                    }\n                }\n            } else {\n                for (int x = 0; x < w; x++) {\n                    int in = srcBuf.get(srcBufferIndex++);\n                    int out;\n                    if (gamma == 1.0) {\n                        out = in;\n                    } else {\n                        out = (int)Math.round(Math.pow((double)in/Integer.MAX_VALUE, gamma)*Integer.MAX_VALUE);\n                    }\n                    dstBuf.put(dstBufferIndex++, out);\n                }\n            }\n            srcLine += srcStep;\n            dstLine += dstStep;\n        }\n    }\n    public static void flipCopyWithGamma(FloatBuffer srcBuf, int srcBufferIndex, int srcStep,\n                                         FloatBuffer dstBuf, int dstBufferIndex, int dstStep,\n                                         double gamma, boolean flip, int channels) {\n        assert srcBuf != dstBuf;\n        int w = Math.min(srcStep, dstStep);\n        int srcLine = srcBufferIndex, dstLine = dstBufferIndex;\n        float[] buffer = new float[channels];\n        while (srcLine < srcBuf.capacity() && dstLine < dstBuf.capacity()) {\n            if (flip) {\n                srcBufferIndex = srcBuf.capacity() - srcLine - srcStep;\n            } else {\n                srcBufferIndex = srcLine;\n            }\n            dstBufferIndex = dstLine;\n            w = Math.min(Math.min(w, srcBuf.capacity() - srcBufferIndex), dstBuf.capacity() - dstBufferIndex);\n            if (channels > 1) {\n                for (int x = 0; x < w; x+=channels) {\n                    for (int z = 0; z < channels; z++) {\n                        float in = srcBuf.get(srcBufferIndex++);\n                        float out;\n                        if (gamma == 1.0) {\n                            out = in;\n                        } else {\n                            out = (float)Math.pow(in, gamma);\n                        }\n                        buffer[z] = out;\n                    }\n                    for (int z = channels-1; z >= 0; z--) {\n                        dstBuf.put(dstBufferIndex++, buffer[z]);\n                    }\n                }\n            } else {\n                for (int x = 0; x < w; x++) {\n                    float in = srcBuf.get(srcBufferIndex++);\n                    float out;\n                    if (gamma == 1.0) {\n                        out = in;\n                    } else {\n                        out = (float)Math.pow(in, gamma);\n                    }\n                    dstBuf.put(dstBufferIndex++, out);\n                }\n            }\n            srcLine += srcStep;\n            dstLine += dstStep;\n        }\n    }\n    public static void flipCopyWithGamma(DoubleBuffer srcBuf, int srcBufferIndex, int srcStep,\n                                         DoubleBuffer dstBuf, int dstBufferIndex, int dstStep,\n                                         double gamma, boolean flip, int channels) {\n        assert srcBuf != dstBuf;\n        int w = Math.min(srcStep, dstStep);\n        int srcLine = srcBufferIndex, dstLine = dstBufferIndex;\n        double[] buffer = new double[channels];\n        while (srcLine < srcBuf.capacity() && dstLine < dstBuf.capacity()) {\n            if (flip) {\n                srcBufferIndex = srcBuf.capacity() - srcLine - srcStep;\n            } else {\n                srcBufferIndex = srcLine;\n            }\n            dstBufferIndex = dstLine;\n            w = Math.min(Math.min(w, srcBuf.capacity() - srcBufferIndex), dstBuf.capacity() - dstBufferIndex);\n            if (channels > 1) {\n                for (int x = 0; x < w; x+=channels) {\n                    for (int z = 0; z < channels; z++) {\n                        double in = srcBuf.get(srcBufferIndex++);\n                        double out;\n                        if (gamma == 1.0) {\n                            out = in;\n                        } else {\n                            out = Math.pow(in, gamma);\n                        }\n                        buffer[z] = out;\n                    }\n                    for (int z = channels-1; z >= 0; z--) {\n                        dstBuf.put(dstBufferIndex++, buffer[z]);\n                    }\n                }\n            } else {\n                for (int x = 0; x < w; x++) {\n                    double in = srcBuf.get(srcBufferIndex++);\n                    double out;\n                    if (gamma == 1.0) {\n                        out = in;\n                    } else {\n                        out = Math.pow(in, gamma);\n                    }\n                    dstBuf.put(dstBufferIndex++, out);\n                }\n            }\n            srcLine += srcStep;\n            dstLine += dstStep;\n        }\n    }\n\n    public static void applyGamma(Frame frame, double gamma) {\n        applyGamma(frame.image[0], frame.imageDepth, frame.imageStride, gamma);\n    }\n    public static void applyGamma(Buffer buffer, int depth, int stride, double gamma) {\n        if (gamma == 1.0) {\n            return;\n        }\n        switch (depth) {\n            case Frame.DEPTH_UBYTE:\n                flipCopyWithGamma(((ByteBuffer)buffer).asReadOnlyBuffer(), 0, stride, (ByteBuffer)buffer, 0, stride, false, gamma, false, 0);\n                break;\n            case Frame.DEPTH_BYTE:\n                flipCopyWithGamma(((ByteBuffer)buffer).asReadOnlyBuffer(), 0, stride, (ByteBuffer)buffer, 0, stride, true, gamma, false, 0);\n                break;\n            case Frame.DEPTH_USHORT:\n                flipCopyWithGamma(((ShortBuffer)buffer).asReadOnlyBuffer(), 0, stride, (ShortBuffer)buffer, 0, stride, false, gamma, false, 0);\n                break;\n            case Frame.DEPTH_SHORT:\n                flipCopyWithGamma(((ShortBuffer)buffer).asReadOnlyBuffer(), 0, stride, (ShortBuffer)buffer, 0, stride, true, gamma, false, 0);\n                break;\n            case Frame.DEPTH_INT:\n                flipCopyWithGamma(((IntBuffer)buffer).asReadOnlyBuffer(), 0, stride, (IntBuffer)buffer, 0, stride, gamma, false, 0);\n                break;\n            case Frame.DEPTH_FLOAT:\n                flipCopyWithGamma(((FloatBuffer)buffer).asReadOnlyBuffer(), 0, stride, (FloatBuffer)buffer, 0, stride, gamma, false, 0);\n                break;\n            case Frame.DEPTH_DOUBLE:\n                flipCopyWithGamma(((DoubleBuffer)buffer).asReadOnlyBuffer(), 0, stride, (DoubleBuffer)buffer, 0, stride, gamma, false, 0);\n                break;\n            default:\n                assert false;\n        }\n    }\n\n    public static void copy(Frame frame, BufferedImage bufferedImage) {\n        copy(frame, bufferedImage, 1.0);\n    }\n    public static void copy(Frame frame, BufferedImage bufferedImage, double gamma) {\n        copy(frame, bufferedImage, gamma, false, null);\n    }\n    public static void copy(Frame frame, BufferedImage bufferedImage, double gamma, boolean flipChannels, Rectangle roi) {\n        Buffer in = frame.image[0];\n        int bufferIndex = roi == null ? 0 : roi.y*frame.imageStride + roi.x*frame.imageChannels;\n        SampleModel sm = bufferedImage.getSampleModel();\n        Raster r       = bufferedImage.getRaster();\n        DataBuffer out = r.getDataBuffer();\n        int x = -r.getSampleModelTranslateX();\n        int y = -r.getSampleModelTranslateY();\n        int step = sm.getWidth()*sm.getNumBands();\n        int channels = sm.getNumBands();\n        if (sm instanceof ComponentSampleModel) {\n            step = ((ComponentSampleModel)sm).getScanlineStride();\n            channels = ((ComponentSampleModel)sm).getPixelStride();\n        } else if (sm instanceof SinglePixelPackedSampleModel) {\n            step = ((SinglePixelPackedSampleModel)sm).getScanlineStride();\n            channels = 1;\n        } else if (sm instanceof MultiPixelPackedSampleModel) {\n            step = ((MultiPixelPackedSampleModel)sm).getScanlineStride();\n            channels = ((MultiPixelPackedSampleModel)sm).getPixelBitStride()/8; // ??\n        }\n        int start = y*step + x*channels;\n\n        if (out instanceof DataBufferByte) {\n            byte[] a = ((DataBufferByte)out).getData();\n            flipCopyWithGamma((ByteBuffer)in, bufferIndex, frame.imageStride, ByteBuffer.wrap(a), start, step, false, gamma, false, flipChannels ? channels : 0);\n        } else if (out instanceof DataBufferDouble) {\n            double[] a = ((DataBufferDouble)out).getData();\n            flipCopyWithGamma((DoubleBuffer)in, bufferIndex, frame.imageStride, DoubleBuffer.wrap(a), start, step, gamma, false, flipChannels ? channels : 0);\n        } else if (out instanceof DataBufferFloat) {\n            float[] a = ((DataBufferFloat)out).getData();\n            flipCopyWithGamma((FloatBuffer)in, bufferIndex, frame.imageStride, FloatBuffer.wrap(a), start, step, gamma, false, flipChannels ? channels : 0);\n        } else if (out instanceof DataBufferInt) {\n            int[] a = ((DataBufferInt)out).getData();\n            int stride = frame.imageStride;\n            if (in instanceof ByteBuffer) {\n                in = ((ByteBuffer)in).order(flipChannels ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN).asIntBuffer();\n                stride /= 4;\n            }\n            flipCopyWithGamma((IntBuffer)in, bufferIndex, stride, IntBuffer.wrap(a), start, step, gamma, false, flipChannels ? channels : 0);\n        } else if (out instanceof DataBufferShort) {\n            short[] a = ((DataBufferShort)out).getData();\n            flipCopyWithGamma((ShortBuffer)in, bufferIndex, frame.imageStride, ShortBuffer.wrap(a), start, step, true, gamma, false, flipChannels ? channels : 0);\n        } else if (out instanceof DataBufferUShort) {\n            short[] a = ((DataBufferUShort)out).getData();\n            flipCopyWithGamma((ShortBuffer)in, bufferIndex, frame.imageStride, ShortBuffer.wrap(a), start, step, false, gamma, false, flipChannels ? channels : 0);\n        } else {\n            assert false;\n        }\n    }\n\n    public static void copy(BufferedImage image, Frame frame) {\n        copy(image, frame, 1.0);\n    }\n    public static void copy(BufferedImage image, Frame frame, double gamma) {\n        copy(image, frame, gamma, false, null);\n    }\n    public static void copy(BufferedImage image, Frame frame, double gamma, boolean flipChannels, Rectangle roi) {\n        Buffer out = frame.image[0];\n        int bufferIndex = roi == null ? 0 : roi.y*frame.imageStride + roi.x*frame.imageChannels;\n        SampleModel sm = image.getSampleModel();\n        Raster r       = image.getRaster();\n        DataBuffer in  = r.getDataBuffer();\n        int x = -r.getSampleModelTranslateX();\n        int y = -r.getSampleModelTranslateY();\n        int step = sm.getWidth()*sm.getNumBands();\n        int channels = sm.getNumBands();\n        if (sm instanceof ComponentSampleModel) {\n            step = ((ComponentSampleModel)sm).getScanlineStride();\n            channels = ((ComponentSampleModel)sm).getPixelStride();\n        } else if (sm instanceof SinglePixelPackedSampleModel) {\n            step = ((SinglePixelPackedSampleModel)sm).getScanlineStride();\n            channels = 1;\n        } else if (sm instanceof MultiPixelPackedSampleModel) {\n            step = ((MultiPixelPackedSampleModel)sm).getScanlineStride();\n            channels = ((MultiPixelPackedSampleModel)sm).getPixelBitStride()/8; // ??\n        }\n        int start = y*step + x*channels;\n\n        if (in instanceof DataBufferByte) {\n            byte[] a = ((DataBufferByte)in).getData();\n            flipCopyWithGamma(ByteBuffer.wrap(a), start, step, (ByteBuffer)out, bufferIndex, frame.imageStride, false, gamma, false, flipChannels ? channels : 0);\n        } else if (in instanceof DataBufferDouble) {\n            double[] a = ((DataBufferDouble)in).getData();\n            flipCopyWithGamma(DoubleBuffer.wrap(a), start, step, (DoubleBuffer)out, bufferIndex, frame.imageStride, gamma, false, flipChannels ? channels : 0);\n        } else if (in instanceof DataBufferFloat) {\n            float[] a = ((DataBufferFloat)in).getData();\n            flipCopyWithGamma(FloatBuffer.wrap(a), start, step, (FloatBuffer)out, bufferIndex, frame.imageStride, gamma, false, flipChannels ? channels : 0);\n        } else if (in instanceof DataBufferInt) {\n            int[] a = ((DataBufferInt)in).getData();\n            int stride = frame.imageStride;\n            if (out instanceof ByteBuffer) {\n                out = ((ByteBuffer)out).order(flipChannels ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN).asIntBuffer();\n                stride /= 4;\n            }\n            flipCopyWithGamma(IntBuffer.wrap(a), start, step, (IntBuffer)out, bufferIndex, stride, gamma, false, flipChannels ? channels : 0);\n        } else if (in instanceof DataBufferShort) {\n            short[] a = ((DataBufferShort)in).getData();\n            flipCopyWithGamma(ShortBuffer.wrap(a), start, step, (ShortBuffer)out, bufferIndex, frame.imageStride, true, gamma, false, flipChannels ? channels : 0);\n        } else if (in instanceof DataBufferUShort) {\n            short[] a = ((DataBufferUShort)in).getData();\n            flipCopyWithGamma(ShortBuffer.wrap(a), start, step, (ShortBuffer)out, bufferIndex, frame.imageStride, false, gamma, false, flipChannels ? channels : 0);\n        } else {\n            assert false;\n        }\n    }\n\n    protected BufferedImage bufferedImage = null;\n    public static int getBufferedImageType(Frame frame) {\n        int type = BufferedImage.TYPE_CUSTOM;\n        if (frame.imageChannels == 1) {\n            if (frame.imageDepth == Frame.DEPTH_UBYTE || frame.imageDepth == Frame.DEPTH_BYTE) {\n                type = BufferedImage.TYPE_BYTE_GRAY;\n            } else if (frame.imageDepth == Frame.DEPTH_USHORT) {\n                type = BufferedImage.TYPE_USHORT_GRAY;\n            }\n        } else if (frame.imageChannels == 3) {\n            if (frame.imageDepth == Frame.DEPTH_UBYTE || frame.imageDepth == Frame.DEPTH_BYTE) {\n                type = BufferedImage.TYPE_3BYTE_BGR;\n            }\n        } else if (frame.imageChannels == 4) {\n            if (frame.imageDepth == Frame.DEPTH_UBYTE || frame.imageDepth == Frame.DEPTH_BYTE) {\n                type = BufferedImage.TYPE_4BYTE_ABGR;\n            }\n        }\n        return type;\n    }\n    public BufferedImage getBufferedImage(Frame frame) {\n        return getBufferedImage(frame, 1.0);\n    }\n    public BufferedImage getBufferedImage(Frame frame, double gamma) {\n        return getBufferedImage(frame, gamma, false, null);\n    }\n    public BufferedImage getBufferedImage(Frame frame, double gamma, boolean flipChannels, ColorSpace cs) {\n        if (frame == null || frame.image == null) {\n            return null;\n        }\n        int type = getBufferedImageType(frame);\n\n        if (bufferedImage == null || bufferedImage.getWidth() != frame.imageWidth\n                || bufferedImage.getHeight() != frame.imageHeight || bufferedImage.getType() != type) {\n            bufferedImage = type == BufferedImage.TYPE_CUSTOM || cs != null ? null\n                    : new BufferedImage(frame.imageWidth, frame.imageHeight, type);\n        }\n\n        if (bufferedImage == null) {\n            boolean alpha = false;\n            int[] offsets = null;\n            if (frame.imageChannels == 1) {\n                alpha = false;\n                if (cs == null) {\n                    cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);\n                }\n                offsets = new int[] {0};\n            } else if (frame.imageChannels == 3) {\n                alpha = false;\n                if (cs == null) {\n                    cs = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);\n                }\n                offsets = new int[] {2, 1, 0};\n            } else if (frame.imageChannels == 4) {\n                alpha = true;\n                if (cs == null) {\n                    cs = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);\n                }\n                offsets = new int[] {0, 1, 2, 3};\n            } else {\n                assert false;\n            }\n\n            ColorModel cm = null;\n            WritableRaster wr = null;\n            if (frame.imageDepth == Frame.DEPTH_UBYTE || frame.imageDepth == Frame.DEPTH_BYTE) {\n                cm = new ComponentColorModel(cs, alpha,\n                        false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n                wr = Raster.createWritableRaster(new ComponentSampleModel(\n                        DataBuffer.TYPE_BYTE, frame.imageWidth, frame.imageHeight, frame.imageChannels, frame.imageStride,\n                        offsets), null);\n            } else if (frame.imageDepth == Frame.DEPTH_USHORT) {\n                cm = new ComponentColorModel(cs, alpha,\n                        false, Transparency.OPAQUE, DataBuffer.TYPE_USHORT);\n                wr = Raster.createWritableRaster(new ComponentSampleModel(\n                        DataBuffer.TYPE_USHORT, frame.imageWidth, frame.imageHeight, frame.imageChannels, frame.imageStride,\n                        offsets), null);\n            } else if (frame.imageDepth == Frame.DEPTH_SHORT) {\n                cm = new ComponentColorModel(cs, alpha,\n                        false, Transparency.OPAQUE, DataBuffer.TYPE_SHORT);\n                wr = Raster.createWritableRaster(new ComponentSampleModel(\n                        DataBuffer.TYPE_SHORT, frame.imageWidth, frame.imageHeight, frame.imageChannels, frame.imageStride,\n                        offsets), null);\n            } else if (frame.imageDepth == Frame.DEPTH_INT) {\n                cm = new ComponentColorModel(cs, alpha,\n                        false, Transparency.OPAQUE, DataBuffer.TYPE_INT);\n                wr = Raster.createWritableRaster(new ComponentSampleModel(\n                        DataBuffer.TYPE_INT, frame.imageWidth, frame.imageHeight, frame.imageChannels, frame.imageStride,\n                        offsets), null);\n            } else if (frame.imageDepth == Frame.DEPTH_FLOAT) {\n                cm = new ComponentColorModel(cs, alpha,\n                        false, Transparency.OPAQUE, DataBuffer.TYPE_FLOAT);\n                wr = Raster.createWritableRaster(new ComponentSampleModel(\n                        DataBuffer.TYPE_FLOAT, frame.imageWidth, frame.imageHeight, frame.imageChannels, frame.imageStride,\n                        offsets), null);\n            } else if (frame.imageDepth == Frame.DEPTH_DOUBLE) {\n                cm = new ComponentColorModel(cs, alpha,\n                        false, Transparency.OPAQUE, DataBuffer.TYPE_DOUBLE);\n                wr = Raster.createWritableRaster(new ComponentSampleModel(\n                        DataBuffer.TYPE_DOUBLE, frame.imageWidth, frame.imageHeight, frame.imageChannels, frame.imageStride,\n                        offsets), null);\n            } else {\n                assert false;\n            }\n\n            bufferedImage = new BufferedImage(cm, wr, false, null);\n        }\n\n        if (bufferedImage != null) {\n            copy(frame, bufferedImage, gamma, flipChannels, null);\n        }\n\n        return bufferedImage;\n    }\n\n    \n    public Frame getFrame(BufferedImage image) {\n        return getFrame(image, 1.0);\n    }\n    \n    public Frame getFrame(BufferedImage image, double gamma) {\n        return getFrame(image, gamma, false);\n    }\n    \n    public Frame getFrame(BufferedImage image, double gamma, boolean flipChannels) {\n        if (image == null) {\n            return null;\n        }\n        SampleModel sm = image.getSampleModel();\n        int depth = 0, numChannels = sm.getNumBands();\n        switch (image.getType()) {\n            case BufferedImage.TYPE_INT_RGB:\n            case BufferedImage.TYPE_INT_ARGB:\n            case BufferedImage.TYPE_INT_ARGB_PRE:\n            case BufferedImage.TYPE_INT_BGR:\n                depth = Frame.DEPTH_UBYTE;\n                numChannels = 4;\n                break;\n        }\n        if (depth == 0 || numChannels == 0) {\n            switch (sm.getDataType()) {\n                case DataBuffer.TYPE_BYTE:   depth = Frame.DEPTH_UBYTE;  break;\n                case DataBuffer.TYPE_USHORT: depth = Frame.DEPTH_USHORT; break;\n                case DataBuffer.TYPE_SHORT:  depth = Frame.DEPTH_SHORT;  break;\n                case DataBuffer.TYPE_INT:    depth = Frame.DEPTH_INT;    break;\n                case DataBuffer.TYPE_FLOAT:  depth = Frame.DEPTH_FLOAT;  break;\n                case DataBuffer.TYPE_DOUBLE: depth = Frame.DEPTH_DOUBLE; break;\n                default: assert false;\n            }\n        }\n        if (frame == null || frame.imageWidth != image.getWidth() || frame.imageHeight != image.getHeight()\n                || frame.imageDepth != depth || frame.imageChannels != numChannels) {\n            frame = new Frame(image.getWidth(), image.getHeight(), depth, numChannels);\n        }\n        copy(image, frame, gamma, flipChannels, null);\n        return frame;\n    }\n}", "nl": "opencv"}
{"code": "\n\npublic class AffineTranslation {\n   public static void main(String args[]) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap24/transform_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Point p1 = new Point( 0,0 );\n      Point p2 = new Point( src.cols() - 1, 0 );\n      Point p3 = new Point( 0, src.rows() - 1 );\n      Point p4 = new Point( src.cols()*0.0, src.rows()*0.33 );\n      Point p5 = new Point( src.cols()*0.85, src.rows()*0.25 );\n      Point p6 = new Point( src.cols()*0.15, src.rows()*0.7 );\n      \n      MatOfPoint2f ma1 = new MatOfPoint2f(p1,p2,p3);\n      MatOfPoint2f ma2 = new MatOfPoint2f(p4,p5,p6);\n\n      Mat tranformMatrix = Imgproc.getAffineTransform(ma1,ma2);\n\n      Size size = new Size(src.cols(), src.cols());\n\n      Imgproc.warpAffine(src, dst, tranformMatrix, size);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap24/Affinetranslate.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\n@Service\npublic class SignInService {\n\n    private static final String IS_MEMBER_URL = \"https://api.github.com/teams/{team}/members/{user}\";\n    private final TeamService teamService;\n    private final String gitHubTeamId;\n\n    @Autowired\n    public SignInService(TeamService teamService, @Value(\"${github.team.id}\") String gitHubTeamId) {\n        this.teamService = teamService;\n        this.gitHubTeamId = gitHubTeamId;\n    }\n\n    public MemberProfile getOrCreateMemberProfile(Long githubId, GitHub gitHub) {\n        GitHubUserProfile remoteProfile = gitHub.userOperations().getUserProfile();\n\n        return teamService.createOrUpdateMemberProfile(githubId, remoteProfile.getUsername(), remoteProfile\n                .getProfileImageUrl(), remoteProfile.getName());\n    }\n\n    public boolean isSpringMember(String userId, GitHub gitHub) {\n        ResponseEntity<Void> response =\n                gitHub.restOperations().getForEntity(IS_MEMBER_URL, Void.class, gitHubTeamId, userId);\n        return response.getStatusCode() == HttpStatus.NO_CONTENT;\n    }\n}", "nl": "spring"}
{"code": "\n\n\npublic class Scaling {\n   public static void main(String args[]) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap24/transform_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Size size = new Size(src.rows()*2, src.rows()*2);\n\n      Imgproc.resize(src, dst, size, 0, 0, Imgproc.INTER_AREA);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap24/scale_output.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n\nclass ToolSuiteBuilder {\n\n    private final DownloadLinkExtractor downloadLinkExtractor = new DownloadLinkExtractor();\n    private final String shortName;\n\n    private Map<String, ToolSuitePlatform> platformMap = new LinkedHashMap<>();\n    private List<UpdateSiteArchive> updateSiteArchives = new ArrayList<>();\n    private Map<String, EclipseVersion> eclipseVersionMap = new LinkedHashMap<>();\n    private Map<String, Architecture> architectureMap = new LinkedHashMap<>();\n    private String releaseName;\n    private String whatsNew;\n\n    public ToolSuiteBuilder(String shortName) {\n        this.shortName = shortName;\n    }\n\n    public void setWhatsNew(String whatsNew) {\n        this.whatsNew = whatsNew;\n    }\n\n    public void addDownload(Download download) {\n        if (download.getOs().equals(\"all\")) {\n            extractArchive(download);\n        } else {\n            if (releaseName == null) {\n                releaseName = download.getVersion();\n            }\n            extractPlatformDownloadLink(download);\n        }\n    }\n\n    private void extractPlatformDownloadLink(Download download) {\n        ToolSuitePlatform platform = createOrFindPlatform(download.getOs(), download.getVersion());\n        EclipseVersion eclipseVersion = createOrFindEclipseVersion(download.getEclipseVersion(), platform);\n        Architecture architecture = createOrFindArchitecture(download.getDescription(), eclipseVersion, platform);\n\n        DownloadLink link = downloadLinkExtractor.createDownloadLink(download);\n        architecture.getDownloadLinks().add(link);\n    }\n\n    private void extractArchive(Download download) {\n        String url = download.getBucket() + download.getFile();\n        UpdateSiteArchive archive = new UpdateSiteArchive(download.getEclipseVersion(), url, download.getSize());\n        if (!updateSiteArchives.contains(archive)) {\n            updateSiteArchives.add(archive);\n        }\n    }\n\n    public ToolSuiteDownloads build() {\n        return new ToolSuiteDownloads(shortName, releaseName, whatsNew, platformMap, updateSiteArchives);\n    }\n\n    private ToolSuitePlatform createOrFindPlatform(String os, String name) {\n        ToolSuitePlatform platform = platformMap.get(os);\n        if (platform == null) {\n            platform = new ToolSuitePlatform(os, new ArrayList<>());\n            platformMap.put(os, platform);\n        }\n        return platform;\n    }\n\n    private EclipseVersion createOrFindEclipseVersion(String eclipseVersionName, ToolSuitePlatform platform) {\n        String key = platform.getName() + eclipseVersionName;\n\n        EclipseVersion eclipseVersion = eclipseVersionMap.get(key);\n        if (eclipseVersion == null) {\n            eclipseVersion = new EclipseVersion(eclipseVersionName, new ArrayList<>());\n            platform.getEclipseVersions().add(eclipseVersion);\n            eclipseVersionMap.put(key, eclipseVersion);\n        }\n        return eclipseVersion;\n    }\n\n    private Architecture createOrFindArchitecture(String architectureName, EclipseVersion eclipseVersion,\n                                                  ToolSuitePlatform platform) {\n        String key = platform.getName() + eclipseVersion.getName() + architectureName;\n\n        Architecture architecture = architectureMap.get(key);\n        if (architecture == null) {\n            architecture = new Architecture(architectureName, new ArrayList<>());\n            eclipseVersion.getArchitectures().add(architecture);\n            architectureMap.put(key, architecture);\n        }\n        return architecture;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n@Entity\npublic class Customer {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n\n    protected Customer() {}\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                \"Customer[id=%d, firstName='%s', lastName='%s']\",\n                id, firstName, lastName);\n    }\n\n\n\tpublic Long getId() {\n\t\treturn id;\n\t}\n\n\tpublic String getFirstName() {\n\t\treturn firstName;\n\t}\n\n\tpublic String getLastName() {\n\t\treturn lastName;\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n@RestController\n@SpringBootApplication\npublic class SayHelloApplication {\n\n  private static Logger log = LoggerFactory.getLogger(SayHelloApplication.class);\n\n  @RequestMapping(value = \"/greeting\")\n  public String greet() {\n    log.info(\"Access /greeting\");\n\n    List<String> greetings = Arrays.asList(\"Hi there\", \"Greetings\", \"Salutations\");\n    Random rand = new Random();\n\n    int randomNum = rand.nextInt(greetings.size());\n    return greetings.get(randomNum);\n  }\n\n  @RequestMapping(value = \"/\")\n  public String home() {\n    log.info(\"Access /\");\n    return \"Hi!\";\n  }\n\n  public static void main(String[] args) {\n    SpringApplication.run(SayHelloApplication.class, args);\n  }\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class VideoEqualizerFilter extends DefaultSegmentFilter {\n\n\tprivate final VideoEqualizer proxy;\n\n\tprivate Mat mHsvMat = new Mat();\n\n\tpublic VideoEqualizerFilter() throws UnsatisfiedLinkError {\n\t\tsuper(\"videoequalizer\");\n\n\t\tproxy = new VideoEqualizer();\n\t\tproxy.init();\n\t}\n\n\t@Override\n\tprotected DefaultSegmentConfigController instantiateController() {\n\t\treturn new VideoEqualizerConfigController();\n\t}\n\n\t@Override\n\tpublic Mat process(Mat rgbaImage, int frameId, FilterContext context) {\n\t\tImgproc.cvtColor(rgbaImage, mHsvMat, Imgproc.COLOR_RGB2HSV_FULL);\n\n\t\tVideoEqualizerConfigController c = ((VideoEqualizerConfigController) getConfigController());\n\n\t\tproxy.process(mHsvMat, frameId, context, c.getBrightness(), c.getContrast(), c.getSaturation());\n\n\t\tImgproc.cvtColor(mHsvMat, rgbaImage, Imgproc.COLOR_HSV2RGB_FULL);\n\n\t\treturn rgbaImage;\n\t}\n\n\t@Override\n\tprotected void initializeController() {\n\t\tVideoEqualizerConfigController c = ((VideoEqualizerConfigController) getConfigController());\n\t\tc.setBrightness(50);\n\t\tc.setContrast(50);\n\t\tc.setSaturation(50);\n\t\tc.initialize();\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Repository\n@Transactional\npublic class CartDaoImpl implements CartDao {\n\n\t@Autowired\n\tprivate SessionFactory sessionFactory;\n\n\t@Autowired\n\tprivate CustomerOrderService customerOrderService;\n\n\tpublic SessionFactory getSessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tpublic void setSessionFactory(SessionFactory sessionFactory) {\n\t\tthis.sessionFactory = sessionFactory;\n\t}\n\n\tpublic Cart getCartByCartId(String CartId) {\n\t\tSession session = sessionFactory.openSession();\n\t\tCart cart = (Cart) session.get(Cart.class, CartId);\n\t\tSystem.out.println(cart);\n\t\tsession.close();\n\t\treturn cart;\n\n\t}\n\n\tpublic Cart validate(String cartId) throws IOException {\n\t\tCart cart = getCartByCartId(cartId);\n\t\tif (cart == null || cart.getCartItem().size() == 0) {\n\t\t\tthrow new IOException(cartId + \"\");\n\t\t}\n\t\tupdate(cart);\n\t\treturn cart;\n\t}\n\n\tpublic void update(Cart cart) {\n\n\t\tString cartId = cart.getCartId();\n\t\tdouble grandTotal = customerOrderService.getCustomerOrderGrandTotal(cartId);\n\t\tcart.setTotalPrice(grandTotal);\n\n\t\tSession session = sessionFactory.openSession();\n\t\tsession.saveOrUpdate(cart);\n\t\tsession.flush();\n\t\tsession.close();\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\npublic class SessionEventHttpSessionListenerAdapter\n\t\timplements ApplicationListener<AbstractSessionEvent>, ServletContextAware {\n\n\tprivate final List<HttpSessionListener> listeners;\n\n\tprivate ServletContext context;\n\n\tpublic SessionEventHttpSessionListenerAdapter(List<HttpSessionListener> listeners) {\n\t\tsuper();\n\t\tthis.listeners = listeners;\n\t}\n\n\t\n\t@Override\n\tpublic void onApplicationEvent(AbstractSessionEvent event) {\n\t\tif (this.listeners.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tHttpSessionEvent httpSessionEvent = createHttpSessionEvent(event);\n\n\t\tfor (HttpSessionListener listener : this.listeners) {\n\t\t\tif (event instanceof SessionDestroyedEvent) {\n\t\t\t\tlistener.sessionDestroyed(httpSessionEvent);\n\t\t\t}\n\t\t\telse if (event instanceof SessionCreatedEvent) {\n\t\t\t\tlistener.sessionCreated(httpSessionEvent);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate HttpSessionEvent createHttpSessionEvent(AbstractSessionEvent event) {\n\t\tSession session = event.getSession();\n\t\tHttpSession httpSession = new HttpSessionAdapter<>(session, this.context);\n\t\treturn new HttpSessionEvent(httpSession);\n\t}\n\n\t\n\t@Override\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tthis.context = servletContext;\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class MotionHistoryEffect extends Effect {\n\ttransient Mat greyImage = null;\n\ttransient Mat movingAverage = null;\n\ttransient Mat difference = null;\n\ttransient Mat temp = null;\n\t\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tif(greyImage == null || movingAverage == null || difference == null || temp == null) {\n\t\t\tgreyImage = new Mat( frame.size(), CvType.CV_8UC1);\n\t\t\tmovingAverage = new Mat(frame.size(), CvType.CV_32FC1);\n\t\t\tdifference = greyImage.clone();\n\t\t\ttemp = frame.clone();\n\t\t} else {\n\t\t\tImgproc.cvtColor(frame, greyImage, Imgproc.COLOR_RGBA2GRAY);\n\t\t\tImgproc.accumulateWeighted(greyImage, movingAverage, 0.5);\n\t\t\tCore.convertScaleAbs(movingAverage, temp, 1.0, 0.0);\n\t\t\tCore.absdiff(greyImage, temp, difference);\n\t\t}\n\t\t\n\t\tMat newFrame = new Mat();\n\t\tImgproc.cvtColor(difference, newFrame, Imgproc.COLOR_GRAY2RGBA);\n\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Motion History\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class HelloControllerIT {\n\n    @LocalServerPort\n    private int port;\n\n    private URL base;\n\n    @Autowired\n    private TestRestTemplate template;\n\n    @Before\n    public void setUp() throws Exception {\n        this.base = new URL(\"http://localhost:\" + port + \"/\");\n    }\n\n    @Test\n    public void getHello() throws Exception {\n        ResponseEntity<String> response = template.getForEntity(base.toString(),\n                String.class);\n        assertThat(response.getBody(), equalTo(\"Greetings from Spring Boot!\"));\n    }\n}", "nl": "spring"}
{"code": "\n\n\n@Controller\npublic class GreetingController {\n\n\n    @MessageMapping(\"/hello\")\n    @SendTo(\"/topic/greetings\")\n    public Greeting greeting(HelloMessage message) throws Exception {\n        Thread.sleep(1000); // simulated delay\n        return new Greeting(\"Hello, \" + HtmlUtils.htmlEscape(message.getName()) + \"!\");\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class SepiaEffect extends Effect {\n\n\tfloat sepia_data[] = {0.272f,  0.534f,  0.131f, 0,0.349f, 0.686f, 0.168f,0,0.393f,0.769f,0.189f,0,0,0,0,1};\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\t\n\t\tMat effect = new Mat();\n\t\t\n\t\tMat m_sepiaKernel = new Mat(new Size(4,4),CvType.CV_32F);\n\t\tm_sepiaKernel.put(0, 0, sepia_data);\n\t\tCore.transform(frame, effect, m_sepiaKernel);\n\t\t\n\t\tImgproc.cvtColor(effect,effect,Imgproc.COLOR_BGRA2RGBA);\n\t\tm_sepiaKernel.release();\n\t\tframe.release();\n\t\treturn effect;\n\t\t\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"Sepia\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class Receiver {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Receiver.class);\n\n    private CountDownLatch latch;\n\n    @Autowired\n    public Receiver(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    public void receiveMessage(String message) {\n        LOGGER.info(\"Received <\" + message + \">\");\n        latch.countDown();\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@Component\npublic class BookingService {\n\n    private final static Logger logger = LoggerFactory.getLogger(BookingService.class);\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public BookingService(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Transactional\n    public void book(String... persons) {\n        for (String person : persons) {\n            logger.info(\"Booking \" + person + \" in a seat...\");\n            jdbcTemplate.update(\"insert into BOOKINGS(FIRST_NAME) values (?)\", person);\n        }\n    }\n\n    public List<String> findAllBookings() {\n        return jdbcTemplate.query(\"select FIRST_NAME from BOOKINGS\",\n                (rs, rowNum) -> rs.getString(\"FIRST_NAME\"));\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n@Entity\npublic class ProjectRepository {\n    private static final ProjectRepository SNAPSHOT = new ProjectRepository(\"spring-snapshots\", \"Spring Snapshots\",\n            \"https://repo.spring.io/libs-snapshot\", true);\n    private static final ProjectRepository MILESTONE = new ProjectRepository(\"spring-milestones\", \"Spring Milestones\",\n            \"https://repo.spring.io/libs-milestone\", false);\n\n    @Id\n    private String id;\n    private String name;\n    private String url;\n    private Boolean snapshotsEnabled;\n\n    @SuppressWarnings(\"unused\")\n    private ProjectRepository() {\n    }\n\n    ProjectRepository(String id, String name, String url, Boolean snapshotsEnabled) {\n        this.id = id;\n        this.name = name;\n        this.url = url;\n        this.snapshotsEnabled = snapshotsEnabled;\n    }\n\n    public static ProjectRepository get(String versionName, ReleaseStatus status) {\n        if (status == ReleaseStatus.GENERAL_AVAILABILITY) {\n            return null;\n        }\n\n        if (status == ReleaseStatus.SNAPSHOT) {\n            return SNAPSHOT;\n        }\n\n        return MILESTONE;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public Boolean getSnapshotsEnabled() {\n        return snapshotsEnabled;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setSnapshotsEnabled(Boolean snapshotsEnabled) {\n        this.snapshotsEnabled = snapshotsEnabled;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || !(o instanceof ProjectRepository))\n            return false;\n\n        ProjectRepository that = (ProjectRepository) o;\n\n        if (id != null ? !id.equals(that.id) : that.id != null)\n            return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return id != null ? id.hashCode() : 0;\n    }\n\n    @Override\n    public String toString() {\n        return \"ProjectRepository{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", url='\" + url + '\\'' +\n                \", snapshotsEnabled=\" + snapshotsEnabled +\n                '}';\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@Service\npublic class DefaultTeamImporter implements TeamImporter {\n\n\tprivate static final String API_URL_BASE = \"https://api.github.com\";\n\n    private final TeamService teamService;\n    private final String gitHubTeamId;\n\n    @Autowired\n    public DefaultTeamImporter(TeamService teamService, @Value(\"${github.team.id}\") String gitHubTeamId) {\n        this.teamService = teamService;\n        this.gitHubTeamId = gitHubTeamId;\n    }\n\n    @Transactional\n    public void importTeamMembers(GitHub gitHub) {\n        GitHubUser[] users = getGitHubUsers(gitHub);\n        List<Long> userIds = new ArrayList<>();\n        for (GitHubUser user : users) {\n            userIds.add(user.getId());\n            String userName = getNameForUser(user.getLogin(), gitHub);\n\n            teamService.createOrUpdateMemberProfile(user.getId(), user.getLogin(), user.getAvatarUrl(), userName);\n        }\n        teamService.showOnlyTeamMembersWithIds(userIds);\n    }\n\n    private GitHubUser[] getGitHubUsers(GitHub gitHub) {\n        String membersUrl = API_URL_BASE + \"/teams/{teamId}/members?per_page=100\";\n        ResponseEntity<GitHubUser[]> entity =\n                gitHub.restOperations().getForEntity(membersUrl, GitHubUser[].class, gitHubTeamId);\n        return entity.getBody();\n    }\n\n    public String getNameForUser(String username, GitHub gitHub) {\n        return gitHub.restOperations()\n                .getForObject(API_URL_BASE +\"/users/{user}\", GitHubUser.class, username)\n                .getName();\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\npublic class SpringSessionRememberMeServices implements RememberMeServices, LogoutHandler {\n\n\t\n\tpublic static final String REMEMBER_ME_LOGIN_ATTR = SpringSessionRememberMeServices.class.getName()\n\t\t\t+ \"REMEMBER_ME_LOGIN_ATTR\";\n\n\tprivate static final String DEFAULT_REMEMBERME_PARAMETER = \"remember-me\";\n\n\tprivate static final int THIRTY_DAYS_SECONDS = 2592000;\n\n\tprivate static final Log logger = LogFactory.getLog(SpringSessionRememberMeServices.class);\n\n\tprivate String rememberMeParameterName = DEFAULT_REMEMBERME_PARAMETER;\n\n\tprivate boolean alwaysRemember;\n\n\tprivate int validitySeconds = THIRTY_DAYS_SECONDS;\n\n\t@Override\n\tpublic final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic final void loginFail(HttpServletRequest request, HttpServletResponse response) {\n\t\tlogout(request);\n\t}\n\n\t@Override\n\tpublic final void loginSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tAuthentication successfulAuthentication) {\n\t\tif (!this.alwaysRemember && !rememberMeRequested(request, this.rememberMeParameterName)) {\n\t\t\tlogger.debug(\"Remember-me login not requested.\");\n\t\t\treturn;\n\t\t}\n\t\trequest.setAttribute(REMEMBER_ME_LOGIN_ATTR, true);\n\t\trequest.getSession().setMaxInactiveInterval(this.validitySeconds);\n\t}\n\n\t\n\tprotected boolean rememberMeRequested(HttpServletRequest request, String parameter) {\n\t\tString rememberMe = request.getParameter(parameter);\n\t\tif (rememberMe != null) {\n\t\t\tif (rememberMe.equalsIgnoreCase(\"true\") || rememberMe.equalsIgnoreCase(\"on\")\n\t\t\t\t\t|| rememberMe.equalsIgnoreCase(\"yes\") || rememberMe.equals(\"1\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Did not send remember-me cookie (principal did not set \" + \"parameter '\" + parameter + \"')\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t\n\tpublic void setRememberMeParameterName(String rememberMeParameterName) {\n\t\tAssert.hasText(rememberMeParameterName, \"rememberMeParameterName cannot be empty or null\");\n\t\tthis.rememberMeParameterName = rememberMeParameterName;\n\t}\n\n\tpublic void setAlwaysRemember(boolean alwaysRemember) {\n\t\tthis.alwaysRemember = alwaysRemember;\n\t}\n\n\tpublic void setValiditySeconds(int validitySeconds) {\n\t\tthis.validitySeconds = validitySeconds;\n\t}\n\n\t@Override\n\tpublic void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n\t\tlogout(request);\n\t}\n\n\tprivate void logout(HttpServletRequest request) {\n\t\tlogger.debug(\"Interactive login attempt was unsuccessful.\");\n\t\tHttpSession session = request.getSession(false);\n\t\tif (session != null) {\n\t\t\tsession.removeAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY);\n\t\t}\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class PolarDetect {\n\n    private static String templatePath = \"res/img/capacity/template.jpg\";  //\n    private Point circle_center;   //\n    private Point gravity_center;   //\n\n    \n    public void detect(Mat src) {\n        Mat template = Imgcodecs.imread(templatePath);\n        Point markPoint = TemplateMatch.match(src, template);\n        findCenter(src);\n        System.out.println(\"markpoint: \" + markPoint.x + \" \" + markPoint.y);\n        System.out.println(\"circle: \" + circle_center.x + \" \" + circle_center.y);\n        System.out.println(\"gravity: \" + gravity_center.x + \" \" + gravity_center.y);\n        double tan1 = (gravity_center.y - circle_center.y) / (circle_center.x - gravity_center.x);\n        double angle1 = Math.atan(tan1) / Math.PI * 180;\n        System.out.println(tan1 + \" \" + angle1);\n        double tan2 = (markPoint.y - circle_center.y) / (circle_center.x - markPoint.x);\n        double angle2 = Math.atan(tan2) / Math.PI * 180;\n        System.out.println(tan2 + \" \" + angle2);\n\n        double angle = 180 + angle1 - angle2;\n        if (angle > 180) {\n            angle = 360 - angle;\n        }\n        System.out.println(angle);\n\n        Imgproc.circle(src, markPoint, 1, new Scalar(0, 0, 255));\n        Imgproc.circle(src, gravity_center, 1, new Scalar(0, 0, 255));\n        Imgproc.circle(src, circle_center, 1, new Scalar(0, 0, 255));\n\n        Imgcodecs.imwrite(\"res/img/capacity/result.jpg\", src);\n    }\n\n    private void findCenter(Mat src) {\n        Mat src_blur = new Mat();\n        Mat src_gray = new Mat();\n\n        Imgproc.GaussianBlur(src, src_blur, new Size(5, 5), 0, 0, 4);\n\n        Imgproc.cvtColor(src, src_gray, Imgproc.COLOR_BGR2GRAY);\n\n        Mat img_threshold = new Mat();\n        Imgproc.threshold(src_gray, img_threshold, 0, 255, Imgproc.THRESH_OTSU);\n\n        Mat element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(20, 20));\n        Imgproc.morphologyEx(img_threshold, img_threshold, Imgproc.MORPH_OPEN, element);\n\n        Mat hierarchy = new Mat();\n        List<MatOfPoint> contours = new ArrayList<MatOfPoint>();\n        Imgproc.findContours(img_threshold, contours, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_NONE);\n\n        double maxArea = 0;\n        int index = -1;\n        for (int i = 0; i < contours.size(); i++) {\n            double area = Imgproc.contourArea(contours.get(i));\n            if (area > maxArea) {\n                index = i;\n                maxArea = area;\n            }\n        }\n\n        Moments m = Imgproc.moments(contours.get(index));\n        int x = (int) (m.get_m10() / m.get_m00());\n        int y = (int) (m.get_m01() / m.get_m00());\n        gravity_center = new Point(x, y);\n\n        MatOfPoint2f mtx = new MatOfPoint2f(contours.get(index).toArray());\n        double dist = 0;\n        double maxDist = 0;\n        for (int i = 0; i < src.rows(); i++) {\n            for (int j = 0; j < src.cols(); j++) {\n                dist = Imgproc.pointPolygonTest(mtx, new Point(i, j), true);\n                if (dist > maxDist) {\n                    maxDist = dist;\n                    circle_center = new Point(i, j);\n                }\n            }\n        }\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\npublic class SaganApplication extends SpringApplication {\n\n    private static final Log logger = LogFactory.getLog(SaganApplication.class);\n\n    public SaganApplication(Class<?> configClass) {\n        super(configClass);\n    }\n\n    \n    @Override\n    protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {\n        super.configureProfiles(environment, args);\n\n        boolean stagingActive = environment.acceptsProfiles(STAGING);\n        boolean productionActive = environment.acceptsProfiles(PRODUCTION);\n\n        if (stagingActive && productionActive) {\n            throw new IllegalStateException(format(\"Only one of the following profiles may be specified: [%s]\",\n                    arrayToCommaDelimitedString(new String[] { STAGING, PRODUCTION })));\n        }\n\n        if (stagingActive || productionActive) {\n            logger.info(format(\"Activating '%s' profile because one of '%s' or '%s' profiles have been specified.\",\n                    CLOUDFOUNDRY, STAGING, PRODUCTION));\n            environment.addActiveProfile(CLOUDFOUNDRY);\n        }\n        else {\n            logger.info(\"The default 'standalone' profile is active because no other profiles have been specified.\");\n            environment.addActiveProfile(STANDALONE);\n            Map<String, Object> map = new HashMap<>();\n            map.put(\"client.dir\", new File(\"../sagan-client\").getAbsolutePath());\n            environment.getPropertySources().addLast(new MapPropertySource(\"clientDir\", map));\n        }\n\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\nabstract class MvcConfig extends WebMvcConfigurerAdapter {\n\n\t@Autowired\n\tprivate StaticPagePathFinder staticPagePathFinder;\n\n\t@Bean(name = {\"uih\", \"viewRenderingHelper\"})\n\t@Scope(\"request\")\n\tpublic ViewRenderingHelper viewRenderingHelper() {\n\t\treturn new ViewRenderingHelper();\n\t}\n\n\t@Bean\n\tpublic StaticPagePathFinder staticPagePathFinder(ResourcePatternResolver resourcePatternResolver) {\n\t\treturn new StaticPagePathFinder(resourcePatternResolver);\n\t}\n\n\t@ExceptionHandler\n\t@ResponseStatus(NOT_FOUND)\n\tpublic void handleException(ResourceNotFoundException ex) {\n\t}\n\n\t@Override\n\tpublic void addViewControllers(ViewControllerRegistry registry) {\n\t\ttry {\n\t\t\tfor (StaticPagePathFinder.PagePaths paths : staticPagePathFinder.findPaths()) {\n\t\t\t\tString urlPath = paths.getUrlPath();\n\t\t\t\tregistry.addViewController(urlPath).setViewName(\"pages\" + paths.getFilePath());\n\t\t\t\tif (!urlPath.isEmpty()) {\n\t\t\t\t\tregistry.addViewController(urlPath + \"/\").setViewName(\"pages\" + paths.getFilePath());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new RuntimeException(\"Unable to locate static pages: \" + e.getMessage(), e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addInterceptors(InterceptorRegistry registry) {\n\t\tregistry.addInterceptor(new HandlerInterceptorAdapter() {\n\t\t\t@Override\n\t\t\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t\t\tModelAndView modelAndView) throws Exception {\n\n\t\t\t\tif (handler instanceof HandlerMethod) {\n\t\t\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n\t\t\t\t\tNavigation navSection = handlerMethod.getBean().getClass().getAnnotation(Navigation.class);\n\t\t\t\t\tif (navSection != null && modelAndView != null) {\n\t\t\t\t\t\tmodelAndView.addObject(\"navSection\", navSection.value().toString().toLowerCase());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic class ViewRenderingHelper {\n\n\t\tprivate final UrlPathHelper urlPathHelper = new UrlPathHelper();\n\n\t\tprivate HttpServletRequest request;\n\n\t\t@Autowired\n\t\tpublic void setRequest(HttpServletRequest request) {\n\t\t\tthis.request = request;\n\t\t}\n\n\t\tpublic String navClass(String active, String current) {\n\t\t\tif (active.equals(current)) {\n\t\t\t\treturn \"navbar-link active\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"navbar-link\";\n\t\t\t}\n\t\t}\n\n\t\tpublic String blogClass(String active, String current) {\n\t\t\tif (active.equals(current)) {\n\t\t\t\treturn \"blog-category active\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"blog-category\";\n\t\t\t}\n\t\t}\n\n\t\tpublic String path() {\n\t\t\treturn urlPathHelper.getPathWithinApplication(request);\n\t\t}\n\t}\n\n}\n\n@Configuration\n@ControllerAdvice\n@Profile(\"cloudfoundry\")\nclass CloudFoundryMvcConfig extends MvcConfig {\n\n\t@Value(\"${spring.git.properties:classpath:git.properties}\")\n\tprivate Resource gitProperties;\n\n\tpublic String getGitCommitId() {\n\t\ttry {\n\t\t\tif (this.gitProperties.exists()) {\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(this.gitProperties);\n\t\t\t\treturn properties.getProperty(\"git.commit.id.abbrev\");\n\t\t\t}\n\t\t}\n\t\tcatch (IOException exc) {\n\n\t\t}\n\t\tthrow new IllegalStateException(\"Missing git.properties file on classpath\");\n\t}\n\n\t@Override\n\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n\n\t\tVersionResourceResolver versionResourceResolver = new VersionResourceResolver()\n\t\t\t\t.addFixedVersionStrategy(getGitCommitId(), \"/app/**\")\n\t\t\t\t.addContentVersionStrategy(\"/**\");\n\n\t\tregistry.addResourceHandler(\"/**\")\n\t\t\t\t.addResourceLocations(\"classpath:/static/\")\n\t\t\t\t.resourceChain(true)\n\t\t\t\t.addResolver(versionResourceResolver);\n\n\t}\n\n\t@Bean\n\tpublic ThymeleafViewResolverCustomizer thymeleafViewResolverCustomizer(ThymeleafViewResolver viewResolver) {\n\t\treturn new ThymeleafViewResolverCustomizer(viewResolver, getGitCommitId());\n\t}\n\n\t@Bean\n\tpublic ResourceUrlEncodingFilter resourceUrlEncodingFilter() {\n\t\treturn new ResourceUrlEncodingFilter();\n\t}\n\n}\n\n@Configuration\n@ControllerAdvice\n@Profile(\"standalone\")\nclass StandaloneMvcConfig extends MvcConfig {\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@AutoConfigureMockMvc\n@SpringBootTest\npublic class FileUploadTests {\n\n    @Autowired\n    private MockMvc mvc;\n\n    @MockBean\n    private StorageService storageService;\n\n    @Test\n    public void shouldListAllFiles() throws Exception {\n        given(this.storageService.loadAll())\n                .willReturn(Stream.of(Paths.get(\"first.txt\"), Paths.get(\"second.txt\")));\n\n        this.mvc.perform(get(\"/\")).andExpect(status().isOk())\n                .andExpect(model().attribute(\"files\",\n                        Matchers.contains(\"http://localhost/files/first.txt\",\n                                \"http://localhost/files/second.txt\")));\n    }\n\n    @Test\n    public void shouldSaveUploadedFile() throws Exception {\n        MockMultipartFile multipartFile = new MockMultipartFile(\"file\", \"test.txt\",\n                \"text/plain\", \"Spring Framework\".getBytes());\n        this.mvc.perform(fileUpload(\"/\").file(multipartFile))\n                .andExpect(status().isFound())\n                .andExpect(header().string(\"Location\", \"/\"));\n\n        then(this.storageService).should().store(multipartFile);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void should404WhenMissingFile() throws Exception {\n        given(this.storageService.loadAsResource(\"test.txt\"))\n                .willThrow(StorageFileNotFoundException.class);\n\n        this.mvc.perform(get(\"/files/test.txt\")).andExpect(status().isNotFound());\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class MotionDetectionEffect extends Effect {\n\n    @Override\n    public Mat applyTo(Mat frame) {\n        MotionDetector motionDetector = new MotionDetector(240);\n        return motionDetector.detect(frame);\n    }\n\n    public String toString() {\n        return \"Motion Detection Effect\";\n    }\n}\n\npublic class MotionDetector {\n    public static final int N = 4;\n\n    private Mat[] buf = null;\n    private int last = 0;\n\n    private List<MatOfPoint> contours = new ArrayList<MatOfPoint>();\n    private int threshold = 240;\n    private Mat hierarchy = new Mat();\n\n    public MotionDetector() {}\n\n    public MotionDetector(int threshold) {\n        this.threshold = threshold;\n    }\n\n    public Mat detect(Mat source) {\n        Size size = source.size(); // get current frame size\n        int i, idx1 = last, idx2;\n        Mat silh;\n\n        if (buf == null || buf[0].width() != size.width || buf[0].height() != size.height) {\n            if (buf == null) {\n                buf = new Mat[N];\n            }\n\n            for (i = 0; i < N; i++) {\n                if (buf[i] != null) {\n                    buf[i].release();\n                    buf[i] = null;\n                }\n                buf[i] = new Mat(size, CvType.CV_8UC1);\n                buf[i] = Mat.zeros(size, CvType.CV_8UC1);\n            }\n        }\n        Imgproc.cvtColor(source, buf[last], Imgproc.COLOR_BGR2GRAY);\n\n        idx2 = (last + 1) % N;\n        last = idx2;\n\n        silh = buf[idx2];\n\n        Core.absdiff(buf[idx1], buf[idx2], silh);\n\n        Imgproc.threshold(silh, silh, threshold, 255, Imgproc.THRESH_BINARY);\n\n        contours.clear();\n        Imgproc.findContours(silh, contours, hierarchy, Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE);\n        Imgproc.drawContours(source, contours, -1, new Scalar(255, 0, 0), 2);\n        return source;\n    }\n}", "nl": "opencv"}
{"code": "\n\npublic class FaceDetector{\n \n    public static void main(String[] args) {\n \n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME); \n        CascadeClassifier faceDetector = new CascadeClassifier(FaceDetector.class.getResource(\"haarcascade_frontalface_default.xml\").getPath());\n       \n        Mat image = Highgui.imread(\"sourceimage.jpg\");\n       \n     \n        MatOfRect faceDetections = new MatOfRect();\n        faceDetector.detectMultiScale(image, faceDetections);\n\n        for (Rect rect : faceDetections.toArray()) {\n     \n            Core.rectangle(image, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y + rect.height),\n                    new Scalar(0, 255, 0));\n        }\n        \n        Highgui.imwrite(\"result.png\", image);\n        System.out.println(\"Succesfull\");\n    }\n    \n    \n}", "nl": "opencv"}
{"code": "\n\n\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t.authorizeRequests()\n\t\t\t\t.anyRequest().fullyAuthenticated()\n\t\t\t\t.and()\n\t\t\t.formLogin();\n\t}\n\n\t@Override\n\tpublic void configure(AuthenticationManagerBuilder auth) throws Exception {\n\t\tauth\n\t\t\t.ldapAuthentication()\n\t\t\t\t.userDnPatterns(\"uid={0},ou=people\")\n\t\t\t\t.groupSearchBase(\"ou=groups\")\n\t\t\t\t.contextSource()\n\t\t\t\t\t.url(\"ldap://localhost:8389/dc=springframework,dc=org\")\n\t\t\t\t\t.and()\n\t\t\t\t.passwordCompare()\n\t\t\t\t\t.passwordEncoder(new LdapShaPasswordEncoder())\n\t\t\t\t\t.passwordAttribute(\"userPassword\");\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class MissParts {\n\n    public void match() {\n        Mat objectImage = Imgcodecs.imread(\"res/img/missparts/missparts_std.jpg\");\n        Mat sceneImage = Imgcodecs.imread(\"res/img/missparts/missparts_test.jpg\");\n\n        MatOfKeyPoint objectKeyPoints = new MatOfKeyPoint();\n        FeatureDetector featureDetector = FeatureDetector.create(FeatureDetector.AKAZE);\n        System.out.println(\"Detecting key points...\");\n        featureDetector.detect(objectImage, objectKeyPoints);\n        KeyPoint[] keypoints = objectKeyPoints.toArray();\n\n        MatOfKeyPoint objectDescriptors = new MatOfKeyPoint();\n        DescriptorExtractor descriptorExtractor = DescriptorExtractor.create(DescriptorExtractor.AKAZE);\n        System.out.println(\"Computing descriptors...\");\n        descriptorExtractor.compute(objectImage, objectKeyPoints, objectDescriptors);\n\n        Mat outputImage = new Mat(objectImage.rows(), objectImage.cols(), Imgcodecs.CV_LOAD_IMAGE_COLOR);\n        Scalar newKeypointColor = new Scalar(255, 0, 0);\n\n        System.out.println(\"Drawing key points on object image...\");\n        Features2d.drawKeypoints(objectImage, objectKeyPoints, outputImage, newKeypointColor, 0);\n\n        MatOfKeyPoint sceneKeyPoints = new MatOfKeyPoint();\n        MatOfKeyPoint sceneDescriptors = new MatOfKeyPoint();\n        System.out.println(\"Detecting key points in background image...\");\n        featureDetector.detect(sceneImage, sceneKeyPoints);\n        System.out.println(\"Computing descriptors in background image...\");\n        descriptorExtractor.compute(sceneImage, sceneKeyPoints, sceneDescriptors);\n\n        Mat matchoutput = new Mat(sceneImage.rows() * 2, sceneImage.cols() * 2, Imgcodecs.CV_LOAD_IMAGE_COLOR);\n        Scalar matchestColor = new Scalar(255, 0, 0);\n\n        List<MatOfDMatch> matches = new LinkedList<MatOfDMatch>();\n        DescriptorMatcher descriptorMatcher = DescriptorMatcher.create(DescriptorMatcher.BRUTEFORCE);\n        System.out.println(\"Matching object and scene images...\");\n        descriptorMatcher.knnMatch(objectDescriptors, sceneDescriptors, matches, 2);\n\n        System.out.println(\"Calculating good match list...\");\n        LinkedList<DMatch> goodMatchesList = new LinkedList<DMatch>();\n\n        float nndrRatio = 0.4f;\n\n        for (int i = 0; i < matches.size(); i++) {\n            MatOfDMatch matofDMatch = matches.get(i);\n            DMatch[] dmatcharray = matofDMatch.toArray();\n            DMatch m1 = dmatcharray[0];\n            DMatch m2 = dmatcharray[1];\n\n            if (m1.distance <= m2.distance * nndrRatio) {\n                goodMatchesList.addLast(m1);\n\n            }\n        }\n\n        if (goodMatchesList.size() >= 7) {\n            System.out.println(\"Object Found!!!\");\n\n            List<KeyPoint> objKeypointlist = objectKeyPoints.toList();\n            List<KeyPoint> scnKeypointlist = sceneKeyPoints.toList();\n\n            LinkedList<Point> objectPoints = new LinkedList<Point>();\n            LinkedList<Point> scenePoints = new LinkedList<Point>();\n\n            for (int i = 0; i < goodMatchesList.size(); i++) {\n                Point point1 = objKeypointlist.get(goodMatchesList.get(i).queryIdx).pt;\n                Point point2 = scnKeypointlist.get(goodMatchesList.get(i).trainIdx).pt;\n                double distance = (point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y);\n                System.out.println(distance);\n                if (distance > 100) {\n                    continue;\n                }\n                System.out.println(point1.x + \" \" + point1.y + \"   \" + point2.x + \" \" + point2.y + \"   \" + distance);\n                objectPoints.addLast(point1);\n                scenePoints.addLast(point2);\n            }\n\n            MatOfPoint2f objMatOfPoint2f = new MatOfPoint2f();\n            objMatOfPoint2f.fromList(objectPoints);\n            MatOfPoint2f scnMatOfPoint2f = new MatOfPoint2f();\n            scnMatOfPoint2f.fromList(scenePoints);\n\n\n            Mat homography = Calib3d.findHomography(objMatOfPoint2f, scnMatOfPoint2f, Calib3d.RANSAC, 3);\n\n            Mat result = new Mat(objectImage.rows(), objectImage.cols(), objectImage.type());\n            System.out.println(\"Transforming object to scene...\");\n            Imgproc.warpPerspective(objectImage, result, homography, new Size(sceneImage.cols(), sceneImage.rows()));\n\n            System.out.println(\"Drawing matches image...\");\n            MatOfDMatch goodMatches = new MatOfDMatch();\n            goodMatches.fromList(goodMatchesList);\n\n            Features2d.drawMatches(objectImage, objectKeyPoints, sceneImage, sceneKeyPoints, goodMatches, matchoutput, matchestColor, newKeypointColor, new MatOfByte(), 2);\n            Imgcodecs.imwrite(\"res/img/missparts/outputImage.jpg\", outputImage);\n            Imgcodecs.imwrite(\"res/img/missparts/matchoutput.jpg\", matchoutput);\n            Imgcodecs.imwrite(\"res/img/missparts/result.jpg\", result);\n\n        }\n    }\n\n    public void subtract() {\n        Mat src1 = Imgcodecs.imread(\"res/img/missparts/result.jpg\", CvType.CV_8UC1);\n        Mat src2 = Imgcodecs.imread(\"res/img/missparts/missparts_test.jpg\", CvType.CV_8UC1);\n\n        Imgproc.GaussianBlur(src1, src1, new Size(5, 5), 0, 0, 4);\n        Imgproc.GaussianBlur(src2, src2, new Size(5, 5), 0, 0, 4);\n\n        Mat dst = new Mat();\n        Core.subtract(src1, src2, dst);\n\n        Imgcodecs.imwrite(\"res/img/missparts/subtract_result.jpg\", dst);\n    }\n}\n", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n@Controller\n@RequestMapping(\"/admin/projects\")\n@Navigation(Section.PROJECTS) class ProjectAdminController {\n    private static final List<String> CATEGORIES =\n            Collections.unmodifiableList(Arrays.asList(\"incubator\", \"active\", \"attic\", \"community\"));\n\n    private ProjectMetadataService service;\n\n    private final PostContentRenderer renderer;\n\n    @Autowired\n    public ProjectAdminController(ProjectMetadataService service, PostContentRenderer renderer) {\n        this.service = service;\n        this.renderer = renderer;\n    }\n\n    @RequestMapping(value = \"\", method = GET)\n    public String list(Model model) {\n        model.addAttribute(\"projects\", service.getProjects());\n        return \"admin/project/index\";\n    }\n\n    @RequestMapping(value = \"new\", method = GET)\n    public String newProject(Model model) {\n        ProjectRelease release = new ProjectRelease(\"1.0.0.BUILD-SNAPSHOT\",\n                ProjectRelease.ReleaseStatus.SNAPSHOT,\n                false,\n                \"http://docs.spring.io/spring-new/docs/{version}/spring-new/htmlsingle/\",\n                \"http://docs.spring.io/spring-new/docs/{version}/javadoc-api/\",\n                \"org.springframework.new\",\n                \"spring-new\");\n\n        Project project = new Project(\"spring-new\",\n                \"New Spring Project\",\n                \"http://github.com/spring-projects/spring-new\",\n                \"http://projects.spring.io/spring-new\",\n                new ArrayList<>(Arrays.asList(release)),\n                CATEGORIES.get(0));\n\n        return edit(project, model);\n    }\n\n    @RequestMapping(value = \"{id}\", method = GET)\n    public String edit(@PathVariable String id, Model model) {\n        Project project = service.getProject(id);\n        return edit(project, model);\n    }\n\n    @RequestMapping(value = \"{id}\", method = DELETE)\n    public String delete(@PathVariable String id, Model model) {\n        service.delete(id);\n        return \"redirect:./\";\n    }\n\n    private String edit(Project project, Model model) {\n        if (project == null) {\n            return \"error/404\";\n        }\n\n        denormalizeProjectReleases(project);\n\n        List<ProjectRelease> releases = project.getProjectReleases();\n        if (!releases.isEmpty()) {\n            model.addAttribute(\"groupId\", releases.get(0).getGroupId());\n        }\n\n        int nextAvailableSampleDisplayOrder = project.getProjectSamples()\n                .stream()\n                .mapToInt(ProjectSample::getDisplayOrder)\n                .max()\n                .orElse(0) + 1;\n\n        model.addAttribute(\"project\", project);\n        model.addAttribute(\"categories\", CATEGORIES);\n        model.addAttribute(\"projectSampleDisplayOrder\", nextAvailableSampleDisplayOrder);\n        return \"admin/project/edit\";\n    }\n\n    @RequestMapping(value = \"{id}\", method = POST)\n    public String save(@Valid Project project,\n                       @RequestParam(defaultValue = \"\") List<String> releasesToDelete,\n                       @RequestParam(defaultValue = \"\") List<Integer> samplesToDelete,\n                       @RequestParam String groupId,\n                       @RequestParam(required = false) String parentId) {\n        Iterator<ProjectRelease> iReleases = project.getProjectReleases().iterator();\n        while (iReleases.hasNext()) {\n            ProjectRelease release = iReleases.next();\n            if (\"\".equals(release.getVersion()) || releasesToDelete.contains(release.getVersion())) {\n                iReleases.remove();\n            }\n        }\n        normalizeProjectReleases(project, groupId);\n\n        String renderedBootConfig = this.renderer.render(project.getRawBootConfig(), PostFormat.ASCIIDOC);\n        project.setRenderedBootConfig(renderedBootConfig);\n        String renderedOverview = this.renderer.render(project.getRawOverview(), PostFormat.ASCIIDOC);\n        project.setRenderedOverview(renderedOverview);\n\n        if (parentId != null) {\n            Project parentProject = service.getProject(parentId);\n            project.setParentProject(parentProject);\n        }\n\n        project.setProjectSamples(\n                project.getProjectSamples()\n                        .stream()\n                        .filter(ps -> !(ps.getTitle().isEmpty() || ps.getUrl().isEmpty()))\n                        .filter(ps -> !samplesToDelete.contains(ps.getDisplayOrder()))\n                        .collect(Collectors.toList())\n        );\n\n        service.save(project);\n\n        return \"redirect:\" + project.getId();\n    }\n\n    private void normalizeProjectReleases(Project project, String groupId) {\n        for (ProjectRelease release : project.getProjectReleases()) {\n            if (groupId != null) {\n                release.setGroupId(groupId);\n            }\n            release.replaceVersionPattern();\n        }\n    }\n\n    private void denormalizeProjectReleases(Project project) {\n        List<ProjectRelease> releases = new ArrayList<>();\n        for (ProjectRelease release : project.getProjectReleases()) {\n            releases.add(release.createWithVersionPattern());\n        }\n        project.setProjectReleases(releases);\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class LineSegmentDetector extends Algorithm {\n\n    protected LineSegmentDetector(long addr) { super(addr); }\n\n\n\n    public  void detect(Mat _image, Mat _lines, Mat width, Mat prec, Mat nfa)\n    {\n        \n        detect_0(nativeObj, _image.nativeObj, _lines.nativeObj, width.nativeObj, prec.nativeObj, nfa.nativeObj);\n        \n        return;\n    }\n\n    public  void detect(Mat _image, Mat _lines)\n    {\n        \n        detect_1(nativeObj, _image.nativeObj, _lines.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void drawSegments(Mat _image, Mat lines)\n    {\n        \n        drawSegments_0(nativeObj, _image.nativeObj, lines.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  int compareSegments(Size size, Mat lines1, Mat lines2, Mat _image)\n    {\n        \n        int retVal = compareSegments_0(nativeObj, size.width, size.height, lines1.nativeObj, lines2.nativeObj, _image.nativeObj);\n        \n        return retVal;\n    }\n\n    public  int compareSegments(Size size, Mat lines1, Mat lines2)\n    {\n        \n        int retVal = compareSegments_1(nativeObj, size.width, size.height, lines1.nativeObj, lines2.nativeObj);\n        \n        return retVal;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n    private static native void detect_0(long nativeObj, long _image_nativeObj, long _lines_nativeObj, long width_nativeObj, long prec_nativeObj, long nfa_nativeObj);\n    private static native void detect_1(long nativeObj, long _image_nativeObj, long _lines_nativeObj);\n\n    private static native void drawSegments_0(long nativeObj, long _image_nativeObj, long lines_nativeObj);\n\n    private static native int compareSegments_0(long nativeObj, double size_width, double size_height, long lines1_nativeObj, long lines2_nativeObj, long _image_nativeObj);\n    private static native int compareSegments_1(long nativeObj, double size_width, double size_height, long lines1_nativeObj, long lines2_nativeObj);\n\n    private static native void delete(long nativeObj);\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n@Service\npublic class BookService {\n\n  private final RestTemplate restTemplate;\n\n  public BookService(RestTemplate rest) {\n    this.restTemplate = rest;\n  }\n\n  @HystrixCommand(fallbackMethod = \"reliable\")\n  public String readingList() {\n    URI uri = URI.create(\"http://localhost:8090/recommended\");\n\n    return this.restTemplate.getForObject(uri, String.class);\n  }\n\n  public String reliable() {\n    return \"Cloud Native Java (O'Reilly)\";\n  }\n\n}", "nl": "spring"}
{"code": "\n\n\n@Configuration\npublic class CountryConfiguration {\n\n\t@Bean\n\tpublic Jaxb2Marshaller marshaller() {\n\t\tJaxb2Marshaller marshaller = new Jaxb2Marshaller();\n\t\tmarshaller.setContextPath(\"hello.wsdl\");\n\t\treturn marshaller;\n\t}\n\n\t@Bean\n\tpublic CountryClient countryClient(Jaxb2Marshaller marshaller) {\n\t\tCountryClient client = new CountryClient();\n\t\tclient.setDefaultUri(\"http://localhost:8080/ws\");\n\t\tclient.setMarshaller(marshaller);\n\t\tclient.setUnmarshaller(marshaller);\n\t\treturn client;\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n@Component\npublic class AppRunner implements CommandLineRunner {\n\n    private static final Logger logger = LoggerFactory.getLogger(AppRunner.class);\n\n    private final GitHubLookupService gitHubLookupService;\n\n    public AppRunner(GitHubLookupService gitHubLookupService) {\n        this.gitHubLookupService = gitHubLookupService;\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        long start = System.currentTimeMillis();\n\n        CompletableFuture<User> page1 = gitHubLookupService.findUser(\"PivotalSoftware\");\n        CompletableFuture<User> page2 = gitHubLookupService.findUser(\"CloudFoundry\");\n        CompletableFuture<User> page3 = gitHubLookupService.findUser(\"Spring-Projects\");\n\n        CompletableFuture.allOf(page1,page2,page3).join();\n\n        logger.info(\"Elapsed time: \" + (System.currentTimeMillis() - start));\n        logger.info(\"--> \" + page1.get());\n        logger.info(\"--> \" + page2.get());\n        logger.info(\"--> \" + page3.get());\n\n    }\n\n}", "nl": "spring"}
{"code": "\n\npublic class Greeting {\n\n    private final long id;\n    private final String content;\n\n    public Greeting(long id, String content) {\n        this.id = id;\n        this.content = content;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\nclass AddingImagesRun{\n    public void run() {\n        double alpha = 0.5; double beta; double input;\n        Scanner scan = new Scanner( System.in );\n\n        Mat src1, src2, dst = new Mat();\n\n        System.out.println(\" Simple Linear Blender \");\n        System.out.println(\"-----------------------\");\n        System.out.println(\"* Enter alpha [0-1]: \");\n        input = scan.nextDouble();\n\n        if( input >= 0.0 && input <= 1.0 )\n            alpha = input;\n\n        src1 = Imgcodecs.imread(\"../../images/LinuxLogo.jpg\");\n        src2 = Imgcodecs.imread(\"../../images/WindowsLogo.jpg\");\n\n        if( src1.empty() == true ){ System.out.println(\"Error loading src1\"); return;}\n        if( src2.empty() == true ){ System.out.println(\"Error loading src2\"); return;}\n\n        beta = ( 1.0 - alpha );\n        Core.addWeighted( src1, alpha, src2, beta, 0.0, dst);\n\n        Image image = toBufferedImage(dst);\n        displayImage(image);\n\n\n    }\n\n    public Image toBufferedImage(Mat m){\n        int type = BufferedImage.TYPE_BYTE_GRAY;\n        if ( m.channels() > 1 ) {\n            type = BufferedImage.TYPE_3BYTE_BGR;\n        }\n        int bufferSize = m.channels()*m.cols()*m.rows();\n        byte [] b = new byte[bufferSize];\n        m.get(0,0,b); // get all the pixels\n        BufferedImage image = new BufferedImage(m.cols(),m.rows(), type);\n        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n        System.arraycopy(b, 0, targetPixels, 0, b.length);\n        return image;\n    }\n\n    public void displayImage(Image img)\n    {\n        ImageIcon icon=new ImageIcon(img);\n        JFrame frame=new JFrame();\n        JLabel lbl=new JLabel(icon);\n        frame.add(lbl);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n\npublic class AddingImages {\n    public static void main(String[] args) {\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n        new AddingImagesRun().run();\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n@Controller\npublic class ProductController {\n\n\t@Autowired\n\tprivate ProductService productService;\n\n\n\tpublic ProductService getProductService() {\n\t\treturn productService;\n\t}\n\n\tpublic void setProductService(ProductService productService) {\n\t\tthis.productService = productService;\n\t}\n\n\n\t@Bean\n\tpublic MultipartResolver multipartResolver() {\n\t\tCommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();\n\t\tmultipartResolver.setMaxUploadSize(10240000);\n\t\treturn multipartResolver;\n\t}\n\n\n\n\t\n\t  @RequestMapping(\"/getAllProducts\") public ModelAndView getAllProducts() {\n\t  List<Product> products = productService.getAllProducts(); return new\n\t  ModelAndView(\"productList\", \"products\", products); }\n\t \n\t\n\n\t@RequestMapping(\"getProductById/{productId}\")\n\tpublic ModelAndView getProductById(@PathVariable(value = \"productId\") String productId) {\n\t\tProduct product = productService.getProductById(productId);\n\t\treturn new ModelAndView(\"productPage\", \"productObj\", product);\n\t}\n\n\t@RequestMapping(\"/admin/delete/{productId}\")\n\tpublic String deleteProduct(@PathVariable(value = \"productId\") String productId) {\n\n\n\t\tPath path = Paths.get(\"C:/Users/Ismail/workspace/ShoppingCart/src/main/webapp/WEB-INF/resource/images/products/\"\n\t\t\t\t+ productId + \".jpg\");\n\n\t\tif (Files.exists(path)) {\n\t\t\ttry {\n\t\t\t\tFiles.delete(path);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tproductService.deleteProduct(productId);\n\t\treturn \"redirect:/getAllProducts\";\n\t}\n\n\t@RequestMapping(value = \"/admin/product/addProduct\", method = RequestMethod.GET)\n\tpublic String getProductForm(Model model) {\n\t\tProduct product = new Product();\n\t\tproduct.setProductCategory(\"Android\");\n\t\tmodel.addAttribute(\"productFormObj\", product);\n\t\treturn \"addProduct\";\n\n\t}\n\n\t@RequestMapping(value = \"/admin/product/addProduct\", method = RequestMethod.POST)\n\tpublic String addProduct(@Valid @ModelAttribute(value = \"productFormObj\") Product product, BindingResult result) {\n\t\tif (result.hasErrors())\n\t\t\treturn \"addProduct\";\n\t\tproductService.addProduct(product);\n\t\tMultipartFile image = product.getProductImage();\n\t\tif (image != null && !image.isEmpty()) {\n\t\t\tPath path = Paths\n\t\t\t\t\t.get(\"C:/Users/Ismail/workspace/ShoppingCart/src/main/webapp/WEB-INF/resource/images/products/\"\n\t\t\t\t\t\t\t+ product.getProductId() + \".jpg\");\n\n\t\t\ttry {\n\t\t\t\timage.transferTo(new File(path.toString()));\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\t\treturn \"redirect:/getAllProducts\";\n\t}\n\n\t@RequestMapping(value = \"/admin/product/editProduct/{productId}\")\n\tpublic ModelAndView getEditForm(@PathVariable(value = \"productId\") String productId) {\n\t\tProduct product = productService.getProductById(productId);\n\t\treturn new ModelAndView(\"editProduct\", \"editProductObj\", product);\n\t}\n\n\t@RequestMapping(value = \"/admin/product/editProduct\", method = RequestMethod.POST)\n\tpublic String editProduct(@ModelAttribute(value = \"editProductObj\") Product product) {\n\t\tproductService.editProduct(product);\n\t\treturn \"redirect:/getAllProducts\";\n\t}\n\n\t@RequestMapping(\"/getProductsList\")\n\tpublic @ResponseBody List<Product> getProductsListInJson() {\n\t\treturn productService.getAllProducts();\n\t}\n\n\t@RequestMapping(\"/productsListAngular\")\n\tpublic String getProducts() {\n\t\treturn \"productListAngular\";\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class ApplicationTests {\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void loginWithValidUserThenAuthenticated() throws Exception {\n        FormLoginRequestBuilder login = formLogin()\n            .user(\"ben\")\n            .password(\"benspassword\");\n\n        mockMvc.perform(login)\n            .andExpect(authenticated().withUsername(\"ben\"));\n    }\n\n    @Test\n    public void loginWithInvalidUserThenUnauthenticated() throws Exception {\n        FormLoginRequestBuilder login = formLogin()\n            .user(\"invalid\")\n            .password(\"invalidpassword\");\n\n        mockMvc.perform(login)\n            .andExpect(unauthenticated());\n    }\n}", "nl": "spring"}
{"code": "\n\nclass MatMaskOperationsRun {\n\n    public void run(String[] args) {\n\n        String filename = \"../data/lena.jpg\";\n\n        int img_codec = Imgcodecs.IMREAD_COLOR;\n        if (args.length != 0) {\n            filename = args[0];\n            if (args.length >= 2 && args[1].equals(\"G\"))\n                img_codec = Imgcodecs.IMREAD_GRAYSCALE;\n        }\n\n        Mat src = Imgcodecs.imread(filename, img_codec);\n\n        if (src.empty()) {\n            System.out.println(\"Can't open image [\" + filename + \"]\");\n            System.out.println(\"Program Arguments: [image_path -- default ../data/lena.jpg] [G -- grayscale]\");\n            System.exit(-1);\n        }\n\n        HighGui.namedWindow(\"Input\", HighGui.WINDOW_AUTOSIZE);\n        HighGui.namedWindow(\"Output\", HighGui.WINDOW_AUTOSIZE);\n\n        HighGui.imshow(\"Input\", src);\n        double t = System.currentTimeMillis();\n\n        Mat dst0 = sharpen(src, new Mat());\n\n        t = ((double) System.currentTimeMillis() - t) / 1000;\n        System.out.println(\"Hand written function time passed in seconds: \" + t);\n\n        HighGui.imshow(\"Output\", dst0);\n        HighGui.moveWindow(\"Output\", src.width(), 0);\n        HighGui.waitKey(0);\n\n        Mat kern = new Mat(3, 3, CvType.CV_8S);\n        int row = 0, col = 0;\n        kern.put(row, col, 0, -1, 0, -1, 5, -1, 0, -1, 0);\n\n        t = System.currentTimeMillis();\n\n        Mat dst1 = new Mat();\n        Imgproc.filter2D(src, dst1, src.depth(), kern);\n        t = ((double) System.currentTimeMillis() - t) / 1000;\n        System.out.println(\"Built-in filter2D time passed in seconds:     \" + t);\n\n        HighGui.imshow(\"Output\", dst1);\n        HighGui.waitKey(0);\n        System.exit(0);\n    }\n\n    public static double saturateCastUchar(double x) {\n        return x > 255.0 ? 255.0 : (x < 0.0 ? 0.0 : x);\n    }\n\n    public Mat sharpen(Mat myImage, Mat Result) {\n        myImage.convertTo(myImage, CvType.CV_8U);\n\n        int nChannels = myImage.channels();\n        Result.create(myImage.size(), myImage.type());\n\n        for (int j = 1; j < myImage.rows() - 1; ++j) {\n            for (int i = 1; i < myImage.cols() - 1; ++i) {\n                double sum[] = new double[nChannels];\n\n                for (int k = 0; k < nChannels; ++k) {\n\n                    double top = -myImage.get(j - 1, i)[k];\n                    double bottom = -myImage.get(j + 1, i)[k];\n                    double center = (5 * myImage.get(j, i)[k]);\n                    double left = -myImage.get(j, i - 1)[k];\n                    double right = -myImage.get(j, i + 1)[k];\n\n                    sum[k] = saturateCastUchar(top + bottom + center + left + right);\n                }\n\n                Result.put(j, i, sum);\n            }\n        }\n\n        Result.row(0).setTo(new Scalar(0));\n        Result.row(Result.rows() - 1).setTo(new Scalar(0));\n        Result.col(0).setTo(new Scalar(0));\n        Result.col(Result.cols() - 1).setTo(new Scalar(0));\n\n        return Result;\n    }\n}\n\npublic class MatMaskOperations {\n    public static void main(String[] args) {\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n        new MatMaskOperationsRun().run(args); // run code\n    }\n}", "nl": "opencv"}
{"code": "\n\npublic class MedianBlurTest {\n   public static void main(String args[]) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"C:/EXAMPLES/OpenCV/sample.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Imgproc.medianBlur(src, dst, 15);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap9/median.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\nclass ImageTrails {\n    OpenCV opencv; // Creates a new OpenCV Object\n    PImage trailsImg; // Image to hold the trails\n    int hCycle; // A variable to hold the hue of the image tint\n\n    void setup() {\n\n        size(320, 240);\n\n        opencv = new OpenCV(this); // Initialises the OpenCV object\n        opencv.capture(320, 240); // Opens a video capture stream\n        trailsImg = new PImage(320, 240); // Initialises trailsImg\n        hCycle = 0; // Initialise hCycle\n    }\n\n    void draw() {\n\n        opencv.read(); // Grabs a frame from the camera\n        PImage camImage; // Creates an image and\n        camImage = opencv.image(); // stores the unprocessed camera frame in it\n\n        opencv.absDiff(); // Calculates the absolute difference\n        opencv.convert(OpenCV.GRAY); // Converts the difference image to greyscale\n        opencv.blur(OpenCV.BLUR, 3); // I like to blur before taking the difference image to reduce camera noise\n        opencv.threshold(20);\n\n        trailsImg.blend(opencv.image(), 0, 0, 320, 240, 0, 0, 320, 240, SCREEN); // Blends the movement image with the\n\n        colorMode(HSB); // Changes the colour mode to HSB so that we can change the hue\n        tint(color(hCycle, 255, 255)); // Sets the tint so that the hue is equal to hcycle and the saturation and\n        image(trailsImg, 0, 0); // Display the blended difference image\n        noTint(); // Turns tint off\n        colorMode(RGB); // Changes the colour mode back to the default\n\n        blend(camImage, 0, 0, 320, 240, 0, 0, 320, 240, SCREEN); // Blends the original image with the trails image\n\n        opencv.copy(trailsImg); // Copies trailsImg into OpenCV buffer so we can put some effects on it\n        opencv.blur(OpenCV.BLUR, 4); // Blurs the trails image\n        opencv.brightness(-20); // Sets the brightness of the trails image to -20 so it will fade out\n        trailsImg = opencv.image(); // Puts the modified image from the buffer back into trailsImg\n\n        opencv.remember(); // Remembers the current frame\n\n        hCycle++; // Increments the hCycle variable by 1 so that the hue changes each frame\n        if (hCycle > 255)\n            hCycle = 0; // If hCycle is greater than 255 (the maximum value for a hue) then make it\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic final class PostView {\n\n    private final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"MMMM dd, yyyy\");\n\n    private final Post post;\n    private final DateFactory dateFactory;\n\n    private PostView(Post post, DateFactory dateFactory) {\n        this.post = post;\n        this.dateFactory = dateFactory;\n    }\n\n    public static PostView of(Post post, DateFactory dateFactory) {\n        return new PostView(post, dateFactory);\n    }\n\n    public static Page<PostView> pageOf(Page<Post> posts, DateFactory dateFactory) {\n        List<PostView> postViews = posts.getContent().stream()\n                .map(post -> of(post, dateFactory))\n                .collect(Collectors.toList());\n        PageRequest pageRequest = new PageRequest(posts.getNumber(), posts.getSize(), posts.getSort());\n        return new PageImpl<>(postViews, pageRequest, posts.getTotalElements());\n    }\n\n    public String getFormattedPublishDate() {\n        return post.isScheduled() ? \"Unscheduled\" : DATE_FORMAT.format(post.getPublishAt());\n    }\n\n    public String getPath() {\n        String path;\n        if (post.isLiveOn(dateFactory.now())) {\n            path = \"/blog/\" + post.getPublicSlug();\n        } else {\n            path = \"/admin/blog/\" + post.getAdminSlug();\n        }\n        return path;\n    }\n\n    public String getTitle() {\n        return post.getTitle();\n    }\n\n    public boolean isScheduled() {\n        return post.isScheduled();\n    }\n\n    public boolean isDraft() {\n        return post.isDraft();\n    }\n\n    public PostCategory getCategory() {\n        return post.getCategory();\n    }\n\n    public boolean isBroadcast() {\n        return post.isBroadcast();\n    }\n\n    public MemberProfile getAuthor() {\n        return post.getAuthor();\n    }\n\n    public String getRenderedSummary() {\n        return post.getRenderedSummary();\n    }\n\n    public String getRenderedContent() {\n        return post.getRenderedContent();\n    }\n\n    public Date getPublishAt() {\n        return post.getPublishAt();\n    }\n\n    public Date getCreatedAt() {\n        return post.getCreatedAt();\n    }\n\n    public Long getId() {\n        return post.getId();\n    }\n\n    public boolean showReadMore() {\n        return !post.getRenderedContent().equals(post.getRenderedSummary());\n    }\n\n    public String getEditPath() {\n        return getUpdatePath() + \"/edit\";\n    }\n\n    public String getUpdatePath() {\n        return \"/admin/blog/\" + post.getAdminSlug();\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class AirlightEstimate {\n\n\tpublic static double[] estimate(Mat img, int blockSize) {\n\t\tint rows = img.rows();\n\t\tint cols = img.cols();\n\t\twhile (rows * cols > blockSize) {\n\t\t\tint midRow = (int) Math.floor(rows / 2.0);\n\t\t\tint midCol = (int) Math.floor(cols / 2.0);\n\t\t\tMat[] subIm = new Mat[4];\n\t\t\tsubIm[0] = img.submat(0, midRow, 0, midCol); // left-top corner\n\t\t\tsubIm[1] = img.submat(midRow, rows, 0, midCol); // right-top corner\n\t\t\tsubIm[2] = img.submat(0, midRow, midCol, cols); // left-bottom corner\n\t\t\tsubIm[3] = img.submat(midRow, rows, midCol, cols); // right-bottom corner\n\t\t\tdouble[] score = new double[4];\n\t\t\tscore[0] = calculateScore(subIm[0]);\n\t\t\tscore[1] = calculateScore(subIm[1]);\n\t\t\tscore[2] = calculateScore(subIm[2]);\n\t\t\tscore[3] = calculateScore(subIm[3]);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 1; i < score.length; i++) {\n\t\t\t\tif (score[index] < score[i]) index = i;\n\t\t\t}\n\t\t\timg = subIm[index].clone();\n\t\t\trows = img.rows();\n\t\t\tcols = img.cols();\n\t\t}\n\t\tint index_X = 0;\n\t\tint index_Y = 0;\n\t\tdouble pointValue = Double.MAX_VALUE;\n\t\tfor (int i = 0; i < img.rows(); i++) {\n\t\t\tfor (int j = 0; j < img.cols(); j++) {\n\t\t\t\tdouble[] data = img.get(i, j);\n\t\t\t\tdouble tmpValue = Math.sqrt(Math.pow(data[0] - 255.0, 2.0) + Math.pow(data[1] - 255.0, 2.0) + Math.pow(data[2] - 255.0, 2.0));\n\t\t\t\tif (pointValue > tmpValue) {\n\t\t\t\t\tindex_X = i;\n\t\t\t\t\tindex_Y = j;\n\t\t\t\t\tpointValue = tmpValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn img.get(index_X, index_Y);\n\t}\n\n\tprivate static double calculateScore(Mat im) {\n\t\tMatOfDouble mean = new MatOfDouble();\n\t\tMatOfDouble std = new MatOfDouble();\n\t\tCore.meanStdDev(im, mean, std);\n\t\tdouble[] means = mean.get(0, 0);\n\t\tdouble[] stds = std.get(0, 0);\n\t\tdouble score = 0.0;\n\t\tfor (int i = 0; i < means.length; i++) score += means[i] - stds[i];\n\t\treturn score;\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class ApplicationMockMvcTests {\n    \n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void checkPersonInfoWhenNameMissingNameThenFailure() throws Exception {\n        MockHttpServletRequestBuilder createPerson = post(\"/\")\n                .param(\"age\", \"20\");\n\n        mockMvc.perform(createPerson)\n            .andExpect(model().hasErrors());\n    }\n\n    @Test\n    public void checkPersonInfoWhenNameTooShortThenFailure() throws Exception {\n        MockHttpServletRequestBuilder createPerson = post(\"/\")\n                .param(\"name\", \"R\")\n                .param(\"age\", \"20\");\n\n        mockMvc.perform(createPerson)\n            .andExpect(model().hasErrors());\n    }\n\n    @Test\n    public void checkPersonInfoWhenAgeMissingThenFailure() throws Exception {\n        MockHttpServletRequestBuilder createPerson = post(\"/\")\n                .param(\"name\", \"Rob\");\n\n        mockMvc.perform(createPerson)\n            .andExpect(model().hasErrors());\n    }\n\n    @Test\n    public void checkPersonInfoWhenAgeTooYoungThenFailure() throws Exception {\n        MockHttpServletRequestBuilder createPerson = post(\"/\")\n                .param(\"age\", \"1\")\n                .param(\"name\", \"Rob\");\n\n        mockMvc.perform(createPerson)\n            .andExpect(model().hasErrors());\n    }\n\n    @Test\n    public void checkPersonInfoWhenValidRequestThenSuccess() throws Exception {\n        MockHttpServletRequestBuilder createPerson = post(\"/\")\n                .param(\"name\", \"Rob\")\n                .param(\"age\", \"20\");\n\n        mockMvc.perform(createPerson)\n            .andExpect(model().hasNoErrors());\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n@Controller\n@RequestMapping(\"/admin/tools\")\npublic class SpringToolsAdminController {\n\n\tprivate final SpringToolsPlatformRepository repository;\n\n\tpublic SpringToolsAdminController(SpringToolsPlatformRepository repository) {\n\t\tthis.repository = repository;\n\t}\n\n\t@GetMapping\n\tpublic String list(Model model) {\n\t\tmodel.addAttribute(\"platforms\", this.repository.findAll());\n\t\treturn \"admin/tools/index\";\n\t}\n\n\t@GetMapping(\"{id}\")\n\tpublic String edit(@PathVariable String id, Model model) {\n\t\tSpringToolsPlatform platform = this.repository.findOne(id);\n\t\treturn edit(platform, model);\n\t}\n\n\t@GetMapping(\"new\")\n\tpublic String newPlatform(Model model) {\n\t\tSpringToolsPlatform platform = new SpringToolsPlatform(\"new-platform\");\n\t\treturn edit(platform, model);\n\t}\n\n\tprivate String edit(SpringToolsPlatform platform, Model model) {\n\t\tif (platform == null) {\n\t\t\treturn \"error/404\";\n\t\t}\n\t\tmodel.addAttribute(\"platform\", platform);\n\t\treturn \"admin/tools/edit\";\n\t}\n\n\t@PostMapping(\"{id}\")\n\tpublic String save(\n\t\t\tSpringToolsPlatform platform,\n\t\t\t@RequestParam(defaultValue = \"\") List<String> downloadsToDelete) {\n\t\tList<SpringToolsDownload> toDelete = platform.getDownloads().stream()\n\t\t\t\t.filter(p -> downloadsToDelete.contains(p.getVariant()) || StringUtils.isEmpty(p.getVariant()))\n\t\t\t\t.collect(Collectors.toList());\n\t\tplatform.getDownloads().removeAll(toDelete);\n\t\tthis.repository.save(platform);\n\t\treturn \"redirect:\" + platform.getId();\n\t}\n\n\t@DeleteMapping(\"{id}\")\n\tpublic String delete(@PathVariable String id) {\n\t\tthis.repository.delete(id);\n\t\treturn \"redirect:./\";\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class Mosaic {\n\n    private Mat img;\n    private Mat result;\n\n    private int xTiles = 10;\n    private int yTiles = 10;\n\n    private int tileWidth = 20;\n    private int tileHeight = 20;\n\n    private SelectAlgorithm algorithm = SelectAlgorithm.COLOR;\n    private boolean avoidRep = false;\n    private Blend blend = Blend.NOBLEND;\n    private int blendAmount = 50;\n\n    private int progress;\n    private PropertyChangeSupport supp = new PropertyChangeSupport(this);\n\n    public enum SelectAlgorithm {\n\n        RANDOM, COLOR, MATCH\n    }\n\n    public enum Blend {\n\n        NOBLEND, COLOR, ORIGINAL\n    }\n\n    public Mosaic() {\n        img = null;\n    }\n\n    \n    public Mat createMosaic(Tileset tileset) {\n        checkState();\n        tileset.resetPriority();\n        this.setProgress(0);\n\n        Mat imgMod = new Mat();\n        Imgproc.resize(img, imgMod, new Size(xTiles * tileWidth, yTiles * tileHeight));\n\n        TileMatch[][] matches = new TileMatch[yTiles][xTiles];\n        ArrayList<Integer> indices = new ArrayList<>(xTiles * yTiles);\n        for (int i = 0; i < yTiles; i++) {\n            for (int j = 0; j < xTiles; j++) {\n                indices.add(i * xTiles + j);\n            }\n        }\n\n        Random r = new Random();\n        int count = 0;\n        int size = indices.size();\n        while (!indices.isEmpty()) {\n            int rand = r.nextInt(indices.size());\n            int index = indices.get(rand);\n            indices.remove(rand);\n\n            int i = index / xTiles;\n            int j = index % xTiles;\n            Mat origTile = imgMod.submat(i * tileHeight, i * tileHeight + tileHeight, j * tileWidth, j * tileWidth + tileWidth);\n            matches[i][j] = tileset.chooseTile(origTile, algorithm, avoidRep);\n\n            count++;\n            double prog = count / ((double) size);\n            this.setProgress((int) (prog * 80));\n        }\n\n        return drawMosaic(matches, new Size(tileWidth, tileHeight), imgMod);\n    }\n\n    \n    private Mat drawMosaic(TileMatch[][] matches, Size tileSize, Mat res) {\n\n        int width = (int) tileSize.width;\n        int height = (int) tileSize.height;\n\n        HashMap<Tile, Mat> loadedTiles = new HashMap<>();\n        for (int i = 0; i < yTiles; i++) {\n            for (int j = 0; j < xTiles; j++) {\n                TileMatch match = matches[i][j];\n\n                if (!loadedTiles.containsKey(match.getTile())) {\n                    loadedTiles.put(match.getTile(), match.getTile().loadImage(tileSize));\n                }\n\n                Mat tile = loadedTiles.get(match.getTile());\n                int rowPos = i * height;\n                int colPos = j * width;\n                Mat origTile = res.rowRange(rowPos, rowPos + height).colRange(colPos, colPos + width);\n\n                if (blend == Blend.COLOR) {\n                    Mat adjusted = ImageUtils.adjustImageToColor(tile, match.getOrigColor(), blendAmount);\n                    adjusted.copyTo(res.rowRange(rowPos, rowPos + height).colRange(colPos, colPos + width));\n                } else if (blend == Blend.ORIGINAL) {\n                    Mat adjusted = ImageUtils.adjustImageToColor(tile, origTile, blendAmount);\n                    adjusted.copyTo(origTile);\n                } else {\n                    tile.copyTo(origTile);\n                }\n            }\n        }\n\n        for (Mat m : loadedTiles.values()) {\n            m.release();\n        }\n\n        this.setProgress(100);\n        return res;\n    }\n\n    private void checkState() {\n        if (xTiles <= 0) {\n            throw new IllegalArgumentException(\"xTiles < 0\");\n        }\n        if (yTiles <= 0) {\n            throw new IllegalArgumentException(\"yTiles < 0\");\n        }\n        if (tileWidth <= 0) {\n            throw new IllegalArgumentException(\"tileWidth < 0\");\n        }\n        if (tileHeight <= 0) {\n            throw new IllegalArgumentException(\"tileHeight < 0\");\n        }\n        if (img == null) {\n            throw new IllegalArgumentException(\"Img is null\");\n        }\n    }\n\n    public Mat getImg() {\n        return img;\n    }\n\n    public void setImg(Mat img) {\n        this.img = img;\n    }\n\n    public int getxTiles() {\n        return xTiles;\n    }\n\n    public void setxTiles(int xTiles) {\n        if (xTiles <= 0) {\n            throw new IllegalArgumentException(\"xTiles <= 0\");\n        }\n        this.xTiles = xTiles;\n    }\n\n    public int getyTiles() {\n        return yTiles;\n    }\n\n    public void setyTiles(int yTiles) {\n        if (yTiles <= 0) {\n            throw new IllegalArgumentException(\"yTiles <= 0\");\n        }\n        this.yTiles = yTiles;\n    }\n\n    public int getTileWidth() {\n        return tileWidth;\n    }\n\n    public void setTileWidth(int tileWidth) {\n        if (tileWidth <= 0) {\n            throw new IllegalArgumentException(\"tileWidth <= 0\");\n        }\n        this.tileWidth = tileWidth;\n    }\n\n    public int getTileHeight() {\n        return tileHeight;\n    }\n\n    public void setTileHeight(int tileHeight) {\n        if (tileHeight <= 0) {\n            throw new IllegalArgumentException(\"tileHeight <= 0\");\n        }\n        this.tileHeight = tileHeight;\n    }\n\n    public Blend getBlend() {\n        return blend;\n    }\n\n    public void setBlend(Blend blendColor) {\n        this.blend = blendColor;\n    }\n\n    public boolean isAvoidRep() {\n        return avoidRep;\n    }\n\n    public void setAvoidRep(boolean avoidRep) {\n        this.avoidRep = avoidRep;\n    }\n\n    public Mat getResult() {\n        return result;\n    }\n\n    public void setResult(Mat result) {\n        this.result = result;\n    }\n\n    public int getBlendAmount() {\n        return blendAmount;\n    }\n\n    public void setBlendAmount(int blendAmount) {\n        this.blendAmount = blendAmount;\n    }\n\n    public void setAlgorithm(SelectAlgorithm a) {\n        algorithm = a;\n    }\n\n    public SelectAlgorithm getAlgorithm() {\n        return algorithm;\n    }\n\n    public int getProgress() {\n        return progress;\n    }\n\n    public void setProgress(int progress) {\n        supp.firePropertyChange(\"progress\", this.progress, progress);\n        this.progress = progress;\n    }\n\n    public void addPropertyChangeListener(PropertyChangeListener l) {\n        supp.addPropertyChangeListener(l);\n    }\n\n    public void removePropertyChangeListener(PropertyChangeListener l) {\n        supp.removePropertyChangeListener(l);\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@SpringBootApplication\n@ClientCacheApplication(name = \"AccessingDataGemFireApplication\", logLevel = \"error\")\n@EnableEntityDefinedRegions(basePackageClasses = Person.class,\n  clientRegionShortcut = ClientRegionShortcut.LOCAL)\n@EnableGemfireRepositories\npublic class Application {\n\n    public static void main(String[] args) throws IOException {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    ApplicationRunner run(PersonRepository personRepository) {\n\n        return args -> {\n\n            Person alice = new Person(\"Adult Alice\", 40);\n            Person bob = new Person(\"Baby Bob\", 1);\n            Person carol = new Person(\"Teen Carol\", 13);\n\n            System.out.println(\"Before accessing data in Pivotal GemFire...\");\n\n            asList(alice, bob, carol).forEach(person -> System.out.println(\"\\t\" + person));\n\n            System.out.println(\"Saving Alice, Bob and Carol to Pivotal GemFire...\");\n\n            personRepository.save(alice);\n            personRepository.save(bob);\n            personRepository.save(carol);\n\n            System.out.println(\"Lookup each person by name...\");\n\n            asList(alice.getName(), bob.getName(), carol.getName())\n              .forEach(name -> System.out.println(\"\\t\" + personRepository.findByName(name)));\n\n            System.out.println(\"Query adults (over 18):\");\n\n            stream(personRepository.findByAgeGreaterThan(18).spliterator(), false)\n              .forEach(person -> System.out.println(\"\\t\" + person));\n\n            System.out.println(\"Query babies (less than 5):\");\n\n            stream(personRepository.findByAgeLessThan(5).spliterator(), false)\n              .forEach(person -> System.out.println(\"\\t\" + person));\n\n            System.out.println(\"Query teens (between 12 and 20):\");\n\n            stream(personRepository.findByAgeGreaterThanAndAgeLessThan(12, 20).spliterator(), false)\n              .forEach(person -> System.out.println(\"\\t\" + person));\n        };\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class FrameTile extends Tile {\n\n    private final int frameNum;\n\n    \n    public FrameTile(File f, Mat frame, int i) {\n        imgFile = f;\n        meanRGB = ImageUtils.getMeanRGB(frame);\n        frameNum = i;\n        icon = ImageUtils.createIcon(frame, new Size(Tile.PREVIEW_WIDTH, Tile.PREVIEW_HEIGHT));\n    }\n\n    public int getFrameNum() {\n        return frameNum;\n    }\n\n    @Override\n    public Mat loadImage(Size s) {\n        VideoCapture c = new VideoCapture(imgFile.getPath());\n\n        if (!c.isOpened()) {\n            return null;\n        }\n\n        c.set(1, frameNum);\n\n        Mat img = new Mat();\n        c.retrieve(img);\n\n        if (s != null) {\n            Mat out = new Mat();\n            Imgproc.resize(img, out, s);\n            img.release();\n            return out;\n        } else {\n            return img;\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 3;\n        hash = 73 * hash + this.frameNum;\n        hash = 73 * hash + Objects.hashCode(this.imgFile);\n        return hash;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final FrameTile other = (FrameTile) obj;\n        if (this.frameNum != other.frameNum) {\n            return false;\n        }\n        if (!Objects.equals(this.imgFile, other.imgFile)) {\n            return false;\n        }\n        return true;\n    }\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n@Component\npublic class Runner implements CommandLineRunner {\n\n    private final RabbitTemplate rabbitTemplate;\n    private final Receiver receiver;\n\n    public Runner(Receiver receiver, RabbitTemplate rabbitTemplate) {\n        this.receiver = receiver;\n        this.rabbitTemplate = rabbitTemplate;\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println(\"Sending message...\");\n        rabbitTemplate.convertAndSend(Application.topicExchangeName, \"foo.bar.baz\", \"Hello from RabbitMQ!\");\n        receiver.getLatch().await(10000, TimeUnit.MILLISECONDS);\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class ObjRecognition extends Application\n{\n\t\n\t@Override\n\tpublic void start(Stage primaryStage)\n\t{\n\t\ttry\n\t\t{\n\t\t\tFXMLLoader loader = new FXMLLoader(getClass().getResource(\"ObjRecognition.fxml\"));\n\t\t\tBorderPane root = (BorderPane) loader.load();\n\t\t\troot.setStyle(\"-fx-background-color: whitesmoke;\");\n\t\t\tScene scene = new Scene(root, 800, 600);\n\t\t\tscene.getStylesheets().add(getClass().getResource(\"application.css\").toExternalForm());\n\t\t\tprimaryStage.setTitle(\"Object Recognition\");\n\t\t\tprimaryStage.setScene(scene);\n\t\t\tprimaryStage.show();\n\t\t\t\n\t\t\tObjRecognitionController controller = loader.getController();\n\t\t\tprimaryStage.setOnCloseRequest((new EventHandler<WindowEvent>() {\n\t\t\t\tpublic void handle(WindowEvent we)\n\t\t\t\t{\n\t\t\t\t\tcontroller.setClosed();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tSystem.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\t\t\n\t\tlaunch(args);\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\npublic class ProjectiveColorTransformer extends ProjectiveTransformer {\n    public ProjectiveColorTransformer(CvMat K1, CvMat K2, CvMat R, CvMat t,\n            CvMat n, double[] referencePoints1, double[] referencePoints2,\n            CvMat X, int numGains, int numBiases) {\n        super(K1, K2, R, t, n, referencePoints1, referencePoints2);\n\n        this.X = X == null ? null : X.clone();\n\n        this.numGains = numGains;\n        this.numBiases = numBiases;\n    }\n\n    protected static ThreadLocal<CvMat>\n            X24x4   = CvMat.createThreadLocal(4, 4),\n            temp3x1 = CvMat.createThreadLocal(3, 1);\n\n    protected CvMat X = null;\n    protected int numGains = 0, numBiases = 0;\n\n    protected CvMat[] X2 = null;\n\n    public CvMat getX() {\n        return X;\n    }\n    public int getNumGains() {\n        return numGains;\n    }\n    public int getNumBiases() {\n        return numBiases;\n    }\n\n    public void transformColor(IplImage srcImage, IplImage dstImage, CvRect roi,\n            int pyramidLevel, ImageTransformer.Parameters parameters, boolean inverse) {\n        Parameters p = ((Parameters)parameters);\n\n        if ((Arrays.equals(p.getColorParameters(), p.getIdentityColorParameters()) &&\n                (X == null || p.fakeIdentity)) || (X == null && numGains == 0 && numBiases == 0)) {\n            if (srcImage != dstImage) {\n                cvCopy(srcImage, dstImage);\n            }\n            return;\n        }\n\n        CvMat X2 = X24x4.get();\n        prepareColorTransform(X2, pyramidLevel, p, inverse);\n        X2.rows(3);\n        if (roi == null) {\n            cvResetImageROI(dstImage);\n        } else {\n            cvSetImageROI(dstImage, roi);\n        }\n        X2.put(0, 3, X2.get(0, 3)*dstImage.highValue());\n        X2.put(1, 3, X2.get(1, 3)*dstImage.highValue());\n        X2.put(2, 3, X2.get(2, 3)*dstImage.highValue());\n        cvTransform(srcImage, dstImage, X2, null);\n        X2.rows(4);\n    }\n\n    protected void prepareColorTransform(CvMat X2, int pyramidLevel, Parameters p, boolean inverse) {\n        CvMat A = p.getA(), b = p.getB();\n\n        cvSetIdentity(X2);\n\n        X2.rows(3); X2.cols(3);\n        if (p.fakeIdentity && !inverse) {\n            X2.put(A);\n        } else if (A != null && X != null) {\n            cvMatMul(X, A, X2);\n        } else if (X == null) {\n            X2.put(A);\n        } else if (A == null) {\n            X2.put(X);\n        }\n\n        X2.rows(4); X2.cols(4);\n        if (b != null) {\n            X2.put(0, 3, b.get(0));\n            X2.put(1, 3, b.get(1));\n            X2.put(2, 3, b.get(2));\n        }\n\n        if (inverse) {\n            cvInvert(X2, X2, CV_SVD);\n        }\n    }\n\n    @Override public void transform(Data[] data, CvRect roi, ImageTransformer.Parameters[] parameters, boolean[] inverses) {\n        assert data.length == parameters.length;\n        if (kernelData == null || kernelData.capacity() < data.length) {\n            kernelData = new KernelData(data.length);\n        }\n        if (H == null || H.length < data.length) {\n            H = new CvMat[data.length];\n            for (int i = 0; i < H.length; i++) {\n                H[i] = CvMat.create(3, 3);\n            }\n        }\n        if (X2 == null || X2.length < data.length) {\n            X2 = new CvMat[data.length];\n            for (int i = 0; i < X2.length; i++) {\n                X2[i] = CvMat.create(4, 4);\n            }\n        }\n\n        for (int i = 0; i < data.length; i++) {\n            kernelData.position(i);\n\n            kernelData.srcImg(data[i].srcImg);\n            kernelData.srcImg2(null);\n            kernelData.subImg(data[i].subImg);\n            kernelData.srcDotImg(data[i].srcDotImg);\n            kernelData.mask(data[i].mask);\n            kernelData.zeroThreshold(data[i].zeroThreshold);\n            kernelData.outlierThreshold(data[i].outlierThreshold);\n\n            boolean inverse = inverses == null ? false : inverses[i];\n            prepareHomography    (H[i], data[i].pyramidLevel, (Parameters)parameters[i], inverse);\n            prepareColorTransform(X2[i], data[i].pyramidLevel, (Parameters)parameters[i], inverse);\n\n            kernelData.H1(H[i]);\n            kernelData.H2(null);\n            kernelData.X(X2[i]);\n\n            kernelData.transImg(data[i].transImg);\n            kernelData.dstImg(data[i].dstImg);\n            kernelData.dstDstDot(data[i].dstDstDot);\n        }\n\n        long fullCapacity = kernelData.capacity();\n        kernelData.capacity(data.length);\n        multiWarpColorTransform(kernelData, roi, getFillColor());\n        kernelData.capacity(fullCapacity);\n\n        for (int i = 0; i < data.length; i++) {\n            kernelData.position(i);\n            data[i].dstCount        = kernelData.dstCount();\n            data[i].dstCountZero    = kernelData.dstCountZero();\n            data[i].dstCountOutlier = kernelData.dstCountOutlier();\n            data[i].srcDstDot       = kernelData.srcDstDot();\n        }\n    }\n\n    @Override public Parameters createParameters() {\n        return new Parameters();\n    }\n\n    public class Parameters extends ProjectiveTransformer.Parameters {\n        protected Parameters() {\n            identityColorParameters = new double[numGains + numBiases];\n            if (numGains > 0) {\n                A = CvMat.create(3, 3);\n                cvSetIdentity(A);\n            }\n            if (numBiases > 0) {\n                b = CvMat.create(3, 1);\n                cvSetZero(b);\n            }\n\n            switch (numGains) {\n                case 0: assert (A == null); break;\n                case 1: identityColorParameters[0] =\n                            (A.get(0) + A.get(4) + A.get(8))/3; break;\n                case 3: identityColorParameters[0] = A.get(0);\n                        identityColorParameters[1] = A.get(4);\n                        identityColorParameters[2] = A.get(8); break;\n                case 9: A.get(0, identityColorParameters, 0, 9); break;\n                default: assert (false);\n            }\n            switch (numBiases) {\n                case 0: assert (b == null); break;\n                case 1: identityColorParameters[numGains] =\n                            (b.get(0) + b.get(1) + b.get(2))/3;   break;\n                case 3: b.get(0, identityColorParameters, numGains, 3); break;\n                default: assert (false);\n            }\n\n            reset(false);\n        }\n\n        protected double[] colorParameters = null, identityColorParameters = null;\n        private CvMat A = null, b = null;\n\n        public double[] getColorParameters() {\n            return colorParameters;\n        }\n        public double[] getIdentityColorParameters() {\n            return identityColorParameters;\n        }\n\n        @Override public int size() {\n            return super.size() + numGains + numBiases;\n        }\n        @Override public double get(int i) {\n            int s = super.size();\n            if (i < s) {\n                return super.get(i);\n            } else {\n                return colorParameters[i-s];\n            }\n        }\n        @Override public void set(int i, double p) {\n            int s = super.size();\n            if (i < s) {\n                super.set(i, p);\n            } else {\n                if (colorParameters[i-s] != p) {\n                    colorParameters[i-s] = p;\n                    setUpdateNeeded(true);\n                }\n            }\n        }\n        @Override public void reset(boolean asIdentity) {\n            super.reset(asIdentity);\n            resetColor(asIdentity);\n        }\n        public void resetColor(boolean asIdentity) {\n            if (identityColorParameters != null) {\n                if (!Arrays.equals(colorParameters, identityColorParameters) ||\n                        fakeIdentity != asIdentity) {\n                    fakeIdentity = asIdentity;\n                    colorParameters = identityColorParameters.clone();\n                    setUpdateNeeded(true);\n                }\n            }\n        }\n        @Override public void compose(ImageTransformer.Parameters p1, boolean inverse1,\n                ImageTransformer.Parameters p2, boolean inverse2) {\n            super.compose(p1, inverse1, p2, inverse2);\n            composeColor(p1, inverse1, p2, inverse2);\n        }\n        public void composeColor(ImageTransformer.Parameters p1, boolean inverse1,\n                ImageTransformer.Parameters p2, boolean inverse2) {\n            assert (!inverse1 && !inverse2);\n\n            Parameters pp1 = (Parameters)p1, pp2 = (Parameters)p2;\n            CvMat A1 = pp1.getA(), b1 = pp1.getB();\n            CvMat A2 = pp2.getA(), b2 = pp2.getB();\n\n            if (b != null) {\n                if (pp1.fakeIdentity && X != null) {\n                    CvMat temp = temp3x1.get();\n                    cvMatMul(X, b1, temp);\n                    b1 = temp;\n                }\n\n                if (A2 == null && b2 == null) {\n                    cvCopy(b1, b);\n                } else if (b1 == null) {\n                    cvCopy(b2, b);\n                } else if (b2 == null) {\n                    cvMatMul(A2, b1, b);\n                } else {\n                    cvGEMM(A2, b1, 1.0,  b2, 1.0,  b, 0);\n                }\n            }\n\n            if (A != null) {\n                if (A1 == null) {\n                    cvCopy(A2, A);\n                } else if (A2 == null) {\n                    cvCopy(A1, A);\n                } else {\n                    cvMatMul(A2, A1, A);\n                }\n            }\n\n            switch (numGains) {\n                case 0: assert (A == null); break;\n                case 1: colorParameters[0] =\n                            (A.get(0) + A.get(4) + A.get(8))/3; break;\n                case 3: colorParameters[0] = A.get(0);\n                        colorParameters[1] = A.get(4);\n                        colorParameters[2] = A.get(8); break;\n                case 9: A.get(0, colorParameters, 0, 9); break;\n                default: assert (false);\n            }\n            switch (numBiases) {\n                case 0: assert (b == null); break;\n                case 1: colorParameters[numGains] =\n                            (b.get(0) + b.get(1) + b.get(2))/3;   break;\n                case 3: b.get(0, colorParameters, numGains, 3); break;\n                default: assert (false);\n            }\n        }\n\n        public CvMat getA() {\n            update();\n            return A;\n        }\n        public CvMat getB() {\n            update();\n            return b;\n        }\n\n        @Override protected void update() {\n            if (!isUpdateNeeded()) {\n                return;\n            }\n\n            switch (numGains) {\n                case 0: assert (A == null); break;\n                case 1: A.put(0, colorParameters[0]);\n                        A.put(4, colorParameters[0]);\n                        A.put(8, colorParameters[0]); break;\n                case 3: A.put(0, colorParameters[0]);\n                        A.put(4, colorParameters[1]);\n                        A.put(8, colorParameters[2]); break;\n                case 9: A.put(0, colorParameters, 0, 9); break;\n                default: assert (false);\n            }\n            switch (numBiases) {\n                case 0: assert (b == null); break;\n                case 1: b.put(0, colorParameters[numGains]);\n                        b.put(1, colorParameters[numGains]);\n                        b.put(2, colorParameters[numGains]);    break;\n                case 3: b.put(0, colorParameters, numGains, 3); break;\n                default: assert (false);\n            }\n\n            super.update();\n            setUpdateNeeded(false);\n        }\n\n        @Override public Parameters clone() {\n            Parameters p = new Parameters();\n            p.set(this);\n            return p;\n        }\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n@ConfigurationProperties(\"example\")\npublic class MyConfiguration {\n\n    private String username;\n\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@SpringBootApplication\n@EnableAsync\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args).close();\n    }\n\n    @Bean\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(2);\n        executor.setMaxPoolSize(2);\n        executor.setQueueCapacity(500);\n        executor.setThreadNamePrefix(\"GithubLookup-\");\n        executor.initialize();\n        return executor;\n    }\n\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class SobelTest {\n   public static void main(String args[]) {\n      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n      String file =\"E:/OpenCV/chap16/sobel_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Imgproc.Sobel(src, dst, -1, 1, 1);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap16/sobel_output.jpg\", dst);\n\n      System.out.println(\"Image processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class Quote {\n\n    private String type;\n    private Value value;\n\n    public Quote() {\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public Value getValue() {\n        return value;\n    }\n\n    public void setValue(Value value) {\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return \"Quote{\" +\n                \"type='\" + type + '\\'' +\n                \", value=\" + value +\n                '}';\n    }\n}\n\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class Value {\n\n    private Long id;\n    private String quote;\n\n    public Value() {\n    }\n\n    public Long getId() {\n        return this.id;\n    }\n\n    public String getQuote() {\n        return this.quote;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public void setQuote(String quote) {\n        this.quote = quote;\n    }\n\n    @Override\n    public String toString() {\n        return \"Value{\" +\n                \"id=\" + id +\n                \", quote='\" + quote + '\\'' +\n                '}';\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@SpringBootApplication\n@EnableConfigurationProperties(UriConfiguration.class)\n@RestController\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public RouteLocator myRoutes(RouteLocatorBuilder builder, UriConfiguration uriConfiguration) {\n        String httpUri = uriConfiguration.getHttpbin();\n        return builder.routes()\n            .route(p -> p\n                .path(\"/get\")\n                .filters(f -> f.addRequestHeader(\"Hello\", \"World\"))\n                .uri(httpUri))\n            .route(p -> p\n                .host(\"*.hystrix.com\")\n                .filters(f -> f\n                    .hystrix(config -> config\n                        .setName(\"mycmd\")\n                        .setFallbackUri(\"forward:/fallback\")))\n                .uri(httpUri))\n            .build();\n    }\n\n    @RequestMapping(\"/fallback\")\n    public Mono<String> fallback() {\n        return Mono.just(\"fallback\");\n    }\n}\n\n@ConfigurationProperties\nclass UriConfiguration {\n    \n    private String httpbin = \"http://httpbin.org:80\";\n\n    public String getHttpbin() {\n        return httpbin;\n    }\n\n    public void setHttpbin(String httpbin) {\n        this.httpbin = httpbin;\n    }\n}", "nl": "spring"}
{"code": "\n\n\npublic class ColorSaturationEffect extends Effect{\n\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat();\n\t\tImgproc.cvtColor(frame, newFrame, Imgproc.COLOR_RGBA2RGB);\n\t\tImgproc.cvtColor(newFrame, newFrame, Imgproc.COLOR_RGB2HSV);\n\t\t\n\t\tbyte[] buff = new byte[(int) (newFrame.total()*newFrame.channels())];\n\t\tnewFrame.get(0, 0, buff);\n\t\t\n\t\tfor(int i = 0; i < newFrame.total()*newFrame.channels(); i += 3) {\n\t\t\tbuff[i] = 90;\n\t\t}\n\t\t\n\t\tnewFrame.put(0, 0, buff);\n\t\tImgproc.cvtColor(newFrame, newFrame, Imgproc.COLOR_HSV2RGB);\n\t\tImgproc.cvtColor(frame, newFrame, Imgproc.COLOR_RGB2RGBA);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Color Saturation\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n@Repository\npublic class CustomerDaoImpl implements CustomerDao {\n\n\t@Autowired\n\tprivate SessionFactory sessionFactory;\n\n\tpublic SessionFactory getSessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tpublic void setSessionFactory(SessionFactory sessionFactory) {\n\t\tthis.sessionFactory = sessionFactory;\n\t}\n\n\tpublic void addCustomer(Customer customer) {\n\t\tSystem.out.println(\"Adding customer in dao\");\n\t\tSession session = sessionFactory.openSession();\n\t\tcustomer.getUsers().setEnabled(true);\n\t\t\n\t\tAuthorities authorities = new Authorities();\n\t\tauthorities.setAuthorities(\"ROLE_USER\");\n\t\tauthorities.setEmailId(customer.getUsers().getEmailId());\n\t\t\n\t\tCart cart = new Cart();\n\t\tcustomer.setCart(cart);//set the cart to the customer\n\t\tcart.setCustomer(customer);\n\t\tsession.save(customer);\n\t\tsession.save(authorities);\n\t\tsession.flush();\n\t\tsession.close();\n\t}\n\n\tpublic List<Customer> getAllCustomers() {\n\t\tSession session = sessionFactory.openSession();\n\t\tList<Customer> customerList = session.createQuery(\"from Customer\").list();\n\t\t\n\t\treturn customerList;\n\t}\n\n\tpublic Customer getCustomerByemailId(String emailId) {\n\t\tSession session = sessionFactory.openSession();\n\t\tQuery query = session.createQuery(\"from User where emailId=?\");\n\t\tquery.setString(0, emailId);\n\t\tUser users = (User)query.uniqueResult();\n\t\tCustomer customer = users.getCustomer();\n\t\treturn customer;\n\t}\n\t\n\t\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\npublic class SaveImage { \n\t\n\tpublic static void main(String[] args) {\n\n\n    System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\t\n\n    Mat inputImg = Highgui.imread(\"files/lena.jpg\");\n    \n    \n    Mat outputImg = new Mat();\n    \n    \n    Core.bitwise_not(inputImg, outputImg);\n       \n\n    MatOfInt params = new MatOfInt();\n    params.fromArray(new int []{Highgui.CV_IMWRITE_JPEG_QUALITY, 75, 0 });\n    \n    System.out.println( \"Saving image to file ....\" );\n    \n    Highgui.imwrite(\"files/lena_inverted.jpg\", outputImg, params);\n    \n    }\n}\n\n", "nl": "opencv"}
{"code": "\n\n\n\n\n@SpringBootApplication\n@EnableNeo4jRepositories\npublic class Application {\n\n\tprivate final static Logger log = LoggerFactory.getLogger(Application.class);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n\t@Bean\n\tCommandLineRunner demo(PersonRepository personRepository) {\n\t\treturn args -> {\n\n\t\t\tpersonRepository.deleteAll();\n\n\t\t\tPerson greg = new Person(\"Greg\");\n\t\t\tPerson roy = new Person(\"Roy\");\n\t\t\tPerson craig = new Person(\"Craig\");\n\n\t\t\tList<Person> team = Arrays.asList(greg, roy, craig);\n\n\t\t\tlog.info(\"Before linking up with Neo4j...\");\n\n\t\t\tteam.stream().forEach(person -> log.info(\"\\t\" + person.toString()));\n\n\t\t\tpersonRepository.save(greg);\n\t\t\tpersonRepository.save(roy);\n\t\t\tpersonRepository.save(craig);\n\n\t\t\tgreg = personRepository.findByName(greg.getName());\n\t\t\tgreg.worksWith(roy);\n\t\t\tgreg.worksWith(craig);\n\t\t\tpersonRepository.save(greg);\n\n\t\t\troy = personRepository.findByName(roy.getName());\n\t\t\troy.worksWith(craig);\n\t\t\tpersonRepository.save(roy);\n\n\n\t\t\tlog.info(\"Lookup each person by name...\");\n\t\t\tteam.stream().forEach(person -> log.info(\n\t\t\t\t\t\"\\t\" + personRepository.findByName(person.getName()).toString()));\n\t\t};\n  }\n  \n  @Bean\n  public WebMvcConfigurer corsConfigurer() {\n      return new WebMvcConfigurer() {\n          @Override\n          public void addCorsMappings(CorsRegistry registry) {\n              registry.addMapping(\"/greeting-javaconfig\").allowedOrigins(\"http://localhost:9000\");\n          }\n      };\n  }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class FeatureWeight {\n\n\tpublic static Mat Saliency(Mat img) {\n\t\tMat gfbgr = new Mat();\n\t\tImgproc.GaussianBlur(img, gfbgr, new Size(3, 3), 3);\n\t\tMat LabIm = new Mat();\n\t\tImgproc.cvtColor(gfbgr, LabIm, Imgproc.COLOR_BGR2Lab);\n\t\tList<Mat> lab = new ArrayList<>();\n\t\tCore.split(LabIm, lab);\n\t\tMat l = lab.get(0);\n\t\tl.convertTo(l, CvType.CV_32F);\n\t\tMat a = lab.get(1);\n\t\ta.convertTo(a, CvType.CV_32F);\n\t\tMat b = lab.get(2);\n\t\tb.convertTo(b, CvType.CV_32F);\n\t\tdouble lm = Core.mean(l).val[0];\n\t\tdouble am = Core.mean(a).val[0];\n\t\tdouble bm = Core.mean(b).val[0];\n\t\tMat sm = Mat.zeros(l.rows(), l.cols(), l.type());\n\t\tCore.subtract(l, new Scalar(lm), l);\n\t\tCore.subtract(a, new Scalar(am), a);\n\t\tCore.subtract(b, new Scalar(bm), b);\n\t\tCore.add(sm, l.mul(l), sm);\n\t\tCore.add(sm, a.mul(a), sm);\n\t\tCore.add(sm, b.mul(b), sm);\n\t\treturn sm;\n\t}\n\n\tpublic static Mat LaplacianContrast(Mat img) {\n\t\tMat laplacian = new Mat();\n\t\tImgproc.Laplacian(img, laplacian, img.depth());\n\t\tCore.convertScaleAbs(laplacian, laplacian);\n\t\treturn laplacian;\n\t}\n\n\tpublic static Mat LocalContrast(Mat img) {\n\t\tdouble[] h = { 1.0 / 16.0, 4.0 / 16.0, 6.0 / 16.0, 4.0 / 16.0, 1.0 / 16.0 };\n\t\tMat mask = new Mat(h.length, h.length, img.type());\n\t\tfor (int i = 0; i < h.length; i++) {\n\t\t\tfor (int j = 0; j < h.length; j++) {\n\t\t\t\tmask.put(i, j, h[i] * h[j]);\n\t\t\t}\n\t\t}\n\t\tMat localContrast = new Mat();\n\t\tImgproc.filter2D(img, localContrast, img.depth(), mask);\n\t\tfor (int i = 0; i < localContrast.rows(); i++) {\n\t\t\tfor (int j = 0; j < localContrast.cols(); j++) {\n\t\t\t\tif (localContrast.get(i, j)[0] > Math.PI / 2.75) localContrast.put(i, j, Math.PI / 2.75);\n\t\t\t}\n\t\t}\n\t\tCore.subtract(img, localContrast, localContrast);\n\t\treturn localContrast.mul(localContrast);\n\t}\n\n\tpublic static Mat Exposedness(Mat img) {\n\t\tdouble sigma = 0.25;\n\t\tdouble average = 0.5;\n\t\tint rows = img.rows();\n\t\tint cols = img.cols();\n\t\tMat exposedness = Mat.zeros(rows, cols, img.type());\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tdouble value = Math.exp(-1.0 * Math.pow(img.get(i, j)[0] - average, 2.0) / (2 * Math.pow(sigma, 2.0)));\n\t\t\t\texposedness.put(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn exposedness;\n\t}\n\t\n\tpublic static Mat LuminanceWeight(Mat img, Mat L) {\n\t\tMat bCnl = new Mat();\n\t\tCore.extractChannel(img, bCnl, 0);\n\t\tbCnl.convertTo(bCnl, CvType.CV_32F);\n\t\tMat gCnl = new Mat();\n\t\tCore.extractChannel(img, gCnl, 1);\n\t\tgCnl.convertTo(gCnl, CvType.CV_32F);\n\t\tMat rCnl = new Mat();\n\t\tCore.extractChannel(img, rCnl, 2);\n\t\trCnl.convertTo(rCnl, CvType.CV_32F);\n\t\tMat lum = new Mat(L.rows(), L.cols(), L.type());\n\t\tfor (int i = 0; i < L.rows(); i++) {\n\t\t\tfor (int j = 0; j < L.cols(); j++) {\n\t\t\t\tdouble data = Math.sqrt( ( Math.pow(bCnl.get(i, j)[0] / 255.0 - L.get(i, j)[0], 2.0) +\n\t\t\t\t\t\tMath.pow(gCnl.get(i, j)[0] / 255.0 - L.get(i, j)[0], 2.0) +\n\t\t\t\t\t\tMath.pow(rCnl.get(i, j)[0] / 255.0 - L.get(i, j)[0], 2.0) ) / 3 );\n\t\t\t\tlum.put(i, j, data);\n\t\t\t}\n\t\t}\n\t\treturn lum;\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\nclass UserFaceAligner {\n    private enum landmark_pos {\n        FACE_CENTER(0),\n        LEFT_EYE_INNER(1),\n        RIGHT_EYE_INNER(2),\n        MOUTH_LEFT(3),\n        MOUTH_RIGHT(4),\n        LEFT_EYE_OUTER(5),\n        RIGHT_EYE_OUTER(6),\n        NOSE_CENTER(7),\n        LEFT_EYE_ALIGN(8),\n        RIGHT_EYE_ALIGN(9);\n\n        public int pos;\n\n        landmark_pos(int pos) {\n            this.pos = pos;\n        }\n    }\n\n    private static final String LOADER_URL = \"save_session/flandmark_model.dat\";\n\n    private static UserFaceAligner userFaceAligner;\n    private final FLANDMARK_Model flandmarkModel;\n\n\n    private UserFaceAligner() {\n        URL loaderUrl = getClass().getClassLoader().getResource(LOADER_URL);\n        if (loaderUrl == null) throw new IllegalStateException(\"Landmark model not found.\");\n\n        flandmarkModel = flandmark_init(loaderUrl.getPath());\n    }\n\n\n    \n    public MatFace align(Mat image, Rect bounds) {\n        List<Point2d> landmarks = getEyesLandmarks(image, bounds);\n\n        if (landmarks == null) {\n            System.out.println(\"No landmarks\");\n            return null;\n        }\n\n        addAlignedEyesPos(landmarks);\n        Mat rotatedFace = rotateImageAndExtractFace(image, landmarks,\n                UserFaceDetector.INITIAL_WIDTH, UserFaceDetector.INITIAL_HEIGHT);\n        int faceType = findFaceType(landmarks);\n\n        return new MatFace(rotatedFace, faceType);\n    }\n\n\n    \n    public Point2d[] getEyesCenterCoordinates(Mat image, Rect bounds) {\n        List<Point2d> landmarks = getEyesLandmarks(image, bounds);\n\n        if (landmarks == null) {\n            return null;\n        }\n\n        Point2d leftEyeOuter = landmarks.get(landmark_pos.LEFT_EYE_OUTER.pos);\n        Point2d leftEyeInner = landmarks.get(landmark_pos.LEFT_EYE_INNER.pos);\n\n        Point2d rightEyeOuter = landmarks.get(landmark_pos.RIGHT_EYE_OUTER.pos);\n        Point2d rightEyeInner = landmarks.get(landmark_pos.RIGHT_EYE_INNER.pos);\n\n        return new Point2d[] { center(leftEyeOuter, leftEyeInner), center(rightEyeOuter, rightEyeInner) };\n    }\n\n\n    private int findFaceType(List<Point2d> landmarks) {\n        int type;\n\n        final double center = landmarks.get(landmark_pos.NOSE_CENTER.pos).x();\n        final double left_eye = landmarks.get(landmark_pos.LEFT_EYE_INNER.pos).x();\n        final double right_eye = landmarks.get(landmark_pos.RIGHT_EYE_INNER.pos).x();\n\n        System.out.println(center + \" \" + left_eye + \" \" + right_eye);\n        double left_center = Math.abs(left_eye - center);\n        double right_center = Math.abs(center - right_eye);\n\n        right_center = right_center == 0 ? 1e-3 : right_center;\n        left_center = left_center == 0 ? 1e-3 : left_center;\n\n\n        if (landmarks.size() <= 8) {\n            throw new IllegalStateException(\"Not enough landmarks\");\n        }\n\n        System.out.println(\"landmarks = \" + landmarks.size());\n        System.out.println(\"right = \" + right_center / left_center);\n        System.out.println(\"left = \" + left_center / right_center);\n        final double scale_threshold = 2.2;\n        if (right_center / left_center >= scale_threshold) {\n            type = FaceFeatures.RIGHT_FACE;\n        } else if ( left_center / right_center >= scale_threshold) {\n            type = FaceFeatures.LEFT_FACE;\n        } else {\n            type = FaceFeatures.CENTER_FACE;\n        }\n\n        System.out.println(\"Found face type = \" + type);\n\n        return type;\n    }\n\n\n    private Point2d center(Point2d left, Point2d right) {\n        return new Point2d(\n                (left.x() + right.x()) * 0.5,\n                (left.y() + right.y()) * 0.5\n        );\n    }\n\n\n    private List<Point2d> getEyesLandmarks(Mat image, Rect bounds) {\n        int[] sizes = new int[]{ bounds.x(), bounds.y(),\n                bounds.x() + bounds.width(), bounds.y() + bounds.height() };\n\n        final double[] landmarksCoord = new double[2 * flandmarkModel.data().options().M()];\n\n        flandmark_detect(new IplImage(image), sizes, flandmarkModel, landmarksCoord);\n\n        boolean found = false;\n        for(int i = 0; i < landmarksCoord.length; i++) {\n            if (landmarksCoord[i] != 0.0) {\n                found = true;\n            }\n        }\n\n        if (!found) {\n            return null;\n        }\n\n        List<Point2d> landmarks = new ArrayList<>(5);\n\n        for (int i = 0; i < this.flandmarkModel.data().options().M(); i++) {\n            landmarks.add(new Point2d(landmarksCoord[2 * i], landmarksCoord[2 * i + 1]));\n        }\n\n        return landmarks;\n    }\n\n\n    private void addAlignedEyesPos(List<Point2d> landmarks) {\n        SimpleRegression linearRegression = new SimpleRegression();\n\n        linearRegression.addData(\n                landmarks.get(landmark_pos.LEFT_EYE_OUTER.pos).x(),\n                landmarks.get(landmark_pos.LEFT_EYE_OUTER.pos).y()\n        );\n\n        linearRegression.addData(\n                landmarks.get(landmark_pos.LEFT_EYE_INNER.pos).x(),\n                landmarks.get(landmark_pos.LEFT_EYE_INNER.pos).y()\n        );\n\n        linearRegression.addData(\n                landmarks.get(landmark_pos.RIGHT_EYE_INNER.pos).x(),\n                landmarks.get(landmark_pos.RIGHT_EYE_INNER.pos).y()\n        );\n\n        linearRegression.addData(\n                landmarks.get(landmark_pos.RIGHT_EYE_OUTER.pos).x(),\n                landmarks.get(landmark_pos.RIGHT_EYE_OUTER.pos).y()\n        );\n\n        Point2d alignedLeftEyePos = new Point2d(\n                landmarks.get(landmark_pos.LEFT_EYE_OUTER.pos).x(),\n                linearRegression.predict(landmarks.get(landmark_pos.LEFT_EYE_OUTER.pos).x())\n        );\n\n        Point2d alignedRightEyePos = new Point2d(\n                landmarks.get(landmark_pos.RIGHT_EYE_OUTER.pos).x(),\n                linearRegression.predict(landmarks.get(landmark_pos.RIGHT_EYE_OUTER.pos).x())\n        );\n\n        landmarks.add(alignedLeftEyePos);\n        landmarks.add(alignedRightEyePos);\n    }\n\n\n    private Mat rotateImageAndExtractFace(Mat image, List<Point2d> landmarks,  int faceWidth, int faceHeight) {\n        final double DESIRED_LEFT_EYE_X = 0.27;\n        final double DESIRED_LEFT_EYE_Y = 0.4;\n\n        Point2d leftEye = landmarks.get(landmark_pos.LEFT_EYE_ALIGN.pos);\n        Point2d rightEye = landmarks.get(landmark_pos.RIGHT_EYE_ALIGN.pos);\n\n        Point2f eyesCenter = new Point2f(\n                (float)((leftEye.x() + rightEye.x()) * 0.5f),\n                (float)((leftEye.y() + rightEye.y()) * 0.5f)\n        );\n\n        final double dy = (rightEye.y() - leftEye.y());\n        final double dx = (rightEye.x() - leftEye.x());\n        final double len = Math.sqrt(dx * dx + dy * dy);\n        final double angle = Math.atan2(dy, dx) * 180.0 / CV_PI;\n\n        final double DESIRED_RIGHT_EYE_X = 1 - DESIRED_LEFT_EYE_X;\n        final double desiredLen = (DESIRED_RIGHT_EYE_X - DESIRED_LEFT_EYE_X) * faceWidth;\n        double scale = desiredLen / len;\n\n        Mat rotMat = getRotationMatrix2D(eyesCenter, angle, scale);\n        DoubleRawIndexer indexer = rotMat.createIndexer();\n        indexer.put(0, 2, indexer.get(0, 2) + (faceWidth * 0.5 - eyesCenter.x()));\n        indexer.put(1, 2, indexer.get(1, 2) + (faceHeight * DESIRED_LEFT_EYE_Y - eyesCenter.y()));\n\n        Mat destImage = new Mat(faceHeight, faceWidth, CV_8U, new Scalar(128));\n        warpAffine(image, destImage, rotMat, destImage.size());\n\n        return destImage;\n    }\n\n\n    public static UserFaceAligner create() {\n        if (userFaceAligner == null) {\n            userFaceAligner = new UserFaceAligner();\n        }\n\n        return userFaceAligner;\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic final class Utils\n{\n\t\n\tpublic static Image mat2Image(Mat frame)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn SwingFXUtils.toFXImage(matToBufferedImage(frame), null);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.err.println(\"Cannot convert the Mat obejct: \" + e);\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t\n\tpublic static <T> void onFXThread(final ObjectProperty<T> property, final T value)\n\t{\n\t\tPlatform.runLater(() -> {\n\t\t\tproperty.set(value);\n\t\t});\n\t}\n\t\n\t\n\tprivate static BufferedImage matToBufferedImage(Mat original)\n\t{\n\t\tBufferedImage image = null;\n\t\tint width = original.width(), height = original.height(), channels = original.channels();\n\t\tbyte[] sourcePixels = new byte[width * height * channels];\n\t\toriginal.get(0, 0, sourcePixels);\n\t\t\n\t\tif (original.channels() > 1)\n\t\t{\n\t\t\timage = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);\n\t\t}\n\t\telse\n\t\t{\n\t\t\timage = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);\n\t\t}\n\t\tfinal byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n\t\tSystem.arraycopy(sourcePixels, 0, targetPixels, 0, sourcePixels.length);\n\t\t\n\t\treturn image;\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\nclass DiscreteFourierTransformRun{\n\n    public void run(){\n\n        Mat I = Imgcodecs.imread(\"../data/lena.jpg\", Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);\n\n        Mat padded = new Mat();                     //expand input image to optimal size\n        int m = Core.getOptimalDFTSize( I.rows() );\n        int n = Core.getOptimalDFTSize( I.cols() ); // on the border add zero values\n        Core.copyMakeBorder(I, padded, 0, m - I.rows(), 0, n - I.cols(), Core.BORDER_CONSTANT, Scalar.all(0));\n\n        List<Mat> planes = new ArrayList<Mat>();\n        padded.convertTo(padded, CvType.CV_32F);\n        planes.add(padded);\n        planes.add(Mat.zeros(padded.size(), CvType.CV_32F));\n        Mat complexI = new Mat();\n        Core.merge(planes, complexI);         // Add to the expanded another plane with zeros\n\n        Core.dft(complexI, complexI);         // this way the result may fit in the source matrix\n\n        Core.split(complexI, planes);                   // planes.get(0) = Re(DFT(I), planes.get(1) = Im(DFT(I))\n\n        Core.magnitude(planes.get(0), planes.get(1), planes.get(0));// planes.get(0) = magnitude\n        Mat magI = planes.get(0);\n\n        Mat matOfOnes = Mat.ones(magI.size(), magI.type());\n        Core.add(matOfOnes, magI, magI);         // switch to logarithmic scale\n        Core.log(magI, magI);\n\n        magI = magI.submat(new Rect(0, 0, magI.cols() & -2, magI.rows() & -2));\n\n        int cx = magI.cols()/2;\n        int cy = magI.rows()/2;\n\n        Mat q0 = new Mat(magI, new Rect(0, 0, cx, cy));   // Top-Left - Create a ROI per quadrant\n        Mat q1 = new Mat(magI, new Rect(cx, 0, cx, cy));  // Top-Right\n        Mat q2 = new Mat(magI, new Rect(0, cy, cx, cy));  // Bottom-Left\n        Mat q3 = new Mat(magI, new Rect(cx, cy, cx, cy)); // Bottom-Right\n\n        Mat tmp = new Mat();               // swap quadrants (Top-Left with Bottom-Right)\n        q0.copyTo(tmp);\n        q3.copyTo(q0);\n        tmp.copyTo(q3);\n\n        q1.copyTo(tmp);                    // swap quadrant (Top-Right with Bottom-Left)\n        q2.copyTo(q1);\n        tmp.copyTo(q2);\n\n        magI.convertTo(magI, CvType.CV_8UC1);\n        Core.normalize(magI, magI, 0, 255, Core.NORM_MINMAX, CvType.CV_8UC1);\n\n        Image img = toBufferedImage( I );\n        displayImage(\"Input Image\" , img, 0, 200 );\n        Image img2 = toBufferedImage( magI );\n        displayImage(\"spectrum magnitude\", img2, 400, 400 );\n\n    }\n\n    public Image toBufferedImage(Mat m) {\n        int type = BufferedImage.TYPE_BYTE_GRAY;\n        if ( m.channels() > 1 ) {\n            type = BufferedImage.TYPE_3BYTE_BGR;\n        }\n        int bufferSize = m.channels()*m.cols()*m.rows();\n        byte [] b = new byte[bufferSize];\n        m.get(0,0,b); // get all the pixels\n        BufferedImage image = new BufferedImage(m.cols(),m.rows(), type);\n        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n        System.arraycopy(b, 0, targetPixels, 0, b.length);\n        return image;\n    }\n\n    public void displayImage(String title, Image img, int x, int y)\n    {\n        ImageIcon icon=new ImageIcon(img);\n        JFrame frame=new JFrame(title);\n        JLabel lbl=new JLabel(icon);\n        frame.add(lbl);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.pack();\n        frame.setLocation(x, y);\n        frame.setVisible(true);\n    }\n}\n\n\npublic class DiscreteFourierTransform {\n    public static void main(String[] args) {\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n        new DiscreteFourierTransformRun().run();\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class DynamicFtpChannelResolver {\n\n\tpublic static final int MAX_CACHE_SIZE = 2;\n\n\tprivate final LinkedHashMap<String, MessageChannel> channels =\n\t\t\t\tnew LinkedHashMap<String, MessageChannel>() {\n\t\t\t\t\t\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected boolean removeEldestEntry(\n\t\t\t\t\t\t\tEntry<String, MessageChannel> eldest) {\n\t\t\t\t\t\tboolean remove = size() > MAX_CACHE_SIZE;\n\t\t\t\t\t\tif(remove) {\n\t\t\t\t\t\t\tMessageChannel channel = eldest.getValue();\n\t\t\t\t\t\t\tConfigurableApplicationContext ctx = contexts.get(channel);\n\t\t\t\t\t\t\tif(ctx != null) { //shouldn't be null ideally\n\t\t\t\t\t\t\t\tctx.close();\n\t\t\t\t\t\t\t\tcontexts.remove(channel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn remove;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t};\n\n\tprivate final Map<MessageChannel, ConfigurableApplicationContext> contexts =\n\t\t\t\tnew HashMap<MessageChannel, ConfigurableApplicationContext>();\n\n\n\n\t\n\tpublic MessageChannel resolve(String customer) {\n\t\tMessageChannel channel = this.channels.get(customer);\n\t\tif (channel == null) {\n\t\t\tchannel = createNewCustomerChannel(customer);\n\t\t}\n\t\treturn channel;\n\t}\n\n\tprivate synchronized MessageChannel createNewCustomerChannel(String customer) {\n\t\tMessageChannel channel = this.channels.get(customer);\n\t\tif (channel == null) {\n\t\t\tConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\n\t\t\t\t\tnew String[] { \"/META-INF/spring/integration/dynamic-ftp-outbound-adapter-context.xml\" },\n\t\t\t\t\tfalse);\n\t\t\tthis.setEnvironmentForCustomer(ctx, customer);\n\t\t\tctx.refresh();\n\t\t\tchannel = ctx.getBean(\"toFtpChannel\", MessageChannel.class);\n\t\t\tthis.channels.put(customer, channel);\n\t\t\tthis.contexts.put(channel, ctx);\n\t\t}\n\t\treturn channel;\n\t}\n\n\t\n\tprivate void setEnvironmentForCustomer(ConfigurableApplicationContext ctx,\n\t\t\tString customer) {\n\t\tStandardEnvironment env = new StandardEnvironment();\n\t\tProperties props = new Properties();\n\t\tprops.setProperty(\"host\", \"host.for.\" + customer);\n\t\tprops.setProperty(\"user\", \"user\");\n\t\tprops.setProperty(\"password\", \"password\");\n\t\tprops.setProperty(\"remote.directory\", \"/tmp\");\n\t\tPropertiesPropertySource pps = new PropertiesPropertySource(\"ftpprops\", props);\n\t\tenv.getPropertySources().addLast(pps);\n\t\tctx.setEnvironment(env);\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\npublic class Ex2ComputeHistogramGraphJava {\n\n    public static void main(final String[] args) {\n        Mat src = loadAndShowOrExit(new File(\"data/group.jpg\"), IMREAD_GRAYSCALE);\n\n        Histogram1DJava h = new Histogram1DJava();\n        BufferedImage histogram = h.getHistogramImage(src);\n        show(histogram, \"Histogram\");\n    }\n}", "nl": "opencv"}
{"code": "\n\n\npublic class ColorMapTest {\n   public static void main(String args[]) {\n      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n      String file =\"E:/OpenCV/chap25/color_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Imgproc.applyColorMap(src, dst, Imgproc.COLORMAP_HOT);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap25/colormap_hot.jpg\", dst);\n      System.out.println(\"Image processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n@RestController\npublic class GreetingController {\n\n    private static final String template = \"Hello, %s!\";\n    private final AtomicLong counter = new AtomicLong();\n\n    @RequestMapping(\"/greeting\")\n    public Greeting greeting(@RequestParam(value=\"name\", defaultValue=\"World\") String name) {\n        return new Greeting(counter.incrementAndGet(),\n                            String.format(template, name));\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic final class Utils {\n\tpublic static Image mat2Image(Mat frame) {\n\t\ttry {\n\t\t\treturn SwingFXUtils.toFXImage(matToBufferedImage(frame), null);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"Cannot convert the Mat obejct: \" + e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static <T> void onFXThread(final ObjectProperty<T> property, final T value) {\n\t\tPlatform.runLater(() -> {\n\t\t\tproperty.set(value);\n\t\t});\n\t}\n\n\tprivate static BufferedImage matToBufferedImage(Mat original) {\n\t\tBufferedImage image = null;\n\t\tint width = original.width(), height = original.height(), channels = original.channels();\n\t\tbyte[] sourcePixels = new byte[width * height * channels];\n\t\toriginal.get(0, 0, sourcePixels);\n\n\t\tif (original.channels() > 1) {\n\t\t\timage = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);\n\t\t} else {\n\t\t\timage = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);\n\t\t}\n\t\tfinal byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n\t\tSystem.arraycopy(sourcePixels, 0, targetPixels, 0, sourcePixels.length);\n\n\t\treturn image;\n\t}\n\n\tpublic static double EuclideanDistance(Point p1, Point p2) {\n\t\treturn Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n\t}\n\n\tpublic static double Clamp(double min, double max, double x) {\n\t\treturn Math.max(max, Math.min(min, x));\n\t}\n\n\tpublic static Point Intersection(Point o1, Point p1, Point o2, Point p2) {\n\t\tPoint res = new Point(0, 0);\n\t\tPoint p = Sub(o2, o1);\n\t\tPoint d1 = Sub(p1, o1);\n\t\tPoint d2 = Sub(p2, o2);\n\n\t\tdouble cross = d1.x * d2.y - d1.y * d2.x;\n\t\tif (Math.abs(cross) < 1e-8) {\n\t\t\treturn res;\n\t\t}\n\n\t\tdouble t1 = (p.x * d2.y - p.y * d2.x) / cross;\n\t\tres = Add(o1, Mul(d1, t1));\n\t\treturn res;\n\t}\n\n\tpublic static Point Sub(Point a, Point b) {\n\t\tPoint res = new Point();\n\t\tres.x = a.x - b.x;\n\t\tres.y = a.y - b.y;\n\n\t\treturn res;\n\t}\n\n\tpublic static Point Add(Point a, Point b) {\n\t\tPoint res = new Point();\n\t\tres.x = a.x + b.x;\n\t\tres.y = a.y + b.y;\n\n\t\treturn res;\n\t}\n\n\tpublic static Point Mul(Point a, double b) {\n\t\tPoint res = new Point();\n\t\tres.x = a.x * b;\n\t\tres.y = a.y * b;\n\n\t\treturn res;\n\t}\n\n\tpublic static Mat OvertrayImage(Mat background, Mat foreground) {\n\t\tMat destination = new Mat(background.size(), background.type());\n\n\t\tfor (int y = 0; y < (int) (background.rows()); ++y) {\n\t\t\tfor (int x = 0; x < (int) (background.cols()); ++x) {\n\t\t\t\tdouble b[] = background.get(y, x);\n\t\t\t\tdouble f[] = foreground.get(y, x);\n\n\t\t\t\tdouble alpha = f[3] / 255.0;\n\n\t\t\t\tdouble d[] = new double[3];\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\td[k] = f[k] * alpha + b[k] * (1.0 - alpha);\n\t\t\t\t}\n\n\t\t\t\tdestination.put(y, x, d);\n\t\t\t}\n\t\t}\n\n\t\treturn destination;\n\t}\n\n\tpublic static void FillWithGradient(Mat background, Point inters, Point leftBottomStripe, Point rightBottomStripe) {\n\t\tdouble two3ds = Math.ceil((inters.y - leftBottomStripe.y) * 2 / 3); // parte\n\t\tPoint[] twoThirds = new Point[2];\n\t\ttwoThirds[0] = new Point(0, two3ds);\n\t\ttwoThirds[1] = new Point(Double.MAX_VALUE, two3ds);\n\t\tMatOfPoint bottom = new MatOfPoint(Intersection(twoThirds[0], twoThirds[1], inters, leftBottomStripe),\n\t\t\t\tleftBottomStripe, Intersection(twoThirds[0], twoThirds[1], inters, rightBottomStripe),\n\t\t\t\trightBottomStripe);\n\t\tImgproc.fillConvexPoly(background, bottom, new Scalar(0, 255, 0, 35));\n\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\npublic class HOGDescriptor {\n\n    protected final long nativeObj;\n    protected HOGDescriptor(long addr) { nativeObj = addr; }\n\n\n    public static final int\n            L2Hys = 0,\n            DEFAULT_NLEVELS = 64;\n\n\n\n    public   HOGDescriptor()\n    {\n        \n        nativeObj = HOGDescriptor_0();\n        \n        return;\n    }\n\n\n\n    public   HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels, boolean _signedGradient)\n    {\n        \n        nativeObj = HOGDescriptor_1(_winSize.width, _winSize.height, _blockSize.width, _blockSize.height, _blockStride.width, _blockStride.height, _cellSize.width, _cellSize.height, _nbins, _derivAperture, _winSigma, _histogramNormType, _L2HysThreshold, _gammaCorrection, _nlevels, _signedGradient);\n        \n        return;\n    }\n\n    public   HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins)\n    {\n        \n        nativeObj = HOGDescriptor_2(_winSize.width, _winSize.height, _blockSize.width, _blockSize.height, _blockStride.width, _blockStride.height, _cellSize.width, _cellSize.height, _nbins);\n        \n        return;\n    }\n\n\n\n    public   HOGDescriptor(String filename)\n    {\n        \n        nativeObj = HOGDescriptor_3(filename);\n        \n        return;\n    }\n\n\n\n    public  long getDescriptorSize()\n    {\n        \n        long retVal = getDescriptorSize_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  boolean checkDetectorSize()\n    {\n        \n        boolean retVal = checkDetectorSize_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  double getWinSigma()\n    {\n        \n        double retVal = getWinSigma_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  void setSVMDetector(Mat _svmdetector)\n    {\n        \n        setSVMDetector_0(nativeObj, _svmdetector.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  boolean load(String filename, String objname)\n    {\n        \n        boolean retVal = load_0(nativeObj, filename, objname);\n        \n        return retVal;\n    }\n\n    public  boolean load(String filename)\n    {\n        \n        boolean retVal = load_1(nativeObj, filename);\n        \n        return retVal;\n    }\n\n\n\n    public  void save(String filename, String objname)\n    {\n        \n        save_0(nativeObj, filename, objname);\n        \n        return;\n    }\n\n    public  void save(String filename)\n    {\n        \n        save_1(nativeObj, filename);\n        \n        return;\n    }\n\n\n\n    public  void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding, MatOfPoint locations)\n    {\n        Mat descriptors_mat = descriptors;\n        Mat locations_mat = locations;\n        compute_0(nativeObj, img.nativeObj, descriptors_mat.nativeObj, winStride.width, winStride.height, padding.width, padding.height, locations_mat.nativeObj);\n        \n        return;\n    }\n\n    public  void compute(Mat img, MatOfFloat descriptors)\n    {\n        Mat descriptors_mat = descriptors;\n        compute_1(nativeObj, img.nativeObj, descriptors_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding, MatOfPoint searchLocations)\n    {\n        Mat foundLocations_mat = foundLocations;\n        Mat weights_mat = weights;\n        Mat searchLocations_mat = searchLocations;\n        detect_0(nativeObj, img.nativeObj, foundLocations_mat.nativeObj, weights_mat.nativeObj, hitThreshold, winStride.width, winStride.height, padding.width, padding.height, searchLocations_mat.nativeObj);\n        \n        return;\n    }\n\n    public  void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights)\n    {\n        Mat foundLocations_mat = foundLocations;\n        Mat weights_mat = weights;\n        detect_1(nativeObj, img.nativeObj, foundLocations_mat.nativeObj, weights_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double finalThreshold, boolean useMeanshiftGrouping)\n    {\n        Mat foundLocations_mat = foundLocations;\n        Mat foundWeights_mat = foundWeights;\n        detectMultiScale_0(nativeObj, img.nativeObj, foundLocations_mat.nativeObj, foundWeights_mat.nativeObj, hitThreshold, winStride.width, winStride.height, padding.width, padding.height, scale, finalThreshold, useMeanshiftGrouping);\n        \n        return;\n    }\n\n    public  void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights)\n    {\n        Mat foundLocations_mat = foundLocations;\n        Mat foundWeights_mat = foundWeights;\n        detectMultiScale_1(nativeObj, img.nativeObj, foundLocations_mat.nativeObj, foundWeights_mat.nativeObj);\n        \n        return;\n    }\n\n\n\n    public  void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL, Size paddingBR)\n    {\n        \n        computeGradient_0(nativeObj, img.nativeObj, grad.nativeObj, angleOfs.nativeObj, paddingTL.width, paddingTL.height, paddingBR.width, paddingBR.height);\n        \n        return;\n    }\n\n    public  void computeGradient(Mat img, Mat grad, Mat angleOfs)\n    {\n        \n        computeGradient_1(nativeObj, img.nativeObj, grad.nativeObj, angleOfs.nativeObj);\n        \n        return;\n    }\n\n\n\n    public static MatOfFloat getDefaultPeopleDetector()\n    {\n        \n        MatOfFloat retVal = MatOfFloat.fromNativeAddr(getDefaultPeopleDetector_0());\n        \n        return retVal;\n    }\n\n\n\n    public static MatOfFloat getDaimlerPeopleDetector()\n    {\n        \n        MatOfFloat retVal = MatOfFloat.fromNativeAddr(getDaimlerPeopleDetector_0());\n        \n        return retVal;\n    }\n\n\n\n    public  Size get_winSize()\n    {\n        \n        Size retVal = new Size(get_winSize_0(nativeObj));\n        \n        return retVal;\n    }\n\n\n\n    public  Size get_blockSize()\n    {\n        \n        Size retVal = new Size(get_blockSize_0(nativeObj));\n        \n        return retVal;\n    }\n\n\n\n    public  Size get_blockStride()\n    {\n        \n        Size retVal = new Size(get_blockStride_0(nativeObj));\n        \n        return retVal;\n    }\n\n\n\n    public  Size get_cellSize()\n    {\n        \n        Size retVal = new Size(get_cellSize_0(nativeObj));\n        \n        return retVal;\n    }\n\n\n\n    public  int get_nbins()\n    {\n        \n        int retVal = get_nbins_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  int get_derivAperture()\n    {\n        \n        int retVal = get_derivAperture_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  double get_winSigma()\n    {\n        \n        double retVal = get_winSigma_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  int get_histogramNormType()\n    {\n        \n        int retVal = get_histogramNormType_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  double get_L2HysThreshold()\n    {\n        \n        double retVal = get_L2HysThreshold_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  boolean get_gammaCorrection()\n    {\n        \n        boolean retVal = get_gammaCorrection_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  MatOfFloat get_svmDetector()\n    {\n        \n        MatOfFloat retVal = MatOfFloat.fromNativeAddr(get_svmDetector_0(nativeObj));\n        \n        return retVal;\n    }\n\n\n\n    public  int get_nlevels()\n    {\n        \n        int retVal = get_nlevels_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n\n    public  boolean get_signedGradient()\n    {\n        \n        boolean retVal = get_signedGradient_0(nativeObj);\n        \n        return retVal;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n    private static native long HOGDescriptor_0();\n\n    private static native long HOGDescriptor_1(double _winSize_width, double _winSize_height, double _blockSize_width, double _blockSize_height, double _blockStride_width, double _blockStride_height, double _cellSize_width, double _cellSize_height, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels, boolean _signedGradient);\n    private static native long HOGDescriptor_2(double _winSize_width, double _winSize_height, double _blockSize_width, double _blockSize_height, double _blockStride_width, double _blockStride_height, double _cellSize_width, double _cellSize_height, int _nbins);\n\n    private static native long HOGDescriptor_3(String filename);\n\n    private static native long getDescriptorSize_0(long nativeObj);\n\n    private static native boolean checkDetectorSize_0(long nativeObj);\n\n    private static native double getWinSigma_0(long nativeObj);\n\n    private static native void setSVMDetector_0(long nativeObj, long _svmdetector_nativeObj);\n\n    private static native boolean load_0(long nativeObj, String filename, String objname);\n    private static native boolean load_1(long nativeObj, String filename);\n\n    private static native void save_0(long nativeObj, String filename, String objname);\n    private static native void save_1(long nativeObj, String filename);\n\n    private static native void compute_0(long nativeObj, long img_nativeObj, long descriptors_mat_nativeObj, double winStride_width, double winStride_height, double padding_width, double padding_height, long locations_mat_nativeObj);\n    private static native void compute_1(long nativeObj, long img_nativeObj, long descriptors_mat_nativeObj);\n\n    private static native void detect_0(long nativeObj, long img_nativeObj, long foundLocations_mat_nativeObj, long weights_mat_nativeObj, double hitThreshold, double winStride_width, double winStride_height, double padding_width, double padding_height, long searchLocations_mat_nativeObj);\n    private static native void detect_1(long nativeObj, long img_nativeObj, long foundLocations_mat_nativeObj, long weights_mat_nativeObj);\n\n    private static native void detectMultiScale_0(long nativeObj, long img_nativeObj, long foundLocations_mat_nativeObj, long foundWeights_mat_nativeObj, double hitThreshold, double winStride_width, double winStride_height, double padding_width, double padding_height, double scale, double finalThreshold, boolean useMeanshiftGrouping);\n    private static native void detectMultiScale_1(long nativeObj, long img_nativeObj, long foundLocations_mat_nativeObj, long foundWeights_mat_nativeObj);\n\n    private static native void computeGradient_0(long nativeObj, long img_nativeObj, long grad_nativeObj, long angleOfs_nativeObj, double paddingTL_width, double paddingTL_height, double paddingBR_width, double paddingBR_height);\n    private static native void computeGradient_1(long nativeObj, long img_nativeObj, long grad_nativeObj, long angleOfs_nativeObj);\n\n    private static native long getDefaultPeopleDetector_0();\n\n    private static native long getDaimlerPeopleDetector_0();\n\n    private static native double[] get_winSize_0(long nativeObj);\n\n    private static native double[] get_blockSize_0(long nativeObj);\n\n    private static native double[] get_blockStride_0(long nativeObj);\n\n    private static native double[] get_cellSize_0(long nativeObj);\n\n    private static native int get_nbins_0(long nativeObj);\n\n    private static native int get_derivAperture_0(long nativeObj);\n\n    private static native double get_winSigma_0(long nativeObj);\n\n    private static native int get_histogramNormType_0(long nativeObj);\n\n    private static native double get_L2HysThreshold_0(long nativeObj);\n\n    private static native boolean get_gammaCorrection_0(long nativeObj);\n\n    private static native long get_svmDetector_0(long nativeObj);\n\n    private static native int get_nlevels_0(long nativeObj);\n\n    private static native boolean get_signedGradient_0(long nativeObj);\n\n    private static native void delete(long nativeObj);\n\n}", "nl": "opencv"}
{"code": "@EnableWebMvc\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n \n   @Override\n   public void addViewControllers(ViewControllerRegistry registry) {\n      registry.addViewController(\"/\").setViewName(\"index\");\n   }\n \n   @Bean\n   public ViewResolver viewResolver() {\n      InternalResourceViewResolver bean = new InternalResourceViewResolver();\n \n      bean.setViewClass(JstlView.class);\n      bean.setPrefix(\"/WEB-INF/view/\");\n      bean.setSuffix(\".jsp\");\n \n      return bean;\n   }\n}", "nl": "spring"}
{"code": "\n\n\n\n@Configuration\n@Profile(SaganProfiles.CLOUDFOUNDRY)\nclass CloudFoundryDatabaseConfig {\n\n    @Bean\n    public Cloud cloud() {\n        return new CloudFactory().getCloud();\n    }\n\n    @Bean\n    public DataSource dataSource() {\n        DataSource dataSource = cloud().getServiceConnector(\"sagan-db\", DataSource.class, null);\n        return dataSource;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class FaceRecognitionEigenFaces {\n\tpublic static String basePath=System.getProperty(\"user.dir\");\n\n\tpublic static String csvFilePath=basePath+\"\\\\src\\\\resources\\\\FaceRecognition\\\\TrainingData.txt\";\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Loading library..\");\n\t\tSystem.loadLibrary(\"libopencv_java342\");\n\t\tSystem.out.println(\"Library loaded!!\");\n\t\tArrayList<Mat> images=new ArrayList<>();\n\t\tArrayList<Integer> labels=new ArrayList<>();\n\t\treadCSV(csvFilePath,images,labels);\n\t\t\n\t\tMat testSample=images.get(images.size()-1);\n\t\tInteger testLabel=labels.get(images.size()-1);\n\t\timages.remove(images.size()-1);\n\t\tlabels.remove(labels.size()-1);\n\t\tMatOfInt labelsMat=new MatOfInt();\n\t\tlabelsMat.fromList(labels);\n\t\tEigenFaceRecognizer efr=EigenFaceRecognizer.create();\n\t\tSystem.out.println(\"Starting training...\");\n\t\tefr.train(images, labelsMat);\n\t\t\n\t\tint[] outLabel=new int[1];\n\t\tdouble[] outConf=new double[1];\n\t\tSystem.out.println(\"Starting Prediction...\");\n\t\t efr.predict(testSample,outLabel,outConf);\n\t\t \n\t\tSystem.out.println(\"***Predicted label is \"+outLabel[0]+\".***\");\n\n\t\tSystem.out.println(\"***Actual label is \"+testLabel+\".***\");\n\t\tSystem.out.println(\"***Confidence value is \"+outConf[0]+\".***\");\n\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\npublic class TransmissionEstimate {\n\n\tpublic static Mat transEstimate(Mat img, int patchSz, double[] airlight, double lambda, double fTrans) {\n\t\tint rows = img.rows();\n\t\tint cols = img.cols();\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(img, bgr);\n\t\tint type = bgr.get(0).type();\n\t\treturn computeTrans(img, patchSz, rows, cols, type, airlight, lambda, fTrans);\n\t}\n\n\tpublic static Mat transEstimateEachChannel(Mat img, int patchSz, double airlight, double lambda, double fTrans) {\n\t\tint rows = img.rows();\n\t\tint cols = img.cols();\n\t\tMat T = new Mat(rows, cols, img.type());\n\t\tfor (int i = 0; i < rows; i += patchSz) {\n\t\t\tfor (int j = 0; j < cols; j += patchSz) {\n\t\t\t\tint endRow = i + patchSz > rows ? rows : i + patchSz;\n\t\t\t\tint endCol = j + patchSz > cols ? cols : j + patchSz;\n\t\t\t\tMat blkIm = img.submat(i, endRow, j, endCol);\n\t\t\t\tdouble Trans = BlkTransEstimate.blkEstimateEachChannel(blkIm, airlight, lambda, fTrans);\n\t\t\t\tfor (int m = i; m < endRow; m++) for (int n = j; n < endCol; n++) T.put(m, n, Trans);\n\t\t\t}\n\t\t}\n\t\treturn T;\n\t}\n\t\n\tpublic static Mat transEstimate(Mat img, int patchSz, double[] airlight, double lambda, double fTrans, \n\t\t\tint r, double eps, double gamma) {\n\t\tint rows = img.rows();\n\t\tint cols = img.cols();\n\t\tList<Mat> bgr = new ArrayList<>();\n\t\tCore.split(img, bgr);\n\t\tint type = bgr.get(0).type();\n\t\tMat T = computeTrans(img, patchSz, rows, cols, type, airlight, lambda, fTrans);\n\t\timg.convertTo(img, CvType.CV_8UC1);\n\t\tMat gray = new Mat();\n\t\tImgproc.cvtColor(img, gray, Imgproc.COLOR_BGR2GRAY);\n\t\tgray.convertTo(gray, CvType.CV_32F);\n\t\tCore.divide(gray, new Scalar(255.0), gray);\n\t\tT = Filters.GuidedImageFilter(gray, T, r, eps);\n\t\tMat Tsmooth = new Mat();\n\t\tImgproc.GaussianBlur(T, Tsmooth, new Size(81, 81), 40);\n\t\tMat Tdetails = new Mat();\n\t\tCore.subtract(T, Tsmooth, Tdetails);\n\t\tCore.multiply(Tdetails, new Scalar(gamma), Tdetails);\n\t\tCore.add(Tsmooth, Tdetails, T);\n\t\treturn T;\n\t}\n\n\tprivate static Mat computeTrans (Mat img, int patchSz, int rows, int cols, int type, double[] airlight, double lambda, double fTrans) {\n\t\tMat T = new Mat(rows, cols, type);\n\t\tfor (int i = 0; i < rows; i += patchSz) {\n\t\t\tfor (int j = 0; j < cols; j += patchSz) {\n\t\t\t\tint endRow = i + patchSz > rows ? rows : i + patchSz;\n\t\t\t\tint endCol = j + patchSz > cols ? cols : j + patchSz;\n\t\t\t\tMat blkIm = img.submat(i, endRow, j, endCol);\n\t\t\t\tdouble Trans = BlkTransEstimate.blkEstimate(blkIm, airlight, lambda, fTrans);\n\t\t\t\tfor (int m = i; m < endRow; m++) for (int n = j; n < endCol; n++) T.put(m, n, Trans);\n\t\t\t}\n\t\t}\n\t\treturn T;\n\t}\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\nclass GeometricDrawingRun{\n\n    private static final int W = 400;\n\n    public void run(){\n        String atom_window = \"Drawing 1: Atom\";\n        String rook_window = \"Drawing 2: Rook\";\n\n        Mat atom_image = Mat.zeros( W, W, CvType.CV_8UC3 );\n        Mat rook_image = Mat.zeros( W, W, CvType.CV_8UC3 );\n\n\n        MyEllipse( atom_image, 90.0 );\n        MyEllipse( atom_image, 0.0 );\n        MyEllipse( atom_image, 45.0 );\n        MyEllipse( atom_image, -45.0 );\n\n        MyFilledCircle( atom_image, new Point( W/2, W/2) );\n\n\n        MyPolygon( rook_image );\n\n        Imgproc.rectangle( rook_image,\n                new Point( 0, 7*W/8 ),\n                new Point( W, W),\n                new Scalar( 0, 255, 255 ),\n                -1,\n                8,\n                0 );\n\n        MyLine( rook_image, new Point( 0, 15*W/16 ), new Point( W, 15*W/16 ) );\n        MyLine( rook_image, new Point( W/4, 7*W/8 ), new Point( W/4, W ) );\n        MyLine( rook_image, new Point( W/2, 7*W/8 ), new Point( W/2, W ) );\n        MyLine( rook_image, new Point( 3*W/4, 7*W/8 ), new Point( 3*W/4, W ) );\n\n        Image image = toBufferedImage( atom_image );\n        displayImage( atom_window, image, 0, 200 );\n\n        Image image2 = toBufferedImage( rook_image );\n        displayImage( rook_window, image2, W, 200 );\n    }\n\n\n    \n    private void MyEllipse( Mat img, double angle ) {\n        int thickness = 2;\n        int lineType = 8;\n        int shift = 0;\n\n        Imgproc.ellipse( img,\n                new Point( W/2, W/2 ),\n                new Size( W/4, W/16 ),\n                angle,\n                0.0,\n                360.0,\n                new Scalar( 255, 0, 0 ),\n                thickness,\n                lineType,\n                shift );\n    }\n    \n    private void MyFilledCircle( Mat img, Point center ) {\n        int thickness = -1;\n        int lineType = 8;\n        int shift = 0;\n\n        Imgproc.circle( img,\n                center,\n                W/32,\n                new Scalar( 0, 0, 255 ),\n                thickness,\n                lineType,\n                shift );\n    }\n    \n    private void MyPolygon( Mat img ) {\n        int lineType = 8;\n        int shift = 0;\n\n        \n        Point[] rook_points = new Point[20];\n        rook_points[0]  = new Point(     W/4, 7*W/8   );\n        rook_points[1]  = new Point(   3*W/4, 7*W/8   );\n        rook_points[2]  = new Point(   3*W/4, 13*W/16 );\n        rook_points[3]  = new Point( 11*W/16, 13*W/16 );\n        rook_points[4]  = new Point( 19*W/32, 3*W/8   );\n        rook_points[5]  = new Point(   3*W/4, 3*W/8   );\n        rook_points[6]  = new Point(   3*W/4, W/8     );\n        rook_points[7]  = new Point( 26*W/40, W/8     );\n        rook_points[8]  = new Point( 26*W/40, W/4     );\n        rook_points[9]  = new Point( 22*W/40, W/4     );\n        rook_points[10] = new Point( 22*W/40, W/8     );\n        rook_points[11] = new Point( 18*W/40, W/8     );\n        rook_points[12] = new Point( 18*W/40, W/4     );\n        rook_points[13] = new Point( 14*W/40, W/4     );\n        rook_points[14] = new Point( 14*W/40, W/8     );\n        rook_points[15] = new Point(     W/4, W/8     );\n        rook_points[16] = new Point(     W/4, 3*W/8   );\n        rook_points[17] = new Point( 13*W/32, 3*W/8   );\n        rook_points[18] = new Point(  5*W/16, 13*W/16 );\n        rook_points[19] = new Point(     W/4, 13*W/16 );\n\n        MatOfPoint matPt = new MatOfPoint();\n        matPt.fromArray(rook_points);\n\n        List<MatOfPoint> pts = new ArrayList<MatOfPoint>();\n        pts.add(matPt);\n\n        Imgproc.fillPoly(img,\n                pts,\n                new Scalar( 255, 255, 255 ),\n                lineType,\n                shift,\n                new Point(0,0) );\n    }\n    \n    private void MyLine( Mat img, Point start, Point end ) {\n        int thickness = 2;\n        int lineType = 8;\n        int shift = 0;\n\n        Imgproc.line( img,\n                start,\n                end,\n                new Scalar( 0, 0, 0 ),\n                thickness,\n                lineType,\n                shift );\n    }\n\n    public Image toBufferedImage(Mat m) {\n        int type = BufferedImage.TYPE_BYTE_GRAY;\n        if ( m.channels() > 1 ) {\n            type = BufferedImage.TYPE_3BYTE_BGR;\n        }\n        int bufferSize = m.channels()*m.cols()*m.rows();\n        byte [] b = new byte[bufferSize];\n        m.get(0,0,b); // get all the pixels\n        BufferedImage image = new BufferedImage(m.cols(),m.rows(), type);\n        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();\n        System.arraycopy(b, 0, targetPixels, 0, b.length);\n        return image;\n    }\n\n    public void displayImage(String title, Image img, int x, int y)\n    {\n        ImageIcon icon=new ImageIcon(img);\n        JFrame frame=new JFrame(title);\n        JLabel lbl=new JLabel(icon);\n        frame.add(lbl);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.pack();\n        frame.setLocation(x, y);\n        frame.setVisible(true);\n    }\n}\n\npublic class BasicGeometricDrawing {\n    public static void main(String[] args) {\n\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n        new GeometricDrawingRun().run();\n    }\n}", "nl": "opencv"}
{"code": "\n \npublic class TemplateMatching {\n \n    public static void main(String[] args) {\n        \n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n        Mat source=null;\n        Mat template=null;\n        String filePath=\"C:\\\\Users\\\\mesutpiskin\\\\Desktop\\\\Object Detection\\\\Template Matching\\\\Sample Image\\\\\";\n        source=Imgcodecs.imread(filePath+\"kapadokya.jpg\");\n        template=Imgcodecs.imread(filePath+\"balon.jpg\");\n    \n        Mat outputImage=new Mat();    \n        int machMethod=Imgproc.TM_CCOEFF;\n        Imgproc.matchTemplate(source, template, outputImage, machMethod);\n \n    \n        MinMaxLocResult mmr = Core.minMaxLoc(outputImage);\n        Point matchLoc=mmr.maxLoc;\n        Imgproc.rectangle(source, matchLoc, new Point(matchLoc.x + template.cols(),\n                matchLoc.y + template.rows()), new Scalar(255, 255, 255));\n \n        Imgcodecs.imwrite(filePath+\"sonuc.jpg\", source);\n        System.out.println(\"Complated.\");\n    }\n \n}", "nl": "opencv"}
{"code": "\n\n\n\n\npublic class Tile implements Comparable<Tile> {\n\n    public static final int PREVIEW_WIDTH = 100;\n    public static final int PREVIEW_HEIGHT = 100;\n\n    protected File imgFile;\n    protected Color meanRGB;\n    protected ImageIcon icon;\n    private int priority = 0;\n\n    public Tile(File f) {\n        imgFile = f;\n        Mat i = ImageUtils.loadImage(f);\n        if (i.empty()) {\n            throw new IllegalArgumentException(\"File could not be read.\");\n        }\n\n        icon = ImageUtils.createIcon(i, new Size(PREVIEW_WIDTH, PREVIEW_HEIGHT));\n        meanRGB = ImageUtils.getMeanRGB(i);\n\n        i.release();\n    }\n    \n    protected Tile() {\n        \n    }\n    \n    public Mat loadImage(Size s) {\n        Mat out = new Mat();\n        Mat img = ImageUtils.loadImage(imgFile);\n        \n        if(img.empty()) return null;\n        \n        if(s != null) {\n            Imgproc.resize(img, out, s);\n            img.release();\n            return out;\n        }else {\n            out.release();\n            return img;\n        }\n    }\n\n    public File getImgFile() {\n        return imgFile;\n    }\n\n    public Color getMeanRGB() {\n        return meanRGB;\n    }\n\n    public ImageIcon getIcon() {\n        return icon;\n    }\n\n    public int getPriority() {\n        return priority;\n    }\n\n    public void resetPriority(int priority) {\n        this.priority = 0;\n    }\n    \n    public void incPriority() {\n        this.priority++;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 5;\n        hash = 97 * hash + Objects.hashCode(this.imgFile);\n        return hash;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final Tile other = (Tile) obj;\n        if (!Objects.equals(this.imgFile, other.imgFile)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int compareTo(Tile o) {\n        return 0;\n    }\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\npublic class Ex1ReadVideoSequenceJ {\n\n    public static void main(String[] args) throws FrameGrabber.Exception, InterruptedException {\n\n        FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(\"data/bike.avi\");\n        grabber.start();\n\n        CanvasFrame canvasFrame = new CanvasFrame(\"Extracted Frame\", 1);\n        canvasFrame.setCanvasSize(grabber.getImageWidth(), grabber.getImageHeight());\n        canvasFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        long delay = Math.round(1000d / grabber.getFrameRate());\n\n        Frame frame;\n        while ((frame = grabber.grab()) != null && canvasFrame.isVisible()) {\n            canvasFrame.showImage(frame);\n            Thread.sleep(delay);\n        }\n\n        grabber.release();\n\n    }\n\n}", "nl": "opencv"}
{"code": "\n\npublic class DilateTest {\n   public static void main( String[] args ) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"C:/EXAMPLES/OpenCV/sample.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n\n      Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, \n         new  Size((2*2) + 1, (2*2)+1));\n\n      Imgproc.dilate(src, dst, kernel);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap10/Dilation.jpg\", dst);\n\n      System.out.println(\"Image Processed\");\n   } \n}\n", "nl": "opencv"}
{"code": "\n\n\n\n@Component\npublic class CoffeeLoader {\n    private final ReactiveRedisConnectionFactory factory;\n    private final ReactiveRedisOperations<String, Coffee> coffeeOps;\n\n    public CoffeeLoader(ReactiveRedisConnectionFactory factory, ReactiveRedisOperations<String, Coffee> coffeeOps) {\n        this.factory = factory;\n        this.coffeeOps = coffeeOps;\n    }\n\n    @PostConstruct\n    public void loadData() {\n        factory.getReactiveConnection().serverCommands().flushAll().thenMany(\n                Flux.just(\"Jet Black Redis\", \"Darth Redis\", \"Black Alert Redis\")\n                        .map(name -> new Coffee(UUID.randomUUID().toString(), name))\n                        .flatMap(coffee -> coffeeOps.opsForValue().set(coffee.getId(), coffee)))\n                .thenMany(coffeeOps.keys(\"*\")\n                        .flatMap(coffeeOps.opsForValue()::get))\n                .subscribe(System.out::println);\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n\t@Bean\n\tCommandLineRunner lookup(CountryClient quoteClient) {\n\t\treturn args -> {\n\t\t\tString country = \"Spain\";\n\n\t\t\tif (args.length > 0) {\n\t\t\t\tcountry = args[0];\n\t\t\t}\n\t\t\tGetCountryResponse response = quoteClient.getCountry(country);\n\t\t\tSystem.err.println(response.getCountry().getCurrency());\n\t\t};\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class VideoLogger {\n\n    private final static Logger LOGGER = Logger.getLogger(VideoLogger.class.getName());\n\n    private static final String FILENAME_DATETIME_FORMAT = \"yyyy-MM-dd_HH.mm\";\n    private static final Scalar TEXT_COLOR = new Scalar(0, 0, 0);\n    private static final Scalar TEXT_BG_COLOR = new Scalar(255, 255, 255);\n    private static final double FONT_SCALE = 1.5;\n    private static final int BOX_WIDTH = 400;\n    private static final int BOX_HEIGHT = 130;\n    private static final int TEXT_THICKNESS = 2;\n    private static final DateTimeFormatter VIDEO_DATETIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\n    private CameraSettingsProvider cameraSettings;\n    private VideoWriter videoWriter = new VideoWriter();\n\n    private boolean gotBeginning;\n    private StringBuilder lastEntryBuilder;\n    private String lastEntry;\n    private int batteryCharge;\n    private Boolean pirState;\n    private int magnetX;\n    private int magnetY;\n    private int magnetZ;\n\n    public VideoLogger(CameraSettingsProvider cameraSettings) {\n        this.cameraSettings = cameraSettings;\n    }\n\n    public void startLogging() {\n        String videoFilePath = String.format(\"%s.avi\",\n                DateTimeFormatter.ofPattern(FILENAME_DATETIME_FORMAT).format(LocalDateTime.now()));\n        LOGGER.log(Level.INFO, String.format(\"Output path: %s\", videoFilePath));\n\n        LOGGER.log(Level.INFO, String.format(\"Resolution: %s\", cameraSettings.getMaxResolution()));\n        LOGGER.log(Level.INFO, String.format(\"FPS: %s\", cameraSettings.getFps()));\n\n        int fourCC = VideoWriter.fourcc('X', '2', '6', '4');\n\n        videoWriter.open(videoFilePath, fourCC, cameraSettings.getFps(), cameraSettings.getMaxResolution(), true);\n        gotBeginning = false;\n        lastEntryBuilder = new StringBuilder();\n    }\n\n    public void stopLogging() {\n        videoWriter.release();\n    }\n\n    public void pushNewEntry(String s) {\n        if (gotBeginning) {\n            if (s.contains(\"e\")) {\n                lastEntryBuilder.append(s.substring(0, s.indexOf('e') + 1));\n                parseOneMessage(s);\n            } else {\n                lastEntryBuilder.append(s);\n            }\n        } else {\n            if (s.contains(\"b\")) {\n                gotBeginning = true;\n                if (s.contains(\"e\")) {\n                    parseOneMessage(s);\n                } else {\n                    lastEntryBuilder.append(s.substring(s.indexOf('b')));\n                }\n\n            }\n        }\n    }\n\n    private void parseOneMessage(String s) {\n        lastEntry = lastEntryBuilder.toString();\n        batteryCharge = getIntBetweenChars('/');\n        pirState = getBoolBetweenChars('#');\n        magnetX = getIntBetweenChars('x');\n        magnetY = getIntBetweenChars('y');\n        magnetZ = getIntBetweenChars('z');\n\n        gotBeginning = false;\n        lastEntryBuilder.setLength(0);\n        lastEntryBuilder.append(s.substring(s.indexOf('e') + 1));\n    }\n\n    private Integer getIntBetweenChars(char c) {\n        return Integer.parseInt(getStringBetweenCharacters(c));\n    }\n\n    private Boolean getBoolBetweenChars(char c) {\n        return \"1\".equals(getStringBetweenCharacters(c));\n    }\n\n    private String getStringBetweenCharacters(char c) {\n        return lastEntry.substring(lastEntry.indexOf(c) + 1, lastEntry.lastIndexOf(c));\n    }\n\n    public void recordFrame(Mat frame) {\n        if (Objects.nonNull(pirState)) {\n            Imgproc.fillPoly(frame, Collections.singletonList(new MatOfPoint(new Point(0, 0),\n                    new Point(BOX_WIDTH, 0),\n                    new Point(BOX_WIDTH, BOX_HEIGHT),\n                    new Point(0, BOX_HEIGHT))), TEXT_BG_COLOR);\n            Imgproc.putText(frame,\n                    String.format(\"%s\", LocalDateTime.now().format(VIDEO_DATETIME_FORMAT)),\n                    new Point(10, 20),\n                    FONT_HERSHEY_PLAIN, FONT_SCALE, TEXT_COLOR, TEXT_THICKNESS);\n            Imgproc.putText(frame,\n                    String.format(\"Battery:%d%%\", batteryCharge),\n                    new Point(10, 50),\n                    FONT_HERSHEY_PLAIN, FONT_SCALE, TEXT_COLOR, TEXT_THICKNESS);\n            Imgproc.putText(frame,\n                    String.format(\"PIR: %s\", pirState ? \"ON\" : \"OFF\"),\n                    new Point(10, 80),\n                    FONT_HERSHEY_PLAIN, FONT_SCALE, TEXT_COLOR, TEXT_THICKNESS);\n            Imgproc.putText(frame,\n                    String.format(\"Magn: (%6s,%6s,%6s)\", Integer.toString(magnetX),\n                            Integer.toString(magnetY), Integer.toString(magnetZ)),\n                    new Point(10, 110),\n                    FONT_HERSHEY_PLAIN, FONT_SCALE, TEXT_COLOR, TEXT_THICKNESS);\n        }\n        videoWriter.write(frame);\n    }\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\npublic class CheckerBoardDetectionEffect extends Effect {\n    final int width = 5;\n    final int height = 4;\n    final int square_size = 20;\n    Mat pic;\n\n\n    public CheckerBoardDetectionEffect() {\n    }\n\n    @Override\n    public Mat applyTo(Mat frame) {\n        Bitmap chessboard = Storage.getChessboard();\n        Mat newFrame = new Mat(chessboard.getWidth(), chessboard.getHeight(), CvType.CV_8UC4);\n        Utils.bitmapToMat(chessboard, newFrame);\n\n        Size size = new Size(frame.cols() * 0.2, frame.rows() * 0.2);\n        resize(newFrame, newFrame, size);\n        Mat pic = new Mat();\n        pic = newFrame.clone();\n\n\n        Mat gray = new Mat();\n        Imgproc.cvtColor(frame, gray, Imgproc.COLOR_RGBA2GRAY);\n\n        Size pat_Size = new Size(width, height);\n\n        MatOfPoint2f corners = new MatOfPoint2f(new Mat(square_size, 1,\n                CvType.CV_32FC2));\n\n        Calib3d.findChessboardCorners(frame, pat_Size, corners,\n                Calib3d.CALIB_CB_ADAPTIVE_THRESH\n                        | Calib3d.CALIB_CB_FILTER_QUADS);\n\n        Size winSize = new Size(11, 11);\n        Size zeroZone = new Size(-1, -1);\n        TermCriteria criteria = new TermCriteria(TermCriteria.EPS\n                + TermCriteria.MAX_ITER, 30, 0.1);\n        if (0 == corners.checkVector(2))\n            return frame;\n        Imgproc.cornerSubPix(gray, corners, winSize, zeroZone, criteria);\n\n        double[] picture = new double[8];\n        double[] borders = new double[8];\n\n        picture[0] = 0;\n        picture[1] = 0;\n        picture[2] = pic.width();\n        picture[3] = 0;\n\n        picture[4] = pic.width();\n        picture[5] = pic.height();\n        picture[6] = 0;\n        picture[7] = pic.height();\n\n        Point[] p_arr = corners.toArray();\n        assert (p_arr.length == square_size);\n\n        borders[0] = p_arr[0].x;\n        borders[1] = p_arr[0].y;\n        borders[2] = p_arr[4].x;\n        borders[3] = p_arr[4].y;\n\n        borders[4] = p_arr[19].x;\n        borders[5] = p_arr[19].y;\n        borders[6] = p_arr[15].x;\n        borders[7] = p_arr[15].y;\n\n        Mat pointsIn = new Mat(4, 1, CvType.CV_32FC2);\n        Mat pointsRes = new Mat(4, 1, CvType.CV_32FC2);\n\n        pointsIn.put(0, 0, picture);\n        pointsRes.put(0, 0, borders);\n\n        Mat warp_mat = Imgproc.getPerspectiveTransform(pointsIn, pointsRes);\n\n        Mat blank = Mat.zeros(frame.size(), frame.type());\n\n        Core.bitwise_not(blank,blank);\n        Mat dst = Mat.zeros(frame.size(), frame.type());\n        Imgproc.warpPerspective(pic, dst, warp_mat, pic.size());\n        Imgproc.warpPerspective(blank, blank, warp_mat, blank.size());\n        Core.bitwise_not(blank,blank);\n        Core.bitwise_and(blank, frame,frame);\n        Core.bitwise_or(frame, dst, frame);\n\n        return frame;\n    }\n\n    public String toString() {\n        return \"Checker Detection\";\n    }\n\n}", "nl": "opencv"}
{"code": "\n\n  \npublic class FaceDetectionImage {\n   public static void main (String[] args) {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file =\"E:/OpenCV/chap23/facedetection_input.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      String xmlFile = \"E:/OpenCV/facedetect/lbpcascade_frontalface.xml\";\n      CascadeClassifier classifier = new CascadeClassifier(xmlFile);\n\n      MatOfRect faceDetections = new MatOfRect();\n      classifier.detectMultiScale(src, faceDetections);\n      System.out.println(String.format(\"Detected %s faces\", \n         faceDetections.toArray().length));\n\n      for (Rect rect : faceDetections.toArray()) {\n         Imgproc.rectangle(\n            src,                                               // where to draw the box\n            new Point(rect.x, rect.y),                            // bottom left\n            new Point(rect.x + rect.width, rect.y + rect.height), // top right\n            new Scalar(0, 0, 255),\n            3                                                     // RGB colour\n         );\n      }\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap23/facedetect_output1.jpg\", src);\n\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\npublic class GaussianTest {\n   public static void main(String args[]) {\n      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n\n      String file =\"C:/EXAMPLES/OpenCV/sample.jpg\";\n      Mat src = Imgcodecs.imread(file);\n\n      Mat dst = new Mat();\n    \n      Imgproc.GaussianBlur(src, dst, new Size(45, 45), 0);\n\n      Imgcodecs.imwrite(\"E:/OpenCV/chap9/Gaussian.jpg\", dst);\n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\n\n\n@SpringBootApplication\npublic class Application {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(Application.class);\n\n\tpublic static void main(String args[]) {\n\t\tSpringApplication.run(Application.class);\n\t}\n\t\n\t@Bean\n\tpublic RestTemplate restTemplate(RestTemplateBuilder builder) {\n\t\treturn builder.build();\n\t}\n\n\t@Bean\n\tpublic CommandLineRunner run(RestTemplate restTemplate) throws Exception {\n\t\treturn args -> {\n\t\t\tQuote quote = restTemplate.getForObject(\n\t\t\t\t\t\"https://gturnquist-quoters.cfapps.io/api/random\", Quote.class);\n\t\t\tlog.info(quote.toString());\n\t\t};\n\t}\n}", "nl": "spring"}
{"code": "\n\n\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker(\"/topic\");\n        config.setApplicationDestinationPrefixes(\"/app\");\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/gs-guide-websocket\").withSockJS();\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class HorizontalFlipEffect extends Effect {\n\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat();\n\t\tCore.flip(frame, newFrame, 1);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Horizontal Flip\";\n\t}\n}", "nl": "opencv"}
{"code": "    \n\n\n\n\n\n\n\n@RunWith(SpringRunner.class)\n@WebMvcTest(GuidesController.class)\npublic class GuidesControllerTests {\n\n\t@Autowired\n\tprivate MockMvc mvc;\n\n\t@MockBean\n\tprivate GuideRenderer guideRenderer;\n\n\t@MockBean\n\tprivate GithubClient githubClient;\n\n\t@Test\n\tpublic void fetchAllGuides() throws Exception {\n\t\tRepository restService = new Repository(12L, \"gs-rest-service\",\n\t\t\t\t\"spring-guides/gs-rest-service\",\n\t\t\t\t\"REST service sample :: Building a REST service\",\n\t\t\t\t\"http://example.org/spring-guides/gs-rest-service\",\n\t\t\t\t\"git://example.org/spring-guides/gs-rest-service.git\",\n\t\t\t\t\"git@example.org:spring-guides/gs-rest-service.git\",\n\t\t\t\t\"https://example.org/spring-guides/gs-rest-service.git\",\n\t\t\t\tArrays.asList(\"spring-boot\", \"spring-framework\"));\n\t\tRepository securingWeb = new Repository(15L, \"gs-securing-web\",\n\t\t\t\t\"spring-guides/gs-securing-web\", \"Securing Web :: Securing a Web Application\",\n\t\t\t\t\"http://example.org/spring-guides/gs-securing-web\",\n\t\t\t\t\"git@example.org:spring-guides/gs-securing-web.git\",\n\t\t\t\t\"https://example.org/spring-guides/gs-securing-web.git\",\n\t\t\t\t\"git://example.org/spring-guides/gs-securing-web.git\", null);\n\n\t\tgiven(this.githubClient.fetchOrgRepositories(\"spring-guides\"))\n\t\t\t\t.willReturn(Arrays.asList(restService, securingWeb));\n\n\t\tthis.mvc.perform(get(\"/guides/\"))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(jsonPath(\"$._embedded.guides[0].name\").value(\"rest-service\"))\n\t\t\t\t.andExpect(jsonPath(\"$._embedded.guides[0].projects[0]\").value(\"spring-boot\"))\n\t\t\t\t.andExpect(hasLink(\"$._embedded.guides[0]._links\", \"self\",\n\t\t\t\t\t\t\"http://localhost/guides/getting-started/rest-service\"))\n\t\t\t\t.andExpect(jsonPath(\"$._embedded.guides[1].name\").value(\"securing-web\"))\n\t\t\t\t.andExpect(jsonPath(\"$._embedded.guides[1].projects\").isEmpty())\n\t\t\t\t.andExpect(hasLink(\"$._embedded.guides[1]._links\", \"self\",\n\t\t\t\t\t\t\"http://localhost/guides/getting-started/securing-web\"));\n\t}\n\n\t@Test\n\tpublic void fetchAllGuidesFiltersUnknownTypes() throws Exception {\n\t\tRepository deprecatedGuide = new Repository(15L, \"deprecate-gs-device-detection\",\n\t\t\t\t\"spring-guides/deprecate-gs-device-detection\",\n\t\t\t\t\"Detecting a Device :: Learn how to use Spring to detect the type of device.\",\n\t\t\t\t\"http://example.org/spring-guides/deprecate-gs-device-detection\",\n\t\t\t\t\"git://example.org/spring-guides/deprecate-gs-device-detection.git\",\n\t\t\t\t\"git@example.org:spring-guides/deprecate-gs-device-detection.git\",\n\t\t\t\t\"https://example.org/spring-guides/deprecate-gs-device-detection.git\",\n\t\t\t\tnull);\n\n\t\tgiven(this.githubClient.fetchOrgRepositories(\"spring-guides\"))\n\t\t\t\t.willReturn(Arrays.asList(deprecatedGuide));\n\n\t\tthis.mvc.perform(get(\"/guides/\"))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(jsonPath(\"$._embedded\").doesNotExist());\n\t}\n\n\t@Test\n\tpublic void fetchGuide() throws Exception {\n\t\tRepository restService = new Repository(12L, \"gs-rest-service\",\n\t\t\t\t\"spring-guides/gs-rest-service\",\n\t\t\t\t\"REST service sample :: Building a REST service :: spring-boot,spring-framework\",\n\t\t\t\t\"http://example.org/spring-guides/gs-rest-service\",\n\t\t\t\t\"git://example.org/spring-guides/gs-rest-service.git\",\n\t\t\t\t\"git@example.org:spring-guides/gs-rest-service.git\",\n\t\t\t\t\"https://example.org/spring-guides/gs-rest-service.git\",\n\t\t\t\tArrays.asList(\"spring-boot\", \"spring-framework\"));\n\t\tgiven(this.githubClient.fetchOrgRepository(\"spring-guides\", \"gs-rest-service\"))\n\t\t\t\t.willReturn(restService);\n\n\t\tthis.mvc.perform(get(\"/guides/getting-started/rest-service\"))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(jsonPath(\"$.name\").value(\"rest-service\"))\n\t\t\t\t.andExpect(jsonPath(\"$.repositoryName\").value(\"spring-guides/gs-rest-service\"))\n\t\t\t\t.andExpect(jsonPath(\"$.title\").value(\"REST service sample\"))\n\t\t\t\t.andExpect(jsonPath(\"$.description\").value(\"Building a REST service\"))\n\t\t\t\t.andExpect(jsonPath(\"$.type\").value(\"getting-started\"))\n\t\t\t\t.andExpect(jsonPath(\"$.githubUrl\").value(\"http://example.org/spring-guides/gs-rest-service\"))\n\t\t\t\t.andExpect(jsonPath(\"$.gitUrl\").value(\"git://example.org/spring-guides/gs-rest-service.git\"))\n\t\t\t\t.andExpect(jsonPath(\"$.sshUrl\").value(\"git@example.org:spring-guides/gs-rest-service.git\"))\n\t\t\t\t.andExpect(jsonPath(\"$.cloneUrl\").value(\"https://example.org/spring-guides/gs-rest-service.git\"))\n\t\t\t\t.andExpect(jsonPath(\"$.projects[0]\").value(\"spring-boot\"))\n\t\t\t\t.andExpect(hasLink(\"self\", \"http://localhost/guides/getting-started/rest-service\"));\n\t}\n\n\t@Test\n\tpublic void fetchUnknownGuide() throws Exception {\n\t\tRepository securingWeb = new Repository(15L, \"gs-securing-web\",\n\t\t\t\t\"spring-guides/gs-securing-web\", \"Securing Web :: Securing a Web Application\",\n\t\t\t\t\"http://example.org/spring-guides/gs-securing-web\",\n\t\t\t\t\"git://example.org/spring-guides/gs-securing-web.git\",\n\t\t\t\t\"git@example.org:spring-guides/gs-securing-web.git\",\n\t\t\t\t\"https://example.org/spring-guides/gs-securing-web.git\",\n\t\t\t\tnull);\n\t\tgiven(this.githubClient.fetchOrgRepository(\"spring-guides\", \"gs-rest-service\"))\n\t\t\t\t.willThrow(new GithubResourceNotFoundException(\"spring-guides\", \"gs-rest-service\",\n\t\t\t\t\t\tnew HttpClientErrorException(HttpStatus.NOT_FOUND)));\n\n\t\tthis.mvc.perform(get(\"/guides/{guide}\", \"gs-rest-service\"))\n\t\t\t\t.andExpect(MockMvcResultMatchers.status().isNotFound());\n\t}\n\n\t@Test\n\tpublic void fetchGuideContent() throws Exception {\n\t\tGuideContentResource content = new GuideContentResource(\"rest-service\", \"content\", \"toc\");\n\t\tcontent.setPushToPwsMetadata(\"repository: https://github.com/spring-guides/gs-rest-service.git\\n\" +\n\t\t\t\t\"directory: complete\\n\" +\n\t\t\t\t\"path: /greeting\");\n\t\tgiven(this.guideRenderer.render(GuideType.GETTING_STARTED, \"rest-service\")).willReturn(content);\n\t\tthis.mvc.perform(get(\"/guides/getting-started/rest-service/content\"))\n\t\t\t\t.andExpect(MockMvcResultMatchers.status().isOk())\n\t\t\t\t.andExpect(jsonPath(\"$.content\").value(\"content\"))\n\t\t\t\t.andExpect(jsonPath(\"$.tableOfContents\").value(\"toc\"))\n\t\t\t\t.andExpect(jsonPath(\"$.pushToPwsMetadata\").value(Matchers.containsString(\"directory: complete\")))\n\t\t\t\t.andExpect(hasLink(\"self\", \"http://localhost/guides/getting-started/rest-service/content\"))\n\t\t\t\t.andExpect(hasLink(\"guide\", \"http://localhost/guides/getting-started/rest-service\"));\n\t}\n\n\t@Test\n\tpublic void fetchUnknownGuideContent() throws Exception {\n\t\tgiven(this.guideRenderer.render(GuideType.GETTING_STARTED, \"rest-service\"))\n\t\t\t\t.willThrow(new GithubResourceNotFoundException(\"spring-guides\", \"gs-securing-web\",\n\t\t\t\t\t\tnew HttpClientErrorException(HttpStatus.NOT_FOUND)));\n\t\tthis.mvc.perform(get(\"/guides/getting-started/rest-service/content\"))\n\t\t\t\t.andExpect(MockMvcResultMatchers.status().isNotFound());\n\t}\n\n\tstatic LinksMatcher hasLink(String name, String href) {\n\t\treturn new LinksMatcher(name, href);\n\t}\n\n\tstatic LinksMatcher hasLink(String prefix, String name, String href) {\n\t\treturn new LinksMatcher(prefix, name, href);\n\t}\n\n\tstatic class LinksMatcher implements ResultMatcher {\n\n\t\tprivate String prefix;\n\n\t\tprivate String linkName;\n\n\t\tprivate String href;\n\n\t\tpublic LinksMatcher(String linkName, String href) {\n\t\t\tthis.linkName = linkName;\n\t\t\tthis.href = href;\n\t\t}\n\n\t\tpublic LinksMatcher(String prefix, String linkName, String href) {\n\t\t\tthis.prefix = prefix;\n\t\t\tthis.linkName = linkName;\n\t\t\tthis.href = href;\n\t\t}\n\n\t\t@Override\n\t\tpublic void match(MvcResult result) throws Exception {\n\t\t\tAssert.hasText(this.linkName, \"The link should have a name\");\n\t\t\tString content = result.getResponse().getContentAsString();\n\t\t\tif (StringUtils.isEmpty(this.prefix)) {\n\t\t\t\tthis.prefix = \"$._links\";\n\t\t\t}\n\t\t\tString hrefExpr = this.prefix + \".\" + this.linkName + \".href\";\n\t\t\tJsonPathExpectationsHelper hrefHelper = new JsonPathExpectationsHelper(hrefExpr);\n\t\t\threfHelper.assertValue(content, this.href);\n\t\t}\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\npublic class HoughLineEffect extends Effect {\n\t\n\t\n\t@Override\n\tpublic Mat applyTo(Mat frame) {\n\t\tMat newFrame = new Mat();\n\t\tImgproc.cvtColor( frame, newFrame, Imgproc.COLOR_BGR2GRAY );\n\t\tImgproc.GaussianBlur( newFrame, newFrame,new Size(9, 9), 2, 2 );\n\t\tImgproc.Canny(frame, newFrame, 80, 100);\n\n\t\tMat lines = new Mat();\n\n\t\tImgproc.HoughLinesP(newFrame, lines, 1, Math.PI/180, 80, 30, 10);\n\t\tfor( int i = 0; i < lines.cols(); i++ )\n\t\t{\n\t\t\tdouble vLines[] = lines.get(0,i);\n\t\t\tif (vLines == null) break;\n\n\t\t\tdouble x0 = vLines[0],  y0 = vLines[1],\n\t\t\t\t\tx1 = vLines[2],  y1 = vLines[3];\n\t\t\tPoint d0 = new Point(x0,y0);\n\t\t\tPoint d1 = new Point(x1,y1);\n\n\t\t\t\n\n\t\t\tImgproc.line( frame, d0, d1, new Scalar(0,0,255), 3);\n\t\t}\n\n\t\tframe.copyTo(newFrame);\n\t\tframe.release();\n\t\treturn newFrame;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"Line Detection\";\n\t}\n}", "nl": "opencv"}
{"code": "\n\n\n\n\npublic class CamCap extends javax.swing.JFrame\n{\n\n    private DaemonThread myThread = null;\n    int count = 0;\n    VideoCapture webSource = null;\n\n    Mat frame = new Mat();\n    MatOfByte mem = new MatOfByte();\n\n    String File_path=\"\";\n\n    class DaemonThread implements Runnable\n    {\n    protected volatile boolean runnable = false;\n\n    @Override\n    public  void run()\n    {\n        synchronized(this)\n        {\n            while(runnable)\n            {\n                if(webSource.grab())\n                {\n\t\t    \ttry\n                        {\n                            webSource.retrieve(frame);\n\t\t\t    Highgui.imencode(\".bmp\", frame, mem);\n\t\t\t    Image im = ImageIO.read(new ByteArrayInputStream(mem.toArray()));\n\n\t\t\t    BufferedImage buff = (BufferedImage) im;\n\t\t\t    Graphics g=jPanel1.getGraphics();\n\n\t\t\t    if (g.drawImage(buff, 0, 0, getWidth(), getHeight() -150 , 0, 0, buff.getWidth(), buff.getHeight(), null))\n\t\t\t    \n\t\t\t    if(runnable == false)\n                            {\n\t\t\t    \tSystem.out.println(\"Going to wait()\");\n\t\t\t    \tthis.wait();\n\t\t\t    }\n\t\t\t }\n\t\t\t catch(Exception ex)\n                         {\n\t\t\t    System.out.println(\"Error\");\n                         }\n                }\n            }\n        }\n     }\n   }\n\n\n    \n    public CamCap() {\n        initComponents();\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    private void initComponents() {\n\n        jButton1 = new javax.swing.JButton();\n        jButton2 = new javax.swing.JButton();\n        jPanel1 = new javax.swing.JPanel();\n        jPanel2 = new javax.swing.JPanel();\n        jComboBox1 = new javax.swing.JComboBox();\n        jButton3 = new javax.swing.JButton();\n        jLabel1 = new javax.swing.JLabel();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n        setTitle(\"Capture\");\n        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));\n        setResizable(false);\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowClosed(java.awt.event.WindowEvent evt) {\n                formWindowClosed(evt);\n            }\n            public void windowClosing(java.awt.event.WindowEvent evt) {\n                formWindowClosing(evt);\n            }\n        });\n\n        jButton1.setFont(new java.awt.Font(\"Cambria\", 0, 18));\n        jButton1.setText(\"Start\");\n        jButton1.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButton1ActionPerformed(evt);\n            }\n        });\n\n        jButton2.setFont(new java.awt.Font(\"Cambria\", 0, 18));\n        jButton2.setText(\"Stop\");\n        jButton2.setEnabled(false);\n        jButton2.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButton2ActionPerformed(evt);\n            }\n        });\n\n        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n        jPanel1.setPreferredSize(new java.awt.Dimension(320, 240));\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 323, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 236, Short.MAX_VALUE)\n        );\n\n        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n        jPanel2.setAlignmentX(0.1F);\n        jPanel2.setAlignmentY(0.1F);\n\n        jComboBox1.setFont(new java.awt.Font(\"Calibri\", 0, 16));\n        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"From WebCam\", \"From File\" }));\n        jComboBox1.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jComboBox1ActionPerformed(evt);\n            }\n        });\n\n        jButton3.setFont(new java.awt.Font(\"Calibri\", 0, 18));\n        jButton3.setText(\"...\");\n        jButton3.setEnabled(false);\n        jButton3.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButton3ActionPerformed(evt);\n            }\n        });\n\n        jLabel1.setFont(new java.awt.Font(\"Calibri\", 0, 16));\n        jLabel1.setText(\"Capture Method:\");\n\n        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);\n        jPanel2.setLayout(jPanel2Layout);\n        jPanel2Layout.setHorizontalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n        jPanel2Layout.setVerticalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel2Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jLabel1)\n                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jButton3))\n                .addContainerGap(13, Short.MAX_VALUE))\n        );\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, 174, Short.MAX_VALUE))\n                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 327, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(6, 6, 6)\n                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jButton1)\n                    .addComponent(jButton2))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed\n\n        if ( (jButton1.getText()).equals(\"Start\") )\n        {\n            if (jComboBox1.getSelectedItem().equals(\"From WebCam\"))\n            {\n                webSource =new VideoCapture(0);\n            }\n            else\n                webSource =new VideoCapture(File_path);\n            \n            myThread = new DaemonThread();\n            Thread t = new Thread(myThread);\n            t.setDaemon(true);\n            myThread.runnable = true;\n            t.start();\n\n            jButton1.setEnabled(false);\n            jButton2.setEnabled(true);\n            jComboBox1.setEnabled(false);\n        }\n    }//GEN-LAST:event_jButton1ActionPerformed\n\n    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed\n\n        if ( (jButton2.getText()).equals(\"Stop\") )\n        {\n            myThread.runnable = false;\n            jButton2.setEnabled(false);\n            jButton1.setEnabled(true);\n            jComboBox1.setEnabled(true);\n            webSource.release();\n        }\n    }//GEN-LAST:event_jButton2ActionPerformed\n\n    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"AVI\",\"avi\");\n        chooser.setFileFilter(filter);\n        int returnVal = chooser.showOpenDialog(this);\n        if(returnVal == JFileChooser.APPROVE_OPTION)\n        {\n            File_path=chooser.getSelectedFile().getPath();\n            jButton1.setEnabled(true);\n        }\n        else\n            File_path=\"\";\n    }//GEN-LAST:event_jButton3ActionPerformed\n\n    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed\n        if(jComboBox1.getSelectedItem().equals(\"From File\"))\n        {\n            jButton3.setEnabled(true);\n            jButton1.setEnabled(false);\n        }\n        else\n        {\n            jButton3.setEnabled(false);\n            jButton1.setEnabled(true);\n        }\n    }//GEN-LAST:event_jComboBox1ActionPerformed\n\n    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed\n            \n\n    }//GEN-LAST:event_formWindowClosed\n\n    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing\n        if (myThread == null) {\n        }\n        else\n             if (myThread.runnable)\n             {\n                myThread.runnable = false;\n                webSource.release();\n              }\n    }//GEN-LAST:event_formWindowClosing\n\n    \n    public static void main(String args[]) {\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n\n                CamCap.setDefaultLookAndFeelDecorated(true);\n                try\n                {\n                        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n                }\n                catch (Exception ex)\n                {\n                        System.out.println(\"Failed loading L&F: \");\n                        System.out.println(ex);\n                        System.out.println(\"Loading default Look & Feel Manager!\");\n                }\n\n                new CamCap().setVisible(true);\n            }\n        });\n        \n    }\n\n    private javax.swing.JButton jButton1;\n    private javax.swing.JButton jButton2;\n    private javax.swing.JButton jButton3;\n    private javax.swing.JComboBox jComboBox1;\n    private javax.swing.JLabel jLabel1;\n    private javax.swing.JPanel jPanel1;\n    private javax.swing.JPanel jPanel2;\n\n}\n", "nl": "opencv"}
{"code": "\n\n\n@Entity // This tells Hibernate to make a table out of this class\npublic class User {\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Integer id;\n\n    private String name;\n\n    private String email;\n\n\tpublic Integer getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(Integer id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getEmail() {\n\t\treturn email;\n\t}\n\n\tpublic void setEmail(String email) {\n\t\tthis.email = email;\n\t}\n    \n    \n}", "nl": "spring"}
{"code": "\n\n\n\n\n@Repository(value = \"productDao\")\npublic class ProductDaoImpl implements ProductDao {\n\n\n\t@Autowired\n\tprivate SessionFactory sessionFactory;\n\n\n\tpublic SessionFactory getSessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tpublic void setSessionFactory(SessionFactory sessionFactory) {\n\t\tthis.sessionFactory = sessionFactory;\n\t}\n\n\tpublic List<Product> getAllProducts() {\n\t\tSession session = sessionFactory.openSession();\n\t\tList<Product> products = session.createCriteria(Product.class).list();\n\t\tSystem.out.println(\"----- List of Products-----\");\n\t\tSystem.out.println(products);\n\t\tsession.flush();\n\t\tsession.close();\n\t\treturn products;\n\t}\n\n\tpublic Product getProductById(String productId) {\n\n\t\tSession session = sessionFactory.openSession();\n\t\tProduct product = (Product) session.get(Product.class, productId);\n\t\tsession.close();\n\t\treturn product;\n\t}\n\n\tpublic void deleteProduct(String productId) {\n\t\tSession session = sessionFactory.openSession();\n\t\tProduct product = (Product) session.get(Product.class, productId);\n\t\tsession.delete(product);\n\t\tsession.flush();\n\t\tsession.close();// close the session\n\t}\n\n\tpublic void addProduct(Product product) {\n\t\tSession session = sessionFactory.openSession();\n\t\tsession.save(product);\n\t\tsession.close();\n\t}\n\n\tpublic void editProduct(Product product) {\n\t\tSession session = sessionFactory.openSession();\n\t\tsession.update(product);\n\t\tsession.flush();\n\t\tsession.close();\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n@SpringBootApplication\n@EnableConfigurationProperties(MyConfiguration.class)\npublic class Application implements CommandLineRunner {\n\n    private final MyConfiguration configuration;\n\n    public Application(MyConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    public void run(String... args) {\n\n        Logger logger = LoggerFactory.getLogger(Application.class);\n\n        logger.info(\"----------------------------------------\");\n        logger.info(\"Configuration properties\");\n        logger.info(\"        example.username is {}\", configuration.getUsername());\n        logger.info(\"        example.password is {}\", configuration.getPassword());\n        logger.info(\"----------------------------------------\");\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\nabstract class AbstractSearchClientConfig {\n\n    private static Log logger = LogFactory.getLog(AbstractSearchClientConfig.class);\n\n    protected abstract String getSearchClientConnectionUri();\n\n    @Bean\n    public Gson gson() {\n        return new GsonBuilder().setDateFormat(\"yyyy-MM-dd'T'HH:mm:ssXXX\").create();\n    }\n\n    @Bean\n    public JestClient jestClient() {\n        String connectionUri = getSearchClientConnectionUri();\n        logger.info(\"**** Elastic Search endpoint: \" + connectionUri);\n\n        HttpClientConfig clientConfig = new HttpClientConfig\n                .Builder(connectionUri)\n                .multiThreaded(true)\n                .gson(gson())\n                .build();\n\n        JestClientFactory factory = new JestClientFactory();\n        factory.setHttpClientConfig(clientConfig);\n        return factory.getObject();\n    }\n\n}\n\n@Configuration\n@Profile(SaganProfiles.STANDALONE)\nclass StandaloneSearchClientConfig extends AbstractSearchClientConfig {\n\n    @Value(\"${elasticsearch.client.endpoint}\")\n    private String endpoint;\n\n    @Override\n    protected String getSearchClientConnectionUri() {\n        return endpoint;\n    }\n}\n\n@Configuration\n@Profile(SaganProfiles.CLOUDFOUNDRY)\nclass CloudFoundrySearchClientConfig extends AbstractSearchClientConfig {\n\n    private final static String SAGAN_SEARCH_CONNECTION_URI_KEY = \"cloud.services.sagan-search.connection.uri\";\n\n    @Bean\n    public Cloud cloud() {\n        return new CloudFactory().getCloud();\n    }\n\n\n    @Override\n    protected String getSearchClientConnectionUri() {\n        Properties cloudProps = cloud().getCloudProperties();\n\n        String connectionUri = cloudProps.getProperty(SAGAN_SEARCH_CONNECTION_URI_KEY);\n        Assert.notNull(connectionUri, \"ElasticSearch endpoint URI should not be null: \"\n                + SAGAN_SEARCH_CONNECTION_URI_KEY);\n        return connectionUri;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n@Controller\n@RequestMapping(\"/team\")\nclass TeamController {\n\n    private final TeamService teamService;\n    private final BlogService blogService;\n    private final DateFactory dateFactory;\n\n    @Autowired\n    public TeamController(TeamService teamService, BlogService blogService, DateFactory dateFactory) {\n        this.teamService = teamService;\n        this.blogService = blogService;\n        this.dateFactory = dateFactory;\n    }\n\n    @RequestMapping(method = { GET, HEAD })\n    public String showTeam(Model model) {\n        List<MemberProfile> profiles = teamService.fetchActiveMembers();\n        model.addAttribute(\"profiles\", profiles);\n        model.addAttribute(\"teamLocations\", profiles.stream()\n                .filter(profile -> profile.getTeamLocation() != null)\n                .map(MemberProfile::getTeamLocation)\n                .collect(Collectors.toList()));\n        return \"team/index\";\n    }\n\n    @RequestMapping(value = \"/{username}\", method = { GET, HEAD })\n    public String showProfile(@PathVariable String username, Model model) {\n        MemberProfile profile = teamService.fetchMemberProfileUsername(username);\n        if (profile == MemberProfile.NOT_FOUND) {\n            throw new MemberNotFoundException(username);\n        }\n        if (profile.isHidden()) {\n            throw new MemberNotFoundException(\"Member profile for username '%s' is hidden\", username);\n        }\n        model.addAttribute(\"profile\", profile);\n        Page<Post> posts = blogService.getPublishedPostsForMember(profile, PageableFactory.forLists(1));\n        Page<PostView> postViewPage = PostView.pageOf(posts, dateFactory);\n        model.addAttribute(\"posts\", postViewPage);\n\n        List<TeamLocation> teamLocations = new ArrayList<>();\n        if (profile.getTeamLocation() != null) {\n            teamLocations.add(profile.getTeamLocation());\n        }\n        model.addAttribute(\"teamLocations\", teamLocations);\n\n        return \"team/show\";\n    }\n}", "nl": "spring"}
{"code": "\n\n\n@Component\nclass MemberProfileSearchEntryMapper implements SearchEntryMapper<MemberProfile> {\n    @Override\n    public SitePage map(MemberProfile profile) {\n        SitePage entry = new SitePage();\n        entry.setTitle(profile.getFullName());\n        entry.setSummary(profile.getBio());\n        entry.setRawContent(profile.getBio());\n        entry.setPath(\"/team/\" + profile.getUsername());\n        return entry;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\npublic final class Ex2MyFirstGUIAppJava extends JFrame {\n\n    private static final long serialVersionUID = 1L;\n\n    private final JFileChooser fileChooser = new JFileChooser(new File(\".\"));\n\n    \n    private final JLabel imageView = new JLabel();\n\n    \n    private Mat image = null;\n\n\n    private Ex2MyFirstGUIAppJava() throws HeadlessException {\n        super(\"My First GUI Java App\");\n\n\n        final Action processAction = new AbstractAction(\"Process\") {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n                    if (image != null) {\n                        processImage(image);\n                        imageView.setIcon(new ImageIcon(toBufferedImage(image)));\n                    } else {\n                        showMessageDialog(Ex2MyFirstGUIAppJava.this, \"Image not opened\", getTitle(), ERROR_MESSAGE);\n                    }\n                } finally {\n                    setCursor(Cursor.getDefaultCursor());\n                }\n            }\n        };\n        processAction.setEnabled(false);\n\n        final Action openImageAction = new AbstractAction(\"Open Image\") {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n                    final Mat img = openImage();\n\n                    if (img != null) {\n                        image = img;\n                        imageView.setIcon(new ImageIcon(toBufferedImage(image)));\n                        processAction.setEnabled(true);\n\n                    }\n                } finally {\n                    setCursor(Cursor.getDefaultCursor());\n                }\n            }\n        };\n\n\n        final JPanel buttonsPanel = new JPanel(new GridLayout(0, 1, 0, 5));\n        buttonsPanel.add(new JButton(openImageAction));\n        buttonsPanel.add(new JButton(processAction));\n\n\n        final JPanel leftPane = new JPanel();\n        leftPane.add(buttonsPanel);\n        add(leftPane, BorderLayout.WEST);\n\n        final JScrollPane imageScrollPane = new JScrollPane(imageView);\n        imageScrollPane.setPreferredSize(new Dimension(640, 480));\n        add(imageScrollPane, BorderLayout.CENTER);\n    }\n\n\n    \n    private Mat openImage() {\n\n        if (fileChooser.showOpenDialog(null) != JFileChooser.APPROVE_OPTION) {\n            return null;\n        }\n\n        final String path = fileChooser.getSelectedFile().getAbsolutePath();\n        final Mat newImage = imread(path);\n        if (newImage != null) {\n            return newImage;\n        } else {\n            showMessageDialog(this, \"Cannot open image file: \" + path, getTitle(), ERROR_MESSAGE);\n            return null;\n        }\n    }\n\n\n    \n    private void processImage(final Mat src) {\n        flip(src, src, 0);\n        cvtColor(src, src, COLOR_BGR2RGB);\n    }\n\n\n    public static void main(final String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                final Ex2MyFirstGUIAppJava frame = new Ex2MyFirstGUIAppJava();\n                frame.pack();\n                frame.setLocationRelativeTo(null);\n                frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n                frame.setVisible(true);\n            }\n        });\n    }\n}", "nl": "opencv"}
{"code": "\n\npublic class Negative \n{ \n\tpublic static void main(String args[])throws IOException \n\t{ \n\t\tBufferedImage img = null; \n\t\tFile f = null; \n\n\t\ttry\n\t\t{ \n\t\t\tf = new File(\"G:\\\\Inp.jpg\"); \n\t\t\timg = ImageIO.read(f); \n\t\t} \n\t\tcatch(IOException e) \n\t\t{ \n\t\t\tSystem.out.println(e); \n\t\t} \n\n\t\tint width = img.getWidth(); \n\t\tint height = img.getHeight(); \n\n\t\tfor (int y = 0; y < height; y++) \n\t\t{ \n\t\t\tfor (int x = 0; x < width; x++) \n\t\t\t{ \n\t\t\t\tint p = img.getRGB(x,y); \n\t\t\t\tint a = (p>>24)&0xff; \n\t\t\t\tint r = (p>>16)&0xff; \n\t\t\t\tint g = (p>>8)&0xff; \n\t\t\t\tint b = p&0xff; \n\n\t\t\t\tr = 255 - r; \n\t\t\t\tg = 255 - g; \n\t\t\t\tb = 255 - b; \n\n\t\t\t\tp = (a<<24) | (r<<16) | (g<<8) | b; \n\t\t\t\timg.setRGB(x, y, p); \n\t\t\t} \n\t\t} \n\n\t\ttry\n\t\t{ \n\t\t\tf = new File(\"G:\\\\Out.jpg\"); \n\t\t\tImageIO.write(img, \"jpg\", f); \n\t\t} \n\t\tcatch(IOException e) \n\t\t{ \n\t\t\tSystem.out.println(e); \n\t\t} \n\t} \n} \n", "nl": "opencv"}
{"code": "\n\n\n@Component\npublic class Receiver {\n\n    @JmsListener(destination = \"mailbox\", containerFactory = \"myFactory\")\n    public void receiveMessage(Email email) {\n        System.out.println(\"Received <\" + email + \">\");\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class HoughlinesTest {\n   public static void main(String args[]) throws Exception {\n      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );\n\n      String file = \"E:/OpenCV/chap21/hough_input.jpg\";\n\n      Mat src = Imgcodecs.imread(file,0);\n\n      Mat canny = new Mat();\n      Imgproc.Canny(src, canny, 50, 200, 3, false);\n\n      Mat cannyColor = new Mat();\n      Imgproc.cvtColor(canny, cannyColor, Imgproc.COLOR_GRAY2BGR);\n\n      Mat lines = new Mat();\n      Imgproc.HoughLines(canny, lines, 1, Math.PI/180, 100);\n\n      System.out.println(lines.rows());\n      System.out.println(lines.cols());\n\n      double[] data;\n      double rho, theta;\n      Point pt1 = new Point();\n      Point pt2 = new Point();\n      double a, b;\n      double x0, y0;\n      \n      for (int i = 0; i < lines.cols(); i++) {\n         data = lines.get(0, i);\n         rho = data[0];\n         theta = data[1];\n         \n         a = Math.cos(theta);\n         b = Math.sin(theta);\n         x0 = a*rho;\n         y0 = b*rho;\n         \n         pt1.x = Math.round(x0 + 1000*(-b));\n         pt1.y = Math.round(y0 + 1000*(a));\n         pt2.x = Math.round(x0 - 1000*(-b));\n         pt2.y = Math.round(y0 - 1000 *(a));\n         Imgproc.line(cannyColor, pt1, pt2, new Scalar(0, 0, 255), 6);\n      }\n      Imgcodecs.imwrite(\"E:/OpenCV/chap21/hough_output.jpg\", cannyColor);\n          \n      System.out.println(\"Image Processed\");\n   }\n}", "nl": "opencv"}
{"code": "\npublic class OrientingImage \n{ \npublic static void main( String[] args ) throws IOException \n{ \n\tSystem.loadLibrary( Core.NATIVE_LIBRARY_NAME ); \n\n\tFile input = new File(\"E:\\\\test.jpg\"); \n\tBufferedImage image = ImageIO.read(input); \n\n\tbyte[] data = ((DataBufferByte) image.getRaster().getDataBuffer()).getData(); \n\tMat mat = new Mat(image.getHeight(),image.getWidth(),CvType.CV_8UC3); \n\tmat.put(0, 0, data); \n\n\tMat newMat = new Mat(image.getHeight(),image.getWidth(),CvType.CV_8UC3); \n\tCore.flip(mat, newMat, -1); //flipping the image about both axis \n\n\tbyte[] newData = new byte[newMat.rows()*newMat.cols()*(int)(newMat.elemSize())]; \n\tnewMat.get(0, 0, newData); \n\tBufferedImage image1 = new BufferedImage(newMat.cols(), newMat.rows(), 5); \n\timage1.getRaster().setDataElements(0,0,newMat.cols(),newMat.rows(),newData); \n\n\tFile ouptut = new File(\"E:\\\\result.jpg\"); \n\tImageIO.write(image1, \"jpg\", ouptut); \n} \n} \n", "nl": "opencv"}
{"code": "\n\npublic class Grayscale \n{ \n\tpublic static void main(String args[])throws IOException \n\t{ \n\t\tBufferedImage img = null; \n\t\tFile f = null; \n\n\t\ttry\n\t\t{ \n\t\t\tf = new File(\"G:\\\\Inp.jpg\"); \n\t\t\timg = ImageIO.read(f); \n\t\t} \n\t\tcatch(IOException e) \n\t\t{ \n\t\t\tSystem.out.println(e); \n\t\t} \n\n\t\tint width = img.getWidth(); \n\t\tint height = img.getHeight(); \n\n\t\tfor (int y = 0; y < height; y++) \n\t\t{ \n\t\t\tfor (int x = 0; x < width; x++) \n\t\t\t{ \n\t\t\t\tint p = img.getRGB(x,y); \n\n\t\t\t\tint a = (p>>24)&0xff; \n\t\t\t\tint r = (p>>16)&0xff; \n\t\t\t\tint g = (p>>8)&0xff; \n\t\t\t\tint b = p&0xff; \n\n\t\t\t\tint avg = (r+g+b)/3; \n\n\t\t\t\tp = (a<<24) | (avg<<16) | (avg<<8) | avg; \n\n\t\t\t\timg.setRGB(x, y, p); \n\t\t\t} \n\t\t} \n\n\t\ttry\n\t\t{ \n\t\t\tf = new File(\"G:\\\\Out.jpg\"); \n\t\t\tImageIO.write(img, \"jpg\", f); \n\t\t} \n\t\tcatch(IOException e) \n\t\t{ \n\t\t\tSystem.out.println(e); \n\t\t} \n\t} \n} \n", "nl": "opencv"}
{"code": "\n\n\n\n\n\n\n\n\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration\n@DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD)\npublic class JmsMockTests {\n\n\tprivate static final Log LOGGER = LogFactory.getLog(JmsMockTests.class);\n\n\tprivate final AtomicReference<String> testMessageHolder = new AtomicReference<>();\n\n\t@Autowired\n\tprivate JmsTemplate mockJmsTemplate;\n\n\t@Autowired\n\tprivate SourcePollingChannelAdapter jmsInboundChannelAdapter;\n\n\t@Autowired\n\t@Qualifier(\"inputChannel\")\n\tprivate MessageChannel inputChannel;\n\n\t@Autowired\n\t@Qualifier(\"outputChannel\")\n\tprivate SubscribableChannel outputChannel;\n\n\t@Autowired\n\t@Qualifier(\"invalidMessageChannel\")\n\tprivate SubscribableChannel invalidMessageChannel;\n\n\n\t@Before\n\tpublic void setup() throws JMSException {\n\t\tMockito.reset(this.mockJmsTemplate);\n\t\tTextMessage message = mock(TextMessage.class);\n\n\t\twillReturn(new SimpleMessageConverter())\n\t\t\t\t.given(this.mockJmsTemplate).getMessageConverter();\n\n\t\twillReturn(message)\n\t\t\t\t.given(this.mockJmsTemplate).receiveSelected(isNull());\n\n\n\t\twillAnswer((Answer<String>) invocation -> testMessageHolder.get())\n\t\t\t\t.given(message).getText();\n\t}\n\n\t\n\t@Test\n\tpublic void testReceiveMessage() throws JMSException, InterruptedException, IOException {\n\t\tString msg = \"hello\";\n\n\t\tboolean sent = verifyJmsMessageReceivedOnOutputChannel(msg, outputChannel, new CountDownHandler() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void verifyMessage(Message<?> message) {\n\t\t\t\t\t\tassertEquals(\"hello\", message.getPayload());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\tassertTrue(\"message not sent to expected output channel\", sent);\n\t}\n\n\t\n\t@Test\n\tpublic void testReceiveInvalidMessage() throws JMSException, IOException, InterruptedException {\n\t\tString msg = \"whoops\";\n\t\tboolean sent = verifyJmsMessageReceivedOnOutputChannel(msg, invalidMessageChannel, new CountDownHandler() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void verifyMessage(Message<?> message) {\n\t\t\t\t\t\tassertEquals(\"invalid payload\", message.getPayload());\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t);\n\t\tassertTrue(\"message not sent to expected output channel\", sent);\n\t}\n\n\t\n\tprotected boolean verifyJmsMessageReceivedOnOutputChannel(Object obj, SubscribableChannel expectedOutputChannel,\n\t\t\tCountDownHandler handler) throws JMSException, InterruptedException {\n\t\treturn verifyJmsMessageOnOutputChannel(obj, expectedOutputChannel, handler, 7000);\n\t}\n\n\n\t\n\tprotected boolean verifyJmsMessageOnOutputChannel(Object obj, SubscribableChannel expectedOutputChannel,\n\t\t\tCountDownHandler handler, int timeoutMillisec) throws JMSException,\n\t\t\tInterruptedException {\n\n\t\tif (!(obj instanceof String)) {\n\t\t\tthrow new IllegalArgumentException(\"Only TextMessage is currently supported\");\n\t\t}\n\n\t\t\n\n\t\tthis.testMessageHolder.set((String) obj);\n\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\thandler.setLatch(latch);\n\n\n\t\texpectedOutputChannel.subscribe(handler);\n\n\t\tthis.jmsInboundChannelAdapter.start();\n\n\t\tboolean latchCountedToZero = latch.await(timeoutMillisec, TimeUnit.MILLISECONDS);\n\n\t\tif (!latchCountedToZero) {\n\t\t\tLOGGER.warn(String.format(\"The specified waiting time of the latch (%s ms) elapsed.\", timeoutMillisec));\n\t\t}\n\n\t\treturn latchCountedToZero;\n\n\t}\n\n\t\n\tprivate abstract class CountDownHandler implements MessageHandler {\n\n\t\tCountDownLatch latch;\n\n\t\tpublic final void setLatch(CountDownLatch latch) {\n\t\t\tthis.latch = latch;\n\t\t}\n\n\t\tprotected abstract void verifyMessage(Message<?> message);\n\n\t\t\n\t\t@Override\n\t\tpublic void handleMessage(Message<?> message) throws MessagingException {\n\t\t\tverifyMessage(message);\n\t\t\tlatch.countDown();\n\t\t}\n\n\t}\n\n}", "nl": "spring"}
{"code": "\n\n\n\n\npublic class ImageUtils {\n\n    \n    public static Color getMeanRGB(Mat m) {\n        Scalar s = Core.mean(m);\n        return new Color((int) (s.val[2]), (int) (s.val[1]), (int) (s.val[0]));\n    }\n\n    \n    public static double getColorDifference(Color c1, Color c2) {\n        int dR = c1.getRed() - c2.getRed();\n        int dG = c1.getGreen() - c2.getGreen();\n        int dB = c1.getBlue() - c2.getBlue();\n        double distance = Math.sqrt(dR * dR + dG * dG + dB * dB);\n        return distance;\n    }\n\n    \n    public static double getMatch(Tile t, Mat pattern) {\n        Mat tile = t.loadImage(pattern.size());\n        Mat out = new Mat();\n        Imgproc.matchTemplate(tile, pattern, out, Imgproc.TM_CCORR);\n        Core.MinMaxLocResult res = Core.minMaxLoc(out);\n        out.release();\n        tile.release();\n\n        return res.maxVal;\n    }\n\n    \n    public static Mat adjustImageToColor(Mat img, Color targetColor, int percent) {\n        Scalar color = new Scalar(targetColor.getBlue(), targetColor.getGreen(), targetColor.getRed());\n        Mat temp = new Mat(img.rows(), img.cols(), img.type(), color);\n        Mat res = new Mat();\n\n        double alpha = percent / 100.0d;\n\n        Core.addWeighted(img, 1 - alpha, temp, alpha, 0, res);\n        temp.release();\n        return res;\n    }\n\n    \n    public static Mat adjustImageToColor(Mat img, Mat template, int percent) {\n        double alpha = percent / 100.0d;\n        Mat res = new Mat();\n\n        Core.addWeighted(img, 1 - alpha, template, alpha, 0, res);\n        return res;\n    }\n\n    \n    public static ImageIcon createIcon(Mat img, Size iconSize) {\n        Mat dst = new Mat();\n        Imgproc.resize(img, dst, iconSize, 0, 0, Imgproc.INTER_LINEAR);\n\n        ImageIcon res = new ImageIcon(mat2image(dst));\n        dst.release();\n\n        return res;\n    }\n\n    \n    public static ImageIcon createIcon(Mat img, double sizeMult) {\n        Size size = new Size(img.width() * sizeMult, img.height() * sizeMult);\n\n        return createIcon(img, size);\n    }\n\n    \n    public static Mat loadImage(File f) {\n        Mat res = Highgui.imread(f.getPath());\n        if (!res.empty()) {\n            return res;\n        }\n\n        BufferedImage bi = null;\n        try {\n            bi = ImageIO.read(f);\n        } catch (IOException e) {\n            return res;\n        }\n        res = ImageUtils.image2mat(bi);\n\n        return res;\n    }\n\n    \n    public static BufferedImage mat2image(Mat matrix) {\n        int cols = matrix.cols();\n        int rows = matrix.rows();\n        int elemSize = (int) matrix.elemSize();\n        byte[] data = new byte[cols * rows * elemSize];\n        int type;\n\n        matrix.get(0, 0, data);\n\n        switch (matrix.channels()) {\n            case 1:\n                type = BufferedImage.TYPE_BYTE_GRAY;\n                break;\n\n            case 3:\n                type = BufferedImage.TYPE_3BYTE_BGR;\n\n                byte b;\n                for (int i = 0; i < data.length; i = i + 3) {\n                    b = data[i];\n                    data[i] = data[i + 2];\n                    data[i + 2] = b;\n                }\n                break;\n\n            default:\n                return null;\n        }\n\n        BufferedImage image = new BufferedImage(cols, rows, type);\n        image.getRaster().setDataElements(0, 0, cols, rows, data);\n\n        return image;\n    }\n\n    \n    public static Mat image2mat(BufferedImage bi) {\n        File f = null;\n        try {\n            f = File.createTempFile(\"tempImg\", \".jpg\");\n            ImageIO.write(bi, \"jpg\", f);\n        } catch (IOException e) {\n            return new Mat();\n        }\n\n        return Highgui.imread(f.getPath());\n    }\n\n}", "nl": "opencv"}
{"code": "\n\n\n\n\n\n@Component\npublic class ScheduledTasks {\n\n    private static final Logger log = LoggerFactory.getLogger(ScheduledTasks.class);\n\n    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\");\n\n    @Scheduled(fixedRate = 5000)\n    public void reportCurrentTime() {\n        log.info(\"The time is now {}\", dateFormat.format(new Date()));\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n\n\n\n\n@RequestMapping(\"/badges\")\n@Controller\nclass BadgeController {\n\n    private final ProjectMetadataService service;\n    private VersionBadgeService versionBadgeService;\n\n    @Autowired\n    public BadgeController(ProjectMetadataService service, VersionBadgeService versionBadgeService) {\n        this.service = service;\n        this.versionBadgeService = versionBadgeService;\n    }\n\n    @RequestMapping(value = { \"/{projectId}/ga.svg\", \"/{projectId}.svg\" }, method = { GET, HEAD }, produces = \"image/svg+xml\")\n    public ResponseEntity<byte[]> releaseBadge(@PathVariable(\"projectId\") String projectId) throws IOException {\n        return badgeFor(projectId, ReleaseStatus.GENERAL_AVAILABILITY);\n    }\n\n    @RequestMapping(value = \"/{projectId}/snapshot.svg\", method = { GET, HEAD }, produces = \"image/svg+xml\")\n    public ResponseEntity<byte[]> snapshotBadge(@PathVariable(\"projectId\") String projectId) throws IOException {\n        return badgeFor(projectId, ReleaseStatus.SNAPSHOT);\n    }\n\n    @RequestMapping(value = \"/{projectId}/prerelease.svg\", method = { GET, HEAD }, produces = \"image/svg+xml\")\n    public ResponseEntity<byte[]> prereleaseBadge(@PathVariable(\"projectId\") String projectId) throws IOException {\n        return badgeFor(projectId, ReleaseStatus.PRERELEASE);\n    }\n\n    @RequestMapping(value = \"/{projectId}/latest.svg\", method = { GET, HEAD }, produces = \"image/svg+xml\")\n    public ResponseEntity<byte[]> latestBadge(@PathVariable(\"projectId\") String projectId) throws IOException {\n        return badgeFor(projectId, null);\n    }\n\n    \n    private ResponseEntity<byte[]> badgeFor(String projectId, ReleaseStatus releaseStatus) throws IOException {\n\n        Project project = service.getProject(projectId);\n\n        if (project == null) {\n            return new ResponseEntity<>(HttpStatus.NOT_FOUND);\n        }\n\n        Optional<ProjectRelease> gaRelease = getRelease(project.getProjectReleases(),\n                projectRelease -> projectRelease.getReleaseStatus() == releaseStatus);\n\n        if (!gaRelease.isPresent()) {\n            return new ResponseEntity<>(HttpStatus.NOT_FOUND);\n        }\n\n        byte[] svgBadge = versionBadgeService.createSvgBadge(project, gaRelease.get());\n        return ResponseEntity.ok().eTag(gaRelease.get().getVersion()).cacheControl(CacheControl.maxAge(1L, TimeUnit.HOURS))\n                .body(svgBadge);\n    }\n\n    private Optional<ProjectRelease> getRelease(Collection<ProjectRelease> projectReleases,\n            Predicate<ProjectRelease> predicate) {\n\n        Optional<ProjectRelease> first = projectReleases //\n                .stream() //\n                .filter(projectRelease -> predicate.test(projectRelease) && projectRelease.isCurrent()) //\n                .findFirst();\n\n        if (first.isPresent()) {\n            return first;\n        }\n\n        return projectReleases //\n                .stream() //\n                .filter(projectRelease -> predicate.test(projectRelease)) //\n                .findFirst();\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\n\n@Component\nclass SiteUrl {\n\n    public String getUrl() {\n        HttpServletRequest request =\n                ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();\n        String requestURL = request.getRequestURL().toString();\n        String requestURI = request.getRequestURI();\n        return requestURL.replace(requestURI, \"\");\n    }\n\n    public String getAbsoluteUrl(String path) {\n        return getUrl() + path;\n    }\n}", "nl": "spring"}
{"code": "\n\n\n\n\n@Service\npublic class TeamService {\n\n    private static Log logger = LogFactory.getLog(TeamService.class);\n\n    private final TeamRepository teamRepository;\n    private final SearchService searchService;\n    private final MemberProfileSearchEntryMapper mapper;\n\n    @Autowired\n    public TeamService(TeamRepository teamRepository, SearchService searchService,\n                       MemberProfileSearchEntryMapper mapper) {\n        this.teamRepository = teamRepository;\n        this.searchService = searchService;\n        this.mapper = mapper;\n    }\n\n    public MemberProfile fetchMemberProfile(Long id) {\n        return teamRepository.findById(id);\n    }\n\n    public MemberProfile fetchMemberProfileUsername(String username) {\n        MemberProfile profile = teamRepository.findByUsername(username);\n        if (profile == null) {\n            profile = MemberProfile.NOT_FOUND;\n        }\n        return profile;\n    }\n\n    public void updateMemberProfile(Long id, MemberProfile profile) {\n        updateMemberProfile(profile, fetchMemberProfile(id));\n    }\n\n    public void updateMemberProfile(String username, MemberProfile updatedProfile) {\n        updateMemberProfile(updatedProfile, fetchMemberProfileUsername(username));\n    }\n\n    private void updateMemberProfile(MemberProfile profile, MemberProfile existingProfile) {\n        existingProfile.setSpeakerdeckUsername(profile.getSpeakerdeckUsername());\n        existingProfile.setTwitterUsername(profile.getTwitterUsername());\n        existingProfile.setBio(profile.getBio());\n        existingProfile.setName(profile.getName());\n        existingProfile.setJobTitle(profile.getJobTitle());\n        existingProfile.setTwitterUsername(profile.getTwitterUsername());\n        existingProfile.setSpeakerdeckUsername(profile.getSpeakerdeckUsername());\n        existingProfile.setLanyrdUsername(profile.getLanyrdUsername());\n        existingProfile.setLocation(profile.getLocation());\n        existingProfile.setGeoLocation(profile.getGeoLocation());\n        existingProfile.setVideoEmbeds(profile.getVideoEmbeds());\n        existingProfile.setGravatarEmail(profile.getGravatarEmail());\n        existingProfile.setHidden(profile.isHidden());\n        updateAvatarUrlwithGravatar(existingProfile);\n\n        teamRepository.save(existingProfile);\n        try {\n            searchService.saveToIndex(mapper.map(existingProfile));\n        } catch (Exception e) {\n            logger.warn(\"Indexing failed for \" + existingProfile.getId(), e);\n        }\n    }\n\n    public List<MemberProfile> fetchActiveMembers() {\n        return teamRepository.findByHiddenOrderByNameAsc(false);\n    }\n\n    public List<MemberProfile> fetchHiddenMembers() {\n        return teamRepository.findByHiddenOrderByNameAsc(true);\n    }\n\n    public MemberProfile createOrUpdateMemberProfile(Long githubId, String username, String avatarUrl, String name) {\n        MemberProfile profile = teamRepository.findByGithubId(githubId);\n\n        if (profile == null) {\n            profile = new MemberProfile();\n            profile.setGithubId(githubId);\n            profile.setUsername(username);\n            profile.setHidden(true);\n        }\n        profile.setAvatarUrl(avatarUrl);\n        profile.setName(name);\n        profile.setGithubUsername(username);\n        updateAvatarUrlwithGravatar(profile);\n        return teamRepository.save(profile);\n    }\n\n    public void showOnlyTeamMembersWithIds(List<Long> userIds) {\n        teamRepository.hideTeamMembersNotInIds(userIds);\n    }\n\n    private void updateAvatarUrlwithGravatar(MemberProfile profile) {\n        if (!StringUtils.isEmpty(profile.getGravatarEmail())) {\n            Md5PasswordEncoder encoder = new Md5PasswordEncoder();\n            String hashedEmail = encoder.encodePassword(profile.getGravatarEmail(), null);\n            profile.setAvatarUrl(String.format(\"https://gravatar.com/avatar/%s\", hashedEmail));\n        }\n    }\n}", "nl": "spring"}
{"code": "\n\n\npublic class FaceDetector \n{ \n\tpublic static void main(String[] args) \n\t{ \n\n\t\tSystem.loadLibrary(Core.NATIVE_LIBRARY_NAME); \n\n\t\tCascadeClassifier faceDetector = new CascadeClassifier(); \n\t\tfaceDetector.load(\"haarcascade_frontalface_alt.xml\"); \n\n\t\tMat image = Imgcodecs.imread(\"E:\\\\input.jpg\"); \n\n\t\tMatOfRect faceDetections = new MatOfRect(); \n\t\tfaceDetector.detectMultiScale(image, faceDetections); \n\n\t\tfor (Rect rect : faceDetections.toArray()) \n\t\t{ \n\t\t\tImgproc.rectangle(image, new Point(rect.x, rect.y), \n\t\t\tnew Point(rect.x + rect.width, rect.y + rect.height), \n\t\t\t\t\t\t\t\t\t\tnew Scalar(0, 255, 0)); \n\t\t} \n\n\t\tString filename = \"Ouput.jpg\"; \n\t\tImgcodecs.imwrite(\"E:\\\\\"+filename, image); \n\t} \n} \n", "nl": "opencv"}
{"code": "\n\n\n@Component\nclass AppRunner implements CommandLineRunner {\n\n    private final static Logger logger = LoggerFactory.getLogger(AppRunner.class);\n\n    private final BookingService bookingService;\n\n    public AppRunner(BookingService bookingService) {\n        this.bookingService = bookingService;\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        bookingService.book(\"Alice\", \"Bob\", \"Carol\");\n        Assert.isTrue(bookingService.findAllBookings().size() == 3,\n                \"First booking should work with no problem\");\n        logger.info(\"Alice, Bob and Carol have been booked\");\n        try {\n            bookingService.book(\"Chris\", \"Samuel\");\n        } catch (RuntimeException e) {\n            logger.info(\"v--- The following exception is expect because 'Samuel' is too \" +\n                    \"big for the DB ---v\");\n            logger.error(e.getMessage());\n        }\n\n        for (String person : bookingService.findAllBookings()) {\n            logger.info(\"So far, \" + person + \" is booked.\");\n        }\n        logger.info(\"You shouldn't see Chris or Samuel. Samuel violated DB constraints, \" +\n                \"and Chris was rolled back in the same TX\");\n        Assert.isTrue(bookingService.findAllBookings().size() == 3,\n                \"'Samuel' should have triggered a rollback\");\n\n        try {\n            bookingService.book(\"Buddy\", null);\n        } catch (RuntimeException e) {\n            logger.info(\"v--- The following exception is expect because null is not \" +\n                    \"valid for the DB ---v\");\n            logger.error(e.getMessage());\n        }\n\n        for (String person : bookingService.findAllBookings()) {\n            logger.info(\"So far, \" + person + \" is booked.\");\n        }\n        logger.info(\"You shouldn't see Buddy or null. null violated DB constraints, and \" +\n                \"Buddy was rolled back in the same TX\");\n        Assert.isTrue(bookingService.findAllBookings().size() == 3,\n                \"'null' should have triggered a rollback\");\n    }\n\n}", "nl": "spring"}
{"code": "\n\n\npublic class StudentDemo \n{ \n  public static void main(String[] args) \n  { \n    ApplicationContext appCon=new ClassPathXmlApplicationContext(\"StudentConfig.xml\"); \n    StudentBean factory=(StudentBean)appCon.getBean(\"studentbean\"); \n    factory.displayInfo(); \n  } \n}", "nl": "spring"}

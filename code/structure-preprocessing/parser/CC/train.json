{"code": "private static String inputOutput(String message) {     System.out.println(message);     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));     String returnString = \"\";     try {       returnString = br.readLine();     }     catch (IOException e){       System.out.println(\"Error reading in value\");       mainMenu();     }     return returnString;}", "nl": "Passes a prompt to the user and returns the user specified string"}
{"code": "public static void addInventory() {          String coffeeString = inputOutput(\"\\nPlease enter the units of coffee to add: \");                   String milkString = inputOutput(\"\\nPlease enter the units of milk to add: \");                   String sugarString = inputOutput(\"\\nPlease enter the units of sugar to add: \");                   String chocolateString = inputOutput(\"\\nPlease enter the units of chocolate to add: \");              try {       coffeeMaker.addInventory(coffeeString, milkString, sugarString, chocolateString);       System.out.println(\"Inventory successfully added\");     } catch (InventoryException e) {       System.out.println(\"Inventory was not added\");     } finally {       mainMenu();}}", "nl": "Add inventory user interface that processes input"}
{"code": "public static void editRecipe() {     Recipe [] recipes = coffeeMaker.getRecipes();     for(int i = 0; i < recipes.length; i++) {       if (recipes[i] != null) {         System.out.println((i+1) + \". \" + recipes[i].getName());       }     }     int recipeToEdit = recipeListSelection(\"Please select the number of the recipe to edit.\");          if(recipeToEdit < 0) {       mainMenu();     }               String priceString = inputOutput(\"\\nPlease enter the recipe price: $\");               String coffeeString = inputOutput(\"\\nPlease enter the units of coffee in the recipe: \");               String milkString = inputOutput(\"\\nPlease enter the units of milk in the recipe: \");               String sugarString = inputOutput(\"\\nPlease enter the units of sugar in the recipe: \");               String chocolateString = inputOutput(\"\\nPlease enter the units of chocolate in the recipe: \");          Recipe newRecipe = new Recipe();     try {       newRecipe.setPrice(priceString);       newRecipe.setAmtCoffee(coffeeString);       newRecipe.setAmtMilk(milkString);       newRecipe.setAmtSugar(sugarString);       newRecipe.setAmtChocolate(chocolateString);              String recipeEdited = coffeeMaker.editRecipe(recipeToEdit, newRecipe);              if (recipeEdited != null) {         System.out.println(recipeEdited + \" successfully edited.\\n\");       }       else {         System.out.println(recipeEdited + \"could not be edited.\\n\");       }     } catch (RecipeException e) {       System.out.println(e.getMessage());     } finally {       mainMenu();}}", "nl": "Edit recipe user interface the processes user input"}
{"code": "private static int recipeListSelection(String message) {     String userSelection = inputOutput(message);     int recipe = 0;     try {       recipe = Integer.parseInt(userSelection) - 1;       if (recipe >= 0 && recipe <=2) {                } else {         recipe = -1;       }     } catch (NumberFormatException e) {       System.out.println(\"Please select a number from 1-3.\");       recipe = -1;     }     return recipe;}", "nl": "Passes a prompt to the user that deals with the recipe list and returns the user selected number"}
{"code": "public static void addRecipe() {               String name = inputOutput(\"\\nPlease enter the recipe name: \");               String priceString = inputOutput(\"\\nPlease enter the recipe price: $\");                   String coffeeString = inputOutput(\"\\nPlease enter the units of coffee in the recipe: \");                   String milkString = inputOutput(\"\\nPlease enter the units of milk in the recipe: \");                   String sugarString = inputOutput(\"\\nPlease enter the units of sugar in the recipe: \");                   String chocolateString = inputOutput(\"\\nPlease enter the units of chocolate in the recipe: \");              Recipe r = new Recipe();     try {       r.setName(name);       r.setPrice(priceString);       r.setAmtCoffee(coffeeString);       r.setAmtMilk(milkString);       r.setAmtSugar(sugarString);       r.setAmtChocolate(chocolateString);              boolean recipeAdded = coffeeMaker.addRecipe(r);              if(recipeAdded) {         System.out.println(name + \" successfully added.\\n\");       } else {         System.out.println(name + \" could not be added.\\n\");       }     } catch (RecipeException e) {       System.out.println(e.getMessage());     } finally {       mainMenu();}}", "nl": "The add recipe user interface that process user input"}
{"code": "public static void checkInventory() {     System.out.println(coffeeMaker.checkInventory());     mainMenu();}", "nl": "Check inventory user interface that processes input"}
{"code": "public synchronized Recipe[] getRecipes() {     return recipeArray;}", "nl": "Returns the recipe array"}
{"code": "public synchronized void addInventory(String amtCoffee, String amtMilk, String amtSugar, String amtChocolate) throws InventoryException {     inventory.addCoffee(amtCoffee);     inventory.addMilk(amtMilk);     inventory.addSugar(amtSugar);     inventory.addChocolate(amtChocolate);}", "nl": "Returns true if inventory was successfully added amtCoffee amtMilk amtSugar amtChocolate @ return boolean"}
{"code": "public synchronized String checkInventory() {     return inventory.toString();}", "nl": "Returns the inventory of the coffee maker @ return Inventory"}
{"code": "public String deleteRecipe(int recipeToDelete) {     return recipeBook.deleteRecipe(recipeToDelete);}", "nl": "Returns the name of the successfully deleted recipe or null if the recipe cannot be deleted"}
{"code": "public String editRecipe(int recipeToEdit, Recipe r) {     return recipeBook.editRecipe(recipeToEdit, r);}", "nl": "Returns the name of the successfully edited recipe or null if the recipe cannot be edited"}
{"code": "public CoffeeMaker() {     recipeBook = new RecipeBook();     inventory = new Inventory();}", "nl": "Constructor for the coffee maker"}
{"code": "public boolean addRecipe(Recipe r) {     return recipeBook.addRecipe(r);}", "nl": "Returns true if the recipe is added to the list of recipes in the CoffeeMaker and false otherwise"}
{"code": "public void setAmtChocolate(String chocolate) throws RecipeException {     int amtChocolate = 0;     try {       amtChocolate = Integer.parseInt(chocolate);     } catch (NumberFormatException e) {       throw new RecipeException(\"Units of chocolate must be a positive integer\");     }     if (amtChocolate >= 0) {       this.amtChocolate = amtChocolate;     } else {       throw new RecipeException(\"Units of chocolate must be a positive integer\");}}", "nl": "incoherencetype"}
{"code": "public void setAmtMilk(String milk) throws RecipeException{     int amtMilk = 0;     try {       amtMilk = Integer.parseInt(milk);     } catch (NumberFormatException e) {       throw new RecipeException(\"Units of milk must be a positive integer\");     }     if (amtMilk >= 0) {       this.amtMilk = amtMilk;     } else {       throw new RecipeException(\"Units of milk must be a positive integer\");}}", "nl": "incoherencetype"}
{"code": "public int getAmtMilk() {     return amtMilk;}", "nl": "@ return Returns the amtMilk"}
{"code": "public void setAmtCoffee(String coffee) throws RecipeException {     int amtCoffee = 0;     try {       amtCoffee = Integer.parseInt(coffee);     } catch (NumberFormatException e) {       throw new RecipeException(\"Units of coffee must be a positive integer\");     }     if (amtCoffee >= 0) {       this.amtCoffee = amtCoffee;     } else {       throw new RecipeException(\"Units of coffee must be a positive integer\");}}", "nl": "incoherencetype"}
{"code": "public int getAmtSugar() {     return amtSugar;}", "nl": "@ return Returns the amtSugar"}
{"code": "public String getName() {     return name;}", "nl": "@ return Returns the name"}
{"code": "public int getAmtChocolate() {     return amtChocolate;}", "nl": "@ return Returns the amtChocolate"}
{"code": "public void setName(String name) {     if(name != null) {       this.name = name;}}", "nl": "set"}
{"code": "public int getChocolate() {     return chocolate;}", "nl": "Returns the current number of chocolate units in the inventory"}
{"code": "public synchronized void addSugar(String sugar) throws InventoryException {     int amtSugar = 0;     try {       amtSugar = Integer.parseInt(sugar);     } catch (NumberFormatException e) {       throw new InventoryException(\"Units of sugar must be a positive integer\");     }     if (amtSugar >= 0) {        Inventory.sugar += amtSugar;     } else {       throw new InventoryException(\"Units of sugar must be a positive integer\");}}", "nl": "Add the number of sugar units in the inventory to the current amount of sugar units"}
{"code": "public synchronized void setSugar(int sugar) {     if(sugar >= 0) {       Inventory.sugar = sugar;}}", "nl": "Sets the number of sugar units in the inventory to the specified amount"}
{"code": "public int getSugar() {     return sugar;}", "nl": "Returns the current number of sugar units in the inventory"}
{"code": "public synchronized boolean useIngredients(Recipe r) {     if (enoughIngredients(r)) {       Inventory.coffee -= r.getAmtCoffee();       Inventory.milk -= r.getAmtMilk();       Inventory.sugar -= r.getAmtSugar();       Inventory.chocolate -= r.getAmtChocolate();       return true;     } else {       return false;}}", "nl": "Removes the ingredients used to make the specified recipe"}
{"code": "public synchronized void setCoffee(int coffee) {     if(coffee >= 0) {       Inventory.coffee = coffee;}}", "nl": "Sets the number of coffee units in the inventory to the specified amount"}
{"code": "public synchronized void addChocolate(String chocolate) throws InventoryException {     int amtChocolate = 0;     try {       amtChocolate = Integer.parseInt(chocolate);     } catch (NumberFormatException e) {       throw new InventoryException(\"Units of chocolate must be a positive integer\");     }     if (amtChocolate >= 0) {       Inventory.chocolate += amtChocolate;     } else {       throw new InventoryException(\"Units of chocolate must be a positive integer\");}}", "nl": "Add the number of chocolate units in the inventory to the current amount of chocolate units"}
{"code": "protected synchronized boolean enoughIngredients(Recipe r) {     boolean isEnough = true;     if(Inventory.coffee < r.getAmtCoffee()) {       isEnough = false;     }     if(Inventory.milk < r.getAmtMilk()) {       isEnough = false;     }     if(Inventory.sugar < r.getAmtSugar()) {       isEnough = false;     }     if(Inventory.chocolate < r.getAmtChocolate()) {       isEnough = false;     }     return isEnough;}", "nl": "Returns true if there are enough ingredients to make the beverage"}
{"code": "public synchronized void addMilk(String milk) throws InventoryException {     int amtMilk = 0;     try {       amtMilk = Integer.parseInt(milk);     } catch (NumberFormatException e) {       throw new InventoryException(\"Units of milk must be a positive integer\");     }     if (amtMilk >= 0) {       Inventory.milk += amtMilk;     } else {       throw new InventoryException(\"Units of milk must be a positive integer\");}}", "nl": "Add the number of milk units in the inventory to the current amount of milk units"}
{"code": "public Inventory() {     setCoffee(15);     setMilk(15);     setSugar(15);     setChocolate(15);}", "nl": "Creates a coffee maker inventory object and fills each item in the inventory with 15 units"}
{"code": "public synchronized void addCoffee(String coffee) throws InventoryException {     int amtCoffee = 0;     try {       amtCoffee = Integer.parseInt(coffee);     } catch (NumberFormatException e) {       throw new InventoryException(\"Units of coffee must be a positive integer\");     }     if (amtCoffee >= 0) {       Inventory.coffee += amtCoffee;     } else {       throw new InventoryException(\"Units of coffee must be a positive integer\");}}", "nl": "Add the number of coffee units in the inventory to the current amount of coffee units"}
{"code": "public void close()     throws IOException    {     try {      int bufferLength = this.buffer.length();      for (;;) {       String str = \"\";       char ch;       if (this.bufferIndex >= bufferLength) {          str = XMLUtil.read(this.reader, '&');          ch = str.charAt(0);       } else {          ch = this.buffer.charAt(this.bufferIndex);          this.bufferIndex++;          continue;        }       if (ch == '<') {          this.reader.unread(ch);          break;       }       if ((ch == '&') && (str.length() > 1)) {          if (str.charAt(1) != '#') {           XMLUtil.processEntity(str, this.reader, this.resolver);          }       }      }     } catch (XMLParseException e) {      throw new IOException(e.getMessage());}}", "nl": "Skips remaining data and closes the stream"}
{"code": "ContentReader(IXMLReader     reader,          IXMLEntityResolver resolver,          String       buffer)    {     this.reader = reader;     this.resolver = resolver;     this.buffer = buffer;     this.bufferIndex = 0;}", "nl": "Creates the reader"}
{"code": "public int read(char[] outputBuffer,            int  offset,            int  size)     throws IOException    {     try {      int charsRead = 0;      int bufferLength = this.buffer.length();      if ((offset + size) > outputBuffer.length) {       size = outputBuffer.length - offset;      }      while (charsRead < size) {       String str = \"\";       char ch;       if (this.bufferIndex >= bufferLength) {          str = XMLUtil.read(this.reader, '&');          ch = str.charAt(0);       } else {          ch = this.buffer.charAt(this.bufferIndex);          this.bufferIndex++;          outputBuffer[charsRead] = ch;          charsRead++;          continue;        }       if (ch == '<') {          this.reader.unread(ch);          break;       }       if ((ch == '&') && (str.length() > 1)) {          if (str.charAt(1) == '#') {           ch = XMLUtil.processCharLiteral(str);          } else {           XMLUtil.processEntity(str, this.reader, this.resolver);           continue;          }       }       outputBuffer[charsRead] = ch;       charsRead++;      }      if (charsRead == 0) {       charsRead = -1;      }      return charsRead;     } catch (XMLParseException e) {      throw new IOException(e.getMessage());}}", "nl": "Reads a block of data"}
{"code": "PIReader(IXMLReader reader)    {     this.reader = reader;     this.atEndOfData = false;}", "nl": "Creates the reader"}
{"code": "public IXMLEntityResolver getParameterEntityResolver()    {     return this.parameterEntityResolver;}", "nl": "Returns the parameter entity resolver"}
{"code": "public void attributeAdded(String key,                 String value,                 String systemId,                 int  lineNr)    {     Properties props = (Properties) this.currentElements.peek();     if (props.containsKey(key)) {      props.remove(key);}}", "nl": "Indicates that an attribute has been added to the current element"}
{"code": "protected void processElement(IXMLReader     reader,                  IXMLEntityResolver entityResolver)     throws Exception    {     String str = XMLUtil.read(reader, '%');     char ch = str.charAt(0);     if (ch != '!') {      XMLUtil.skipTag(reader);      return;     }     str = XMLUtil.read(reader, '%');     ch = str.charAt(0);     switch (ch) {      case '-':       XMLUtil.skipComment(reader);       break;      case '[':       this.processConditionalSection(reader, entityResolver);       break;      case 'E':       this.processEntity(reader, entityResolver);       break;      case 'A':       this.processAttList(reader, entityResolver);       break;      default:       XMLUtil.skipTag(reader);}}", "nl": "Processes an element in the DTD"}
{"code": "public NonValidator()    {     this.attributeDefaultValues = new Hashtable();     this.currentElements = new Stack();     this.parameterEntityResolver = new XMLEntityResolver();}", "nl": "Creates the & quot ; validator & quot ;"}
{"code": "public void elementStarted(String name,                 String systemId,                 int  lineNr)    {     Properties attribs      = (Properties) this.attributeDefaultValues.get(name);     if (attribs == null) {      attribs = new Properties();     } else {      attribs = (Properties) attribs.clone();     }     this.currentElements.push(attribs);}", "nl": "Indicates that an element has been started"}
{"code": "public void elementAttributesProcessed(String   name,                       Properties extraAttributes,                       String   systemId,                       int    lineNr)    {     Properties props = (Properties) this.currentElements.pop();     Enumeration enm = props.keys();     while (enm.hasMoreElements()) {      String key = (String) enm.nextElement();      extraAttributes.put(key, props.get(key));}}", "nl": "This method is called when the attributes of an XML element have been processed"}
{"code": "protected void processAttList(IXMLReader     reader,                  IXMLEntityResolver entityResolver)     throws Exception    {     if (! XMLUtil.checkLiteral(reader,  \"TTLIST\")) {      XMLUtil.skipTag(reader);      return;     }     XMLUtil.skipWhitespace(reader, null);     String str = XMLUtil.read(reader, '%');     char ch = str.charAt(0);     while (ch == '%') {      XMLUtil.processEntity(str, reader,                  this.parameterEntityResolver);      str = XMLUtil.read(reader, '%');      ch = str.charAt(0);     }     reader.unread(ch);     String elementName = XMLUtil.scanIdentifier(reader);     XMLUtil.skipWhitespace(reader, null);          str = XMLUtil.read(reader, '%');     ch = str.charAt(0);     while (ch == '%') {      XMLUtil.processEntity(str, reader,                  this.parameterEntityResolver);      str = XMLUtil.read(reader, '%');      ch = str.charAt(0);     }     Properties props = new Properties();     while (ch != '>') {      reader.unread(ch);      String attName = XMLUtil.scanIdentifier(reader);      XMLUtil.skipWhitespace(reader, null);      str = XMLUtil.read(reader, '%');      ch = str.charAt(0);      while (ch == '%') {        XMLUtil.processEntity(str, reader,                    this.parameterEntityResolver);        str = XMLUtil.read(reader, '%');        ch = str.charAt(0);      }      if (ch == '(') {        while (ch != ')') {          str = XMLUtil.read(reader, '%');          ch = str.charAt(0);          while (ch == '%') {            XMLUtil.processEntity(str, reader,                        this.parameterEntityResolver);            str = XMLUtil.read(reader, '%');            ch = str.charAt(0);          }        }      } else {       reader.unread(ch);       XMLUtil.scanIdentifier(reader);      }      XMLUtil.skipWhitespace(reader, null);      str = XMLUtil.read(reader, '%');      ch = str.charAt(0);      while (ch == '%') {        XMLUtil.processEntity(str, reader,                    this.parameterEntityResolver);        str = XMLUtil.read(reader, '%');        ch = str.charAt(0);      }            if (ch == '#') {       str = XMLUtil.scanIdentifier(reader);       XMLUtil.skipWhitespace(reader, null);       if (! str.equals(\"FIXED\")) {          XMLUtil.skipWhitespace(reader, null);          str = XMLUtil.read(reader, '%');          ch = str.charAt(0);          while (ch == '%') {           XMLUtil.processEntity(str, reader,                     this.parameterEntityResolver);           str = XMLUtil.read(reader, '%');           ch = str.charAt(0);          }          continue;       }      } else {       reader.unread(ch);      }      String value = XMLUtil.scanString(reader, '%',                        this.parameterEntityResolver);      props.put(attName, value);      XMLUtil.skipWhitespace(reader, null);      str = XMLUtil.read(reader, '%');      ch = str.charAt(0);      while (ch == '%') {       XMLUtil.processEntity(str, reader,                   this.parameterEntityResolver);       str = XMLUtil.read(reader, '%');       ch = str.charAt(0);      }     }     if (! props.isEmpty()) {      this.attributeDefaultValues.put(elementName, props);}}", "nl": "Processes an ATTLIST element"}
{"code": "protected void finalize()     throws Throwable    {     this.parameterEntityResolver = null;     this.attributeDefaultValues.clear();     this.attributeDefaultValues = null;     this.currentElements.clear();     this.currentElements = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "CDATAReader(IXMLReader reader)    {     this.reader = reader;     this.savedChar = 0;     this.atEndOfData = false;}", "nl": "Creates the reader"}
{"code": "protected void finalize()     throws Throwable    {     this.reader = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "public int read(char[] buffer,            int  offset,            int  size)     throws IOException    {     int charsRead = 0;     if (this.atEndOfData) {      return -1;     }     if ((offset + size) > buffer.length) {      size = buffer.length - offset;     }     while (charsRead < size) {      char ch = this.savedChar;      if (ch == 0) {       ch = this.reader.read();      } else {       this.savedChar = 0;      }      if (ch == ']') {       char ch2 = this.reader.read();              if (ch2 == ']') {          char ch3 = this.reader.read();          if (ch3 == '>') {           this.atEndOfData = true;           break;          }          this.savedChar = ch2;          this.reader.unread(ch3);       } else {          this.reader.unread(ch2);       }      }      buffer[charsRead] = ch;      charsRead++;     }     if (charsRead == 0) {      charsRead = -1;     }     return charsRead;}", "nl": "Reads a block of data"}
{"code": "public String getElementName()    {     return this.elementName;}", "nl": "Returns the name of the element in which the validation is violated"}
{"code": "public String getAttributeName()    {     return this.attributeName;}", "nl": "Returns the name of the attribute in which the validation is violated"}
{"code": "static void errorUnexpectedPCData(String systemID,                    int  lineNr,                    String parentElementName)     throws XMLValidationException    {     throw new XMLValidationException(             XMLValidationException.UNEXPECTED_PCDATA,             systemID, lineNr,              null,              null,              null,             \"Unexpected #PCDATA in element \" + parentElementName);}", "nl": "Throws an XMLValidationException to indicate that a # PCDATA element was unexpected"}
{"code": "static void errorUnexpectedCDATA(String systemID,                   int  lineNr)     throws XMLParseException    {     throw new XMLParseException(systemID, lineNr,                   \"No CDATA section is expected here\");}", "nl": "Throws an XMLParseException to indicate that a CDATA section is unexpected at this point"}
{"code": "static void errorInvalidAttributeValue(String systemID,                       int  lineNr,                       String elementName,                       String attributeName,                       String attributeValue)     throws XMLValidationException    {     throw new XMLValidationException(                XMLValidationException.ATTRIBUTE_WITH_INVALID_VALUE,                systemID, lineNr,                elementName,                attributeName,                attributeValue,                \"Invalid value for attribute \" + attributeName);}", "nl": "Throws an XMLValidationException to indicate that an attribute has an invalid value"}
{"code": "static void errorUnexpectedAttribute(String systemID,                     int  lineNr,                     String elementName,                     String attributeName)     throws XMLValidationException    {     throw new XMLValidationException(            XMLValidationException.UNEXPECTED_ATTRIBUTE,            systemID, lineNr,            elementName,            attributeName,             null,            \"Element \" + elementName + \" did not expect an attribute \"            + \"named \" + attributeName);}", "nl": "Throws an XMLValidationException to indicate that an attribute is unexpected"}
{"code": "static void errorWrongClosingTag(String systemID,                   int  lineNr,                   String   expectedName,                   String   wrongName)     throws XMLParseException    {     throw new XMLParseException(systemID, lineNr,                   \"Closing tag does not match opening tag: `\"                   + wrongName + \"' != `\" + expectedName                   + \"'\");}", "nl": "Throws an XMLParseException to indicate that the closing tag of an element does not match the opening tag"}
{"code": "static char readChar(IXMLReader reader,             char     entityChar)     throws IOException,        XMLParseException    {     String str = XMLUtil.read(reader, entityChar);     char ch = str.charAt(0);     if (ch == entityChar) {      XMLUtil.errorUnexpectedEntity(reader.getSystemID(),                      reader.getLineNr(),                      str);     }     return ch;}", "nl": "Reads a character from the reader disallowing entities"}
{"code": "protected void updateApplicationEnabled() {     firePropertyChange(\"enabled\",         Boolean.valueOf(!isEnabled()),         Boolean.valueOf(isEnabled()));}", "nl": "Updates the enabled state of this action depending on the new enabled state of the application"}
{"code": "static String scanString(IXMLReader     reader,               char         entityChar,               IXMLEntityResolver entityResolver)     throws IOException,        XMLParseException    {     StringBuffer result = new StringBuffer();     int startingLevel = reader.getStreamLevel();     char delim = reader.read();     if ((delim != '\\'') && (delim != '\"')) {      XMLUtil.errorExpectedInput(reader.getSystemID(),                   reader.getLineNr(),                   \"delimited string\");     }     for (;;) {      String str = XMLUtil.read(reader, entityChar);      char ch = str.charAt(0);      if (ch == entityChar) {       if (str.charAt(1) == '#') {          result.append(XMLUtil.processCharLiteral(str));       } else {          XMLUtil.processEntity(str, reader, entityResolver);       }      } else if (ch == '&') {       reader.unread(ch);       str = XMLUtil.read(reader, '&');       if (str.charAt(1) == '#') {          result.append(XMLUtil.processCharLiteral(str));       } else {          result.append(str);       }      } else if (reader.getStreamLevel() == startingLevel) {       if (ch == delim) {          break;       } else if ((ch == 9) || (ch == 10) || (ch == 13)) {          result.append(' ');       } else {          result.append(ch);       }      } else {       result.append(ch);      }     }     return result.toString();}", "nl": "Retrieves a delimited string from the data"}
{"code": "protected void uninstallApplicationListeners(Application app) {     app.removePropertyChangeListener(applicationListener);}", "nl": "Installs listeners on the application object"}
{"code": "public AbstractApplicationAction(Application app) {     this.app = app;     installApplicationListeners(app);     updateApplicationEnabled();}", "nl": "Creates a new instance"}
{"code": "static void errorMissingAttribute(String systemID,                    int  lineNr,                    String elementName,                    String attributeName)     throws XMLValidationException    {     throw new XMLValidationException(            XMLValidationException.MISSING_ATTRIBUTE,            systemID, lineNr,            elementName,            attributeName,             null,            \"Element \" + elementName + \" expects an attribute named \"            + attributeName);}", "nl": "Throws an XMLValidationException to indicate that an attribute is missing"}
{"code": "static String scanSystemID(IXMLReader reader)     throws IOException,       XMLParseException    {     if (! XMLUtil.checkLiteral(reader, \"YSTEM\")) {      return null;     }     XMLUtil.skipWhitespace(reader, null);     return XMLUtil.scanString(reader, '\\0', null);}", "nl": "Scans a system ID"}
{"code": "static void skipComment(IXMLReader reader)     throws IOException,        XMLParseException    {     if (reader.read() != '-') {      XMLUtil.errorExpectedInput(reader.getSystemID(),                   reader.getLineNr(),                   \"<!--\");     }          int dashesRead = 0;     for (;;) {      char ch = reader.read();      switch (ch) {       case '-':          dashesRead++;          break;       case '>':          if (dashesRead == 2) {           return;          }       default:          dashesRead = 0;}}}", "nl": "Skips the remainder of a comment"}
{"code": "static String read(IXMLReader     reader,             char         entityChar)     throws IOException,        XMLParseException    {     char ch = reader.read();     StringBuffer buf = new StringBuffer();     buf.append(ch);     if (ch == entityChar) {      while (ch != ';') {       ch = reader.read();       buf.append(ch);      }     }     return buf.toString();}", "nl": "Reads a character from the reader"}
{"code": "static void errorMissingPCData(String systemID,                   int  lineNr,                   String parentElementName)     throws XMLValidationException    {     throw new XMLValidationException(                XMLValidationException.MISSING_PCDATA,                systemID, lineNr,                 null,                 null,                 null,                \"Missing #PCDATA in element \" + parentElementName);}", "nl": "Throws an XMLValidationException to indicate that a # PCDATA element was missing"}
{"code": "static void errorExpectedInput(String systemID,                   int  lineNr,                   String expectedString)     throws XMLParseException    {     throw new XMLParseException(systemID, lineNr,                   \"Expected: \" + expectedString);}", "nl": "Throws an XMLParseException to indicate that an expected string is not encountered"}
{"code": "static void errorMissingElement(String systemID,                    int  lineNr,                    String parentElementName,                    String missingElementName)     throws XMLValidationException    {     throw new XMLValidationException(                 XMLValidationException.MISSING_ELEMENT,                 systemID, lineNr,                 missingElementName,                  null,                  null,                 \"Element \" + parentElementName                 + \" expects to have a \" + missingElementName);}", "nl": "Throws an XMLValidationException to indicate that an element is missing"}
{"code": "static void errorUnexpectedEntity(String systemID,                    int  lineNr,                    String entity)     throws XMLParseException    {     throw new XMLParseException(systemID, lineNr,                   \"No entity reference is expected here (\"                   + entity + \")\");}", "nl": "Throws an XMLParseException to indicate that an entity reference is unexpected at this point"}
{"code": "public AbstractSaveUnsavedChangesAction(Application app, View view) {     super(app, view);}", "nl": "Creates a new instance"}
{"code": "static void processEntity(String       entity,                IXMLReader     reader,                IXMLEntityResolver entityResolver)     throws IOException,        XMLParseException    {     entity = entity.substring(1, entity.length() - 1);     Reader entityReader = entityResolver.getEntity(reader, entity);     if (entityReader == null) {      XMLUtil.errorInvalidEntity(reader.getSystemID(),                   reader.getLineNr(),                   entity);     }     boolean externalEntity = entityResolver.isExternalEntity(entity);     reader.startNewStream(entityReader, !externalEntity);}", "nl": "Processes an entity"}
{"code": "static String scanIdentifier(IXMLReader reader)     throws IOException,        XMLParseException    {     StringBuffer result = new StringBuffer();     for (;;) {      char ch = reader.read();      if ((ch == '_') || (ch == ':') || (ch == '-') || (ch == '.')        || ((ch >= 'a') && (ch <= 'z'))        || ((ch >= 'A') && (ch <= 'Z'))        || ((ch >= '0') && (ch <= '9')) || (ch > '\\u007E')) {       result.append(ch);      } else {       reader.unread(ch);       break;      }     }     return result.toString();}", "nl": "Retrieves an identifier from the data"}
{"code": "public void setViewClassName(String newValue) {     String oldValue = viewClassName;     viewClassName = newValue;     firePropertyChange(VIEW_CLASS_NAME_PROPERTY, oldValue, newValue);}", "nl": "Use this method for best application startup performance"}
{"code": "@Override   public URIChooser createImportChooser(Application a, View v) {     return createOpenChooser(a,v);}", "nl": "Returns createOpenChooser"}
{"code": "public void setViewClass(Class newValue) {     Class oldValue = viewClass;     viewClass = newValue;     firePropertyChange(VIEW_CLASS_PROPERTY, oldValue, newValue);}", "nl": "Use this method only , if setViewClassName does not suit you"}
{"code": "public XMLParseException(String msg)    {     super(msg);}", "nl": "Creates a new exception"}
{"code": "protected JMenuBar createMenuBar(View v) {     JMenuBar mb = new JMenuBar();          JMenu fileMenu = null;     JMenu editMenu = null;     JMenu helpMenu = null;     JMenu viewMenu = null;     JMenu windowMenu = null;     String fileMenuText = labels.getString(\"file.text\");     String editMenuText = labels.getString(\"edit.text\");     String viewMenuText = labels.getString(\"view.text\");     String windowMenuText = labels.getString(\"window.text\");     String helpMenuText = labels.getString(\"help.text\");     for (JMenu mm : getModel().createMenus(this, v)) {       String text = mm.getText();       if (text == null) {         mm.setText(\"-null-\");       } else if (text.equals(fileMenuText)) {         fileMenu = mm;         continue;       } else if (text.equals(editMenuText)) {         editMenu = mm;         continue;       } else if (text.equals(viewMenuText)) {         viewMenu = mm;         continue;       } else if (text.equals(windowMenuText)) {         windowMenu = mm;         continue;       } else if (text.equals(helpMenuText)) {         helpMenu = mm;         continue;       }       mb.add(mm);     }          if (fileMenu == null) {       fileMenu = createFileMenu(v);     }     if (editMenu == null) {       editMenu = createEditMenu(v);     }     if (viewMenu == null) {       viewMenu = createViewMenu(v);     }     if (windowMenu == null) {       windowMenu = createWindowMenu(v);     }     if (helpMenu == null) {       helpMenu = createHelpMenu(v);     }          if (fileMenu != null) {       mb.add(fileMenu, 0);     }     if (editMenu != null) {       mb.add(editMenu, Math.min(1, mb.getComponentCount()));     }     if (viewMenu != null) {       mb.add(viewMenu, Math.min(2, mb.getComponentCount()));     }     if (windowMenu != null) {       mb.add(windowMenu);     }     if (helpMenu != null) {       mb.add(helpMenu);     }     return mb;}", "nl": "Creates a menu bar"}
{"code": "public void addDisposable(Disposable disposable) {     if (disposables == null) {       disposables = new LinkedList<Disposable>();     }     disposables.add(disposable);}", "nl": "Adds a disposable object , which will be disposed when the specified view is disposed"}
{"code": "private void initComponents() {     setLayout(new java.awt.BorderLayout());}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public void execute(Runnable worker) {     if (executor == null) {       executor = Executors.newSingleThreadExecutor();     }     executor.execute(worker);}", "nl": "Executes the specified runnable on the worker thread of the view"}
{"code": "public boolean isExternalEntity(String name)    {     Object obj = this.entities.get(name);     return ! (obj instanceof java.lang.String);}", "nl": "Returns true if an entity is external"}
{"code": "@SuppressWarnings(\"unchecked\")   public void dispose() {     if (executor != null) {       executor.shutdown();       executor = null;     }     if (disposables != null) {       for (Disposable d : (LinkedList<Disposable>)disposables.clone()) {         d.dispose();       }       disposables = null;     }     removeAll();}", "nl": "Gets rid of all the resources of the view"}
{"code": "public void addInternalEntity(String name,                  String value)    {     if (! this.entities.containsKey(name)) {      this.entities.put(name, value);}}", "nl": "Adds an internal entity"}
{"code": "public AbstractView() {     preferences = PreferencesUtil.userNodeForPackage(getClass());}", "nl": "Creates a new instance"}
{"code": "public XMLEntityResolver()    {     this.entities = new Hashtable();     this.entities.put(\"amp\", \"&#38;\");     this.entities.put(\"quot\", \"&#34;\");     this.entities.put(\"apos\", \"&#39;\");     this.entities.put(\"lt\", \"&#60;\");     this.entities.put(\"gt\", \"&#62;\");}", "nl": "Initializes the resolver"}
{"code": "public Reader getEntity(IXMLReader xmlReader,                String   name)     throws XMLParseException    {     Object obj = this.entities.get(name);     if (obj == null) {      return null;     } else if (obj instanceof java.lang.String) {      return new StringReader((String)obj);     } else {      String[] id = (String[]) obj;      return this.openExternalEntity(xmlReader, id[0], id[1]);}}", "nl": "Returns a Java reader containing the value of an entity"}
{"code": "public void write(IXMLElement xml)     throws IOException    {     this.write(xml, false, 0, true);}", "nl": "Writes an XML element"}
{"code": "public XMLWriter(Writer writer)    {     if (writer instanceof PrintWriter) {      this.writer = (PrintWriter) writer;     } else {      this.writer = new PrintWriter(writer);}}", "nl": "Creates a new XML writer"}
{"code": "protected JMenuBar createMenuBar(View v) {     JMenuBar mb = new JMenuBar();          JMenu fileMenu = null;     JMenu editMenu = null;     JMenu helpMenu = null;     JMenu viewMenu = null;     JMenu windowMenu = null;     String fileMenuText = labels.getString(\"file.text\");     String editMenuText = labels.getString(\"edit.text\");     String viewMenuText = labels.getString(\"view.text\");     String windowMenuText = labels.getString(\"window.text\");     String helpMenuText = labels.getString(\"help.text\");     for (JMenu mm : getModel().createMenus(this, v)) {       String text = mm.getText();       if (text == null) {         mm.setText(\"-null-\");       } else if (text.equals(fileMenuText)) {         fileMenu = mm;         continue;       } else if (text.equals(editMenuText)) {         editMenu = mm;         continue;       } else if (text.equals(viewMenuText)) {         viewMenu = mm;         continue;       } else if (text.equals(windowMenuText)) {         windowMenu = mm;         continue;       } else if (text.equals(helpMenuText)) {         helpMenu = mm;         continue;       }       mb.add(mm);     }          if (fileMenu == null) {       fileMenu = createFileMenu(v);     }     if (editMenu == null) {       editMenu = createEditMenu(v);     }     if (viewMenu == null) {       viewMenu = createViewMenu(v);     }     if (windowMenu == null) {       windowMenu = createWindowMenu(v);     }     if (helpMenu == null) {       helpMenu = createHelpMenu(v);     }          if (fileMenu != null) {       mb.add(fileMenu, 0);     }     if (editMenu != null) {       mb.add(editMenu, Math.min(1, mb.getComponentCount()));     }     if (viewMenu != null) {       mb.add(viewMenu, Math.min(2, mb.getComponentCount()));     }     if (windowMenu != null) {       mb.add(windowMenu);     }     if (helpMenu != null) {       mb.add(helpMenu);     }     return mb;}", "nl": "Creates a menu bar"}
{"code": "protected Component wrapDesktopPane(Component c, LinkedList<Action> toolBarActions) {     if (getModel() != null) {       int id = 0;       for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, null))) {         id++;         JPanel panel = new JPanel(new BorderLayout());         panel.add(tb, BorderLayout.NORTH);         panel.add(c, BorderLayout.CENTER);         c = panel;         PreferencesUtil.installToolBarPrefsHandler(prefs, \"toolbar.\" + id, tb);         toolBarActions.addFirst(new ToggleToolBarAction(tb, tb.getName()));       }     }     return c;}", "nl": "Returns the wrapped desktop pane"}
{"code": "public String getNamespace() {     return this.namespace;}", "nl": "Returns the namespace of the element"}
{"code": "public ArrayList getChildren() {     return this.children;}", "nl": "Returns a vector containing all the child iterator"}
{"code": "protected void maybeAddSeparator(JMenu m) {     m.putClientProperty(\"needsSeparator\", Boolean.TRUE);}", "nl": "Adds a separator to the supplied menu"}
{"code": "public String getAttributeType(String name,       String namespace) {     XMLAttribute attr = this.findAttribute(name, namespace);     if (attr == null) {       return null;     } else {       return attr.getType();}}", "nl": "Returns the type of an attribute"}
{"code": "public void addChild(IXMLElement child) {     if (child == null) {       throw new IllegalArgumentException(\"child must not be null\");     }     if ((child.getName() == null) && (! this.children.isEmpty())) {       IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);              if (lastChild.getName() == null) {         lastChild.setContent(lastChild.getContent()         + child.getContent());         return;       }     }     ((XMLElement)child).parent = this;     this.children.add(child);}", "nl": "Adds a child element"}
{"code": "public IXMLElement getFirstChildNamed(String name,       String namespace) {     Iterator enm = this.children.iterator();     while (enm.hasNext()) {       IXMLElement child = (IXMLElement) enm.next();       String str = child.getName();       boolean found = (str != null) && (str.equals(name));       str = child.getNamespace();       if (str == null) {         found &= (name == null);       } else {         found &= str.equals(namespace);       }       if (found) {         return child;       }     }     return null;}", "nl": "Searches a child element"}
{"code": "protected void addAction(JMenu m, Action a) {     if (a != null) {       if (m.getClientProperty(\"needsSeparator\") == Boolean.TRUE) {         m.addSeparator();         m.putClientProperty(\"needsSeparator\", null);       }       JMenuItem mi;       mi = m.add(a);       mi.setIcon(null);       mi.setToolTipText(null);}}", "nl": "Adds the specified action as a menu item to the supplied menu"}
{"code": "public View getActiveView() {     return activeView;}", "nl": "Gets the active view"}
{"code": "public void removeChildAtIndex(int index) {     this.children.remove(index);}", "nl": "Removes the child located at a certain index"}
{"code": "public void setActionMap(ActionMap m) {     actionMap = m;}", "nl": "Sets the application - wide action map"}
{"code": "protected void addMenuItem(JMenu m, JMenuItem mi) {     if (mi != null) {       if (m.getClientProperty(\"needsSeparator\") == Boolean.TRUE) {         m.addSeparator();         m.putClientProperty(\"needsSeparator\", null);       }       m.add(mi);}}", "nl": "Adds the specified action as a menu item to the supplied menu"}
{"code": "public boolean equals(Object rawElement) {     try {       return this.equalsXMLElement((IXMLElement) rawElement);     } catch (ClassCastException e) {       return false;}}", "nl": "Returns true if the element equals another element"}
{"code": "public String getName() {     return this.name;}", "nl": "Returns the name of the element"}
{"code": "public int getAttribute(String name,       int  defaultValue) {     String value = this.getAttribute(name, Integer.toString(defaultValue));     return Integer.parseInt(value);}", "nl": "Returns the value of an attribute"}
{"code": "public XMLElement(String fullName) {     this(fullName, null, null, NO_LINE);}", "nl": "Creates an empty element"}
{"code": "public XMLElement() {     this(null, null, null, NO_LINE);}", "nl": "Creates an empty element to be used for # PCDATA content"}
{"code": "public String getContent() {     return this.content;}", "nl": "Return the # PCDATA content of the element"}
{"code": "public boolean equalsXMLElement(IXMLElement elt) {     if (! this.name.equals(elt.getName())) {       return false;     }     if (this.attributes.size() != elt.getAttributeCount()) {       return false;     }     Iterator enm = this.attributes.iterator();     while (enm.hasNext()) {       XMLAttribute attr = (XMLAttribute) enm.next();       if (! elt.hasAttribute(attr.getName(), attr.getNamespace())) {         return false;       }       String value = elt.getAttribute(attr.getName(),           attr.getNamespace(),           null);       if (! attr.getValue().equals(value)) {         return false;       }       String type = elt.getAttributeType(attr.getName(),           attr.getNamespace());       if (! attr.getType().equals(type)) {         return false;       }     }     if (this.children.size() != elt.getChildrenCount()) {       return false;     }     for (int i = 0; i < this.children.size(); i++) {       IXMLElement child1 = this.getChildAtIndex(i);       IXMLElement child2 = elt.getChildAtIndex(i);              if (! child1.equalsXMLElement(child2)) {         return false;       }     }     return true;}", "nl": "Returns true if the element equals another element"}
{"code": "public int getLineNr() {     return this.lineNr;}", "nl": "Returns the line number in the data where the element started"}
{"code": "public void removeChild(IXMLElement child) {     if (child == null) {       throw new IllegalArgumentException(\"child must not be null\");     }     this.children.remove(child);}", "nl": "Removes a child element"}
{"code": "public IXMLElement createPCDataElement() {     return new XMLElement();}", "nl": "Creates an element to be used for # PCDATA content"}
{"code": "public XMLElement(String fullName,       String namespace) {     this(fullName, namespace, null, NO_LINE);}", "nl": "Creates an empty element"}
{"code": "public String getAttributeNamespace(String name) {     XMLAttribute attr = this.findAttribute(name);     if (attr == null) {       return null;     } else {       return attr.getNamespace();}}", "nl": "Returns the namespace of an attribute"}
{"code": "public ArrayList getChildrenNamed(String name) {     ArrayList result = new ArrayList(this.children.size());     Iterator enm = this.children.iterator();     while (enm.hasNext()) {       IXMLElement child = (IXMLElement) enm.next();       String childName = child.getFullName();       if ((childName != null) && childName.equals(name)) {         result.add(child);       }     }     return result;}", "nl": "Returns a vector of all child iterator named name"}
{"code": "public IXMLElement getFirstChildNamed(String name) {     Iterator enm = this.children.iterator();     while (enm.hasNext()) {       IXMLElement child = (IXMLElement) enm.next();       String childName = child.getFullName();       if ((childName != null) && childName.equals(name)) {         return child;       }     }     return null;}", "nl": "Searches a child element"}
{"code": "public int getAttributeCount() {     return this.attributes.size();}", "nl": "Returns the number of attributes"}
{"code": "public XMLElement(String fullName,       String systemID,       int  lineNr) {     this(fullName, null, systemID, lineNr);}", "nl": "Creates an empty element"}
{"code": "public XMLElement(String fullName,       String namespace,       String systemID,       int  lineNr) {     this.attributes = new ArrayList();     this.children = new ArrayList(8);     this.fullName = fullName;     if (namespace == null) {       this.name = fullName;     } else {       int index = fullName.indexOf(':');       if (index >= 0) {         this.name = fullName.substring(index + 1);       } else {         this.name = fullName;       }     }     this.namespace = namespace;     this.content = null;     this.lineNr = lineNr;     this.systemID = systemID;     this.parent = null;}", "nl": "Creates an empty element"}
{"code": "public IXMLElement createElement(String fullName) {     return new XMLElement(fullName);}", "nl": "Creates an empty element"}
{"code": "public void setName(String fullName,       String namespace) {     int index = fullName.indexOf(':');     if ((namespace == null) || (index < 0)) {       this.name = fullName;     } else {       this.name = fullName.substring(index + 1);     }     this.fullName = fullName;     this.namespace = namespace;}", "nl": "Sets the name"}
{"code": "public boolean hasAttribute(String name) {     return this.findAttribute(name) != null;}", "nl": "Returns whether an attribute exists"}
{"code": "public boolean isLeaf() {     return this.children.isEmpty();}", "nl": "Returns whether the element is a leaf element"}
{"code": "private XMLAttribute findAttribute(String fullName) {     Iterator enm = this.attributes.iterator();     while (enm.hasNext()) {       XMLAttribute attr = (XMLAttribute) enm.next();       if (attr.getFullName().equals(fullName)) {         return attr;       }     }     return null;}", "nl": "Searches an attribute"}
{"code": "private XMLAttribute findAttribute(String name,       String namespace) {     Iterator enm = this.attributes.iterator();     while (enm.hasNext()) {       XMLAttribute attr = (XMLAttribute) enm.next();       boolean found = attr.getName().equals(name);       if (namespace == null) {         found &= (attr.getNamespace() == null);       } else {         found &= namespace.equals(attr.getNamespace());       }              if (found) {         return attr;       }     }     return null;}", "nl": "Searches an attribute"}
{"code": "public int getChildrenCount() {     return this.children.size();}", "nl": "Returns the number of children"}
{"code": "public double getDoubleAttribute(String name,       String namespace,       double defaultValue) {     XMLAttribute attr = this.findAttribute(name, namespace);     if (attr == null) {       return defaultValue;     } else {       try {         return Double.parseDouble(attr.getValue());       } catch (NumberFormatException e) {         return defaultValue;}}}", "nl": "Returns an attribute of the element"}
{"code": "public ArrayList getChildrenNamed(String name,       String namespace) {     ArrayList result = new ArrayList(this.children.size());     Iterator enm = this.children.iterator();     while (enm.hasNext()) {       IXMLElement child = (IXMLElement) enm.next();       String str = child.getName();       boolean found = (str != null) && (str.equals(name));       str = child.getNamespace();       if (str == null) {         found &= (name == null);       } else {         found &= str.equals(namespace);       }              if (found) {         result.add(child);       }     }     return result;}", "nl": "Returns a vector of all child iterator named name"}
{"code": "public Object getAttribute(String name, String namespace,       Map valueSet,       String  defaultKey) {     String key = this.getAttribute(name, namespace, null);     if (key == null || ! valueSet.containsKey(key)) {       return valueSet.get(defaultKey);     }     return valueSet.get(key);}", "nl": "Returns an attribute by looking up a key in a hashtable"}
{"code": "public String getSystemID() {     return this.systemID;}", "nl": "Returns the system ID of the data where the element started"}
{"code": "public String getAttributeType(String name) {     XMLAttribute attr = this.findAttribute(name);     if (attr == null) {       return null;     } else {       return attr.getType();}}", "nl": "Returns the type of an attribute"}
{"code": "public IXMLElement getChildAtIndex(int index)   throws ArrayIndexOutOfBoundsException {     return (IXMLElement) this.children.get(index);}", "nl": "Returns the child at a specific index"}
{"code": "public Iterator iterateChildren() {     return this.children.iterator();}", "nl": "Returns an enumeration of all child iterator"}
{"code": "public void setName(String name) {     this.name = name;     this.fullName = name;     this.namespace = null;}", "nl": "Sets the full name"}
{"code": "public void insertChild(IXMLElement child,       int     index) {     if (child == null) {       throw new IllegalArgumentException(\"child must not be null\");     }     if ((child.getName() == null) && (! this.children.isEmpty())) {       IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);       if (lastChild.getName() == null) {         lastChild.setContent(lastChild.getContent()         + child.getContent());         return;       }     }     ((XMLElement) child).parent = this;     this.children.add(index, child);}", "nl": "Inserts a child element"}
{"code": "public String getAttribute(String name,       String defaultValue) {     XMLAttribute attr = this.findAttribute(name);     if (attr == null) {       return defaultValue;     } else {       return attr.getValue();}}", "nl": "Returns the value of an attribute"}
{"code": "public void setAttribute(String fullName,       String namespace,       String value) {     int index = fullName.indexOf(':');     String name = fullName.substring(index + 1);     XMLAttribute attr = this.findAttribute(name, namespace);     if (attr == null) {       attr = new XMLAttribute(fullName, name, namespace, value, \"CDATA\");       this.attributes.add(attr);     } else {       attr.setValue(value);}}", "nl": "Sets an attribute"}
{"code": "protected Component wrapViewComponent(View p) {     JComponent c = p.getComponent();     if (getModel() != null) {       LinkedList<Action> toolBarActions = new LinkedList<Action>();       int id = 0;       for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, p))) {         id++;         JPanel panel = new JPanel(new BorderLayout());         panel.add(tb, BorderLayout.NORTH);         panel.add(c, BorderLayout.CENTER);         c = panel;         PreferencesUtil.installToolBarPrefsHandler(prefs, \"toolbar.\" + id, tb);         toolBarActions.addFirst(new ToggleVisibleAction(tb, tb.getName()));       }       p.getComponent().putClientProperty(\"toolBarActions\", toolBarActions);     }     return c;}", "nl": "Returns the view component"}
{"code": "public static IXMLReader stringReader(String str)    {     return new StdXMLReader(new StringReader(str));}", "nl": "Creates a new reader using a string as input"}
{"code": "public static IXMLReader fileReader(String filename)     throws FileNotFoundException,        IOException    {     StdXMLReader r = new StdXMLReader(new FileInputStream(filename));     r.setSystemID(filename);     for (int i = 0; i < r.readers.size(); i++) {      StackedReader sr = (StackedReader) r.readers.elementAt(i);      sr.systemId = r.currentReader.systemId;     }     return r;}", "nl": "Creates a new reader using a file as input"}
{"code": "public String getSystemID()    {     return this.currentReader.systemId.toString();}", "nl": "Returns the current system ID"}
{"code": "public int getLineNr()    {     if (this.currentReader.lineReader == null) {      StackedReader sr = (StackedReader) this.readers.peek();      if (sr.lineReader == null) {       return 0;      } else {       return sr.lineReader.getLineNumber() + 1;      }     }     return this.currentReader.lineReader.getLineNumber() + 1;}", "nl": "Returns the line number of the data in the current stream"}
{"code": "protected String getEncoding(String str)    {     if (! str.startsWith(\"<?xml\")) {      return null;     }     int index = 5;     while (index < str.length()) {      StringBuffer key = new StringBuffer();      while ((index < str.length()) && (str.charAt(index) <= ' ')) {       index++;      }      while ((index < str.length())         && (str.charAt(index) >= 'a')         && (str.charAt(index) <= 'z')) {       key.append(str.charAt(index));       index++;      }      while ((index < str.length()) && (str.charAt(index) <= ' ')) {       index++;      }      if ((index >= str.length()) || (str.charAt(index) != '=')) {       break;      }      while ((index < str.length()) && (str.charAt(index) != '\\'')         && (str.charAt(index) != '\"')) {       index++;      }      if (index >= str.length()) {       break;      }      char delimiter = str.charAt(index);      index++;      int index2 = str.indexOf(delimiter, index);      if (index2 < 0) {       break;      }      if (key.toString().equals(\"encoding\")) {       return str.substring(index, index2);      }      index = index2 + 1;     }     return null;}", "nl": "Scans the encoding from an & lt ; ? xml"}
{"code": "public char read()     throws IOException    {     int ch = this.currentReader.pbReader.read();     while (ch < 0) {      if (this.readers.empty()) {       throw new IOException(\"Unexpected EOF\");      }      this.currentReader.pbReader.close();      this.currentReader = (StackedReader) this.readers.pop();      ch = this.currentReader.pbReader.read();     }     return (char) ch;}", "nl": "Reads a character"}
{"code": "public boolean atEOF()     throws IOException    {     int ch = this.currentReader.pbReader.read();     while (ch < 0) {      if (this.readers.empty()) {       return true;      }      this.currentReader.pbReader.close();      this.currentReader = (StackedReader) this.readers.pop();      ch = this.currentReader.pbReader.read();     }     this.currentReader.pbReader.unread(ch);     return false;}", "nl": "Returns true if there are no more characters left to be read"}
{"code": "public boolean atEOFOfCurrentStream()     throws IOException    {     int ch = this.currentReader.pbReader.read();     if (ch < 0) {      return true;     } else {      this.currentReader.pbReader.unread(ch);      return false;}}", "nl": "Returns true if the current stream has no more characters left to be read"}
{"code": "public void setSystemID(String systemID)     throws MalformedURLException    {     this.currentReader.systemId = new URL(this.currentReader.systemId,                       systemID);}", "nl": "Sets the system ID of the current stream"}
{"code": "protected void finalize()     throws Throwable    {     this.currentReader.lineReader = null;     this.currentReader.pbReader = null;     this.currentReader.systemId = null;     this.currentReader.publicId = null;     this.currentReader = null;     this.readers.clear();     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "public int getStreamLevel()    {     return this.readers.size();}", "nl": "Returns the current level of the stream on the stack of streams"}
{"code": "public void invalidAttributeValue(String systemID,                    int  lineNr,                    String elementName,                    String attributeName,                    String attributeValue)     throws XMLValidationException    {     XMLUtil.errorInvalidAttributeValue(systemID, lineNr, elementName,                      attributeName, attributeValue);}", "nl": "Throws an XMLValidationException to indicate that an attribute has an invalid value"}
{"code": "public ValidatorPlugin()    {     this.delegate = null;}", "nl": "Initializes the plugin"}
{"code": "protected void finalize()     throws Throwable    {     this.delegate = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "public void setDelegate(IXMLValidator delegate)    {     this.delegate = delegate;}", "nl": "Sets the delegate"}
{"code": "public void unexpectedAttribute(String systemID,                    int  lineNr,                    String elementName,                    String attributeName)     throws XMLValidationException    {     XMLUtil.errorUnexpectedAttribute(systemID, lineNr, elementName,                      attributeName);}", "nl": "Throws an XMLValidationException to indicate that an attribute is unexpected"}
{"code": "public StdXMLBuilder()    {     this(new XMLElement());}", "nl": "Creates the builder"}
{"code": "public StdXMLBuilder(IXMLElement prototype)    {     this.stack = null;     this.root = null;     this.prototype = prototype;}", "nl": "Creates the builder"}
{"code": "public void addPCData(Reader reader,              String systemID,              int  lineNr)    {     int bufSize = 2048;     int sizeRead = 0;     StringBuffer str = new StringBuffer(bufSize);     char[] buf = new char[bufSize];     for (;;) {      if (sizeRead >= bufSize) {       bufSize *= 2;       str.ensureCapacity(bufSize);      }      int size;      try {       size = reader.read(buf);      } catch (IOException e) {       break;      }      if (size < 0) {       break;      }      str.append(buf, 0, size);      sizeRead += size;     }     IXMLElement elt = this.prototype.createElement(null, systemID, lineNr);     elt.setContent(str.toString());     if (! this.stack.empty()) {      IXMLElement top = (IXMLElement) this.stack.peek();      top.addChild(elt);}}", "nl": "This method is called when a PCDATA element is encountered"}
{"code": "public void startBuilding(String systemID,                int  lineNr)    {     this.stack = new Stack();     this.root = null;}", "nl": "This method is called before the parser starts processing its input"}
{"code": "public void startElement(String name,               String nsPrefix,               String nsURI,               String systemID,               int  lineNr)    {     String fullName = name;     if (nsPrefix != null) {      fullName = nsPrefix + ':' + name;     }     IXMLElement elt = this.prototype.createElement(fullName, nsURI,                            systemID, lineNr);     if (this.stack.empty()) {      this.root = elt;     } else {      IXMLElement top = (IXMLElement) this.stack.peek();      top.addChild(elt);     }     this.stack.push(elt);}", "nl": "This method is called when a new XML element is encountered"}
{"code": "public void setReader(IXMLReader reader)    {     this.reader = reader;}", "nl": "Sets the reader from which the parser retrieves its data"}
{"code": "public void setValidator(IXMLValidator validator)    {     this.validator = validator;}", "nl": "Sets the validator that validates the XML data"}
{"code": "public void setResolver(IXMLEntityResolver resolver)    {     this.entityResolver = resolver;}", "nl": "Sets the entity resolver"}
{"code": "protected void scanSomeTag(boolean  allowCDATA,                 String   defaultNamespace,                 Properties namespaces)     throws Exception    {     String str = XMLUtil.read(this.reader, '&');     char ch = str.charAt(0);     if (ch == '&') {      XMLUtil.errorUnexpectedEntity(reader.getSystemID(),                      reader.getLineNr(),                      str);     }     switch (ch) {      case '?':       this.processPI();       break;      case '!':       this.processSpecialTag(allowCDATA);       break;      default:       this.reader.unread(ch);       this.processElement(defaultNamespace, namespaces);}}", "nl": "Scans an XML tag"}
{"code": "protected void processElement(String   defaultNamespace,                  Properties namespaces)     throws Exception    {     String fullName = XMLUtil.scanIdentifier(this.reader);     String name = fullName;     XMLUtil.skipWhitespace(this.reader, null);     String prefix = null;     int colonIndex = name.indexOf(':');     if (colonIndex > 0) {      prefix = name.substring(0, colonIndex);      name = name.substring(colonIndex + 1);     }     Vector attrNames = new Vector();     Vector attrValues = new Vector();     Vector attrTypes = new Vector();     this.validator.elementStarted(fullName,                   this.reader.getSystemID(),                   this.reader.getLineNr());     char ch;     for (;;) {      ch = this.reader.read();      if ((ch == '/') || (ch == '>')) {       break;      }      this.reader.unread(ch);      this.processAttribute(attrNames, attrValues, attrTypes);      XMLUtil.skipWhitespace(this.reader, null);     }     Properties extraAttributes = new Properties();     this.validator.elementAttributesProcessed(fullName,                         extraAttributes,                         this.reader.getSystemID(),                         this.reader.getLineNr());     Enumeration enm = extraAttributes.keys();     while (enm.hasMoreElements()) {      String key = (String) enm.nextElement();      String value = extraAttributes.getProperty(key);      attrNames.addElement(key);      attrValues.addElement(value);      attrTypes.addElement(\"CDATA\");     }     for (int i = 0; i < attrNames.size(); i++) {      String key = (String) attrNames.elementAt(i);      String value = (String) attrValues.elementAt(i);      String type = (String) attrTypes.elementAt(i);      if (key.equals(\"xmlns\")) {       defaultNamespace = value;      } else if (key.startsWith(\"xmlns:\")) {       namespaces.put(key.substring(6), value);      }     }     if (prefix == null) {      this.builder.startElement(name, prefix, defaultNamespace,                    this.reader.getSystemID(),                    this.reader.getLineNr());     } else {      this.builder.startElement(name, prefix,                    namespaces.getProperty(prefix),                    this.reader.getSystemID(),                    this.reader.getLineNr());     }     for (int i = 0; i < attrNames.size(); i++) {      String key = (String) attrNames.elementAt(i);      if (key.startsWith(\"xmlns\")) {       continue;      }      String value = (String) attrValues.elementAt(i);      String type = (String) attrTypes.elementAt(i);      colonIndex = key.indexOf(':');      if (colonIndex > 0) {       String attPrefix = key.substring(0, colonIndex);       key = key.substring(colonIndex + 1);       this.builder.addAttribute(key, attPrefix,                     namespaces.getProperty(attPrefix),                     value, type);      } else {       this.builder.addAttribute(key, null, null, value, type);      }     }     if (prefix == null) {      this.builder.elementAttributesProcessed(name, prefix,                          defaultNamespace);     } else {      this.builder.elementAttributesProcessed(name, prefix,                          namespaces                            .getProperty(prefix));     }     if (ch == '/') {      if (this.reader.read() != '>') {       XMLUtil.errorExpectedInput(reader.getSystemID(),                      reader.getLineNr(),                      \"`>'\");      }      this.validator.elementEnded(name,                    this.reader.getSystemID(),                    this.reader.getLineNr());      if (prefix == null) {       this.builder.endElement(name, prefix, defaultNamespace);      } else {       this.builder.endElement(name, prefix,                   namespaces.getProperty(prefix));      }      return;     }     StringBuffer buffer = new StringBuffer(16);     for (;;) {      buffer.setLength(0);      String str;      for (;;) {       XMLUtil.skipWhitespace(this.reader, buffer);       str = XMLUtil.read(this.reader, '&');       if ((str.charAt(0) == '&') && (str.charAt(1) != '#')) {          XMLUtil.processEntity(str, this.reader,                    this.entityResolver);       } else {          break;       }      }      if (str.charAt(0) == '<') {       str = XMLUtil.read(this.reader, '\\0');       if (str.charAt(0) == '/') {          XMLUtil.skipWhitespace(this.reader, null);          str = XMLUtil.scanIdentifier(this.reader);          if (! str.equals(fullName)) {           XMLUtil.errorWrongClosingTag(reader.getSystemID(),                          reader.getLineNr(),                          name, str);          }          XMLUtil.skipWhitespace(this.reader, null);          if (this.reader.read() != '>') {           XMLUtil.errorClosingTagNotEmpty(reader.getSystemID(),                           reader.getLineNr());          }          this.validator.elementEnded(fullName,                        this.reader.getSystemID(),                        this.reader.getLineNr());          if (prefix == null) {            this.builder.endElement(name, prefix, defaultNamespace);          } else {            this.builder.endElement(name, prefix,                        namespaces.getProperty(prefix));          }          break;       } else {           this.reader.unread(str.charAt(0));          this.scanSomeTag(true,                  defaultNamespace,                 (Properties) namespaces.clone());       }      } else {        if (str.charAt(0) == '&') {          ch = XMLUtil.processCharLiteral(str);          buffer.append(ch);       } else {          reader.unread(str.charAt(0));       }       this.validator.PCDataAdded(this.reader.getSystemID(),                      this.reader.getLineNr());       Reader r = new ContentReader(this.reader,                      this.entityResolver,                      buffer.toString());       this.builder.addPCData(r, this.reader.getSystemID(),                    this.reader.getLineNr());       r.close();}}}", "nl": "Processes a regular element"}
{"code": "protected void scanData()     throws Exception    {     while ((! this.reader.atEOF()) && (this.builder.getResult() == null)) {      String str = XMLUtil.read(this.reader, '&');      char ch = str.charAt(0);      if (ch == '&') {       XMLUtil.processEntity(str, this.reader, this.entityResolver);       continue;      }      switch (ch) {       case '<':          this.scanSomeTag(false,                  null,                   new Properties());          break;       case ' ':       case '\\t':       case '\\r':       case '\\n':                    break;       default:          XMLUtil.errorInvalidInput(reader.getSystemID(),                      reader.getLineNr(),                      \"`\" + ch + \"' (0x\"                      + Integer.toHexString((int) ch)                      + ')');}}}", "nl": "Scans the XML data for elements"}
{"code": "public IXMLValidator getValidator()    {     return this.validator;}", "nl": "Returns the validator that validates the XML data"}
{"code": "public PasteAction() {     this(null);}", "nl": "Creates a new instance which acts on the currently focused component"}
{"code": "protected void processCDATA()     throws Exception    {     if (! XMLUtil.checkLiteral(this.reader, \"CDATA[\")) {      XMLUtil.errorExpectedInput(reader.getSystemID(),                   reader.getLineNr(),                   \"<![[CDATA[\");     }     this.validator.PCDataAdded(this.reader.getSystemID(),                  this.reader.getLineNr());     Reader reader = new CDATAReader(this.reader);     this.builder.addPCData(reader, this.reader.getSystemID(),                this.reader.getLineNr());     reader.close();}", "nl": "Processes a CDATA section"}
{"code": "protected void processPI()     throws Exception    {     XMLUtil.skipWhitespace(this.reader, null);     String target = XMLUtil.scanIdentifier(this.reader);     XMLUtil.skipWhitespace(this.reader, null);     Reader reader = new PIReader(this.reader);     if (! target.equalsIgnoreCase(\"xml\")) {      this.builder.newProcessingInstruction(target, reader);     }     reader.close();}", "nl": "Processes a processing instruction"}
{"code": "public Object parse()     throws XMLException    {     try {      this.builder.startBuilding(this.reader.getSystemID(),                   this.reader.getLineNr());      this.scanData();      return this.builder.getResult();     } catch (XMLException e) {      throw e;     } catch (Exception e) {       XMLException error = new XMLException(e);       error.initCause(e);       throw error;}}", "nl": "Parses the data and lets the builder create the logical data structure"}
{"code": "public IXMLReader getReader()    {     return this.reader;}", "nl": "Returns the reader from which the parser retrieves its data"}
{"code": "@Override   protected void installViewListeners(View p) {     super.installViewListeners(p);     Action redoActionInView = p.getActionMap().get(ID);     if (redoActionInView != null && redoActionInView != this) {       redoActionInView.addPropertyChangeListener(redoActionPropertyListener);}}", "nl": "Installs listeners on the view object"}
{"code": "public RedoAction(Application app, View view) {     super(app, view);     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "@Override protected void installViewListeners(View p) {     super.installViewListeners(p);     Action undoActionInView = p.getActionMap().get(ID);     if (undoActionInView != null && undoActionInView != this) {     undoActionInView.addPropertyChangeListener(redoActionPropertyListener);}}", "nl": "Installs listeners on the view object"}
{"code": "XMLAttribute(String fullName,         String name,         String namespace,         String value,         String type)    {     this.fullName = fullName;     this.name = name;     this.namespace = namespace;     this.value = value;     this.type = type;}", "nl": "Creates a new attribute"}
{"code": "public UndoAction(Application app, View view) {     super(app, view);     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "void setValue(String value)    {     this.value = value;}", "nl": "Sets the value of the attribute"}
{"code": "String getValue()    {     return this.value;}", "nl": "Returns the value of the attribute"}
{"code": "public ClearSelectionAction() {     this(null);}", "nl": "Creates a new instance which acts on the currently focused component"}
{"code": "public DuplicateAction() {     this(null);}", "nl": "Creates a new instance which acts on the currently focused component"}
{"code": "public CopyAction(JComponent target) {     super(target);     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.app.Labels\");     labels.configureAction(this, ID);}", "nl": "Creates a new instance which acts on the specified component"}
{"code": "private static String buildMessage(String  systemID,                     int     lineNr,                     Exception e,                     String  msg,                     boolean   reportParams)    {     String str = msg;     if (reportParams) {      if (systemID != null) {       str += \", SystemID='\" + systemID + \"'\";      }      if (lineNr >= 0) {       str += \", Line=\" + lineNr;      }      if (e != null) {       str += \", Exception: \" + e;      }     }     return str;}", "nl": "Builds the exception message came exception occurred"}
{"code": "public CopyAction() {     this(null);}", "nl": "Creates a new instance which acts on the currently focused component"}
{"code": "public XMLException(String systemID,              int  lineNr,              String msg)    {     this(systemID, lineNr, null, msg, true);}", "nl": "Creates a new exception"}
{"code": "public XMLException(String systemID,              int  lineNr,              Exception e)    {     this(systemID, lineNr, e, \"Nested Exception\", true);}", "nl": "Creates a new exception"}
{"code": "public XMLException(String  systemID,              int     lineNr,              Exception e,              String  msg,              boolean   reportParams)    {     super(XMLException.buildMessage(systemID, lineNr, e, msg,                     reportParams));     this.systemID = systemID;     this.lineNr = lineNr;     this.encapsulatedException = e;     this.msg = XMLException.buildMessage(systemID, lineNr, e, msg,                        reportParams);}", "nl": "Creates a new exception"}
{"code": "public DeleteAction() {     this(null);}", "nl": "Creates a new instance which acts on the currently focused component"}
{"code": "public boolean contains(Point2D.Double p) {     return getOwner().contains(p);}", "nl": "Tests if a point is contained in the connector"}
{"code": "public Exception getException()    {     return this.encapsulatedException;}", "nl": "Returns the encapsulated exception , or null if no exception is encapsulated"}
{"code": "public AbstractConnector(Figure owner) {     this.owner = owner;}", "nl": "Constructs a connector with the given owner figure"}
{"code": "public void printStackTrace(PrintWriter writer)    {     super.printStackTrace(writer);     if (this.encapsulatedException != null) {      writer.println(\"*** Nested Exception:\");      this.encapsulatedException.printStackTrace(writer);}}", "nl": "Dumps the exception stack to a print writer"}
{"code": "protected Point2D.Double findPoint(ConnectionFigure connection) {     return Geom.center(getBounds());}", "nl": "Gets the connection point"}
{"code": "protected void setOwner(Figure newValue) {     owner = newValue;}", "nl": "Sets the connector ' s owner"}
{"code": "public void printStackTrace()    {     super.printStackTrace();     if (this.encapsulatedException != null) {      System.err.println(\"*** Nested Exception:\");      this.encapsulatedException.printStackTrace();}}", "nl": "Dumps the exception stack to System . err"}
{"code": "public AbstractConnector() {     owner = null;}", "nl": "Constructs a connector that has no owner"}
{"code": "public int getLineNr()    {     return this.lineNr;}", "nl": "Returns the line number in the XML data where the exception occurred"}
{"code": "public CutAction() {     this(null);}", "nl": "Creates a new instance which acts on the currently focused component"}
{"code": "@Override public boolean contains(Point2D.Double p) {     return getBounds().contains(p);}", "nl": "Tests if a point is contained in the connector"}
{"code": "public ZoomEditorAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {     this(editor, scaleFactor, button, true);}", "nl": "Creates a new instance"}
{"code": "@Override   public void actionPerformed(ActionEvent evt) {     final Application app = getApplication();     final String filename = evt.getActionCommand();     if (app.isEnabled()) {       app.setEnabled(false);              View emptyView = app.getActiveView();       if (emptyView == null           || emptyView.getURI() != null           || emptyView.hasUnsavedChanges()) {         emptyView = null;       }       final View p;       if (emptyView == null) {         p = app.createView();         app.add(p);         app.show(p);       } else {         p = emptyView;       }       openView(p, new File(filename).toURI());}}", "nl": "Opens a new view"}
{"code": "public OpenApplicationFileAction(Application app) {     super(app);     putValue(Action.NAME, \"OSX Open File\");}", "nl": "Creates a new instance"}
{"code": "protected void installViewListeners(View p) {     p.addPropertyChangeListener(viewListener);}", "nl": "Installs listeners on the view object"}
{"code": "@Override   public boolean isEnabled() {     return getActiveView() != null         && getActiveView().isEnabled()         && this.enabled;}", "nl": "Returns true if the action is enabled"}
{"code": "protected void updateView(View oldValue, View newValue) {          if (view == null) {       if (oldValue != null) {         uninstallViewListeners(oldValue);       }       if (newValue != null) {         installViewListeners(newValue);       }       firePropertyChange(VIEW_PROPERTY, oldValue, newValue);       updateEnabled(oldValue != null && oldValue.isEnabled(),           newValue != null && newValue.isEnabled());       updateView();}}", "nl": "Updates the listeners of this action depending on the current view of the application"}
{"code": "protected void setPropertyName(String name) {     this.propertyName = name;     if (name != null) {       updateView();}}", "nl": "Sets the property name"}
{"code": "protected String getPropertyName() {     return propertyName;}", "nl": "Gets the property name"}
{"code": "public AboutAction(Application app) {     super(app);     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.app.Labels\");     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "public AttributeChangeEdit(Figure owner, AttributeKey<T> name, T oldValue, T newValue) {     this.owner = owner;     this.name = name;     this.oldValue = oldValue;     this.newValue = newValue;}", "nl": "Creates a new instance"}
{"code": "public CompositeFigureEdit(Figure figure, String presentationName) {     super(presentationName);     this.figure = figure;}", "nl": "Creates new CompositeFigureEdit which uses the specified presentation name"}
{"code": "public CompositeFigureEdit(Figure figure, boolean isSignificant) {     super(isSignificant);     this.figure = figure;}", "nl": "Creates new CompositeFigureEdit which uses the specified significance"}
{"code": "public CompositeFigureEdit(Figure figure) {     this.figure = figure;}", "nl": "Creates a new CompositeFigureEdit which uses CompoundEdit . getPresentatioName and is significant"}
{"code": "public ArrowTip(double angle, double outerRadius, double innerRadius) {     this(angle, outerRadius, innerRadius, true, false, true);}", "nl": "Constructs an arrow tip with the specified angle and outer and inner radius"}
{"code": "public ArrowTip(double angle, double outerRadius, double innerRadius, boolean isFilled, boolean isStroked, boolean isSolid) {     super(isFilled, isStroked, isSolid);     this.angle = angle;     this.outerRadius = outerRadius;     this.innerRadius = innerRadius;}", "nl": "Constructs an arrow tip with the specified parameters"}
{"code": "public PerpendicularBar() {     this(10);}", "nl": "Constructs a perpendicular line with a height of 10"}
{"code": "public PerpendicularBar(double height) {     super(false, true, false);     this.height = height;}", "nl": "Constructs a perpendicular line with the given height"}
{"code": "protected Path2D.Double getDecoratorPath(Figure f) {     Path2D.Double path = new Path2D.Double();     double halfHeight = height / 2;     path.moveTo(+halfHeight, 0);     path.lineTo(-halfHeight, 0);     return path;}", "nl": "Calculates the path of the decorator"}
{"code": "public CompositeLineDecoration(LineDecoration decoration1, LineDecoration decoration2) {     addDecoration(decoration1);     addDecoration(decoration2);}", "nl": "Constructs a composite line decoration with the two supplied decorations"}
{"code": "public void addDecoration(LineDecoration decoration) {     if (decoration != null) {       decorations.add(decoration);}}", "nl": "Add another line decoration into the composite line decoration"}
{"code": "public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {     for (LineDecoration decoration : decorations) {       decoration.draw(g, f, p1, p2);}}", "nl": "Draws the arrow tip in the direction specified by the given two Points"}
{"code": "public Rectangle2D.Double getDrawingArea(Figure f, Point2D.Double p1, Point2D.Double p2) {     Rectangle2D.Double r = null;          for (LineDecoration decoration : decorations) {       Rectangle2D.Double aR = decoration.getDrawingArea(f, p1, p2);       if (r == null)         r = aR;       else         r.add(aR);     }          return r;}", "nl": "Returns the drawing area of the decorator"}
{"code": "public FigureEvent(Figure source, Rectangle2D.Double invalidatedArea) {     super(source);     this.invalidatedArea = invalidatedArea;}", "nl": "Constructs an event for the given source Figure"}
{"code": "public HandleEvent(Handle src, Rectangle invalidatedArea) {     super(src);     this.invalidatedArea = invalidatedArea;}", "nl": "Creates a new instance"}
{"code": "public CompositeFigureEvent(CompositeFigure source, Figure child, Rectangle2D.Double invalidatedArea, int zIndex) {     super(source);     this.child = child;     this.invalidatedArea = invalidatedArea;     this.index = 0;}", "nl": "Constructs an event for the provided CompositeFigure"}
{"code": "public Rectangle2D.Double getInvalidatedArea() {     return invalidatedArea;}", "nl": "Gets the bounds of the invalidated area on the drawing"}
{"code": "public Figure getChildFigure() {     return child;}", "nl": "Gets the changed child figure"}
{"code": "public CompositeFigure getCompositeFigure() {     return (CompositeFigure) getSource();}", "nl": "Gets the changed drawing"}
{"code": "public OpenFileAction(Application app) {     super(app);     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.app.Labels\");     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "public ClearRecentFilesMenuAction(Application app) {     super(app);     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.app.Labels\");     labels.configureAction(this, ID);     updateEnabled();}", "nl": "Creates a new instance"}
{"code": "@Override protected void installApplicationListeners(Application app) {     super.installApplicationListeners(app);     if (applicationListener == null) {       applicationListener = createApplicationListener();     }     app.addPropertyChangeListener(applicationListener);}", "nl": "Installs listeners on the application object"}
{"code": "public void areaInvalidated(FigureEvent evt) {     updateBounds();}", "nl": "Sent when a region used by the figure needs to be repainted"}
{"code": "public AbstractHandle(Figure owner) {     if (owner == null) {       throw new IllegalArgumentException(\"owner must not be null\");     }     this.owner = owner;     owner.addFigureListener(this);}", "nl": "Creates a new instance"}
{"code": "public Cursor getCursor() {     return Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);}", "nl": "Returns a cursor for the handle"}
{"code": "public LoadRecentFileAction(Application app, View view, URI uri) {     super(app, view);     this.uri = uri;     putValue(Action.NAME, URIUtil.getName(uri));}", "nl": "Creates a new instance"}
{"code": "public String getToolTipText(Point p) {     return toolTipText;}", "nl": "Returns a tooltip for the specified location"}
{"code": "public boolean isCombinableWith(Handle handle) {     return getClass().isAssignableFrom(handle.getClass());}", "nl": "Returns true , if the given handle is an instance of the same class or of a subclass of this handle ,"}
{"code": "public void trackStart(Point anchor, int modifiersEx) {     savedTarget = getTarget();     start = anchor;     savedLiner = getOwner().getLiner();     getOwner().setLiner(null);          fireHandleRequestSecondaryHandles();}", "nl": "Disconnects the connection"}
{"code": "protected Connector getSource() {     if (getTarget() == getOwner().getStartConnector()) {       return getOwner().getEndConnector();     }     return getOwner().getStartConnector();}", "nl": "Gets the side of the connection that is unaffected by the change"}
{"code": "public void trackStep(Point anchor, Point lead, int modifiersEx) {     Point2D.Double p = view.viewToDrawing(lead);     view.getConstrainer().constrainPoint(p);     connectableFigure = findConnectableFigure(p, view.getDrawing());     if (connectableFigure != null) {       Connector aTarget = findConnectionTarget(p, view.getDrawing());       if (aTarget != null) {         p = aTarget.getAnchor();       }     }     getOwner().willChange();     setLocation(p);     getOwner().changed();     repaintConnectors();}", "nl": "Finds a new connectableConnector of the connection"}
{"code": "@Override   public void draw(Graphics2D g) {     Graphics2D gg = (Graphics2D) g.create();     gg.transform(view.getDrawingToViewTransform());     for (Connector c : connectors) {       c.draw(gg);     }     gg.dispose();     if (getTarget() == null) {       drawCircle(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_FILL_COLOR),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_STROKE_COLOR));     } else {       drawCircle(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_FILL_COLOR),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_STROKE_COLOR));}}", "nl": "Draws this handle"}
{"code": "public void trackEnd(Point anchor, Point lead, int modifiersEx) {     ConnectionFigure f = getOwner();          if ((modifiersEx & (InputEvent.META_DOWN_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.ALT_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK)) != 0 &&         (modifiersEx & InputEvent.BUTTON2_DOWN_MASK) == 0) {       f.willChange();       int index = getBezierNodeIndex();       BezierPath.Node v = f.getNode(index);       if (index > 0 && index < f.getNodeCount()) {         v.mask = (v.mask + 3) % 4;       } else if (index == 0) {         v.mask = ((v.mask & BezierPath.C2_MASK) == 0) ? BezierPath.C2_MASK : 0;       } else {         v.mask = ((v.mask & BezierPath.C1_MASK) == 0) ? BezierPath.C1_MASK : 0;       }       f.setNode(index, v);       f.changed();       fireHandleRequestSecondaryHandles();     }     Point2D.Double p = view.viewToDrawing(lead);     view.getConstrainer().constrainPoint(p);     Connector target = findConnectionTarget(p, view.getDrawing());     if (target == null) {       target = savedTarget;     }     setLocation(p);     if (target != savedTarget) {       disconnect();       connect(target);     }     getOwner().setLiner(savedLiner);     getOwner().updateConnection();     connectableConnector = null;     connectors = Collections.emptyList();}", "nl": "Connects the figure to the new connectableConnector"}
{"code": "public Tool getTool() {     return (Tool) getSource();}", "nl": "Gets the tool which is the source of the event"}
{"code": "public BezierControlPointHandle(BezierFigure owner, int index, int coord) {     this(owner, index, coord, owner);}", "nl": "Creates a new instance"}
{"code": "public AbstractRotateHandle(Figure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "public ColorWheelImageProducer(ColorSystem sys, int w, int h) {     super(w, h, null, 0, w);     pixels = new int[w * h];     this.w = w;     this.h = h;     this.colorSystem = sys;     setAnimated(true);          newPixels(pixels, ColorModel.getRGBdefault(), 0, w);}", "nl": "Creates a new instance"}
{"code": "public DefaultBoundedRangeModel getBoundedRangeModel(int componentIndex) {     return componentModels[componentIndex];}", "nl": "Returns the bounded range model of the specified color componentIndex"}
{"code": "public void unconfigureSlider(JSlider slider) {     if (slider.getClientProperty(\"colorSliderModel\") == this) {                     slider.setModel(new DefaultBoundedRangeModel());       slider.putClientProperty(\"colorSliderModel\", null);       slider.putClientProperty(\"colorComponentIndex\", null);       removeColorSlider(slider);}}", "nl": "Unconfigures a JSlider from this AbstractColorSystem"}
{"code": "public int getSliderValue(int componentIndex) {     return componentModels[componentIndex].getValue();}", "nl": "Returns the value of the specified color componentIndex"}
{"code": "public void configureSlider(int componentIndex, JSlider slider) {     if (slider.getClientProperty(\"colorSliderModel\") != null) {       ((DefaultColorSliderModel) slider.getClientProperty(\"colorSliderModel\")).unconfigureSlider(slider);     }     if (!(slider.getUI() instanceof ColorSliderUI)) {       slider.setUI((ColorSliderUI) ColorSliderUI.createUI(slider));     }     slider.setModel(getBoundedRangeModel(componentIndex));     slider.putClientProperty(\"colorSliderModel\", this);     slider.putClientProperty(\"colorComponentIndex\", new Integer(componentIndex));     addColorSlider(slider);}", "nl": "Configures a JSlider for this AbstractColorSystem"}
{"code": "public void printJava2DAlternative(PrintableView v) {     Pageable pageable = v.createPageable();     if (pageable == null) {       throw new InternalError(\"View does not have a method named java.awt.Pageable createPageable()\");     }     try {       final PrinterJob job = PrinterJob.getPrinterJob();       PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();       attr.add(new PrinterResolution(300, 300, PrinterResolution.DPI));       job.setPageable(pageable);       if (job.printDialog(attr)) {         try {           job.print();         } catch (PrinterException e) {           ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.app.Labels\");           JSheet.showMessageSheet(getActiveView().getComponent(),               labels.getFormatted(\"couldntPrint\", e));         }       } else {         System.out.println(\"JOB ABORTED!\");       }     } catch (Throwable t) {       t.printStackTrace();}}", "nl": "This prints at 72 DPI only"}
{"code": "public PrintFileAction(Application app, View view) {     super(app, view);     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.app.Labels\");     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "public ViewPropertyAction(Application app, View view, String propertyName, Object propertyValue) {     this(app, view, propertyName, propertyValue.getClass(), propertyValue);}", "nl": "Creates a new instance"}
{"code": "public OpenRecentFileAction(Application app, URI uri) {     super(app);     this.uri = uri;     putValue(Action.NAME, URIUtil.getName(uri));}", "nl": "Creates a new instance"}
{"code": "public ToggleViewPropertyAction(Application app, View view, String propertyName) {     this(app, view, propertyName, Boolean.TYPE, true, false);}", "nl": "Creates a new instance"}
{"code": "public <T> T get(AttributeKey<T> key) {     return key.get(attributes);}", "nl": "Gets an attribute from the figure"}
{"code": "public <T> void set(AttributeKey<T> key, T newValue) {     if (forbiddenAttributes == null         || ! forbiddenAttributes.contains(key)) {       T oldValue = (T) key.put(attributes, newValue);       fireAttributeChanged(key, oldValue, newValue);}}", "nl": "Sets an attribute of the figure"}
{"code": "public Layouter getLayouter() {     return layouter;}", "nl": "Get a Layouter object which encapsulated a layout algorithm for this figure"}
{"code": "public synchronized void bringToFront(Figure figure) {     if (basicRemove(figure) != -1) {       basicAdd(figure);       fireAreaInvalidated(figure.getDrawingArea());}}", "nl": "Brings a figure to the front of the drawing"}
{"code": "public void setLayouter(Layouter newLayouter) {     this.layouter = newLayouter;}", "nl": "Set a Layouter object which encapsulated a layout algorithm for this figure"}
{"code": "public void removeAll(Collection<? extends Figure> figures) {     for (Figure f : figures) {       remove(f);}}", "nl": "Removes all specified children"}
{"code": "public synchronized void sendToBack(Figure figure) {     if (basicRemove(figure) != -1) {       basicAdd(0, figure);       fireAreaInvalidated(figure.getDrawingArea());}}", "nl": "Sends a figure to the back of the composite figure"}
{"code": "public void basicRemoveAllChildren() {     for (Figure f : new LinkedList<Figure>(getChildren())) {       basicRemove(f);}}", "nl": "Removes all children"}
{"code": "public void layout() {     if (getLayouter() != null) {       Rectangle2D.Double bounds = getBounds();       Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);       Rectangle2D.Double r = getLayouter().layout(           this, p, p);       setBounds(new Point2D.Double(r.x, r.y), new Point2D.Double(r.x + r.width, r.y + r.height));       invalidate();}}", "nl": "A layout algorithm is used to define how the child components should be laid out in relation to each other"}
{"code": "public JColorWheel() {     this(new HSVRGBColorSystem());}", "nl": "Creates a new instance"}
{"code": "public JHarmonicColorWheel() {     super(new HSLRYBColorSystem());     initComponents();     setRadialComponentIndex(2);     setVerticalComponentIndex(1);     getModel().setComponentValue(1, 1f);     setWheelInsets(new Insets(5, 5, 5, 5));     modelHandler = new ModelHandler();     DefaultHarmonicColorModel p = new DefaultHarmonicColorModel();     setHarmonicColorModel(p);     setToolTipText(\"\");}", "nl": "Creates new form"}
{"code": "@Override   public void draw(Graphics2D g) {     BezierFigure f = getOwner();     int size = f.getNodeCount();     boolean isClosed = f.isClosed();     Color fillColor;     Color strokeColor;     if (getEditor().getTool().supportsHandleInteraction()) {       fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR);       strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR);     } else {       fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR_DISABLED);       strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR_DISABLED);     }     if (size > index) {       BezierPath.Node v = f.getNode(index);       if (v.mask == 0 ||           index == 0 && v.mask == BezierPath.C1_MASK && !isClosed ||           index == size - 1 && v.mask == BezierPath.C2_MASK && !isClosed) {         drawRectangle(g, fillColor, strokeColor);       } else if (v.mask == BezierPath.C1_MASK ||           v.mask == BezierPath.C2_MASK ||           index == 0 && !isClosed ||           index == size - 1 && !isClosed) {         drawDiamond(g, fillColor, strokeColor);       } else {         drawCircle(g, fillColor, strokeColor);}}}", "nl": "Draws this handle"}
{"code": "public BezierNodeHandle(BezierFigure owner, int index) {     this(owner, index, owner);}", "nl": "Creates a new instance"}
{"code": "public ConnectorHandle(Connector connector, ConnectionFigure prototype) {     super(connector.getOwner());     this.connector = connector;     this.prototype = prototype;}", "nl": "Creates a new instance"}
{"code": "protected ConnectionFigure createConnection() {     return (ConnectionFigure) prototype.clone();}", "nl": "Creates the ConnectionFigure"}
{"code": "protected Connector findConnectableConnector(Figure connectableFigure, Point2D.Double p) {     Connector target = (connectableFigure == null) ? null : connectableFigure.findConnector(p, getConnection());     if ((connectableFigure != null) && connectableFigure.isConnectable() && !connectableFigure.includes(getOwner()) && getConnection().canConnect(connector, target)) {       return target;     }     return null;}", "nl": "Finds a connection end figure"}
{"code": "public FontSizeHandle(TextHolderFigure owner) {     super(owner, new FontSizeLocator());}", "nl": "Creates a new instance"}
{"code": "public void draw(Graphics2D g) {     drawCircle(g,          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_FILL_COLOR),         (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_STROKE_COLOR));}", "nl": "Draws this handle"}
{"code": "public BezierScaleHandle(BezierFigure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "public DragHandle(Figure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "protected void setLocation(Point2D.Double p) {     getOwner().willChange();     getOwner().setEndPoint(p);     getOwner().changed();}", "nl": "Sets the start point of the connection"}
{"code": "protected void disconnect() {     getOwner().setEndConnector(null);}", "nl": "Disconnects the start figure"}
{"code": "public ConnectionEndHandle(ConnectionFigure owner) {     super(owner);}", "nl": "Constructs the connection handle for the given start figure"}
{"code": "public BoundsOutlineHandle(Figure owner) {     this(owner, false, false);}", "nl": "Creates a bounds outline handle for resizing a component"}
{"code": "protected void disconnect() {     getOwner().setStartConnector(null);}", "nl": "Disconnects the start figure"}
{"code": "protected void setLocation(Point2D.Double p) {     getOwner().willChange();     getOwner().setStartPoint(p);     getOwner().changed();}", "nl": "Sets the start point of the connection"}
{"code": "protected void connect(Connector c) {     getOwner().setStartConnector(c);}", "nl": "Sets the start of the connection"}
{"code": "public ConnectionStartHandle(ConnectionFigure owner) {     super(owner);}", "nl": "Constructs the connection handle for the given start figure"}
{"code": "public boolean callTarget(Object appleEvent) throws InvocationTargetException, IllegalAccessException {     if (targetAction != null) {       targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, proxySignature));       return true;     } else {       Object result = targetMethod.invoke(targetObject, (Object[]) null);       if (result == null) {         return true;       }       return Boolean.valueOf(result.toString()).booleanValue();}}", "nl": "Override this method to perform any operations on the event that comes with the various callbacks"}
{"code": "protected boolean isCorrectMethod(Method method, Object[] args) {     return (proxySignature.equals(method.getName()) && args.length == 1);}", "nl": "Compare the method that was called to the intended method when the OSXAdapter instance was created"}
{"code": "protected OSXAdapter(String proxySignature, ActionListener handler) {     this.proxySignature = proxySignature;     this.targetAction = handler;}", "nl": "Each OSXAdapter has the name of the EAWT method it intends to listen for , the Object that will ultimately perform the task , and the Method to be called on that Object"}
{"code": "@Override   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (isCorrectMethod(method, args)) {       boolean handled = callTarget(args[0]);       setApplicationEventHandled(args[0], handled);     }               return null;}", "nl": "InvocationHandler implementation"}
{"code": "public PropertyChangeEdit(Object source, String propertyName, int oldValue, int newValue) {     this(source, propertyName, Integer.TYPE, oldValue, newValue);}", "nl": "Creates a new PropertyChangeEdit"}
{"code": "@Override   public boolean addEdit(UndoableEdit anEdit) {     if (anEdit instanceof PropertyChangeEdit) {       PropertyChangeEdit that = (PropertyChangeEdit) anEdit;       if (that.source == this.source && that.propertyName.equals(this.propertyName)) {         this.newValue = that.newValue;         return true;       }     }     return false;}", "nl": "Adds the specified edit to this one , if it is a PropertyChangeEdit from the same owner and the same property"}
{"code": "public PropertyChangeEdit(Object source, String propertyName, char oldValue, char newValue) {     this(source, propertyName, Character.TYPE, oldValue, newValue);}", "nl": "Creates a new PropertyChangeEdit"}
{"code": "public PropertyChangeEdit(Object source, String propertyName, float oldValue, float newValue) {     this(source, propertyName, Float.TYPE, oldValue, newValue);}", "nl": "Creates a new PropertyChangeEdit"}
{"code": "public PropertyChangeEdit(Object source, String propertyName, boolean oldValue, boolean newValue) {     this(source, propertyName, Boolean.TYPE, oldValue, newValue);}", "nl": "Creates a new PropertyChangeEdit"}
{"code": "protected Method getSetter() {     try {       return source.getClass().getMethod(\"set\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1), type);     } catch (Exception e) {       InternalError ie = new InternalError(\"Couldn't find setter for property \\\"\" + propertyName + \"\\\" in \" + source);       ie.initCause(e);       throw ie;}}", "nl": "Returns the setter for the property"}
{"code": "public PropertyChangeEdit(Object source, String propertyName, double oldValue, double newValue) {     this(source, propertyName, Double.TYPE, oldValue, newValue);}", "nl": "Creates a new PropertyChangeEdit"}
{"code": "@Override   public String getPresentationName() {     return presentationName;}", "nl": "Returns the presentation name of the undoable edit"}
{"code": "public void setPresentationName(String presentationName) {     this.presentationName = presentationName;}", "nl": "Sets the presentation name of the undoable edit"}
{"code": "public <T> PropertyChangeEdit(Object source, String propertyName, Class<T> type, T oldValue, T newValue) {     this.source = source;     this.propertyName = this.presentationName = propertyName;     this.type = type;     this.oldValue = oldValue;     this.newValue = newValue;}", "nl": "Creates a new PropertyChangeEdit"}
{"code": "public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {                    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners(propertyName)) {       if (l == listener) {         propertySupport.removePropertyChangeListener(propertyName, l);         break;       }       if (l instanceof WeakPropertyChangeListener) {         WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;         PropertyChangeListener target = wl.getTarget();         if (target == listener) {           propertySupport.removePropertyChangeListener(propertyName, l);           break;}}}}", "nl": "Removes a PropertyChangeListener"}
{"code": "public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {     propertySupport.addPropertyChangeListener(propertyName, listener);}", "nl": "Adds a PropertyChangeListener which can optionally be wrapped into a WeakPropertyChangeListener"}
{"code": "static public void addCornerResizeHandles(Figure f, Collection<Handle> handles) {     handles.add(southEast(f));     handles.add(southWest(f));     handles.add(northEast(f));     handles.add(northWest(f));}", "nl": "Creates handles for each corner of a figure and adds them to the provided collection"}
{"code": "public NullHandle(Figure owner, Locator locator) {     super(owner, locator);}", "nl": "Creates a new instance"}
{"code": "static public void addLeadHandles(Figure f, Collection<Handle> handles) {     handles.add(new NullHandle(f, new RelativeLocator(0f,0f)));     handles.add(new NullHandle(f, new RelativeLocator(0f,1f)));     handles.add(new NullHandle(f, new RelativeLocator(1f,0f)));     handles.add(new NullHandle(f, new RelativeLocator(1f,1f)));}", "nl": "Creates handles for each lead of a figure and adds them to the provided collection"}
{"code": "public RotateHandle(Figure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "@Override   public void draw(Graphics2D g) {     if (getOwner().isTransformable()) {       drawRectangle(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_FILL_COLOR),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_STROKE_COLOR));     } else {       drawRectangle(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_FILL_COLOR),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_STROKE_COLOR));}}", "nl": "Draws this handle"}
{"code": "static public void addMoveHandles(Figure f, Collection<Handle> handles) {     handles.add(southEast(f));     handles.add(southWest(f));     handles.add(northEast(f));     handles.add(northWest(f));}", "nl": "Creates handles for each corner of a figure and adds them to the provided collection"}
{"code": "public MoveHandle(Figure owner, Locator locator) {     super(owner, locator);}", "nl": "Creates a new instance"}
{"code": "public RoundRectangleRadiusHandle(Figure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "@Override   public void draw(Graphics2D g) {     if (getEditor().getTool().supportsHandleInteraction()) {       drawDiamond(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));     } else {       drawDiamond(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));}}", "nl": "Draws this handle"}
{"code": "public ColorTrackImageProducer(int w, int h, int trackBuffer, boolean isHorizontal) {     super(w, h, null, 0, w);     pixels = new int[w*h];     this.w = w;     this.h = h;          this.trackBuffer = (trackBuffer % 2 == 1) ? trackBuffer - 1 : trackBuffer;     this.componentIndex = componentIndex;     this.isHorizontal = isHorizontal;     newPixels(pixels, new DirectColorModel(24,               0x00ff0000,                 0x0000ff00,                 0x000000ff                 )               , 0, w);     setAnimated(true);}", "nl": "Creates a new instance"}
{"code": "protected int getTickLength() {     return 4;}", "nl": "Gets the height of the tick area for horizontal sliders and the width of the tick area for vertical sliders"}
{"code": "public ColorSliderUI(JSlider b)   {     super(b);}", "nl": "Creates a new instance"}
{"code": "public void mousePressed(MouseEvent e) {       if ( !slider.isEnabled() )         return;              currentMouseX = e.getX();       currentMouseY = e.getY();              if (slider.isRequestFocusEnabled()) {         slider.requestFocus();       }                     if (thumbRect.contains(currentMouseX, currentMouseY) ) {         super.mousePressed(e);       } else {         Dimension sbSize = slider.getSize();         int direction = POSITIVE_SCROLL;                  switch ( slider.getOrientation() ) {           case JSlider.VERTICAL:             slider.setValue(valueForYPosition(currentMouseY));             break;           case JSlider.HORIZONTAL:             slider.setValue(valueForXPosition(currentMouseX));             break;}}}", "nl": "If the mouse is pressed above the thumb component then reduce the scrollbars value by one page , otherwise increase it by one page"}
{"code": "private void initComponents() {     brightnessSlider = new javax.swing.JSlider();     setLayout(new java.awt.BorderLayout());     brightnessSlider.setMajorTickSpacing(50);     brightnessSlider.setOrientation(javax.swing.JSlider.VERTICAL);     brightnessSlider.setPaintTicks(true);     add(brightnessSlider, java.awt.BorderLayout.EAST);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "static public Locator north() {     return new RelativeDecoratorLocator(0.5, 0.0);}", "nl": "North"}
{"code": "static public void addCornerTransformHandles(Figure f, Collection<Handle> handles) {     handles.add(southEast(f));     handles.add(southWest(f));     handles.add(northEast(f));     handles.add(northWest(f));}", "nl": "Creates handles for each corner of a figure and adds them to the provided collection"}
{"code": "public RelativeDecoratorLocator(double relativeX, double relativeY) {     super(relativeX, relativeY);}", "nl": "Creates a new instance"}
{"code": "static public void addScaleMoveTransformHandles(Figure f, Collection<Handle> handles) {     addCornerTransformHandles(f, handles);     addEdgeTransformHandles(f, handles);}", "nl": "Adds handles for scaling and moving a Figure"}
{"code": "static public Locator northWest() {     return new RelativeDecoratorLocator(0.0, 0.0);}", "nl": "North west"}
{"code": "static public void addEdgeTransformHandles(Figure f, Collection<Handle> handles) {     handles.add(south(f));     handles.add(north(f));     handles.add(east(f));     handles.add(west(f));}", "nl": "Fills the given Vector with handles at each the north , south , east , and west of the figure"}
{"code": "static public Locator west() {     return new RelativeDecoratorLocator(0.0, 0.5);}", "nl": "West"}
{"code": "static public void addTransformHandles(Figure f, Collection<Handle> handles) {     handles.add(new BoundsOutlineHandle(f, true, false));     addCornerTransformHandles(f, handles);     addEdgeTransformHandles(f, handles);     handles.add(new RotateHandle(f));}", "nl": "Adds handles for scaling , moving , rotating and shearing a Figure"}
{"code": "static public Locator southWest() {     return new RelativeDecoratorLocator(0.0, 1.0);}", "nl": "South west"}
{"code": "static public Locator southEast() {     return new RelativeDecoratorLocator(1.0, 1.0);}", "nl": "South east"}
{"code": "public void draw(Graphics2D g) {       if (getEditor().getTool().supportsHandleInteraction()) {                           drawDiamond(g,             (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR),             (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR));                  } else {         drawDiamond(g,             (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR_DISABLED),             (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR_DISABLED));}}", "nl": "Draws this handle"}
{"code": "public BezierTool(BezierFigure prototype) {     this(prototype, null);}", "nl": "Creates a new instance"}
{"code": "public BezierTool(BezierFigure prototype, Map<AttributeKey, Object> attributes) {     this(prototype, attributes, null);}", "nl": "Creates a new instance"}
{"code": "public AbstractTool() {     editorProxy = new DrawingEditorProxy();     setInputMap(createInputMap());     setActionMap(createActionMap());}", "nl": "Creates a new instance"}
{"code": "public DOMStorableInputOutputFormat(       DOMFactory factory,       String description, String fileExtension, String mimeType) {     this.factory = factory;     this.fileExtension = fileExtension;     this.mimeType = mimeType;     try {       this.dataFlavor = new DataFlavor(mimeType);     } catch (ClassNotFoundException ex) {       InternalError error = new InternalError(\"Unable to create data flavor for mime type:\" + mimeType);       error.initCause(ex);       throw error;}}", "nl": "Creates a new instance using the specified parameters"}
{"code": "public DOMStorableInputOutputFormat(DOMFactory factory) {     this(factory, \"Drawing\", \"xml\", \"image/x-jhotdraw\");}", "nl": "Creates a new instance with format name Drawing , file extension xml and mime type image x - jhotdraw"}
{"code": "public InputMap getInputMap() {     return inputMap;}", "nl": "Gets the input map of the Tool"}
{"code": "public void setActionMap(ActionMap newValue) {     actionMap = newValue;}", "nl": "Sets the ActionMap for the Tool"}
{"code": "public void keyPressed(KeyEvent evt) {     if (!evt.isConsumed()) {       if (evt.getSource() instanceof Container) {         editor.setActiveView(editor.findView((Container) evt.getSource()));       }       Object obj = null;       if (inputMap != null) {                  obj = inputMap.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));       }       if (obj == null) {                  InputMap im = editor.getInputMap();         if (im != null) {           obj = im.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));         }       }       ActionListener al = null;       if (obj instanceof ActionListener) {         al = (ActionListener) obj;       } else if (obj != null) {                  if (actionMap != null) {           al = actionMap.get(obj);         }         if (al == null) {                      al = editor.getActionMap().get(obj);         }       }       if (al != null) {         evt.consume();         al.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"tool\", evt.getWhen(), evt.getModifiers()));         fireToolDone();}}}", "nl": "The Tool uses the InputMap to determine what to do , when a key is pressed"}
{"code": "protected void fireAreaInvalidated(Rectangle2D.Double r) {     Point p1 = getView().drawingToView(new Point2D.Double(r.x, r.y));     Point p2 = getView().drawingToView(new Point2D.Double(r.x + r.width, r.y + r.height));     fireAreaInvalidated(         new Rectangle(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y));}", "nl": "Notify all listenerList that have registered interest for notification on this event type"}
{"code": "public ActionMap getActionMap() {     return actionMap;}", "nl": "Gets the action map of the Tool"}
{"code": "public void write(OutputStream out, Drawing drawing,       AffineTransform drawingTransform, Dimension imageSize) throws IOException {     write(out, drawing, drawing.getChildren(), drawingTransform, imageSize);}", "nl": "Writes the drawing to the specified output stream"}
{"code": "public Transferable createTransferable(Drawing drawing, java.util.List<Figure> figures, double scaleFactor) throws IOException {     return new ImageTransferable(toImage(drawing, figures, scaleFactor, true));}", "nl": "Writes the drawing to the specified output stream"}
{"code": "public ImageOutputFormat(String formatName, String description, String fileExtension,       int bufferedImageType) {     this.formatName = formatName;     this.description = description;     this.fileExtension = fileExtension;     this.imageType = bufferedImageType;}", "nl": "Creates a new image output format for the specified image format"}
{"code": "public void write(OutputStream out, Drawing drawing) throws IOException {     write(out, drawing, drawing.getChildren(), null, null);}", "nl": "Writes the drawing to the specified output stream"}
{"code": "public BufferedImage toImage(       Drawing drawing,       java.util.List<Figure> figures,       AffineTransform transform,       Dimension imageSize) {               Color background = drawing.get(CANVAS_FILL_COLOR);     double opacity = drawing.get(CANVAS_FILL_OPACITY);     if (background == null) {       background = new Color(0xff, 0xff, 0xff, 0x0);     } else {       background = new Color(background.getRed(), background.getGreen(), background.getBlue(), (int)(background.getAlpha() * opacity));     }     BufferedImage buf = new BufferedImage(         Math.max(1,imageSize.width), Math.max(1,imageSize.height),         (background.getAlpha() == 255) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB         );     Graphics2D g = buf.createGraphics();               Composite savedComposite = g.getComposite();     g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));     g.setColor(background);     g.fillRect(0,0,buf.getWidth(),buf.getHeight());     g.setComposite(savedComposite);               setRenderingHints(g);     g.transform(transform);     for (Figure f : figures) {       f.draw(g);     }     g.dispose();               if (imageType != BufferedImage.TYPE_INT_ARGB) {       BufferedImage buf2 = new BufferedImage(           buf.getWidth(), buf.getHeight(),           imageType           );       g = buf2.createGraphics();       setRenderingHints(g);       g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));       g.drawImage(buf, 0, 0, null);       g.dispose();       buf.flush();       buf = buf2;     }          return buf;}", "nl": "Creates a BufferedImage from the specified list of figures"}
{"code": "static public Locator north(boolean isTransform) {     return new RelativeLocator(0.5, 0.0, isTransform);}", "nl": "North"}
{"code": "public RelativeLocator(double relativeX, double relativeY) {     this(relativeX, relativeY, false);}", "nl": "Creates a new instance"}
{"code": "static public Locator center() {     return center(false);}", "nl": "Non - transforming Center"}
{"code": "public void write(File file, Drawing drawing) throws IOException {     BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));     try {       write(out, drawing);     } finally {         out.close();}}", "nl": "Writes the drawing to the specified file"}
{"code": "static public Locator south(boolean isTransform) {     return new RelativeLocator(0.5, 1.0, isTransform);}", "nl": "South"}
{"code": "static public Locator north() {     return north(false);}", "nl": "Non - transforming North"}
{"code": "public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {     write(out, drawing, figures, null, null);}", "nl": "Writes the figures to the specified output stream"}
{"code": "static public Locator southEast() {     return southEast(false);}", "nl": "Non - transforming South east"}
{"code": "public RelativeLocator() {     this(0, 0, false);}", "nl": "Creates a new instance"}
{"code": "static public Locator northEast() {     return northEast(false);}", "nl": "Non - transforming North east"}
{"code": "static public Locator east(boolean isTransform) {     return new RelativeLocator(1.0, 0.5, isTransform);}", "nl": "East"}
{"code": "static public Locator west(boolean isTransform) {     return new RelativeLocator(0.0, 0.5, isTransform);}", "nl": "West"}
{"code": "public RelativeLocator(double relativeX, double relativeY, boolean isTransform) {     this.relativeX = relativeX;     this.relativeY = relativeY;     this.isTransform = isTransform;}", "nl": "x - position relative to bounds expressed as a value between 0 and 1"}
{"code": "static public Locator south() {     return south(false);}", "nl": "Non - transforming South"}
{"code": "static public Locator northWest(boolean isTransform) {     return new RelativeLocator(0.0, 0.0, isTransform);}", "nl": "North West"}
{"code": "static public Locator northWest() {     return northWest(false);}", "nl": "Non - transforming North west"}
{"code": "public void mouseDragged(java.awt.event.MouseEvent e) {     repaintConnectors(e);     if (createdFigure != null) {       createdFigure.willChange();       Point2D.Double endPoint = viewToDrawing(new Point(e.getX(), e.getY()));       getView().getConstrainer().constrainPoint(endPoint);       Figure endFigure = getDrawing().findFigureExcept(endPoint, createdFigure);       endConnector = (endFigure == null) ? null : endFigure.findConnector(endPoint, prototype);       if (endConnector != null && canConnect(createdFigure, startConnector, endConnector)) {         endPoint = endConnector.getAnchor();       }       Rectangle r = new Rectangle(getView().drawingToView(createdFigure.getEndPoint()));       createdFigure.setEndPoint(endPoint);       r.add(getView().drawingToView(endPoint));       r.grow(ANCHOR_WIDTH + 2, ANCHOR_WIDTH + 2);       getView().getComponent().repaint(r);       createdFigure.changed();}}", "nl": "Adjust the created connection"}
{"code": "public void repaintConnectors(MouseEvent evt) {     Rectangle2D.Double invalidArea = null;     Point2D.Double targetPoint = viewToDrawing(new Point(evt.getX(), evt.getY()));     Figure aFigure = getDrawing().findFigureExcept(targetPoint, createdFigure);     if (aFigure != null && !aFigure.isConnectable()) {       aFigure = null;     }     if (targetFigure != aFigure) {       for (Connector c : connectors) {         if (invalidArea == null) {           invalidArea = c.getDrawingArea();         } else {           invalidArea.add(c.getDrawingArea());         }       }       targetFigure = aFigure;       if (targetFigure != null) {         connectors = targetFigure.getConnectors(getPrototype());         for (Connector c : connectors) {           if (invalidArea == null) {             invalidArea = c.getDrawingArea();           } else {             invalidArea.add(c.getDrawingArea());           }         }       }     }     if (invalidArea != null) {       getView().getComponent().repaint(           getView().drawingToView(invalidArea));}}", "nl": "Updates the list of connectors that we draw when the user moves or drags the mouse over a figure to which can connect"}
{"code": "public void mousePressed(MouseEvent evt) {     super.mousePressed(evt);     getView().clearSelection();     Point2D.Double startPoint = viewToDrawing(anchor);     Figure startFigure = getDrawing().findFigure(startPoint);     startConnector = (startFigure == null) ? null : startFigure.findConnector(startPoint, prototype);     if (startConnector != null && canConnect(prototype, startConnector)) {       Point2D.Double anchor = startConnector.getAnchor();       createdFigure = createFigure();       createdFigure.setStartPoint(anchor);       createdFigure.setEndPoint(anchor);       getDrawing().add(createdFigure);       Rectangle r = new Rectangle(getView().drawingToView(anchor));       r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);       fireAreaInvalidated(r);     } else {       startConnector = null;       createdFigure = null;     }     endConnector = null;}", "nl": "Manipulates connections in a context dependent way"}
{"code": "public void setToolDoneAfterCreation(boolean newValue) {     boolean oldValue = isToolDoneAfterCreation;     isToolDoneAfterCreation = newValue;}", "nl": "If this is set to false , the CreationTool does not fire toolDone after a new Figure has been created"}
{"code": "protected boolean canConnect(ConnectionFigure f, Connector startConnector, Connector endConnector) {     return f.canConnect(startConnector, endConnector);}", "nl": "This method is called on the Figure , onto which the user wants to end a new connection"}
{"code": "public ConnectionTool(ConnectionFigure prototype) {     this(prototype, null, null);}", "nl": "Creates a new instance"}
{"code": "@SuppressWarnings(\"unchecked\")   protected ConnectionFigure createFigure() {     ConnectionFigure f = (ConnectionFigure) prototype.clone();     getEditor().applyDefaultAttributesTo(f);     if (prototypeAttributes != null) {       for (Map.Entry<AttributeKey, Object> entry : prototypeAttributes.entrySet()) {         f.set(entry.getKey(), entry.getValue());       }     }     return f;}", "nl": "Creates the ConnectionFigure"}
{"code": "public void createOverlay(DrawingView view) {     createOverlay(view, null);}", "nl": "Creates the overlay within the given container"}
{"code": "public String getText() {     return textArea.getText();}", "nl": "Gets the text contents of the overlay"}
{"code": "public FloatingTextArea() {     textArea = new JTextArea();     textArea.setWrapStyleWord(true);     textArea.setLineWrap(true);     editScrollContainer = new JScrollPane(textArea,         JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,         JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);     editScrollContainer.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));     editScrollContainer.setBorder(BorderFactory.createLineBorder(Color.black));}", "nl": "Constructor for the FloatingTextArea object"}
{"code": "public Dimension getPreferredSize(int cols) {     return new Dimension(textArea.getWidth(), textArea.getHeight());}", "nl": "Gets the preferred size of the overlay"}
{"code": "public void createOverlay(DrawingView view, TextHolderFigure figure) {     view.getComponent().add(editScrollContainer, 0);     editedFigure = figure;     this.view = view;     if (editedFigure != null) {       editedFigure.addFigureListener(figureHandler);       updateWidget();}}", "nl": "Creates the overlay for the given Container using a specific font"}
{"code": "public void setBounds(Rectangle2D.Double r, String text) {     textArea.setText(text);     editScrollContainer.setBounds(view.drawingToView(r));     editScrollContainer.setVisible(true);     textArea.setCaretPosition(0);     textArea.requestFocus();}", "nl": "Positions and sizes the overlay"}
{"code": "public void createOverlay(DrawingView view) {     createOverlay(view, null);}", "nl": "Creates the overlay for the given Component"}
{"code": "public Dimension getPreferredSize(int cols) {     textField.setColumns(cols);     return textField.getPreferredSize();}", "nl": "Gets the preferred size of the overlay"}
{"code": "public void addActionListener(ActionListener listener) {     textField.addActionListener(listener);}", "nl": "Adds an action listener"}
{"code": "public ElbowLiner() {     this(20);}", "nl": "Creates a new instance"}
{"code": "public CurvedLiner() {     this(20);}", "nl": "Creates a new instance"}
{"code": "public BezierLabelLocator(double relativePosition, double angle, double distance) {     this.relativePosition = relativePosition;     this.angle = angle;     this.distance = distance;}", "nl": "Creates a new locator"}
{"code": "public Point2D.Double getRelativePoint(BezierFigure owner) {     Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);     Point2D.Double nextPoint = owner.getPointOnPath(         (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,         3);          double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);     if (relativePosition >= 0.5) {       dir += Math.PI;     }     double alpha = dir + angle;          Point2D.Double p = new Point2D.Double(         point.x + distance * Math.cos(alpha),         point.y + distance * Math.sin(alpha)         );          if (Double.isNaN(p.x)) p = point;          return p;}", "nl": "Returns the coordinates of the relative point on the path of the specified bezier figure"}
{"code": "public Point2D.Double getRelativeLabelPoint(BezierFigure owner, Figure label) {          Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);     if (point == null) {       return new Point2D.Double(0,0);     }     Point2D.Double nextPoint = owner.getPointOnPath(         (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,         3);          double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);     if (relativePosition >= 0.5) {       dir += Math.PI;     }     double alpha = dir + angle;          Point2D.Double p = new Point2D.Double(         point.x + distance * Math.cos(alpha),         point.y + distance * Math.sin(alpha)         );     if (Double.isNaN(p.x)) p = point;          Dimension2DDouble labelDim = label.getPreferredSize();     if (relativePosition == 0.5 &&          p.x >= point.x - distance / 2 &&          p.x <= point.x + distance / 2) {       if (p.y >= point.y) {                  return new Point2D.Double(p.x - labelDim.width / 2, p.y);       } else {                  return new Point2D.Double(p.x - labelDim.width / 2, p.y - labelDim.height);       }     } else {       if (p.x >= point.x) {         if (p.y >= point.y) {                      return new Point2D.Double(p.x, p.y);         } else {                      return new Point2D.Double(p.x, p.y - labelDim.height);         }       } else {         if (p.y >= point.y) {                      return new Point2D.Double(p.x - labelDim.width,  p.y);         } else {                      return new Point2D.Double(p.x - labelDim.width, p.y - labelDim.height);}}}}", "nl": "Returns a Point2D . Double on the polyline that is at the provided relative position"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public JAttributeSlider() {     this(JSlider.VERTICAL, 0, 100, 50);}", "nl": "Creates new instance"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public static int outcode(Rectangle r1, Rectangle r2) {     int outcode = 0;     if (r2.x > r1.x + r1.width) {       outcode = OUT_RIGHT;     } else if (r2.x + r2.width < r1.x) {       outcode = OUT_LEFT;     }     if (r2.y > r1.y + r1.height) {       outcode |= OUT_BOTTOM;     } else if (r2.y + r2.height < r1.y) {       outcode |= OUT_TOP;     }     return outcode;}", "nl": "This method computes a binary OR of the appropriate mask values indicating , for each side of Rectangle r1 , whether or not the Rectangle r2 is on the same side of the edge as the rest of this Rectangle"}
{"code": "public static int range(int min, int max, int value) {     if (value < min) {       value = min;     }     if (value > max) {       value = max;     }     return value;}", "nl": "Constains a value to the given range"}
{"code": "public static double length(double x1, double y1, double x2, double y2) {     return sqrt(length2(x1, y1, x2, y2));}", "nl": "Gets the distance between to points"}
{"code": "public static double length2(double x1, double y1, double x2, double y2) {     return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);}", "nl": "Gets the square distance between two points"}
{"code": "public static boolean lineContainsPoint(int x1, int y1,       int x2, int y2,       int px, int py, double tolerance) {     Rectangle r = new Rectangle(new Point(x1, y1));     r.add(x2, y2);     r.grow(max(2, (int) ceil(tolerance)), max(2, (int) ceil(tolerance)));     if (!r.contains(px, py)) {       return false;     }     double a, b, x, y;     if (x1 == x2) {       return (abs(px - x1) <= tolerance);     }     if (y1 == y2) {       return (abs(py - y1) <= tolerance);     }     a = (double) (y1 - y2) / (double) (x1 - x2);     b = (double) y1 - a * (double) x1;     x = (py - b) / a;     y = a * px + b;     return (min(abs(x - px), abs(y - py)) <= tolerance);}", "nl": "Tests if a point is on a line"}
{"code": "public static Point2D.Double polarToPoint2D(double angle, double fx, double fy) {     double si = sin(angle);     double co = cos(angle);     return new Point2D.Double(fx * co + 0.5, fy * si + 0.5);}", "nl": "Converts a polar to a point"}
{"code": "public static double pointToAngle(Rectangle r, Point p) {     int px = p.x - (r.x + r.width / 2);     int py = p.y - (r.y + r.height / 2);     return atan2(py * r.width, px * r.height);}", "nl": "Gets the angle of a point relative to a rectangle"}
{"code": "public static boolean contains(Rectangle2D.Double r1, Rectangle2D.Double r2) {     return (r2.x >= r1.x &&         r2.y >= r1.y &&         (r2.x + max(0, r2.width)) <= r1.x + max(0, r1.width) &&         (r2.y + max(0, r2.height)) <= r1.y + max(0, r1.height));}", "nl": "Returns true , if rectangle 1 contains rectangle 2"}
{"code": "public static Point2D.Double angleToPoint(Rectangle2D.Double r, double angle) {     double si = sin(angle);     double co = cos(angle);     double e = 0.0001;     double x = 0, y = 0;     if (abs(si) > e) {       x = (1.0 + co / abs(si)) / 2.0 * r.width;       x = range(0, r.width, x);     } else if (co >= 0.0) {       x = r.width;     }     if (abs(co) > e) {       y = (1.0 + si / abs(co)) / 2.0 * r.height;       y = range(0, r.height, y);     } else if (si >= 0.0) {       y = r.height;     }     return new Point2D.Double(r.x + x, r.y + y);}", "nl": "Gets the point on a rectangle that corresponds to the given angle"}
{"code": "public static int direction(double x1, double y1, double x2, double y2) {     int direction = 0;     double vx = x2 - x1;     double vy = y2 - y1;     if (vy < vx && vx > -vy) {       direction = OUT_RIGHT;     } else if (vy > vx && vy > -vx) {       direction = OUT_TOP;     } else if (vx < vy && vx < -vy) {       direction = OUT_LEFT;     } else {       direction = OUT_BOTTOM;     }     return direction;}", "nl": "Returns the direction OUT _ TOP , OUT _ BOTTOM , OUT _ LEFT , OUT _ RIGHT from one point to another one"}
{"code": "public static Point angleToPoint(Rectangle r, double angle) {     double si = sin(angle);     double co = cos(angle);     double e = 0.0001;     int x = 0, y = 0;     if (abs(si) > e) {       x = (int) ((1.0 + co / abs(si)) / 2.0 * r.width);       x = range(0, r.width, x);     } else if (co >= 0.0) {       x = r.width;     }     if (abs(co) > e) {       y = (int) ((1.0 + si / abs(co)) / 2.0 * r.height);       y = range(0, r.height, y);     } else if (si >= 0.0) {       y = r.height;     }     return new Point(r.x + x, r.y + y);}", "nl": "Gets the point on a rectangle that corresponds to the given angle"}
{"code": "public static int outcode(Rectangle2D.Double r1, Rectangle2D.Double r2) {     int outcode = 0;     if (r2.x > r1.x + r1.width) {       outcode = OUT_RIGHT;     } else if (r2.x + r2.width < r1.x) {       outcode = OUT_LEFT;     }     if (r2.y > r1.y + r1.height) {       outcode |= OUT_BOTTOM;     } else if (r2.y + r2.height < r1.y) {       outcode |= OUT_TOP;     }     return outcode;}", "nl": "This method computes a binary OR of the appropriate mask values indicating , for each side of Rectangle r1 , whether or not the Rectangle r2 is on the same side of the edge as the rest of this Rectangle"}
{"code": "public static int direction(int x1, int y1, int x2, int y2) {     int direction = 0;     int vx = x2 - x1;     int vy = y2 - y1;     if (vy < vx && vx > -vy) {       direction = OUT_RIGHT;     } else if (vy > vx && vy > -vx) {       direction = OUT_TOP;     } else if (vx < vy && vx < -vy) {       direction = OUT_LEFT;     } else {       direction = OUT_BOTTOM;     }     return direction;}", "nl": "Returns the direction OUT _ TOP , OUT _ BOTTOM , OUT _ LEFT , OUT _ RIGHT from one point to another one"}
{"code": "public static double range(double min, double max, double value) {     if (value < min) {       value = min;     }     if (value > max) {       value = max;     }     return value;}", "nl": "Constains a value to the given range"}
{"code": "public static double angle(double x1, double y1, double x2, double y2) {     return atan2(y2 - y1, x2 - x1);}", "nl": "Gets the angle of the specified line"}
{"code": "public static boolean lineContainsPoint(double x1, double y1,       double x2, double y2,       double px, double py, double tolerance) {     Rectangle2D.Double r = new Rectangle2D.Double(x1, y1, 0, 0);     r.add(x2, y2);     double grow = max(2, (int) ceil(tolerance));     r.x -= grow;     r.y -= grow;     r.width += grow * 2;     r.height += grow * 2;     if (!r.contains(px, py)) {       return false;     }     double a, b, x, y;     if (x1 == x2) {       return (abs(px - x1) <= tolerance);     }     if (y1 == y2) {       return (abs(py - y1) <= tolerance);     }     a = (double) (y1 - y2) / (double) (x1 - x2);     b = (double) y1 - a * (double) x1;     x = (py - b) / a;     y = a * px + b;     return (min(abs(x - px), abs(y - py)) <= tolerance);}", "nl": "Tests if a point is on a line"}
{"code": "public static boolean lineContainsPoint(int x1, int y1,       int x2, int y2,       int px, int py) {     return lineContainsPoint(x1, y1, x2, y2, px, py, 3d);}", "nl": "Tests if a point is on a line"}
{"code": "public static Point polarToPoint(double angle, double fx, double fy) {     double si = sin(angle);     double co = cos(angle);     return new Point((int) (fx * co + 0.5), (int) (fy * si + 0.5));}", "nl": "Converts a polar to a point"}
{"code": "public void reset() {     npoints = 0;     invalidate();}", "nl": "Resets this Polygon object to an empty polygon"}
{"code": "public boolean contains(Point p) {     return contains(p.x, p.y);}", "nl": "Determines whether the specified Point is inside this Polygon"}
{"code": "public Rectangle getBounds() {     return getBounds2D().getBounds();}", "nl": "Gets the bounding box of this Polygon"}
{"code": "@Deprecated   public boolean inside(int x, int y) {     return contains((double) x, (double) y);}", "nl": "Determines whether the specified coordinates are contained in this Polygon"}
{"code": "public boolean contains(int x, int y) {     return contains((double) x, (double) y);}", "nl": "Determines whether the specified coordinates are inside this Polygon"}
{"code": "@Override     public void translate(double deltaX, double deltaY) {       for (int i = 0; i < npoints; i++) {         xpoints[i] += deltaX;         ypoints[i] += deltaY;       }       if (bounds != null) {         bounds.x += deltaX;         bounds.y += deltaY;}}", "nl": "Translates the vertices of the Polygon by deltaX along the x axis and by deltaY along the y axis"}
{"code": "void calculateBounds(double xpoints[], double ypoints[], int npoints) {       double boundsMinX = java.lang.Double.MAX_VALUE;       double boundsMinY = java.lang.Double.MAX_VALUE;       double boundsMaxX = -java.lang.Double.MAX_VALUE;       double boundsMaxY = -java.lang.Double.MAX_VALUE;       for (int i = 0; i < npoints; i++) {         double x = xpoints[i];         boundsMinX = Math.min(boundsMinX, x);         boundsMaxX = Math.max(boundsMaxX, x);         double y = ypoints[i];         boundsMinY = Math.min(boundsMinY, y);         boundsMaxY = Math.max(boundsMaxY, y);       }       bounds = new Rectangle2D.Double(boundsMinX, boundsMinY,           boundsMaxX - boundsMinX,           boundsMaxY - boundsMinY);}", "nl": "Calculates the bounding box of the points passed to the constructor"}
{"code": "void calculateBounds(float xpoints[], float ypoints[], int npoints) {       float boundsMinX = java.lang.Float.MAX_VALUE;       float boundsMinY = java.lang.Float.MAX_VALUE;       float boundsMaxX = -java.lang.Float.MAX_VALUE;       float boundsMaxY = -java.lang.Float.MAX_VALUE;       for (int i = 0; i < npoints; i++) {         float x = xpoints[i];         boundsMinX = Math.min(boundsMinX, x);         boundsMaxX = Math.max(boundsMaxX, x);         float y = ypoints[i];         boundsMinY = Math.min(boundsMinY, y);         boundsMaxY = Math.max(boundsMaxY, y);       }       bounds = new Rectangle2D.Float(boundsMinX, boundsMinY,           boundsMaxX - boundsMinX,           boundsMaxY - boundsMinY);}", "nl": "Calculates the bounding box of the points passed to the constructor"}
{"code": "@Override     public void translate(double deltaX, double deltaY) {       translate((float) deltaX, (float) deltaY);}", "nl": "Translates the vertices of the Polygon by deltaX along the x axis and by deltaY along the y axis"}
{"code": "public int getWindingRule() {       return WIND_EVEN_ODD;}", "nl": "Returns the winding rule for determining the interior of the path"}
{"code": "public void next() {       index++;}", "nl": "Moves the iterator forwards , along the primary direction of traversal , to the next segment of the path when there are more points in that direction"}
{"code": "public boolean isDone() {       return index > poly.npoints;}", "nl": "Tests if there are more points to read"}
{"code": "public int currentSegment(float[] coords) {       if (index >= poly.npoints) {         return SEG_CLOSE;       }       coords[0] = (float) poly.xpoints[index];       coords[1] = (float) poly.ypoints[index];       if (transform != null) {         transform.transform(coords, 0, coords, 0, 1);       }       return (index == 0 ? SEG_MOVETO : SEG_LINETO);}", "nl": "Returns the coordinates and type of the current path segment in the iteration"}
{"code": "public int getWindingRule() {       return WIND_EVEN_ODD;}", "nl": "Returns the winding rule for determining the interior of the path"}
{"code": "public int hashCode() {     double sum1 = getLeft() + getBottom();     double sum2 = getRight() + getTop();     double val1 = sum1 * (sum1 + 1)/2 + getLeft();     double val2 = sum2 * (sum2 + 1)/2 + getTop();     double sum3 = val1 + val2;     return java.lang.Float.floatToIntBits((float) (sum3 * (sum3 + 1)/2 + val2));}", "nl": "Returns the hash code for this Insets2DDouble"}
{"code": "public Object clone() {     try {       return super.clone();     } catch (CloneNotSupportedException e) {              throw new InternalError();}}", "nl": "Creates a new object of the same class as this object"}
{"code": "public void add(Insets2D i) {     set(         getTop() + i.getTop(),         getLeft() + i.getLeft(),         getBottom() + i.getBottom(),         getRight() + i.getRight());}", "nl": "Adds the specified insets to the current insets"}
{"code": "public void subtractTo(Rectangle2D r) {     r.setRect(         r.getX() + getLeft(),         r.getY() + getTop(),         r.getWidth() - getLeft() - getRight(),         r.getHeight() - getTop() - getBottom());}", "nl": "Subtracts the current insets to the specified Rectangle2D making the rectangle smaller"}
{"code": "public void subtract(Insets2D i) {     set(         getTop() - i.getTop(),         getLeft() - i.getLeft(),         getBottom() - i.getBottom(),         getRight() - i.getRight());}", "nl": "Subtracts the specified insets from the current insets"}
{"code": "public void subtract(double top, double left, double bottom, double right) {     set(         getTop() - top,         getLeft() - left,         getBottom() - bottom,         getRight() - right);}", "nl": "Subtracts the specified insets from the current insets"}
{"code": "public void add(double top, double left, double bottom, double right) {     set(         getTop() + top,         getLeft() + left,         getBottom() + bottom,         getRight() + right);}", "nl": "Adds the specified insets to the current insets"}
{"code": "public Dimension2DDouble(double width, double height) {   this.width = width;   this.height = height;}", "nl": "Constructs a Dimension2DDouble and initializes it to the specified width and specified height"}
{"code": "public Dimension2DDouble(Dimension2DDouble d) {   this(d.width, d.height);}", "nl": "Creates an instance of Dimension2DDouble whose width and height are the same as for the specified dimension"}
{"code": "public int hashCode() {     float sum = (float) (width + height);     return Float.floatToIntBits(sum * (sum + 1)/2 + (float) width);}", "nl": "Returns the hash code for this Dimension2DDouble"}
{"code": "public void setSize(double width, double height) {     this.width = width;     this.height = height;}", "nl": "Sets the size of this Dimension2DDouble object to the specified width and height in double precision"}
{"code": "public Dimension2DDouble() {   this(0, 0);}", "nl": "Creates an instance of Dimension2DDouble with a width of zero and a height of zero"}
{"code": "public void setSize(Dimension2DDouble d) {   setSize(d.width, d.height);}", "nl": "Sets the size of this Dimension2DDouble object to the specified size"}
{"code": "public double getWidth() {   return width;}", "nl": "Returns the width of this dimension in double precision"}
{"code": "@Override   public boolean isSelectable() {     return isSelectable;}", "nl": "Checks whether this figure is selectable"}
{"code": "@Override   public void willChange() {     if (changingDepth == 0) {       fireAreaInvalidated();       invalidate();     }     changingDepth++;}", "nl": "Informs that a figure is about to change something that affects the contents of its display box"}
{"code": "@Override   public Tool getTool(Point2D.Double p) {     return null;}", "nl": "Returns a specialized tool for the given coordinate"}
{"code": "@Override   public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {     return false;}", "nl": "Handles a mouse click"}
{"code": "@Override   public void changed() {     if (changingDepth == 1) {       validate();       fireFigureChanged(getDrawingArea());     } else if (changingDepth < 0) {       throw new InternalError(\"changed was called without a prior call to willChange. \"+changingDepth);     }     changingDepth--;}", "nl": "Informs that a figure changed the area of its display box"}
{"code": "@Override   public boolean isTransformable() {     return isTransformable;}", "nl": "Checks whether this figure is transformable"}
{"code": "@Override   public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {     return new ChopRectangleConnector(this);}", "nl": "Returns the Figures connector for the specified location"}
{"code": "protected void fireUndoableEditHappened(UndoableEdit edit) {     if (getDrawing() != null) {       getDrawing().fireUndoableEditHappened(edit);}}", "nl": "Notify all UndoableEditListener of the Drawing , to which this Figure has been added to"}
{"code": "@Override   public boolean isRemovable() {     return isRemovable;}", "nl": "Checks whether this figure is removable"}
{"code": "public String getKey() {     return key;}", "nl": "Returns the key string"}
{"code": "public T getDefaultValue() {     return defaultValue;}", "nl": "Returns the default value of the attribute"}
{"code": "@SuppressWarnings(\"unchecked\")   public T put(Map<AttributeKey, Object> a, T value) {     if (value == null && !isNullValueAllowed) {       throw new NullPointerException(\"Null value not allowed for AttributeKey \" + key);     }     return (T) a.put(this, value);}", "nl": "Use this method to perform a type - safe put operation of an attribute into a Map"}
{"code": "@SuppressWarnings(\"unchecked\")   public T get(Map<AttributeKey, Object> a) {     return a.containsKey(this) ? (T) a.get(this) : defaultValue;}", "nl": "Gets the value of the attribute denoted by this AttributeKey from a Map"}
{"code": "public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed) {     this(key, clazz, defaultValue, isNullValueAllowed, null);}", "nl": "Creates a new instance with the specified attribute key , type token class , default value , and allowing or disallowing null values"}
{"code": "public String getPresentationName() {     return (labels == null) ? key : labels.getString(\"attribute.\" + key + \".text\");}", "nl": "Returns a localized human friendly presentation of the key"}
{"code": "public T get(Figure f) {     return f.get(this);}", "nl": "Gets the value of the attribute denoted by this AttributeKey from a Figure"}
{"code": "public boolean isAssignable(Object value) {     if (value == null) {       return isNullValueAllowed();     }     return clazz.isInstance(value);}", "nl": "Returns true if the specified value is assignable with this key"}
{"code": "public AttributeKey(String key, Class<T> clazz) {     this(key, clazz, null, true);}", "nl": "Creates a new instance with the specified attribute key , type token class , default value null , and allowing null values"}
{"code": "public void set(Figure f, T value) {     if (value == null && !isNullValueAllowed) {       throw new NullPointerException(\"Null value not allowed for AttributeKey \" + key);     }     f.set(this, value);}", "nl": "Convenience method for setting a value on a Figure"}
{"code": "public AttributeKey(String key, Class<T> clazz, T defaultValue) {     this(key, clazz, defaultValue, true);}", "nl": "Creates a new instance with the specified attribute key , type token class , and default value , and allowing null values"}
{"code": "public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed, ResourceBundleUtil labels) {     this.key = key;     this.clazz = clazz;     this.defaultValue = defaultValue;     this.isNullValueAllowed = isNullValueAllowed;     this.labels = (labels == null) ? ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\") : labels;}", "nl": "Creates a new instance with the specified attribute key , type token class , default value , and allowing or disallowing null values"}
{"code": "public BezierPath.Node getNode(int index) {     return (BezierPath.Node) path.get(index).clone();}", "nl": "Gets a control point"}
{"code": "public void setStartPoint(Point2D.Double p) {          for (int i=getNodeCount(); i < 2; i++) {       addNode(0, new BezierPath.Node(p.x, p.y));     }     setPoint(0, p);}", "nl": "Convenience method for setting the point coordinate of the start point"}
{"code": "public int findNode(Point2D.Double p) {     BezierPath tp = path;     for (int i=0; i < tp.size(); i++) {       BezierPath.Node p2 = tp.get(i);       if (p2.x[0] == p.x && p2.y[0] == p.y) {         return i;       }     }     return -1;}", "nl": "Finds a control point index"}
{"code": "@Override   public Point2D.Double getEndPoint() {     return getPoint(getNodeCount() - 1, 0);}", "nl": "Convenience method for getting the end point"}
{"code": "public void setPoint(int index, int coord, Point2D.Double p) {     BezierPath.Node cp = new BezierPath.Node(path.get(index));     cp.setControlPoint(coord, p);     setNode(index, cp);}", "nl": "Sets the point coordinate of a control point"}
{"code": "@Override   public Point2D.Double getStartPoint() {     return getPoint(0, 0);}", "nl": "Convenience method for getting the start point"}
{"code": "public int splitSegment(Point2D.Double split, float tolerance) {     return path.splitSegment(split, tolerance);}", "nl": "Splits the segment at the given Point2D . Double if a segment was hit"}
{"code": "public int getNodeCount() {     return path.size();}", "nl": "Gets the node count"}
{"code": "public void setPoint(int index, Point2D.Double p) {     BezierPath.Node node = path.get(index);     double dx = p.x - node.x[0];     double dy = p.y - node.y[0];     for (int i=0; i < node.x.length; i++) {       node.x[i] += dx;       node.y[i] += dy;     }     invalidate();}", "nl": "Sets the point coordinate of control point 0 at the specified node"}
{"code": "@Override   public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {     return new ChopBezierConnector(this);}", "nl": "Returns the Figures connector for the specified location"}
{"code": "public BezierPath.Node removeNode(int index) {      return path.remove(index);}", "nl": "Removes the Node at the specified index"}
{"code": "public int findSegment(Point2D.Double find, double tolerance) {     return getBezierPath().findSegment(find, tolerance);}", "nl": "Gets the segment of the polyline that is hit by the given Point2D . Double"}
{"code": "@Override   public void setBounds(Point2D.Double anchor, Point2D.Double lead) {     setStartPoint(anchor);     setEndPoint(lead);     invalidate();}", "nl": "Sets the location of the first and the last BezierPath . Node of the BezierFigure"}
{"code": "public void addNode(final int index, BezierPath.Node p) {     final BezierPath.Node newPoint = new BezierPath.Node(p);     path.add(index, p);     invalidate();}", "nl": "Adds a node to the list of points"}
{"code": "public void addNode(BezierPath.Node p) {     addNode(getNodeCount(), p);}", "nl": "Adds a control point"}
{"code": "public boolean joinSegments(Point2D.Double join, double tolerance) {     int i = findSegment(join, tolerance);     if (i != -1 && i > 1) {       removeNode(i);       return true;     }     return false;}", "nl": "Joins two segments into one if the given Point2D . Double hits a node of the polyline"}
{"code": "public int splitSegment(Point2D.Double split, double tolerance) {     int i = findSegment(split, tolerance);     if (i != -1) {       addNode(i + 1, new BezierPath.Node(split));     }     return i+1;}", "nl": "Splits the segment at the given Point2D . Double if a segment was hit"}
{"code": "protected void removeAllNodes() {     path.clear();}", "nl": "Removes the Point2D . Double at the specified index"}
{"code": "public void setEndPoint(Point2D.Double p) {          for (int i=getNodeCount(); i < 2; i++) {       addNode(0, new BezierPath.Node(p.x, p.y));     }     setPoint(getNodeCount() - 1, p);}", "nl": "Convenience method for setting the point coordinate of the end point"}
{"code": "@Override   public Object getLock() {     return lock;}", "nl": "The drawing view synchronizes on the lock when drawing a drawing"}
{"code": "private void invalidateSortOrder() {     needsSorting = true;}", "nl": "Invalidates the sort order"}
{"code": "public DefaultDrawingEditor() {     toolHandler = new ToolHandler();     setDefaultAttribute(FILL_COLOR, Color.white);     setDefaultAttribute(STROKE_COLOR, Color.black);     setDefaultAttribute(TEXT_COLOR, Color.black);     views = new HashSet<DrawingView>();     inputMap = createInputMap();     actionMap = createActionMap();}", "nl": "Creates a new instance"}
{"code": "public void setTarget(DrawingEditor newValue) {     if (target != null) {       target.removePropertyChangeListener(forwarder);     }     this.target = newValue;     if (target != null) {       target.addPropertyChangeListener(forwarder);}}", "nl": "Sets the target of the proxy"}
{"code": "public DrawingEditorProxy() {     forwarder = new Forwarder();}", "nl": "Creates a new instance"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public static JPopupButton createDrawingColorButton(       DrawingEditor editor, AttributeKey<Color> attributeKey,       java.util.List<ColorIcon> swatches, int columnCount,       String labelKey, ResourceBundleUtil labels) {     return createDrawingColorButton(         editor, attributeKey,         swatches, columnCount,         labelKey, labels,         null);}", "nl": "Creates a color button , with an action region and a popup menu"}
{"code": "public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor, java.util.List<Disposable> dsp) {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     AbstractSelectedAction d;     bar.add(d = new AlignAction.West(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new AlignAction.East(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new AlignAction.Horizontal(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new AlignAction.North(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new AlignAction.South(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new AlignAction.Vertical(editor)).setFocusable(false);     dsp.add(d);     bar.addSeparator();     bar.add(d = new MoveAction.West(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new MoveAction.East(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new MoveAction.North(editor)).setFocusable(false);     dsp.add(d);     bar.add(d = new MoveAction.South(editor)).setFocusable(false);     dsp.add(d);     bar.addSeparator();     bar.add(new BringToFrontAction(editor)).setFocusable(false);     dsp.add(d);     bar.add(new SendToBackAction(editor)).setFocusable(false);     dsp.add(d);}", "nl": "Creates toolbar buttons and adds them to the specified JToolBar"}
{"code": "public static JPopupButton createSelectionColorButton(       DrawingEditor editor, AttributeKey<Color> attributeKey,       java.util.List<ColorIcon> swatches, int columnCount,       String labelKey, ResourceBundleUtil labels) {     return createSelectionColorButton(         editor, attributeKey,         swatches, columnCount,         labelKey, labels,         null);}", "nl": "Creates a color button , with an action region and a popup menu"}
{"code": "public static JPopupButton createDrawingColorButton(       DrawingEditor editor, AttributeKey<Color> attributeKey,       java.util.List<ColorIcon> swatches, int columnCount,       String labelKey, ResourceBundleUtil labels,       Map<AttributeKey, Object> defaultAttributes) {     return createDrawingColorButton(editor, attributeKey,         swatches, columnCount, labelKey, labels, defaultAttributes,         new Rectangle(1, 17, 20, 4));}", "nl": "Creates a color button , with an action region and a popup menu"}
{"code": "public static JPopupButton createDrawingColorButton(       DrawingEditor editor, AttributeKey<Color> attributeKey,       java.util.List<ColorIcon> swatches, int columnCount,       String labelKey, ResourceBundleUtil labels,       Map<AttributeKey, Object> defaultAttributes,       Shape colorShape) {     return createDrawingColorButton(editor, attributeKey,         swatches, columnCount, labelKey, labels, defaultAttributes,         colorShape, new LinkedList<Disposable>());}", "nl": "Creates a color button , with an action region and a popup menu"}
{"code": "public static void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     JButton b;     b = bar.add(new PickAttributesAction(editor));     b.setFocusable(false);     b = bar.add(new ApplyAttributesAction(editor));     b.setFocusable(false);     bar.addSeparator();     addColorButtonsTo(bar, editor);     bar.addSeparator();     addStrokeButtonsTo(bar, editor);     bar.addSeparator();     addFontButtonsTo(bar, editor);}", "nl": "Creates toolbar buttons and adds them to the specified JToolBar"}
{"code": "public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor) {     addAlignmentButtonsTo(bar, editor, new LinkedList<Disposable>());}", "nl": "Creates toolbar buttons and adds them to the specified JToolBar"}
{"code": "public static JPopupButton createEditorColorButton(       DrawingEditor editor, AttributeKey<Color> attributeKey,       java.util.List<ColorIcon> swatches, int columnCount,       String labelKey, ResourceBundleUtil labels,       Map<AttributeKey, Object> defaultAttributes) {     return createEditorColorButton(editor, attributeKey,         swatches, columnCount, labelKey, labels, defaultAttributes,         new Rectangle(1, 17, 20, 4));}", "nl": "Creates a color button , with an action region and a popup menu"}
{"code": "public DefaultAttributeAction(DrawingEditor editor, AttributeKey key) {     this(editor, key, null, null);}", "nl": "Creates a new instance"}
{"code": "public DefaultAttributeAction(DrawingEditor editor, AttributeKey key, Icon icon) {     this(editor, key, null, icon);}", "nl": "Creates a new instance"}
{"code": "public void setDrawing(Drawing newValue) {     drawing = newValue;          opacitySliderHandler.setDrawing(drawing);     opacityFieldHandler.setDrawing(drawing);     updatePanel();}", "nl": "Sets the GridConstrainer to be edited by this panel"}
{"code": "private void updateDrawing() {     if (drawing != null) {       drawing.willChange();       drawing.fireUndoableEditHappened(           CANVAS_FILL_COLOR.setUndoable(drawing, colorButton.getBackground())           );       drawing.changed();}}", "nl": "Updates the drawing due to changes made on this panel"}
{"code": "public EditCanvasPanel() {     labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     initComponents();     colorButton.putClientProperty(\"Quaqua.Button.style\", \"colorWell\");     opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);     opacityPopupButton.add(opacitySlider);     opacityPopupButton.putClientProperty(\"JButton.buttonType\", \"toolbar\");     add(opacityPopupButton);     NumberFormatter nf = new NumberFormatter();     nf.setMaximum(1d);     nf.setMinimum(0d);     opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));     opacityFieldHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacityField, null);     opacitySliderHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacitySlider, null);}", "nl": "Creates new form"}
{"code": "public Drawing getDrawing() {     return drawing;}", "nl": "Returns the GridConstrainer currently being edited by this panel"}
{"code": "public ColorIcon(int rgb) {     this(new Color(rgb));}", "nl": "Creates a new instance"}
{"code": "public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {     this(editor, key, null, null);}", "nl": "Creates a new instance"}
{"code": "public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, String name) {     this(editor, key, name, null);}", "nl": "Creates a new instance"}
{"code": "public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {     this(editor, key, null, icon);}", "nl": "Creates a new instance"}
{"code": "private void initComponents() {     setLayout(null);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "@Override   public void toggleSelection(Figure figure) {     if (selectedFigures.contains(figure)) {       removeFromSelection(figure);     } else {       addToSelection(figure);}}", "nl": "If a figure isn ' t selected it is added to the selection"}
{"code": "protected Paint getBackgroundPaint(       int x, int y) {     if (backgroundTile == null) {       backgroundTile = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);       Graphics2D g = backgroundTile.createGraphics();       g.setColor(Color.white);       g.fillRect(0, 0, 16, 16);       g.setColor(new Color(0xdfdfdf));       g.fillRect(0, 0, 8, 8);       g.fillRect(8, 8, 8, 8);       g.dispose();     }     return new TexturePaint(backgroundTile,         new Rectangle(x, y, backgroundTile.getWidth(), backgroundTile.getHeight()));}", "nl": "Returns a paint for drawing the background of the drawing area"}
{"code": "protected void drawDrawingNonvolatileBuffered(Graphics2D g) {     Rectangle vr = getVisibleRect();     Point shift = new Point(0, 0);     if (bufferedArea.contains(vr) ||         bufferedArea.width >= vr.width && bufferedArea.height >= vr.height) {              shift.x = bufferedArea.x - vr.x;       shift.y = bufferedArea.y - vr.y;       if (shift.x > 0) {         dirtyArea.add(new Rectangle(bufferedArea.x - shift.x, vr.y, shift.x + bufferedArea.width - vr.width, bufferedArea.height));       } else if (shift.x < 0) {         dirtyArea.add(new Rectangle(bufferedArea.x + vr.width, vr.y, -shift.x + bufferedArea.width - vr.width, bufferedArea.height));       }       if (shift.y > 0) {         dirtyArea.add(new Rectangle(vr.x, bufferedArea.y - shift.y, bufferedArea.width, shift.y + bufferedArea.height - vr.height));       } else if (shift.y < 0) {         dirtyArea.add(new Rectangle(vr.x, bufferedArea.y + vr.height, bufferedArea.width, -shift.y + bufferedArea.height - vr.height));       }       bufferedArea.x = vr.x;       bufferedArea.y = vr.y;     } else {                     bufferedArea.setBounds(vr);       dirtyArea.setBounds(vr);       if (drawingBufferNV != null &&            (drawingBufferNV.getWidth() != vr.width ||           drawingBufferNV.getHeight() != vr.height)) {                           drawingBufferNV.flush();         drawingBufferNV = null;       }     }          int valid = (drawingBufferNV == null) ?          VolatileImage.IMAGE_INCOMPATIBLE : VolatileImage.IMAGE_OK;     switch (valid) {       case VolatileImage.IMAGE_INCOMPATIBLE:                  try {           drawingBufferNV = getGraphicsConfiguration().createCompatibleImage(vr.width, vr.height, Transparency.TRANSLUCENT);         } catch (OutOfMemoryError e) {           drawingBufferNV = null;         }         dirtyArea.setBounds(bufferedArea);         break;     }     if (drawingBufferNV == null) {                     drawDrawing(g);       return;     }     if (!dirtyArea.isEmpty()) {              Graphics2D gBuf = drawingBufferNV.createGraphics();       setViewRenderingHints(gBuf);              gBuf.setComposite(AlphaComposite.Src);              if (shift.x != 0 || shift.y != 0) {         gBuf.copyArea(Math.max(0, -shift.x), Math.max(0, -shift.y), drawingBufferNV.getWidth() - Math.abs(shift.x), drawingBufferNV.getHeight() - Math.abs(shift.y), shift.x, shift.y);         shift.x = shift.y = 0;       }              gBuf.translate(-bufferedArea.x, -bufferedArea.y);       gBuf.clip(dirtyArea);              gBuf.setBackground(new Color(0x0, true));       gBuf.clearRect(dirtyArea.x, dirtyArea.y, dirtyArea.width, dirtyArea.height);       gBuf.setComposite(AlphaComposite.SrcOver);              drawDrawing(gBuf);       gBuf.dispose();     }     g.drawImage(drawingBufferNV, bufferedArea.x, bufferedArea.y, null);     dirtyArea.setSize(-1, -1);}", "nl": "Draws the drawing double buffered using a buffered image"}
{"code": "@Override   public void printComponent(Graphics gr) {     Graphics2D g = (Graphics2D) gr;          g.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);     g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);     g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);     g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);     g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);     g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);     g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);     drawDrawing(g);}", "nl": "Prints the drawing view"}
{"code": "public boolean isDrawingDoubleBuffered() {     return isDrawingDoubleBuffered;}", "nl": "Returns true , if the the drawing is double buffered"}
{"code": "@Override   public Point2D.Double viewToDrawing(Point p) {     return new Point2D.Double(         (p.x + translation.x) / scaleFactor,         (p.y + translation.y) / scaleFactor);}", "nl": "Converts view coordinates to drawing coordinates"}
{"code": "public void addToSelection(Figure figure) {     if (DEBUG) {       System.out.println(\"DefaultDrawingView\" + \".addToSelection(\" + figure + \")\");     }     Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);     if (selectedFigures.add(figure)) {       figure.addFigureListener(handleInvalidator);       Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);       Rectangle invalidatedArea = null;       if (handlesAreValid && getEditor() != null) {         for (Handle h : figure.createHandles(detailLevel)) {           h.setView(this);           selectionHandles.add(h);           h.addHandleListener(eventHandler);           if (invalidatedArea == null) {             invalidatedArea = h.getDrawingArea();           } else {             invalidatedArea.add(h.getDrawingArea());           }         }       }       fireSelectionChanged(oldSelection, newSelection);       if (invalidatedArea != null) {         repaint(invalidatedArea);}}}", "nl": "Adds a figure to the current selection"}
{"code": "@Override   public void paintComponent(Graphics gr) {     long start = System.currentTimeMillis();     Graphics2D g = (Graphics2D) gr;     setViewRenderingHints(g);     drawBackground(g);     drawCanvas(g);     drawConstrainer(g);     if (isDrawingDoubleBuffered()) {       if (isWindows) {         drawDrawingNonvolatileBuffered(g);       } else {         drawDrawingVolatileBuffered(g);       }     } else {       drawDrawing(g);     }     drawHandles(g);     drawTool(g);}", "nl": "Paints the drawing view"}
{"code": "protected void drawBackground(Graphics2D g) {     g.setColor(getBackground());     g.fillRect(0, 0, getWidth(), getHeight());}", "nl": "Draws the background of the drawing view"}
{"code": "protected Rectangle getCanvasViewBounds() {          int x = -translation.x;     int y = -translation.y;     int w = getWidth();     int h = getHeight();     if (getDrawing() != null) {       Double cw = getDrawing().get(CANVAS_WIDTH);       Double ch = getDrawing().get(CANVAS_HEIGHT);       if (cw != null && ch != null) {         Point lowerRight = drawingToView(             new Point2D.Double(cw, ch));         w = lowerRight.x - x;         h = lowerRight.y - y;       }     }     return new Rectangle(x, y, w, h);}", "nl": "Returns the bounds of the canvas on the drawing view"}
{"code": "@Override   public boolean isFigureSelected(Figure checkFigure) {     return selectedFigures.contains(checkFigure);}", "nl": "Test whether a given figure is selected"}
{"code": "public void setDrawingDoubleBuffered(boolean newValue) {     boolean oldValue = isDrawingDoubleBuffered;     isDrawingDoubleBuffered =         newValue;     if (!isDrawingDoubleBuffered && drawingBufferV != null) {       drawingBufferV.flush();       drawingBufferV = null;     }     if (!isDrawingDoubleBuffered && drawingBufferNV != null) {       drawingBufferNV.flush();       drawingBufferNV = null;     }     firePropertyChange(DRAWING_DOUBLE_BUFFERED_PROPERTY, oldValue, newValue);}", "nl": "Sets whether the drawing is double buffered"}
{"code": "private java.util.List<Handle> getSecondaryHandles() {     validateHandles();     return Collections.unmodifiableList(secondaryHandles);}", "nl": "Gets the currently active secondary handles"}
{"code": "@Override   public Set<Figure> getSelectedFigures() {     return Collections.unmodifiableSet(selectedFigures);}", "nl": "Gets the current selection as a FigureSelection"}
{"code": "@Override   public Handle findHandle(       Point p) {     validateHandles();     for (Handle handle : new ReversedList<Handle>(getSecondaryHandles())) {       if (handle.contains(p)) {         return handle;       }     }     for (Handle handle : new ReversedList<Handle>(getSelectionHandles())) {       if (handle.contains(p)) {         return handle;       }     }     return null;}", "nl": "Finds a handle at a given coordinates"}
{"code": "public void addToSelection(Collection<Figure> figures) {     Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);     Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);     boolean selectionChanged = false;     Rectangle invalidatedArea = null;     for (Figure figure : figures) {       if (selectedFigures.add(figure)) {         selectionChanged = true;         newSelection.add(figure);         figure.addFigureListener(handleInvalidator);         if (handlesAreValid && getEditor() != null) {           for (Handle h : figure.createHandles(detailLevel)) {             h.setView(this);             selectionHandles.add(h);             h.addHandleListener(eventHandler);             if (invalidatedArea == null) {               invalidatedArea = h.getDrawingArea();             } else {               invalidatedArea.add(h.getDrawingArea());             }           }         }       }     }     if (selectionChanged) {       fireSelectionChanged(oldSelection, newSelection);       if (invalidatedArea != null) {         repaint(invalidatedArea);}}}", "nl": "Adds a collection of figures to the current selection"}
{"code": "private void validateViewTranslation() {     if (getDrawing() == null) {       translation.x = translation.y = 0;       return;     }     Point oldTranslation = (Point) translation.clone();     int width = getWidth();     int height = getHeight();     Insets insets = getInsets();     Rectangle2D.Double da = getDrawingArea();     Rectangle r = new Rectangle((int) (da.x * scaleFactor), (int) (da.y * scaleFactor), (int) (da.width * scaleFactor), (int) (da.height * scaleFactor));     int cw, ch;     Double cwd = getDrawing().get(CANVAS_WIDTH);     Double chd = getDrawing().get(CANVAS_HEIGHT);     if (cwd == null || chd == null) {              cw = Math.max(width - insets.left - insets.right, (int) ((Math.max(0, da.x) + da.width) * scaleFactor));       ch = Math.max(height - insets.top - insets.bottom, (int) ((Math.max(0, da.y) + da.height) * scaleFactor));              translation.x = insets.top;       translation.y = insets.left;     } else {              cw = (int) (cwd * scaleFactor);       ch = (int) (chd * scaleFactor);              if (cw < width) {         translation.x = insets.left + (width - insets.left - insets.right - cw) / -2;       }       if (ch < height) {         translation.y = insets.top + (height - insets.top - insets.bottom - ch) / -2;       }     }     if (r.y + r.height - translation.y > (height - insets.bottom)) {              translation.y = r.y + r.height - (height - insets.bottom);     }     if (Math.min(0, r.y) - translation.y < insets.top) {              translation.y = Math.min(0, r.y) - insets.top;     }     if (r.x + r.width - translation.x > (width - insets.right)) {              translation.x = r.x + r.width - (width - insets.right);     }     if (Math.min(0, r.x) - translation.x < insets.left) {              translation.x = Math.min(0, r.x) - insets.left;     }     if (!oldTranslation.equals(translation)) {       bufferedArea.translate(oldTranslation.x - translation.x, oldTranslation.y - translation.y);       fireViewTransformChanged();}}", "nl": "Updates the view translation taking into account the current dimension of the view JComponent , the size of the drawing , and the scale factor"}
{"code": "@Override   public int getSelectionCount() {     return selectedFigures.size();}", "nl": "Gets the number of selected figures"}
{"code": "public DefaultDrawingView() {     initComponents();     eventHandler = createEventHandler();     setToolTipText(\"dummy\");      setFocusable(true);     addFocusListener(eventHandler);     setTransferHandler(new DefaultDrawingViewTransferHandler());     setBackground(new Color(0xb0b0b0));     setOpaque(true);}", "nl": "Creates new instance"}
{"code": "@Override   public Collection<Handle> getCompatibleHandles(Handle master) {     validateHandles();     HashSet<Figure> owners = new HashSet<Figure>();     LinkedList<Handle> compatibleHandles = new LinkedList<Handle>();     owners.add(master.getOwner());     compatibleHandles.add(master);     for (Handle handle : getSelectionHandles()) {       if (!owners.contains(handle.getOwner()) && handle.isCombinableWith(master)) {         owners.add(handle.getOwner());         compatibleHandles.add(handle);       }     }     return compatibleHandles;}", "nl": "Gets compatible handles"}
{"code": "private java.util.List<Handle> getSelectionHandles() {     validateHandles();     return Collections.unmodifiableList(selectionHandles);}", "nl": "Gets the currently active selection handles"}
{"code": "private void validateHandles() {               if (!handlesAreValid && getEditor() != null) {       handlesAreValid = true;       selectionHandles.clear();       Rectangle invalidatedArea = null;       while (true) {         for (Figure figure : getSelectedFigures()) {           for (Handle handle : figure.createHandles(detailLevel)) {             handle.setView(this);             selectionHandles.add(handle);             handle.addHandleListener(eventHandler);             if (invalidatedArea == null) {               invalidatedArea = handle.getDrawingArea();             } else {               invalidatedArea.add(handle.getDrawingArea());             }           }         }         if (selectionHandles.size() == 0 && detailLevel != 0) {                                 detailLevel = 0;           continue;         }         break;       }       if (invalidatedArea != null) {         repaint(invalidatedArea);}}}", "nl": "Validates the handles"}
{"code": "public void dragGestureRecognized(DragGestureEvent dge) {       JComponent c = (JComponent) dge.getComponent();       DefaultDrawingViewTransferHandler th = (DefaultDrawingViewTransferHandler) c.getTransferHandler();       Transferable t = transferable;       if (t != null) {         scrolls = c.getAutoscrolls();         c.setAutoscrolls(false);         try {           Icon icon = th.getVisualRepresentation(t);           Image dragImage;           if (icon instanceof ImageIcon) {             dragImage = ((ImageIcon) icon).getImage();           } else {             dragImage = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_ARGB);             Graphics g = ((BufferedImage) dragImage).createGraphics();             icon.paintIcon(c, g, 0, 0);             g.dispose();           }           dge.startDrag(null, dragImage, imageOffset, t, this);           return;         } catch (RuntimeException re) {           c.setAutoscrolls(scrolls);         }       }       th.exportDone(c, t, NONE);}", "nl": "a Drag gesture has been recognized"}
{"code": "public boolean contains(Point2D.Double p) {     Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();     if (get(IS_QUADRATIC)) {       double side = Math.max(r.width, r.height);       r.x -= (side - r.width) / 2;       r.y -= (side - r.height) / 2;       r.width = r.height = side;     }          double grow = AttributeKeys.getPerpendicularFillGrowth(this);     double growx, growy;     if (grow == 0d) {       growx = growy = 0d;     } else {       double w = r.width / 2d;       double h = r.height / 2d;       double lineLength = Math.sqrt(w * w + h * h);       double scale = grow / lineLength;       double yb = scale * w;       double xa = scale * h;       growx = ((yb * yb) / xa + xa);       growy = ((xa * xa) / yb + yb);       Geom.grow(r, growx, growy);     }     Path2D.Double diamond = new Path2D.Double();     diamond.moveTo((r.x + r.width / 2), r.y);     diamond.lineTo((r.x + r.width), (r.y + r.height / 2));     diamond.lineTo((r.x + r.width / 2), (r.y + r.height));     diamond.lineTo(r.x, (r.y + r.height / 2));     diamond.closePath();     return diamond.contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public ToolBarLayout() {     this(X_AXIS);}", "nl": "Creates a layout manager that will lay out components along the X - axis"}
{"code": "public AbstractTransferable(DataFlavor flavor) {     this.flavors = new DataFlavor[] {flavor};}", "nl": "Creates a new instance"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public VerticalGridLayout(int rows, int cols, int hgap, int vgap, boolean isVertical) {     if ((rows == 0) && (cols == 0)) {       throw new IllegalArgumentException(\"rows and cols cannot both be zero\");     }     this.rows = rows;     this.cols = cols;     this.hgap = hgap;     this.vgap = vgap;     this.isVertical = isVertical;}", "nl": "Creates a grid layout with the specified number of rows and columns"}
{"code": "public void setRows(int rows) {     if ((rows == 0) && (this.cols == 0)) {       throw new IllegalArgumentException(\"rows and cols cannot both be zero\");     }     this.rows = rows;}", "nl": "Sets the number of rows in this layout to the specified value"}
{"code": "public Dimension minimumLayoutSize(Container parent) {     synchronized (parent.getTreeLock()) {       Insets insets = parent.getInsets();       int ncomponents = parent.getComponentCount();       int nrows = rows;       int ncols = cols;              if (nrows > 0) {         ncols = (ncomponents + nrows - 1) / nrows;       } else {         nrows = (ncomponents + ncols - 1) / ncols;       }       int w = 0;       int h = 0;       for (int i = 0 ; i < ncomponents ; i++) {         Component comp = parent.getComponent(i);         Dimension d = comp.getMinimumSize();         if (w < d.width) {           w = d.width;         }         if (h < d.height) {           h = d.height;         }       }       return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,       insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);}}", "nl": "Determines the minimum size of the container argument using this grid layout"}
{"code": "public int getRows() {     return rows;}", "nl": "Gets the number of rows in this layout"}
{"code": "public void setColumns(int cols) {     if ((cols == 0) && (this.rows == 0)) {       throw new IllegalArgumentException(\"rows and cols cannot both be zero\");     }     this.cols = cols;}", "nl": "Sets the number of columns in this layout to the specified value"}
{"code": "public void setVgap(int vgap) {     this.vgap = vgap;}", "nl": "Sets the vertical gap between components to the specified value"}
{"code": "public VerticalGridLayout() {     this(1, 0, 0, 0);}", "nl": "Creates a grid layout with a default of one column per component , in a single row"}
{"code": "public void setHgap(int hgap) {     this.hgap = hgap;}", "nl": "Sets the horizontal gap between components to the specified value"}
{"code": "public VerticalGridLayout(int rows, int cols) {     this(rows, cols, 0, 0);}", "nl": "Creates a grid layout with the specified number of rows and columns"}
{"code": "public Dimension preferredLayoutSize(Container parent) {     synchronized (parent.getTreeLock()) {       Insets insets = parent.getInsets();       int ncomponents = parent.getComponentCount();       int nrows = rows;       int ncols = cols;              if (nrows > 0) {         ncols = (ncomponents + nrows - 1) / nrows;       } else {         nrows = (ncomponents + ncols - 1) / ncols;       }       int w = 0;       int h = 0;       for (int i = 0 ; i < ncomponents ; i++) {         Component comp = parent.getComponent(i);         Dimension d = comp.getPreferredSize();         if (w < d.width) {           w = d.width;         }         if (h < d.height) {           h = d.height;         }       }       return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,       insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);}}", "nl": "Determines the preferred size of the container argument using this grid layout"}
{"code": "public Clipboard getTarget() {     return target;}", "nl": "Returns the proxy target"}
{"code": "public AWTClipboard(Clipboard target) {     this.target = target;}", "nl": "Creates a new proxy for the specified target object"}
{"code": "private synchronized void setError(Throwable x) {     error = x;}", "nl": "Set the error thrown by constrct"}
{"code": "protected synchronized Throwable getError() {     return error;}", "nl": "Get the error produced by the worker thread , or null if it hasn ' t thrown one"}
{"code": "public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {     Transferable t = (Transferable) transferables.get(flavor);     if (t == null) throw new UnsupportedFlavorException(flavor);     return t.getTransferData(flavor);}", "nl": "Returns an object which represents the data to be transferred"}
{"code": "public DataFlavor[] getTransferDataFlavors() {     return (DataFlavor[]) flavors.toArray(new DataFlavor[transferables.size()]);}", "nl": "Returns an array of DataFlavor objects indicating the flavors the data can be provided in"}
{"code": "public JSheet(Dialog owner) {     super(owner);     init();}", "nl": "Creates a new JSheet"}
{"code": "private static boolean isDocumentModalitySupported() {     return isDocumentModalitySupported;}", "nl": "If this returns true , the JSheet uses native support for sheet display"}
{"code": "public static void showMessageSheet(Component parentComponent,       Object message, int messageType, SheetListener listener) {     showMessageSheet(parentComponent, message, messageType, null, listener);}", "nl": "Brings up a sheet that displays a message using a default icon determined by the messageType parameter"}
{"code": "private static boolean isNativeSheetSupported() {     return isNativeSheetSupported;}", "nl": "If this returns true , the JSheet uses native support for sheet display"}
{"code": "public static void showOptionSheet(Component parentComponent,       Object message, int optionType, int messageType,       Icon icon, Object[] options, Object initialValue, SheetListener listener) {     JOptionPane pane = new JOptionPane(message, messageType,         optionType, icon,         options, initialValue);     pane.setInitialValue(initialValue);     pane.setComponentOrientation(((parentComponent == null) ? JOptionPane.getRootFrame() : parentComponent).getComponentOrientation());     int style = styleFromMessageType(messageType);     JSheet sheet = createSheet(pane, parentComponent, style);     pane.selectInitialValue();     sheet.addSheetListener(listener);     sheet.show();     sheet.toFront();}", "nl": "Brings up a sheet with a specified icon , where the initial choice is determined by the initialValue parameter and the number of choices is determined by the optionType parameter"}
{"code": "public static void showMessageSheet(Component parentComponent,       Object message, SheetListener listener) {     showMessageSheet(parentComponent, message,         JOptionPane.INFORMATION_MESSAGE, listener);}", "nl": "Brings up an information - message sheet"}
{"code": "public static void showConfirmSheet(Component parentComponent, Object message, SheetListener listener) {     showConfirmSheet(parentComponent, message,         JOptionPane.YES_NO_CANCEL_OPTION, listener);}", "nl": "Brings up a sheet with the options Yes , No and Cancel"}
{"code": "public static void showInputSheet(Component parentComponent,       Object message, int messageType, SheetListener listener) {     showInputSheet(parentComponent, message,         messageType, null, null, null, listener);}", "nl": "Shows a sheet requesting input from the user parented to parentComponent and message type messageType"}
{"code": "protected void fireOptionSelected(JOptionPane pane) {     Object value = pane.getValue();     int option;     if (value == null) {       option = JOptionPane.CLOSED_OPTION;     } else {       if (pane.getOptions() == null) {         if (value instanceof Integer) {           option = ((Integer) value).intValue();         } else {           option = JOptionPane.CLOSED_OPTION;         }       } else {         option = JOptionPane.CLOSED_OPTION;         Object[] options = pane.getOptions();         for (int i = 0, n = options.length; i < n; i++) {           if (options[i].equals(value)) {             option = i;             break;           }         }         if (option == JOptionPane.CLOSED_OPTION) {           value = null;         }       }     }     fireOptionSelected(pane, option, value, pane.getInputValue());}", "nl": "Notify all listeners that have registered interest for notification on this event type"}
{"code": "public static void showSaveSheet(JFileChooser chooser, Component parent, SheetListener listener) {     chooser.setDialogType(JFileChooser.SAVE_DIALOG);     showSheet(chooser, parent, null, listener);}", "nl": "Displays a Save File file chooser sheet"}
{"code": "public static void showOpenSheet(JFileChooser chooser, Component parent, SheetListener listener) {     chooser.setDialogType(JFileChooser.OPEN_DIALOG);     showSheet(chooser, parent, null, listener);}", "nl": "Displays an Open File file chooser sheet"}
{"code": "protected void installSheet() {     if (!isNativeSheetSupported() && !isInstalled) {       Window owner = getOwner();       if (owner != null) {                                             Point ownerLoc = owner.getLocation();         Point sheetLoc;         if (isShowAsSheet()) {           if (owner instanceof JFrame) {             sheetLoc = new Point(                 ownerLoc.x + (owner.getWidth() - getWidth()) / 2,                 ownerLoc.y + owner.getInsets().top + ((JFrame) owner).getRootPane().getContentPane().getY());           } else if (owner instanceof JDialog) {             sheetLoc = new Point(                 ownerLoc.x + (owner.getWidth() - getWidth()) / 2,                 ownerLoc.y + owner.getInsets().top + ((JDialog) owner).getRootPane().getContentPane().getY());           } else {             sheetLoc = new Point(                 ownerLoc.x + (owner.getWidth() - getWidth()) / 2,                 ownerLoc.y + owner.getInsets().top);           }           if (sheetLoc.x < 0) {             owner.setLocation(ownerLoc.x - sheetLoc.x, ownerLoc.y);             sheetLoc.x = 0;             shiftBackLocation = ownerLoc;             oldLocation = owner.getLocation();           } else {             shiftBackLocation = null;             oldLocation = ownerLoc;           }         } else {           sheetLoc = new Point(               ownerLoc.x + (owner.getWidth() - getWidth()) / 2,               ownerLoc.y + (owner.getHeight() - getHeight()) / 3);         }         setLocation(sheetLoc);         oldFocusOwner = owner.getFocusOwner();                                    owner.setEnabled(false);                  if (isShowAsSheet()) {           owner.addComponentListener(ownerMovementHandler);         } else {           if (owner instanceof Frame) {             setTitle(((Frame) owner).getTitle());           }         }       }       isInstalled = true;     } else {       Window owner = getOwner();       Point ownerLoc = owner.getLocation();       Point sheetLoc = new Point(           ownerLoc.x + (owner.getWidth() - getWidth()) / 2,           ownerLoc.y + (owner.getHeight() - getHeight()) / 3);         setLocation(sheetLoc);}}", "nl": "Installs the sheet on the owner"}
{"code": "public static void showInputSheet(Component parentComponent,       Object message, SheetListener listener) {     showInputSheet(parentComponent, message, JOptionPane.QUESTION_MESSAGE, listener);}", "nl": "Shows a question - message sheet requesting input from the user parented to parentComponent"}
{"code": "public static void showConfirmSheet(Component parentComponent,       Object message, int optionType, SheetListener listener) {     showConfirmSheet(parentComponent, message, optionType,         JOptionPane.QUESTION_MESSAGE, listener);}", "nl": "Brings up a sheet where the number of choices is determined by the optionType parameter"}
{"code": "public JSheet(Frame owner) {     super(owner);     init();}", "nl": "Creates a new JSheet"}
{"code": "public static void showConfirmSheet(Component parentComponent,       Object message, int optionType, int messageType, SheetListener listener) {     showConfirmSheet(parentComponent, message, optionType,         messageType, null, listener);}", "nl": "Brings up a sheet where the number of choices is determined by the optionType parameter , where the messageType parameter determines the icon to display"}
{"code": "public static void showSheet(JOptionPane pane, Component parentComponent, SheetListener listener) {     final JSheet sheet = createSheet(pane, parentComponent, styleFromMessageType(pane.getMessageType()));     sheet.addSheetListener(listener);     sheet.show();}", "nl": "Displays an option pane as a sheet on its parent window"}
{"code": "public static void showMessageSheet(Component parentComponent,       Object message, int messageType, Icon icon, SheetListener listener) {     showOptionSheet(parentComponent, message, JOptionPane.DEFAULT_OPTION,         messageType, icon, null, null, listener);}", "nl": "Brings up a sheet displaying a message , specifying all parameters"}
{"code": "static Window getWindowForComponent(Component parentComponent) {     if (parentComponent == null) {       return JOptionPane.getRootFrame();     }     if (parentComponent instanceof Frame || parentComponent instanceof Dialog) {       return (Window) parentComponent;     }     return getWindowForComponent(parentComponent.getParent());}", "nl": "Returns the specified component ' s toplevel Frame or Dialog"}
{"code": "protected void updateText() {     if (updatingDepth++ == 0) {       if (getFormatter() != null) {         try {           String newText = getFormatter().valueToString(getValue());           setText(newText);           if (!isFocusOwner()) {                                                                 setCaretPosition(getDocument().getLength());             moveCaretPosition(0);           }         } catch (ParseException ex) {                    }       }     }     updatingDepth--;}", "nl": "Updates the text of the field from the value"}
{"code": "protected void updateValue() {     if (updatingDepth++ == 0) {       if (getFormatter() != null) {         try {           Object newValue = getFormatter().stringToValue(getText());           setValue(newValue);         } catch (ParseException ex) {                    }       }     }     updatingDepth--;}", "nl": "Updates the value from the text of the field"}
{"code": "private AbstractFormatterFactory getDefaultFormatterFactory(Object type) {     if (type instanceof DateFormat) {       return new DefaultFormatterFactory(new DateFormatter((DateFormat) type));     }     if (type instanceof NumberFormat) {       return new DefaultFormatterFactory(new NumberFormatter(           (NumberFormat) type));     }     if (type instanceof Format) {       return new DefaultFormatterFactory(new InternationalFormatter(           (Format) type));     }     if (type instanceof Date) {       return new DefaultFormatterFactory(new DateFormatter());     }     if (type instanceof Number) {       AbstractFormatter displayFormatter = new NumberFormatter();       ((NumberFormatter) displayFormatter).setValueClass(type.getClass());       AbstractFormatter editFormatter = new NumberFormatter(           new DecimalFormat(\"#.#\"));       ((NumberFormatter) editFormatter).setValueClass(type.getClass());       return new DefaultFormatterFactory(displayFormatter,           displayFormatter, editFormatter);     }     return new DefaultFormatterFactory(new DefaultFormatter());}", "nl": "Returns an AbstractFormatterFactory suitable for the passed in Object type"}
{"code": "public void arrangeFramesVertically() {     Component[] allFrames = getAllFrames();          if (allFrames.length == 0) {       return;     }          manager.setNormalSize();          int vertFrames = (int)Math.floor(Math.sqrt(allFrames.length));     int horFrames = (int)Math.ceil(Math.sqrt(allFrames.length));               int frameWidth = getBounds().width / horFrames;     int frameHeight = getBounds().height / vertFrames;     int x = 0;     int y = 0;     int frameIdx = 0;     for (int horCnt = 0; horCnt < horFrames-1; horCnt++) {       y = 0;       for (int vertCnt = 0; vertCnt < vertFrames; vertCnt++) {         try {           ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);         } catch (PropertyVetoException e) {           e.printStackTrace();         }                  allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);         frameIdx++;         y = y + frameHeight;       }       x = x + frameWidth;     }                    frameHeight = getBounds().height / (allFrames.length - frameIdx);     y = 0;     for (; frameIdx < allFrames.length; frameIdx++) {       try {         ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);       } catch (PropertyVetoException e) {         e.printStackTrace();       }              allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);       y = y + frameHeight;     }          checkDesktopSize();}", "nl": "Arranges the frames as efficiently as possibly with preference for keeping vertical size maximal"}
{"code": "public void arrangeFramesHorizontally() {     Component[] allFrames = getAllFrames();          if (allFrames.length == 0) {       return;     }          manager.setNormalSize();          int vertFrames = (int)Math.ceil(Math.sqrt(allFrames.length));     int horFrames = (int)Math.floor(Math.sqrt(allFrames.length));               int frameWidth = getBounds().width / horFrames;     int frameHeight = getBounds().height / vertFrames;     int x = 0;     int y = 0;     int frameIdx = 0;     for (int vertCnt = 0; vertCnt < vertFrames-1; vertCnt++) {       x = 0;       for (int horCnt = 0; horCnt < horFrames; horCnt++) {         try {           ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);         } catch (PropertyVetoException e) {           e.printStackTrace();         }                  allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);         frameIdx++;         x = x + frameWidth;       }       y = y + frameHeight;     }                    frameWidth = getBounds().width / (allFrames.length - frameIdx);     x = 0;     for (; frameIdx < allFrames.length; frameIdx++) {       try {         ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);       } catch (PropertyVetoException e) {         e.printStackTrace();       }              allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);       x = x + frameWidth;     }          checkDesktopSize();}", "nl": "Arranges the frames as efficiently as possibly with preference for keeping horizontal size maximal"}
{"code": "public void setAllSize(Dimension d) {     setMinimumSize(d);     setMaximumSize(d);     setPreferredSize(d);     setBounds(0, 0, d.width, d.height);}", "nl": "Sets all component size properties to the given dimension"}
{"code": "private void arrangeFramesCascading() {     JInternalFrame[] allFrames = getAllFrames();               if (allFrames.length == 0) {       return;     }          manager.setNormalSize();     Insets insets = getInsets();     int x = insets.left;     int y = insets.top;     int frameOffset=0;     for (int i = allFrames.length - 1; i >= 0; i--) {       Point p=SwingUtilities.convertPoint(allFrames[i].getContentPane(),0,0,allFrames[i]);       frameOffset=Math.max(frameOffset,Math.max(p.x,p.y));     }     int frameHeight = (getBounds().height-insets.top-insets.bottom) - allFrames.length * frameOffset;     int frameWidth = (getBounds().width-insets.left-insets.right) - allFrames.length * frameOffset;     for (int i = allFrames.length - 1; i >= 0; i--) {       try {         allFrames[i].setMaximum(false);       } catch (PropertyVetoException e) {         e.printStackTrace();       }              allFrames[i].setBounds(x, y, frameWidth, frameHeight);       x = x + frameOffset;       y = y + frameOffset;     }          checkDesktopSize();}", "nl": "Cascade all internal frames"}
{"code": "public TreePath getSelectionPath() {     return selectionPath;}", "nl": "Gets the selected Font"}
{"code": "public void setSelectedFont(Font newValue) {     Font oldValue = selectedFont;     this.selectedFont = newValue;     firePropertyChange(SELECTED_FONT_PROPERTY, oldValue, newValue);     updateSelectionPath(newValue);}", "nl": "Sets the selected Font"}
{"code": "public void setSelectionPath(TreePath newValue) {     TreePath oldValue = selectionPath;     this.selectionPath = newValue;     firePropertyChange(SELECTION_PATH_PROPERTY, oldValue, newValue);     if (selectionPath != null && selectionPath.getPathCount() == 4) {       setSelectedFont(((FontFaceNode) selectionPath.getLastPathComponent()).getFont());}}", "nl": "Sets the selected Font"}
{"code": "public LabelFigure() {     this(\"Label\");}", "nl": "Creates a new instance"}
{"code": "public void cancelSelection() {     returnValue = CANCEL_OPTION;     if (dialog != null) {       dialog.setVisible(false);     }     fireActionPerformed(CANCEL_SELECTION);}", "nl": "Called by the UI when the user chooses the Cancel button"}
{"code": "@Override   public String getUIClassID() {     return uiClassID;}", "nl": "Returns a string that specifies the name of the L & F class that renders this component"}
{"code": "public Font getSelectedFont() {     return selectedFont;}", "nl": "Gets the selected Font"}
{"code": "public void setUI(FontChooserUI ui) {     super.setUI(ui);}", "nl": "Sets the look and feel object that renders this component"}
{"code": "public void approveSelection() {     returnValue = APPROVE_OPTION;     if (dialog != null) {       dialog.setVisible(false);     }     fireActionPerformed(APPROVE_SELECTION);}", "nl": "Called by the UI when the user hits the Approve button"}
{"code": "public FontChooserModel getModel() {     return model;}", "nl": "Gets the selected Font"}
{"code": "protected void updateSelectionPath(Font newValue) {     if (newValue == null || selectionPath == null || selectionPath.getPathCount() != 4 ||         !((FontFaceNode) selectionPath.getLastPathComponent()).getFont().getFontName().equals(newValue.getFontName())) {       if (newValue == null) {         setSelectionPath(null);       } else {         TreePath path = selectionPath;         FontCollectionNode oldCollection = (path != null && path.getPathCount() > 1) ? (FontCollectionNode) path.getPathComponent(1) : null;         FontFamilyNode oldFamily = (path != null && path.getPathCount() > 2) ? (FontFamilyNode) path.getPathComponent(2) : null;         FontFaceNode oldFace = (path != null && path.getPathCount() > 3) ? (FontFaceNode) path.getPathComponent(3) : null;         FontCollectionNode newCollection = oldCollection;         FontFamilyNode newFamily = oldFamily;         FontFaceNode newFace = null;                  if (newFace == null && newFamily != null) {           for (FontFaceNode face : newFamily.faces()) {             if (face.getFont().getFontName().equals(newValue.getFontName())) {               newFace = face;               break;             }           }         }                  if (newFace == null && newCollection != null) {           for (FontFamilyNode family : newCollection.families()) {             for (FontFaceNode face : family.faces()) {               if (face.getFont().getFontName().equals(newValue.getFontName())) {                 newFamily = family;                 newFace = face;                 break;               }             }           }         }                  if (newFace == null) {           TreeNode root = (TreeNode) getModel().getRoot();           OuterLoop:           for (int i = 0, n = root.getChildCount(); i < n; i++) {             FontCollectionNode collection = (FontCollectionNode) root.getChildAt(i);             for (FontFamilyNode family : collection.families()) {               for (FontFaceNode face : family.faces()) {                 if (face.getFont().getFontName().equals(newValue.getFontName())) {                   newCollection = collection;                   newFamily = family;                   newFace = face;                   break OuterLoop;                 }               }             }           }         }         if (newFace != null) {           setSelectionPath(new TreePath(new Object[]{                 getModel().getRoot(), newCollection, newFamily, newFace               }));         } else {           setSelectionPath(null);}}}}", "nl": "Updates the selection path to the selected font"}
{"code": "public void setImageData(byte[] imageData) {     willChange();     this.imageData = imageData;     this.bufferedImage = null;     changed();}", "nl": "Sets the image data"}
{"code": "public BufferedImage getBufferedImage() {     if (bufferedImage == null && imageData != null) {       try {         bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));       } catch (IOException e) {         e.printStackTrace();                                    imageData = null;       }     }     return bufferedImage;}", "nl": "Gets the buffered image"}
{"code": "public PickAttributesAction(DrawingEditor editor) {     super(editor);     labels.configureAction(this, \"edit.pickAttributes\");     setEnabled(true);}", "nl": "Creates a new instance"}
{"code": "public void setBufferedImage(BufferedImage image) {     willChange();     this.imageData = null;     this.bufferedImage = image;     changed();}", "nl": "Sets the buffered image"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public byte[] getImageData() {     if (bufferedImage != null && imageData == null) {       try {         ByteArrayOutputStream bout = new ByteArrayOutputStream();         ImageIO.write(bufferedImage, \"PNG\", bout);         bout.close();         imageData = bout.toByteArray();       } catch (IOException e) {         e.printStackTrace();                                    bufferedImage = null;       }     }     return imageData;}", "nl": "Gets the image data"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public void transform(AffineTransform tx) {     Point2D.Double anchor = getStartPoint();     Point2D.Double lead = getEndPoint();     setBounds(         (Point2D.Double) tx.transform(anchor, anchor),         (Point2D.Double) tx.transform(lead, lead));}", "nl": "Transforms the figure"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public ZoomAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {     this((DrawingView) null, scaleFactor, button);     setEditor(editor);}", "nl": "Creates a new instance"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public void setPresentationFigure(Figure newPresentationFigure) {     if (this.presentationFigure != null) {       this.presentationFigure.removeFigureListener(presentationFigureHandler);       if (getDrawing() != null) {         this.presentationFigure.removeNotify(getDrawing());       }     }     this.presentationFigure = newPresentationFigure;     if (this.presentationFigure != null) {       this.presentationFigure.addFigureListener(presentationFigureHandler);       if (getDrawing() != null) {         this.presentationFigure.addNotify(getDrawing());}}}", "nl": "Set a figure which renders this BasicCompositeFigure"}
{"code": "public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {     this(editor, key, null, icon);}", "nl": "Creates a new instance"}
{"code": "public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {     this(editor, key, null, null);}", "nl": "Creates a new instance"}
{"code": "public void setBounds(Point2D.Double anchor, Point2D.Double lead) {     if (getLayouter() == null) {       super.setBounds(anchor, lead);       basicSetPresentationFigureBounds(anchor, lead);     } else {       Rectangle2D.Double r = getLayouter().layout(this, anchor, lead);       basicSetPresentationFigureBounds(new Point2D.Double(r.getX(), r.getY()),           new Point2D.Double(           Math.max(lead.x, (int) r.getMaxX()),           Math.max(lead.y, (int) r.getMaxY())           )           );       invalidate();}}", "nl": "Moves the figure"}
{"code": "@Override   public <T> T get(AttributeKey<T> key) {     if (getPresentationFigure() != null) {       return getPresentationFigure().get(key);     } else {       return (! attributes.containsKey(key)) ?         key.getDefaultValue() :         key.get(attributes);}}", "nl": "Gets an attribute from the figure"}
{"code": "public void transform(AffineTransform tx) {     super.transform(tx);     if (getPresentationFigure() != null) {       getPresentationFigure().transform(tx);}}", "nl": "Standard presentation method which is delegated to the encapsulated presentation figure"}
{"code": "public Rectangle2D.Double getBounds() {     if (getPresentationFigure() == null) return super.getBounds();     return getPresentationFigure().getBounds();}", "nl": "Return the logcal display area"}
{"code": "public void draw(Graphics2D g) {     drawPresentationFigure(g);     super.draw(g);}", "nl": "Draw the figure"}
{"code": "@Override   public <T> void set(AttributeKey<T> key, T newValue) {     if (forbiddenAttributes == null         || ! forbiddenAttributes.contains(key)) {       if (getPresentationFigure() != null) {         getPresentationFigure().set(key, newValue);       }       super.set(key, newValue);       Object oldValue = attributes.put(key, newValue);}}", "nl": "Sets an attribute of the figure"}
{"code": "public GridConstrainer(double width, double height) {     this(width, height, Math.PI / 8d, true);}", "nl": "Creates a new instance with the specified grid size , and by 11"}
{"code": "public int getMajorGridSpacing() {     return majorGridSpacing;}", "nl": "Spacing between major grid lines"}
{"code": "public GridConstrainer() {     this(1d, 1d, 0d, false);}", "nl": "Creates a new instance with a grid of 1x1"}
{"code": "public Point2D.Double translatePoint(Point2D.Double p, TranslationDirection dir) {     Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());     switch (dir) {       case NORTH:       case NORTH_WEST:       case NORTH_EAST:         p.y = p0.y - height;         break;       case SOUTH:       case SOUTH_WEST:       case SOUTH_EAST:         p.y = p0.y + height;         break;     }     switch (dir) {       case WEST:       case NORTH_WEST:       case SOUTH_WEST:         p.x = p0.x - width;         break;       case EAST:       case NORTH_EAST:       case SOUTH_EAST:         p.x = p0.x + width;         break;     }     return p;}", "nl": "Moves a point to the closest grid point in a direction"}
{"code": "public GridConstrainer(double width, double height, double theta, boolean visible) {     if (width <= 0 || height <= 0) {       throw new IllegalArgumentException(\"Width or height is <= 0\");     }     this.width = width;     this.height = height;     this.theta = theta;     this.isVisible = visible;}", "nl": "Creates a new instance with the specified grid size"}
{"code": "public void setMajorGridSpacing(int newValue) {     int oldValue = majorGridSpacing;     majorGridSpacing = newValue;     firePropertyChange(\"majorGridSpacing\", oldValue, newValue);     fireStateChanged();}", "nl": "Spacing between major grid lines"}
{"code": "public Point2D.Double constrainPoint(Point2D.Double p) {     p.x = Math.round(p.x / width) * width;     p.y = Math.round(p.y / height) * height;     return p;}", "nl": "Constrains a point to the closest grid point in any direction"}
{"code": "public java.util.List<Figure> getChildrenFrontToBack() {     return children ==  null ?       new LinkedList<Figure>() :       new ReversedList<Figure>(children);}", "nl": "Returns an iterator to iterate in Z - order front to back over the children"}
{"code": "public void transform(AffineTransform tx) {     super.transform(tx);     for (Figure f : children) {       f.transform(tx);     }     invalidate();}", "nl": "Transforms the figure"}
{"code": "public <T> void set(AttributeKey<T> key, T newValue) {     super.set(key, newValue);     if (isAttributeEnabled(key)) {       if (children != null) {         for (Figure child : children) {           child.set(key, newValue);}}}}", "nl": "Sets an attribute of the figure"}
{"code": "public Layouter getLayouter() {     return layouter;}", "nl": "Get a Layouter object which encapsulated a layout algorithm for this figure"}
{"code": "public void layout() {     if (getLayouter() != null) {       Rectangle2D.Double bounds = getBounds();       Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);       Rectangle2D.Double r = getLayouter().layout(           this, p, p           );       invalidate();}}", "nl": "A layout algorithm is used to define how the child components should be laid out in relation to each other"}
{"code": "public EllipseFigure(double x, double y, double width, double height) {     ellipse = new Ellipse2D.Double(x, y, width, height);}", "nl": "Constructs and initializes an EllipseFigure from the specified coordinates"}
{"code": "public void mouseReleased(MouseEvent evt) {     if (popupTimer != null) {       popupTimer.stop();       popupTimer = null;     }     if (isMousePressedPopupTrigger) {       isMousePressedPopupTrigger = false;     } else {       if (evt.isPopupTrigger()) {         handlePopupMenu(evt);       } else {         super.mouseReleased(evt);}}}", "nl": "MouseListener method for mouseReleased events"}
{"code": "protected void handlePopupMenu(MouseEvent evt) {     Point p = new Point(evt.getX(), evt.getY());     Figure figure = getView().findFigure(p);     if (figure != null || drawingActions.size() > 0) {       showPopupMenu(figure, p, evt.getComponent());     } else {       popupMenu = null;}}", "nl": "Hook method which can be overriden by subclasses to provide specialised behaviour in the event of a popup trigger"}
{"code": "public DelegationSelectionTool() {     this(new LinkedList<Action>(), new LinkedList<Action>());}", "nl": "Creates a new instance"}
{"code": "public DelegationSelectionTool(Collection<Action> drawingActions, Collection<Action> selectionActions) {     this.drawingActions = drawingActions;     this.selectionActions = selectionActions;}", "nl": "Creates a new instance"}
{"code": "protected void handleDoubleClick(MouseEvent evt) {     if (DEBUG) {       System.out.println(\"DelegationSelectionTool.handleDoubleClick \" + evt);     }     DrawingView v = getView();     Point pos = new Point(evt.getX(), evt.getY());     Handle handle = v.findHandle(pos);     if (handle != null) {       if (DEBUG) {         System.out.println(\"DelegationSelectionTool.handleDoubleClick by handle\");       }       handle.trackDoubleClick(pos, evt.getModifiersEx());     } else {       Point2D.Double p = viewToDrawing(pos);                                   Figure figure = null;       if (isSelectBehindEnabled()) {         for (Figure f : v.getSelectedFigures()) {           if (f.contains(p)) {             figure = f;             break;           }         }       }                     if (figure == null) {         figure = v.findFigure(pos);       }       Figure outerFigure = figure;       if (figure != null && figure.isSelectable()) {         if (DEBUG) {           System.out.println(\"DelegationSelectionTool.handleDoubleClick by figure\");         }         Tool figureTool = figure.getTool(p);         if (figureTool == null) {           figure = getDrawing().findFigureInside(p);           if (figure != null) {             figureTool = figure.getTool(p);           }         }         if (figureTool != null) {           setTracker(figureTool);           figureTool.mousePressed(evt);         } else {           if (outerFigure.handleMouseClick(p, evt, getView())) {             v.clearSelection();             v.addToSelection(outerFigure);           } else {             v.clearSelection();             v.addToSelection(outerFigure);             v.setHandleDetailLevel(v.getHandleDetailLevel() + 1);           }         }       }     }     evt.consume();}", "nl": "Hook method which can be overriden by subclasses to provide specialised behaviour in the event of a double click"}
{"code": "public DefaultHandleTracker(Handle handle) {     masterHandle = handle;     multicaster = new HandleMulticaster(handle);}", "nl": "Creates a new instance"}
{"code": "public CreationTool(Figure prototype, Map<AttributeKey, Object> attributes, String name) {     this.prototype = prototype;     this.prototypeAttributes = attributes;     if (name == null) {       ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");       name = labels.getString(\"edit.createFigure.text\");     }     this.presentationName = name;}", "nl": "Creates a new instance with the specified prototype and attribute set"}
{"code": "public CreationTool(Figure prototype) {     this(prototype, null, null);}", "nl": "Creates a new instance with the specified prototype but without an attribute set"}
{"code": "public CreationTool(String prototypeClassName) {     this(prototypeClassName, null, null);}", "nl": "Creates a new instance"}
{"code": "public void setToolDoneAfterCreation(boolean newValue) {     boolean oldValue = isToolDoneAfterCreation;     isToolDoneAfterCreation = newValue;}", "nl": "If this is set to false , the CreationTool does not fire toolDone after a new Figure has been created"}
{"code": "protected void creationFinished(Figure createdFigure) {     if (createdFigure.isSelectable()) {       getView().addToSelection(createdFigure);     }     if (isToolDoneAfterCreation()) {       fireToolDone();}}", "nl": "This method allows subclasses to do perform additonal user interactions after the new figure has been created"}
{"code": "public ImageTransferable(Image image) {     this.image = image;}", "nl": "Creates a new instance"}
{"code": "public void setUpdateDrawingEditorDefaults(boolean newValue) {     isUpdateDrawingEditorDefaults = newValue;}", "nl": "Set this to true if you want the attribute editor to update the default values of the drawing editor"}
{"code": "public AttributeEditor<T> getAttributeEditor() {     return attributeEditor;}", "nl": "Returns the AttributeEditor to which this FigureAttributeEditorHandler is attached"}
{"code": "public DrawingView getView() {     return view;}", "nl": "Returns the DrawingView to which this FigureAttributeEditorHandler is attached"}
{"code": "public boolean isUpdateDrawingEditorDefaults() {     return isUpdateDrawingEditorDefaults;}", "nl": "Returns true if the attribute editor updates the default values of the drawing editor"}
{"code": "public DrawingEditor getDrawingEditor() {     return drawingEditor;}", "nl": "Returns the DrawingEditor to which this FigureAttributeEditorHandler is attached"}
{"code": "private static Method getListenerMethod(Class listenerInterface,   String listenerMethodName) {          Method[] m = listenerInterface.getMethods();     Method result = null;     for (int i = 0; i < m.length; i++) {       if (listenerMethodName.equals(m[i].getName())) {         if (result != null) {           throw new RuntimeException(\"ambiguous method: \"+m[i]+\" vs. \"+result);         }         result = m[i];       }     }     if (result == null) {       throw new RuntimeException(\"no such method \"+listenerMethodName+\" in \"+listenerInterface);     }     return result;}", "nl": "Helper methods for EZ version of create : - - - - - - - - - - - - - - Implementation of the InvocationHandler which handles the basic object methods"}
{"code": "public static Object create(   Class listenerInterface,   String listenerMethodName,   Object target,   String targetMethodName) {     Method listenerMethod = getListenerMethod(listenerInterface, listenerMethodName);               Method targetMethod =     getTargetMethod(target, targetMethodName, listenerMethod.getParameterTypes());               if (targetMethod == null) {       targetMethod = getTargetMethod(target, targetMethodName, new Class[0]);     }               if (targetMethod == null) {       throw new RuntimeException(\"no such method \"+targetMethodName+\" in \"+target.getClass());     }          return create(listenerMethod, target, targetMethod);}", "nl": "A convenient version of create"}
{"code": "public JNLPClipboard(Object target) {     this.target = target;}", "nl": "Creates a new proxy for the specified target object"}
{"code": "@SuppressWarnings(\"unchecked\")   private void initDrawing(Drawing d) {     d.setInputFormats((java.util.List<InputFormat>) Collections.EMPTY_LIST);     d.setOutputFormats((java.util.List<OutputFormat>) Collections.EMPTY_LIST);     DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(         new NetFactory());     d.addInputFormat(ioFormat);     d.addInputFormat(new ImageInputFormat(new ImageFigure()));     d.addInputFormat(new TextInputFormat(new TextFigure()));     d.addOutputFormat(ioFormat);     d.addOutputFormat(new ImageOutputFormat());}", "nl": "Configure Drawing object to support copy and paste"}
{"code": "public String getParameter(String name) {     try {       return super.getParameter(name);     } catch (NullPointerException e) {       return null;}}", "nl": "We override getParameter to make it work even if we have no Applet context"}
{"code": "public void init() {               try {       UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());     } catch (Throwable e) {                          }                    try {       PopupFactory.setSharedInstance(new PopupFactory());     } catch (Throwable e) {            }                Container c = getContentPane();     c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));     String[] labels = getAppletInfo().split(\"\\n\");     for (int i = 0; i < labels.length; i++) {       c.add(new JLabel((labels[i].length() == 0) ? \" \" : labels[i]));     }               new Worker<Drawing>() {       protected Drawing construct() throws IOException {         Drawing result;         System.out.println(\"getParameter.datafile:\" + getParameter(\"datafile\"));         if (getParameter(\"data\") != null) {           NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), new StringReader(getParameter(\"data\")));           result = (Drawing) domi.readObject(0);         } else if (getParameter(\"datafile\") != null) {           URL url = new URL(getDocumentBase(), getParameter(\"datafile\"));           InputStream in = url.openConnection().getInputStream();           try {             NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), in);             result = (Drawing) domi.readObject(0);           } finally {             in.close();           }         } else {           result = null;         }         return result;       }       @Override       protected void done(Drawing result) {         Container c = getContentPane();         c.setLayout(new BorderLayout());         c.removeAll();         c.add(drawingPanel = new NetPanel());         if (result != null) {           Drawing drawing = (Drawing) result;           setDrawing(drawing);         }       }       @Override       protected void failed(Throwable value) {         Container c = getContentPane();         c.setLayout(new BorderLayout());         c.removeAll();         c.add(drawingPanel = new NetPanel());         value.printStackTrace();         getDrawing().add(new TextFigure(value.toString()));         value.printStackTrace();       }       @Override       protected void finished() {         Container c = getContentPane();         initDrawing(getDrawing());         c.validate();       }     }.start();}", "nl": "Initializes the applet NetApplet"}
{"code": "private void initComponents() {     toolButtonGroup = new javax.swing.ButtonGroup();}", "nl": "This method is called from within the init method to initialize the form"}
{"code": "public SVGDrawingPanelSample() {     initComponents();     setSize(new Dimension(600, 400));}", "nl": "Creates new form SVGDrawingPanelSample"}
{"code": "@SuppressWarnings(\"unchecked\")      private void initComponents() {     svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();     menuBar = new javax.swing.JMenuBar();     fileMenu = new javax.swing.JMenu();     openMenuItem = new javax.swing.JMenuItem();     saveAsMenuItem = new javax.swing.JMenuItem();     FormListener formListener = new FormListener();     setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);     getContentPane().add(svgPanel, java.awt.BorderLayout.CENTER);     fileMenu.setText(\"File\");     openMenuItem.setText(\"Open...\");     openMenuItem.addActionListener(formListener);     fileMenu.add(openMenuItem);     saveAsMenuItem.setText(\"Save As...\");     saveAsMenuItem.addActionListener(formListener);     fileMenu.add(saveAsMenuItem);     menuBar.add(fileMenu);     setJMenuBar(menuBar);     pack();}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public SelectionToolSample() {       LineFigure lf = new LineFigure();       lf.setBounds(new Point2D.Double(40,40), new Point2D.Double(200, 40));              Drawing drawing = new DefaultDrawing();        drawing.add(lf);              JFrame f = new JFrame(\"UltraMini\");        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        f.setSize(600,300);        DrawingView view = new DefaultDrawingView();        view.setDrawing(drawing);       f.getContentPane().add(view.getComponent());               DrawingEditor editor = new DefaultDrawingEditor();       editor.add(view);                                   editor.setTool(new SelectionTool());                                                                                                  f.show();}", "nl": "Creates a new instance of SelectionToolSample"}
{"code": "public SheetEvent(JSheet source, URIChooser chooser, int option, Object value) {     super(source);     this.pane = chooser;     this.option = option;     this.value = value;}", "nl": "Creates a new instance"}
{"code": "public Object getPane() {     return pane;}", "nl": "Returns the pane on the sheet"}
{"code": "public JFileChooser getFileChooser() {     return (JFileChooser) pane;}", "nl": "Returns the JFileChooser pane on the sheet"}
{"code": "public SheetEvent(JSheet source) {     super(source);}", "nl": "Creates a new instance"}
{"code": "public SheetEvent(JSheet source, JFileChooser fileChooser, int option, Object value) {     super(source);     this.pane = fileChooser;     this.option = option;     this.value = value;}", "nl": "Creates a new instance"}
{"code": "public Object getValue() {     return value;}", "nl": "Returns the value that the JFileChooser or JOptionPane returned"}
{"code": "public JOptionPane getOptionPane() {     return (JOptionPane) pane;}", "nl": "Returns the JOptionPane pane on the sheet"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     linkLabel = new javax.swing.JLabel();     linkField = new org.jhotdraw.gui.JAttributeTextField();     opacityLabel = new javax.swing.JLabel();     opacityField = new org.jhotdraw.gui.JAttributeTextField();     opacityPopupButton = new org.jhotdraw.gui.JPopupButton();     setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));     setLayout(new java.awt.GridBagLayout());     linkLabel.setLabelFor(linkField);     linkLabel.setText(labels.getString(\"link\"));      add(linkLabel, new java.awt.GridBagConstraints());     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.weightx = 1.0;     add(linkField, gridBagConstraints);     opacityLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/jhotdraw/draw/action/images/attributeOpacity.png\")));      opacityLabel.setToolTipText(labels.getString(\"opacity\"));      gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);     add(opacityLabel, gridBagConstraints);     opacityField.setColumns(3);     add(opacityField, new java.awt.GridBagConstraints());     opacityPopupButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/jhotdraw/draw/action/images/popupIcon.png\")));      add(opacityPopupButton, new java.awt.GridBagConstraints());}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "protected Drawing createDrawing() {     Drawing drawing = new ODGDrawing();     LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();     inputFormats.add(new ODGInputFormat());     inputFormats.add(new ImageInputFormat(new SVGImageFigure()));     inputFormats.add(new TextInputFormat(new SVGTextFigure()));     drawing.setInputFormats(inputFormats);     LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();     outputFormats.add(new SVGOutputFormat());     outputFormats.add(new SVGZOutputFormat());     outputFormats.add(new ImageOutputFormat());     outputFormats.add(new ImageOutputFormat(\"JPG\", \"Joint Photographics Experts Group (JPEG)\", \"jpg\", BufferedImage.TYPE_INT_RGB));     outputFormats.add(new ImageOutputFormat(\"BMP\", \"Windows Bitmap (BMP)\", \"bmp\", BufferedImage.TYPE_BYTE_INDEXED));     outputFormats.add(new ImageMapOutputFormat());     drawing.setOutputFormats(outputFormats);     return drawing;}", "nl": "Creates a new Drawing for this view"}
{"code": "public Pageable createPageable() {     return new DrawingPageable(view.getDrawing());}", "nl": "Creates a Pageable object for printing the view"}
{"code": "private void initComponents() {     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     propertiesPanel = new org.jhotdraw.samples.odg.ODGPropertiesPanel();     setLayout(new java.awt.BorderLayout());     scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);     scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);     add(propertiesPanel, java.awt.BorderLayout.SOUTH);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "private void initActions() {     getActionMap().put(UndoAction.ID, undo.getUndoAction());     getActionMap().put(RedoAction.ID, undo.getRedoAction());}", "nl": "Initializes view specific actions"}
{"code": "public boolean contains(Point2D.Double p) {          return getTransformedShape().contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public ODGEllipseFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public void transform(AffineTransform tx) {     if (get(TRANSFORM) != null ||         (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {       if (get(TRANSFORM) == null) {         TRANSFORM.setClone(this, tx);       } else {         AffineTransform t = TRANSFORM.getClone(this);         t.preConcatenate(tx);         set(TRANSFORM, t);       }     } else {       Point2D.Double anchor = getStartPoint();       Point2D.Double lead = getEndPoint();       setBounds(           (Point2D.Double) tx.transform(anchor, anchor),           (Point2D.Double) tx.transform(lead, lead));       if (get(FILL_GRADIENT) != null &&           !get(FILL_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = FILL_GRADIENT.getClone(this);         g.transform(tx);         set(FILL_GRADIENT, g);       }       if (get(STROKE_GRADIENT) != null &&           !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = STROKE_GRADIENT.getClone(this);         g.transform(tx);         set(STROKE_GRADIENT, g);       }     }     invalidate();}", "nl": "Transforms the figure"}
{"code": "@SuppressWarnings(\"unchecked\")      private void initComponents() {     previewLabel = new javax.swing.JLabel();     setLayout(new java.awt.BorderLayout());     previewLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);     add(previewLabel, java.awt.BorderLayout.CENTER);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "@Override   public void installUI(JComponent c) {     installComponents(fontChooser);     installListeners(fontChooser);}", "nl": "Configures the specified component appropriate for the look and feel"}
{"code": "public static ComponentUI createUI(JComponent c) {     PaletteFontChooserUI ui = new PaletteFontChooserUI((JFontChooser) c);     return ui;}", "nl": "Returns an instance of the UI delegate for the specified component"}
{"code": "public void uninstallUI(JComponent c) {     uninstallListeners(fontChooser);     uninstallComponents(fontChooser);}", "nl": "Reverses configuration which was done on the specified component during installUI"}
{"code": "public TextCreationTool(TextHolderFigure prototype, Map<AttributeKey,Object> attributes) {     super(prototype, attributes);}", "nl": "Creates a new instance"}
{"code": "public TextCreationTool(TextHolderFigure prototype) {     super(prototype);}", "nl": "Creates a new instance"}
{"code": "@Override   public void mousePressed(MouseEvent e) {     TextHolderFigure textHolder = null;                         DrawingView v = getView();     Point2D.Double p = v.viewToDrawing(e.getPoint());     Figure pressedFigure = null;     if (true ) {       for (Figure f : v.getSelectedFigures()) {         if (f.contains(p)) {           pressedFigure = f;           break;         }       }     }               if (pressedFigure == null) {       pressedFigure = getDrawing().findFigureInside(p);     }     if (pressedFigure instanceof TextHolderFigure) {       textHolder = ((TextHolderFigure) pressedFigure).getLabelFor();         textHolder = null;     }     if (textHolder != null) {       beginEdit(textHolder);       updateCursor(getView(), e.getPoint());           return;     }     if (typingTarget != null) {       endEdit();       if (isToolDoneAfterCreation()) {         fireToolDone();       }     } else {       super.mousePressed(e);                     textHolder = (TextHolderFigure)getCreatedFigure();       getView().clearSelection();       getView().addToSelection(textHolder);       beginEdit(textHolder);       updateCursor(getView(), e.getPoint());}}", "nl": "Creates a new figure at the location where the mouse was pressed"}
{"code": "public TextAreaCreationTool(TextHolderFigure prototype) {     super(prototype);}", "nl": "Creates a new instance"}
{"code": "public PaletteFontChooserSelectionPanel() {      labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.gui.Labels\");     initComponents();     collectionList.setModel(new DefaultListModel());     familyList.setModel(new DefaultListModel());     faceList.setModel(new DefaultListModel());               Font smallSystemFont = new Font(\"Dialog\", Font.PLAIN, 11);     collectionsScrollPane.setFont(smallSystemFont);     familiesScrollPane.setFont(smallSystemFont);     facesScrollPane.setFont(smallSystemFont);}", "nl": "Creates new form FontChooserPanel"}
{"code": "@SuppressWarnings(\"unchecked\")      private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     collectionsPanel = new javax.swing.JPanel();     collectionsScrollPane = new javax.swing.JScrollPane();     collectionList = new javax.swing.JList();     collectionsLabel = new javax.swing.JLabel();     familiesPanel = new javax.swing.JPanel();     familiesScrollPane = new javax.swing.JScrollPane();     familyList = new javax.swing.JList();     familyLabel = new javax.swing.JLabel();     facesPanel = new javax.swing.JPanel();     facesScrollPane = new javax.swing.JScrollPane();     faceList = new javax.swing.JList();     faceLabel = new javax.swing.JLabel();     setBorder(javax.swing.BorderFactory.createEmptyBorder(3, 3, 3, 3));     setLayout(new java.awt.GridBagLayout());     collectionsPanel.setPreferredSize(new java.awt.Dimension(80, 200));     collectionsPanel.setLayout(new java.awt.BorderLayout());     collectionsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);     collectionList.setFont(collectionList.getFont().deriveFont((float)11));     collectionsScrollPane.setViewportView(collectionList);     collectionsPanel.add(collectionsScrollPane, java.awt.BorderLayout.CENTER);     collectionsLabel.setFont(collectionsLabel.getFont().deriveFont((float)11));     collectionsLabel.setText(labels.getString(\"FontCollection.collections\"));      collectionsPanel.add(collectionsLabel, java.awt.BorderLayout.PAGE_START);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;     gridBagConstraints.weightx = 0.3;     gridBagConstraints.weighty = 1.0;     add(collectionsPanel, gridBagConstraints);     familiesPanel.setPreferredSize(new java.awt.Dimension(140, 200));     familiesPanel.setLayout(new java.awt.BorderLayout());     familiesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);     familyList.setFont(familyList.getFont().deriveFont((float)11));     familiesScrollPane.setViewportView(familyList);     familiesPanel.add(familiesScrollPane, java.awt.BorderLayout.CENTER);     familyLabel.setFont(familyLabel.getFont().deriveFont((float)11));     familyLabel.setText(labels.getString(\"FontCollection.family\"));      familiesPanel.add(familyLabel, java.awt.BorderLayout.PAGE_START);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;     gridBagConstraints.weightx = 0.4;     gridBagConstraints.weighty = 1.0;     gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);     add(familiesPanel, gridBagConstraints);     facesPanel.setPreferredSize(new java.awt.Dimension(80, 200));     facesPanel.setLayout(new java.awt.BorderLayout());     facesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);     facesScrollPane.setPreferredSize(new java.awt.Dimension(130, 240));     faceList.setFont(faceList.getFont().deriveFont((float)11));     facesScrollPane.setViewportView(faceList);     facesPanel.add(facesScrollPane, java.awt.BorderLayout.CENTER);     faceLabel.setFont(faceLabel.getFont().deriveFont((float)11));     faceLabel.setText(labels.getString(\"FontCollection.typeface\"));      facesPanel.add(faceLabel, java.awt.BorderLayout.PAGE_START);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;     gridBagConstraints.weightx = 0.3;     gridBagConstraints.weighty = 1.0;     gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);     add(facesPanel, gridBagConstraints);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "protected String layoutCL(       JLabel label,       FontMetrics fontMetrics,       String text,       Icon icon,       Rectangle viewR,       Rectangle iconR,       Rectangle textR) {     return SwingUtilities.layoutCompoundLabel(         (JComponent) label,         fontMetrics,         text,         icon,         label.getVerticalAlignment(),         label.getHorizontalAlignment(),         label.getVerticalTextPosition(),         label.getHorizontalTextPosition(),         viewR,         iconR,         textR,         label.getIconTextGap());}", "nl": "Forwards the call to SwingUtilities . layoutCompoundLabel"}
{"code": "public static ComponentUI createUI(JComponent c) {     return labelUI;}", "nl": "Preferred spacing between labels and other components"}
{"code": "protected void paintDisabledText(JLabel l, Graphics g, String s, int textX, int textY) {     Color c = UIManager.getColor(\"Label.disabledForeground\");     g.setColor((c != null) ? c : l.getForeground());     int accChar = -1;      PaletteUtilities.drawString(g, s, accChar,         textX, textY);}", "nl": "Paint label with disabled text color"}
{"code": "public MultiIcon(Icon[] icons) {     this.icons = icons;     generateMissingIcons();}", "nl": "Creates a new instance from an array of icons"}
{"code": "public Point2D.Double[] toPolygonArray() {     Point2D.Double[] points = new Point2D.Double[size()];     for (int i = 0, n = size(); i < n; i++) {       points[i] = new Point2D.Double(get(i).x[0], get(i).y[0]);     }     return points;}", "nl": "Creates a polygon array of the bezier path"}
{"code": "public int indexOfOutermostNode() {     if (outer == -1) {       Point2D.Double ctr = getCenter();       outer = 0;       double dist = 0;       for (int i = 0, n = size(); i < n; i++) {         Node cp = get(i);         double d = Geom.length2(ctr.x, ctr.y,             cp.x[0],             cp.y[0]);         if (d > dist) {           dist = d;           outer = i;         }       }     }     return outer;}", "nl": "Return the index of the control point that is furthest from the center - - - - - - - - - - - - - - Point2D . Double ctr = getCenter ; Chopped point double cx = - 1 ; double cy = - 1 ; double len = Double . MAX _ VALUE ; Try for points along edge validatePath ; PathIterator i = generalPath . getPathIterator , 1 ) ; double [ ] coords = new double [ 6 ] ; int type = i . currentSegment ; double prevX = coords [ 0 ] ; double prevY = coords [ 1 ] ; i . next ; for ; i . next ) i . currentSegment ; Point2D . Double chop = Geom . intersect ; if double cl = Geom . length2 ; if len = cl ; cx = chop . x ; cy = chop . y ; } prevX = coords [ 0 ] ; prevY = coords [ 1 ] ; } if & & size > 1 ) Node first = get ; Node last = get - 1 ) ; Point2D . Double chop = Geom . intersect ; if double cl = Geom . length2 ; if len = cl ; cx = chop . x ; cy = chop . y ; } } if none found , pick closest vertex if for ; j"}
{"code": "public Point2D.Double get(int index, int coord) {     Node c = get(index);     return new Point2D.Double(         c.x[coord],         c.y[coord]);}", "nl": "Convenience method for getting a single coordinate of a control point"}
{"code": "public double getLengthOfPath(double flatness) {     double len = 0;     PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);     double[] coords = new double[6];     int type = i.currentSegment(coords);     double prevX = coords[0];     double prevY = coords[1];     i.next();     for (; !i.isDone(); i.next()) {       i.currentSegment(coords);       len += Geom.length(prevX, prevY, coords[0], coords[1]);       prevX = coords[0];       prevY = coords[1];     }     return len;}", "nl": "Returns the length of the path"}
{"code": "public void transform(AffineTransform tx) {     Point2D.Double p = new Point2D.Double();     for (Node cp : this) {       for (int i = 0; i < 3; i++) {         p.x = cp.x[i];         p.y = cp.y[i];         tx.transform(p, p);         cp.x[i] = p.x;         cp.y[i] = p.y;       }     }     invalidatePath();}", "nl": "Transforms the BezierPath"}
{"code": "public void set(int index, int coord, Point2D.Double p) {     Node c = get(index);     c.x[coord] = p.x;     c.y[coord] = p.y;}", "nl": "Convenience method for changing a single coordinate of a control point"}
{"code": "public void add(int mask, Point2D.Double c0, Point2D.Double c1, Point2D.Double c2) {     add(new Node(mask, c0, c1, c2));}", "nl": "Convenience method for adding a control point with three coordinates C0 , C1 and C2 with a mask"}
{"code": "public Point2D.Double chop(Point2D.Double p) {     validatePath();     return Geom.chop(generalPath, p);}", "nl": "Returns a point on the edge of the bezier path which crosses the line from the center of the bezier path to the specified point"}
{"code": "public void setWindingRule(int newValue) {     if (newValue != windingRule) {       invalidatePath();       int oldValue = windingRule;       this.windingRule = newValue;}}", "nl": "Sets winding rule for filling the bezier path"}
{"code": "public void validatePath() {     if (generalPath == null) {       generalPath = toGeneralPath();}}", "nl": "Recomputes the BezierPath , if it is invalid"}
{"code": "public int findSegment(Point2D.Double find, double tolerance) {          Node v1, v2;     BezierPath tempPath = new BezierPath();     Node t1, t2;     tempPath.add(t1 = new Node());     tempPath.add(t2 = new Node());     for (int i = 0, n = size() - 1; i < n; i++) {       v1 = get(i);       v2 = get(i + 1);       if (v1.mask == 0 && v2.mask == 0) {         if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {           return i;         }       } else {         t1.setTo(v1);         t2.setTo(v2);         tempPath.invalidatePath();         if (tempPath.outlineContains(find, tolerance)) {           return i;         }       }     }     if (isClosed && size() > 1) {       v1 = get(size() - 1);       v2 = get(0);       if (v1.mask == 0 && v2.mask == 0) {         if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {           return size() - 1;         }       } else {         t1.setTo(v1);         t2.setTo(v2);         tempPath.invalidatePath();         if (tempPath.outlineContains(find, tolerance)) {           return size() - 1;         }       }     }     return -1;}", "nl": "Gets the segment of the polyline that is hit by the given Point2D . Double"}
{"code": "public Point2D.Double getPointOnPath(double relative, double flatness) {          if (size() == 0) {       return null;     } else if (size() == 1) {       return get(0).getControlPoint(0);     }     if (relative <= 0) {       return get(0).getControlPoint(0);     } else if (relative >= 1) {       return get(size() - 1).getControlPoint(0);     }     validatePath();          double len = getLengthOfPath(flatness);     double relativeLen = len * relative;     double pos = 0;     double[] coords = new double[6];     PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);     int type = i.currentSegment(coords);     double prevX = coords[0];     double prevY = coords[1];     i.next();     for (; !i.isDone(); i.next()) {       i.currentSegment(coords);       double segLen = Geom.length(prevX, prevY, coords[0], coords[1]);       if (pos + segLen >= relativeLen) {                                    double factor = (relativeLen - pos) / segLen;         return new Point2D.Double(             prevX * (1 - factor) + coords[0] * factor,             prevY * (1 - factor) + coords[1] * factor);       }       pos += segLen;       prevX = coords[0];       prevY = coords[1];     }     throw new InternalError(\"We should never get here\");}", "nl": "Returns a relative point on the path"}
{"code": "public int joinSegments(Point2D.Double join, double tolerance) {     for (int i = 0; i < size(); i++) {       Node p = get(i);       if (Geom.length(p.x[0], p.y[0], join.x, join.y) < tolerance) {         remove(i);         return i;       }     }     return -1;}", "nl": "Joins two segments into one if the given Point2D . Double hits a node of the bezier path"}
{"code": "public boolean outlineContains(Point2D.Double p, double tolerance) {     return Shapes.outlineContains(this, p, tolerance);}", "nl": "Returns true , if the outline of this bezier path contains the specified point"}
{"code": "public void invalidatePath() {     generalPath = null;     bounds = null;     outer = -1;}", "nl": "This must be called after the BezierPath has been changed"}
{"code": "@Override   public void mousePressed(MouseEvent e) {     if (typingTarget != null) {       beginEdit(typingTarget);       updateCursor(getView(), e.getPoint());}}", "nl": "Creates a new figure at the mouse location"}
{"code": "public TextAreaEditingTool(TextHolderFigure typingTarget) {     this.typingTarget = typingTarget;}", "nl": "Creates a new instance"}
{"code": "@Override   public void mousePressed(MouseEvent e) {     if (typingTarget != null) {       beginEdit(typingTarget);       updateCursor(getView(), e.getPoint());}}", "nl": "If the pressed figure is a TextHolderFigure it can be edited"}
{"code": "public TextEditingTool(TextHolderFigure typingTarget) {     this.typingTarget = typingTarget;}", "nl": "Creates a new instance"}
{"code": "private static double[] reparameterize(ArrayList<Point2D.Double> d, int first, int last, double[] u, Point2D.Double[] bezCurve) {     int nPts = last - first + 1;     int i;     double[] uPrime;      uPrime = new double[nPts];     for (i = first; i <= last; i++) {       uPrime[i - first] = newtonRaphsonRootFind(bezCurve, d.get(i), u[i - first]);     }     return (uPrime);}", "nl": "Given set of points and their parameterization , try to find a better parameterization"}
{"code": "public static BezierPath fitBezierPath(Point2D.Double[] digitizedPoints, double error) {     return fitBezierPath(Arrays.asList(digitizedPoints), error);}", "nl": "Fits a bezier path to the specified list of digitized points"}
{"code": "private static double[] chordLengthParameterize(ArrayList<Point2D.Double> d, int first, int last) {     int i;     double[] u;       u = new double[last - first + 1];     u[0] = 0.0;     for (i = first + 1; i <= last; i++) {       u[i - first] = u[i - first - 1] +           v2DistanceBetween2Points(d.get(i), d.get(i - 1));     }     for (i = first + 1; i <= last; i++) {       u[i - first] = u[i - first] / u[last - first];     }     return (u);}", "nl": "Assign parameter values to digitized points using relative distances between points"}
{"code": "private static void fitCubic(ArrayList<Point2D.Double> d, int first, int last,       Point2D.Double tHat1, Point2D.Double tHat2,       double errorSquared, BezierPath bezierPath) {     Point2D.Double[] bezCurve;      double[] u;         double maxError;       int[] splitPoint = new int[1];      int nPts;         double iterationError;      int maxIterations = 4;      Point2D.Double tHatCenter = new Point2D.Double();      int i;               tHat1 = (Point2D.Double) tHat1.clone();     tHat2 = (Point2D.Double) tHat2.clone();     iterationError = errorSquared * errorSquared;     nPts = last - first + 1;          if (nPts == 2) {       double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;       bezCurve = new Point2D.Double[4];       for (i = 0; i < bezCurve.length; i++) {         bezCurve[i] = new Point2D.Double();       }       bezCurve[0] = d.get(first);       bezCurve[3] = d.get(last);       v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);       v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);       bezierPath.curveTo(           bezCurve[1].x, bezCurve[1].y,           bezCurve[2].x, bezCurve[2].y,           bezCurve[3].x, bezCurve[3].y);       return;     }          u = chordLengthParameterize(d, first, last);     bezCurve = generateBezier(d, first, last, u, tHat1, tHat2);}", "nl": "Fit one or multiple subsequent cubic bezier curves to a set of digitized points"}
{"code": "private static Point2D.Double computeCenterTangent(ArrayList<Point2D.Double> d, int center) {     Point2D.Double V1 = new Point2D.Double(), V2 = new Point2D.Double(),         tHatCenter = new Point2D.Double();     V1 = v2SubII(d.get(center - 1), d.get(center));     V2 = v2SubII(d.get(center), d.get(center + 1));     tHatCenter.x = (V1.x + V2.x) / 2.0;     tHatCenter.y = (V1.y + V2.y) / 2.0;     tHatCenter = v2Normalize(tHatCenter);     return tHatCenter;}", "nl": "Approximate unit tangents at center of digitized curve"}
{"code": "private static Point2D.Double v2SubII(Point2D.Double a, Point2D.Double b) {     Point2D.Double c = new Point2D.Double();     c.x = a.x - b.x;     c.y = a.y - b.y;     return (c);}", "nl": "Subtract Vector a from Vector b"}
{"code": "private static Point2D.Double v2Normalize(Point2D.Double v) {     double len = v2Length(v);     if (len != 0.0) {       v.x /= len;       v.y /= len;     }     return v;}", "nl": "Normalizes the input vector and returns it"}
{"code": "private static Point2D.Double bezierII(int degree, Point2D.Double[] V, double t) {     int i, j;     Point2D.Double q;      Point2D.Double[] vTemp;           vTemp = new Point2D.Double[degree + 1];     for (i = 0; i <= degree; i++) {       vTemp[i] = (Point2D.Double) V[i].clone();     }          for (i = 1; i <= degree; i++) {       for (j = 0; j <= degree - i; j++) {         vTemp[j].x = (1.0 - t) * vTemp[j].x + t * vTemp[j + 1].x;         vTemp[j].y = (1.0 - t) * vTemp[j].y + t * vTemp[j + 1].y;       }     }     q = vTemp[0];     return q;}", "nl": "Evaluate a Bezier curve at a particular parameter value"}
{"code": "private static double v2DistanceBetween2Points(Point2D.Double a, Point2D.Double b) {     return Math.sqrt(v2SquaredDistanceBetween2Points(a, b));}", "nl": "Return the distance between two points"}
{"code": "private static Point2D.Double computeRightTangent(ArrayList<Point2D.Double> d, int end) {     Point2D.Double tHat2 = new Point2D.Double();     tHat2 = v2SubII(d.get(end - 1), d.get(end));     tHat2 = v2Normalize(tHat2);     return tHat2;}", "nl": "Approximate unit tangents at right endpoint of digitized curve"}
{"code": "private static Point2D.Double v2Negate(Point2D.Double v) {     v.x = -v.x;     v.y = -v.y;     return v;}", "nl": "Negates the input vector and returns it"}
{"code": "private static void addCurveTo(Point2D.Double[] bezCurve, BezierPath bezierPath, double errorSquared, boolean connectsCorners) {     BezierPath.Node lastNode = bezierPath.get(bezierPath.size() - 1);     double error = Math.sqrt(errorSquared);     if (connectsCorners && Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[1].x, bezCurve[1].y, error) &&         Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[2].x, bezCurve[2].y, error)) {       bezierPath.lineTo(           bezCurve[3].x, bezCurve[3].y);     } else {       bezierPath.curveTo(           bezCurve[1].x, bezCurve[1].y,           bezCurve[2].x, bezCurve[2].y,           bezCurve[3].x, bezCurve[3].y);}}", "nl": "Adds the curve to the bezier path"}
{"code": "public static ArrayList<ArrayList<Point2D.Double>> splitAtCorners(java.util.List<Point2D.Double> digitizedPoints, double maxAngle, double minDistance) {     ArrayList<Integer> cornerIndices = findCorners(digitizedPoints, maxAngle, minDistance);     ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>(cornerIndices.size() + 1);     if (cornerIndices.size() == 0) {       segments.add(new ArrayList<Point2D.Double>(digitizedPoints));     } else {       segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(0, cornerIndices.get(0) + 1)));       for (int i = 1; i < cornerIndices.size(); i++) {         segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(i - 1), cornerIndices.get(i) + 1)));       }       segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(cornerIndices.size() - 1), digitizedPoints.size())));     }     return segments;}", "nl": "Splits the digitized points into multiple segments at each corner point"}
{"code": "private static double v2Dot(Point2D.Double a, Point2D.Double b) {     return (a.x * b.x) + (a.y * b.y);}", "nl": "Return the dot product of vectors a and b"}
{"code": "private static Point2D.Double computeLeftTangent(ArrayList<Point2D.Double> d, int end) {     Point2D.Double tHat1 = new Point2D.Double();     tHat1 = v2SubII(d.get(end + 1), d.get(end));     tHat1 = v2Normalize(tHat1);     return tHat1;}", "nl": "Approximate unit tangents at left endpoint of digitized curve"}
{"code": "private static Point2D.Double v2AddII(Point2D.Double a, Point2D.Double b) {     Point2D.Double c = new Point2D.Double();     c.x = a.x + b.x;     c.y = a.y + b.y;     return c;}", "nl": "Return vector sum = a + b"}
{"code": "public static BezierPath fitBezierPath(java.util.List<Point2D.Double> digitizedPoints, double error) {          ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>();     segments = splitAtCorners(digitizedPoints, 77 / 180d * Math.PI, error * error);               for (int i = 0, n = segments.size(); i < n; i++) {       ArrayList<Point2D.Double> seg = segments.get(i);       seg = removeClosePoints(seg, error * 2);       seg = reduceNoise(seg, 0.8);       segments.set(i, seg);     }           BezierPath fittedPath = new BezierPath();           boolean isEmpty = false;     for (ArrayList<Point2D.Double> seg : segments) {       if (seg.isEmpty()) {         isEmpty = false;         break;       }     }     if (!isEmpty) {              double errorSquared = error * error;       for (ArrayList<Point2D.Double> seg : segments) {         switch (seg.size()) {           case 0:             break;           case 1:             fittedPath.add(new BezierPath.Node(seg.get(0)));             break;           case 2:             if (fittedPath.isEmpty()) {               fittedPath.add(new BezierPath.Node(seg.get(0)));             }             fittedPath.lineTo(seg.get(1).x, seg.get(1).y);             break;           default:             if (fittedPath.isEmpty()) {               fittedPath.add(new BezierPath.Node(seg.get(0)));             }                          Point2D.Double tHat1 = new Point2D.Double();             Point2D.Double tHat2 = new Point2D.Double();             tHat1 = computeLeftTangent(seg, 0);             tHat2 = computeRightTangent(seg, seg.size() - 1);             fitCubic(seg, 0, seg.size() - 1, tHat1, tHat2, errorSquared, fittedPath);             break;         }       }     }     return fittedPath;}", "nl": "Fits a bezier path to the specified list of digitized points"}
{"code": "private static Point2D.Double v2ScaleIII(Point2D.Double v, double s) {     Point2D.Double result = new Point2D.Double();     result.x = v.x * s;     result.y = v.y * s;     return result;}", "nl": "Scales the input vector by the specified factor and returns it"}
{"code": "private static double computeMaxError(ArrayList<Point2D.Double> d, int first, int last, Point2D.Double[] bezCurve, double[] u, int[] splitPoint) {     int i;     double maxDist;         double dist;         Point2D.Double P = new Point2D.Double();      Point2D.Double v = new Point2D.Double();      splitPoint[0] = (last - first + 1) / 2;     maxDist = 0.0;     for (i = first + 1; i < last; i++) {       P = bezierII(3, bezCurve, u[i - first]);       v = v2SubII(P, d.get(i));       dist = v2SquaredLength(v);       if (dist >= maxDist) {         maxDist = dist;         splitPoint[0] = i;       }     }     return (maxDist);}", "nl": "Find the maximum squared distance of digitized points to fitted curve"}
{"code": "public static ArrayList<Point2D.Double> removeClosePoints(java.util.List<Point2D.Double> digitizedPoints, double minDistance) {     if (minDistance == 0) {       return removeCoincidentPoints(digitizedPoints);     } else {       double squaredDistance = minDistance * minDistance;       java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();       if (digitizedPoints.size() > 0) {         Point2D.Double prev = digitizedPoints.get(0);         cleaned.add(prev);         for (Point2D.Double p : digitizedPoints) {           if (v2SquaredDistanceBetween2Points(prev, p) > squaredDistance) {             cleaned.add(p);             prev = p;           }         }         if (!prev.equals(digitizedPoints.get(digitizedPoints.size() - 1))) {           cleaned.set(cleaned.size() - 1, digitizedPoints.get(digitizedPoints.size() - 1));         }       }       return cleaned;}}", "nl": "Removes points which are closer together than the specified minimal distance"}
{"code": "private static Point2D.Double v2Add(Point2D.Double a, Point2D.Double b, Point2D.Double c) {     c.x = a.x + b.x;     c.y = a.y + b.y;     return c;}", "nl": "Return vector sum c = a + b"}
{"code": "private static double newtonRaphsonRootFind(Point2D.Double[] Q, Point2D.Double P, double u) {     double numerator, denominator;     Point2D.Double[] Q1 = new Point2D.Double[3], Q2 = new Point2D.Double[2];       Point2D.Double Q_u = new Point2D.Double(), Q1_u = new Point2D.Double(), Q2_u = new Point2D.Double();      double uPrime;         int i;          Q_u = bezierII(3, Q, u);          for (i = 0; i <= 2; i++) {       Q1[i] = new Point2D.Double(           (Q[i + 1].x - Q[i].x) * 3.0,           (Q[i + 1].y - Q[i].y) * 3.0);     }          for (i = 0; i <= 1; i++) {       Q2[i] = new Point2D.Double(           (Q1[i + 1].x - Q1[i].x) * 2.0,           (Q1[i + 1].y - Q1[i].y) * 2.0);     }          Q1_u = bezierII(2, Q1, u);     Q2_u = bezierII(1, Q2, u);          numerator = (Q_u.x - P.x) * (Q1_u.x) + (Q_u.y - P.y) * (Q1_u.y);     denominator = (Q1_u.x) * (Q1_u.x) + (Q1_u.y) * (Q1_u.y) +         (Q_u.x - P.x) * (Q2_u.x) + (Q_u.y - P.y) * (Q2_u.y);          uPrime = u - (numerator / denominator);     return (uPrime);}", "nl": "Use Newton - Raphson iteration to find better root"}
{"code": "public boolean isDone() {     return (index >= path.size() + (path.isClosed() ? 2 : 0));}", "nl": "Tests if there are more points to read"}
{"code": "public BezierPathIterator(BezierPath path, AffineTransform at) {     this.path = path;     this.affine = at;}", "nl": "Constructs an iterator given a BezierPath and an optional AffineTransform"}
{"code": "public int currentSegment(double[] coords) {     int numCoords = 0;     int type = 0;     if (index == path.size()) {              if (path.size() > 1) {         BezierPath.Node previous = path.get(path.size() - 1);         BezierPath.Node current = path.get(0);                  if ((previous.mask & BezierPath.C2_MASK) == 0) {           if ((current.mask & BezierPath.C1_MASK) == 0) {             numCoords = 1;             type = SEG_LINETO;             coords[0] = current.x[0];             coords[1] = current.y[0];           } else {             numCoords = 2;             type = SEG_QUADTO;             coords[0] = current.x[1];             coords[1] = current.y[1];             coords[2] = current.x[0];             coords[3] = current.y[0];           }         } else {           if ((current.mask & BezierPath.C1_MASK) == 0) {             numCoords = 2;             type = SEG_QUADTO;             coords[0] = previous.x[2];             coords[1] = previous.y[2];             coords[2] = current.x[0];             coords[3] = current.y[0];           } else {             numCoords = 3;             type = SEG_CUBICTO;             coords[0] = previous.x[2];             coords[1] = previous.y[2];             coords[2] = current.x[1];             coords[3] = current.y[1];             coords[4] = current.x[0];             coords[5] = current.y[0];           }         }       }     } else if (index > path.size()) {              return SEG_CLOSE;     } else if (index == 0) {       BezierPath.Node current = path.get(index);       coords[0] = current.x[0];       coords[1] = current.y[0];       numCoords = 1;       type = SEG_MOVETO;            } else if (index < path.size()) {       BezierPath.Node current = path.get(index);       BezierPath.Node previous = path.get(index - 1);              if ((previous.mask & BezierPath.C2_MASK) == 0) {         if ((current.mask & BezierPath.C1_MASK) == 0) {           numCoords = 1;           type = SEG_LINETO;           coords[0] = current.x[0];           coords[1] = current.y[0];                    } else {           numCoords = 2;           type = SEG_QUADTO;           coords[0] = current.x[1];           coords[1] = current.y[1];           coords[2] = current.x[0];           coords[3] = current.y[0];         }       } else {         if ((current.mask & BezierPath.C1_MASK) == 0) {           numCoords = 2;           type = SEG_QUADTO;           coords[0] = previous.x[2];           coords[1] = previous.y[2];           coords[2] = current.x[0];           coords[3] = current.y[0];         } else {           numCoords = 3;           type = SEG_CUBICTO;           coords[0] = previous.x[2];           coords[1] = previous.y[2];           coords[2] = current.x[1];           coords[3] = current.y[1];           coords[4] = current.x[0];           coords[5] = current.y[0];         }       }     }               if (affine != null) {       affine.transform(coords, 0, coords, 0, numCoords);     } else {       System.arraycopy(coords, 0, coords, 0, numCoords);     }     return type;}", "nl": "Returns the coordinates and type of the current path segment in the iteration"}
{"code": "public BezierPathIterator(BezierPath path) {     this(path, null);}", "nl": "Constructs an iterator given a BezierPath"}
{"code": "public static Polygon getConvexHullPolygon(List<Point> points) {     Polygon convexHull = new Polygon();     for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {       convexHull.addPoint(p.x, p.y);     }     return convexHull;}", "nl": "Computes the convex hull from a set of points"}
{"code": "public static Polygon2D.Double getConvexHullPath2D(List<Point2D.Double> points) {     Polygon2D.Double convexHull = new Polygon2D.Double();     for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {       convexHull.add(p);     }     return convexHull;}", "nl": "Computes the convex hull from a set of points"}
{"code": "public static List<Point2D.Double> getConvexHull2D(List<Point2D.Double> points) {     return Arrays.asList(getConvexHull2D(points.toArray(new Point2D.Double[points.size()])));}", "nl": "Computes the convex hull from a set of points"}
{"code": "public static List<Point> getConvexHull(List<Point> points) {     return Arrays.asList(getConvexHull(points.toArray(new Point[points.size()])));}", "nl": "Computes the convex hull from a set of points"}
{"code": "public void setDragTracker(DragTracker newValue) {     dragTracker = newValue;}", "nl": "Method to set a DragTracker"}
{"code": "public void setHandleTracker(HandleTracker newValue) {     handleTracker = newValue;}", "nl": "Method to set a HandleTracker"}
{"code": "public void setSelectAreaTracker(SelectAreaTracker newValue) {     selectAreaTracker = newValue;}", "nl": "Method to set a SelectAreaTracker"}
{"code": "public void setSelectBehindEnabled(boolean newValue) {     boolean oldValue = isSelectBehindEnabled;     isSelectBehindEnabled = newValue;     firePropertyChange(SELECT_BEHIND_ENABLED_PROPERTY, oldValue, newValue);}", "nl": "Sets the selectBehindEnabled property"}
{"code": "protected HandleTracker getHandleTracker(Handle handle) {     if (handleTracker == null) {       handleTracker = new DefaultHandleTracker();     }     handleTracker.setHandles(handle, getView().getCompatibleHandles(handle));     return handleTracker;}", "nl": "Method to get a HandleTracker which handles user interaction for the specified handle"}
{"code": "protected DragTracker getDragTracker(Figure f) {     if (dragTracker == null) {       dragTracker = new DefaultDragTracker();     }     dragTracker.setDraggedFigure(f);     return dragTracker;}", "nl": "Method to get a DragTracker which handles user interaction for dragging the specified figure"}
{"code": "public SelectionTool() {     tracker = getSelectAreaTracker();     trackerHandler = new TrackerHandler();     tracker.addToolListener(trackerHandler);}", "nl": "Creates a new instance"}
{"code": "private static Drawing createDrawing() {               DefaultDrawing drawing = new DefaultDrawing();     drawing.addInputFormat(new SerializationInputOutputFormat());     drawing.addOutputFormat(new SerializationInputOutputFormat());     drawing.addOutputFormat(new ImageOutputFormat());     return drawing;}", "nl": "Creates a drawing with input and output formats , so that drawing figures can be copied and pasted between drawing views"}
{"code": "public void write(URI f, URIChooser fc) throws IOException {     Drawing drawing = view.getDrawing();     OutputFormat outputFormat = drawing.getOutputFormats().get(0);     outputFormat.write(new File(f), drawing);}", "nl": "Writes the view to the specified uri"}
{"code": "public DrawingEditor getEditor() {     return editor;}", "nl": "Gets the drawing editor of the view"}
{"code": "public void setEditor(DrawingEditor newValue) {     if (editor != null) {       editor.remove(view);     }     editor = newValue;     if (editor != null) {       editor.add(view);}}", "nl": "Sets a drawing editor for the view"}
{"code": "private void initComponents() {     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     setLayout(new java.awt.BorderLayout());     scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);     scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "private void initActions() {     getActionMap().put(UndoAction.ID, undo.getUndoAction());     getActionMap().put(RedoAction.ID, undo.getRedoAction());}", "nl": "Initializes view specific actions"}
{"code": "public Pageable createPageable() {     return new DrawingPageable(view.getDrawing());}", "nl": "Creates a Pageable object for printing the view"}
{"code": "@SuppressWarnings(\"unchecked\")      private void initComponents() {     setLayout(new java.awt.BorderLayout());}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     toolButtonGroup = new javax.swing.ButtonGroup();     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     jPanel1 = new javax.swing.JPanel();     creationToolbar = new javax.swing.JToolBar();     attributesToolbar = new javax.swing.JToolBar();     setLayout(new java.awt.BorderLayout());     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);     jPanel1.setLayout(new java.awt.GridBagLayout());     creationToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 0;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(creationToolbar, gridBagConstraints);     attributesToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 1;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(attributesToolbar, gridBagConstraints);     add(jPanel1, java.awt.BorderLayout.SOUTH);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public DrawingPanel() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     initComponents();     undoManager = new UndoRedoManager();     editor = new DefaultDrawingEditor();     editor.add(view);     addCreationButtonsTo(creationToolbar, editor);     ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);     JPopupButton pb = new JPopupButton();     pb.setItemFont(UIManager.getFont(\"MenuItem.font\"));     labels.configureToolBarButton(pb, \"actions\");     pb.add(new DuplicateAction());     pb.addSeparator();     pb.add(new GroupAction(editor));     pb.add(new UngroupAction(editor));     pb.addSeparator();     pb.add(new BringToFrontAction(editor));     pb.add(new SendToBackAction(editor));     pb.addSeparator();     pb.add(new CutAction());     pb.add(new CopyAction());     pb.add(new PasteAction());     pb.add(new SelectAllAction());     pb.add(new SelectSameAction(editor));     pb.addSeparator();     pb.add(undoManager.getUndoAction());     pb.add(undoManager.getRedoAction());                    JMenu m = new JMenu(labels.getString(\"view.zoomFactor.text\"));     JRadioButtonMenuItem rbmi;     ButtonGroup group = new ButtonGroup();     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));     rbmi.setSelected(true);     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));     group.add(rbmi);     pb.add(m);     pb.setFocusable(false);     creationToolbar.addSeparator();     creationToolbar.add(pb);      DefaultDrawing drawing = new DefaultDrawing();     view.setDrawing(drawing);     drawing.addUndoableEditListener(undoManager);}", "nl": "Creates new instance"}
{"code": "public MessagePanel() {     this(null, null);}", "nl": "Creates new instance"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public SummaryToolBar() {     labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     initComponents();          GridBagLayout layout = new GridBagLayout();     setLayout(layout);          GridBagConstraints gbc;     gbc = new GridBagConstraints();     gbc.insets = new Insets(0,10,0,0);     gbc.weightx = 1d;     gbc.fill = GridBagConstraints.HORIZONTAL;     layout.setConstraints(summaryField, gbc);}", "nl": "Creates new instance"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public int getMaximum() {     return progressModel.getMaximum();}", "nl": "Returns the maximum value - - the higher end of the progress value"}
{"code": "public void setMinimum(int m) {     progressModel.setMinimum(m);}", "nl": "Specifies the minimum value"}
{"code": "public ProgressIndicator(       String message,       String note,       int min,       int max,       boolean indeterminate) {     initComponents();          messageLabel.setFont(messageLabel.getFont().deriveFont(Font.BOLD));     progressModel = new DefaultBoundedRangeModel(0, 0, min, max);     progressBar.setModel(progressModel);     setMessage(message);     setNote(note);     setIndeterminate(indeterminate);}", "nl": "Creates new instance"}
{"code": "private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     messageLabel = new javax.swing.JLabel();     noteLabel = new javax.swing.JLabel();     progressBar = new javax.swing.JProgressBar();     setBackground(new java.awt.Color(255, 255, 255));     setLayout(new java.awt.GridBagLayout());     messageLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     add(messageLabel, gridBagConstraints);     noteLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);     add(noteLabel, gridBagConstraints);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);     add(progressBar, gridBagConstraints);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public void setProgress(int nv) {     progressModel.setValue(nv);}", "nl": "Indicate the progress of the operation being monitored"}
{"code": "public ProgressIndicator(       String message,       String note) {     this(message, note, 0, 100, true);}", "nl": "Creates new instance"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public ODGRectRadiusHandle(Figure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "public void draw(Graphics2D g) {     drawDiamond(g, Color.yellow, Color.black);}", "nl": "Draws this handle"}
{"code": "public StrokeToolBar() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(\"stroke.toolbar\"));     setDisclosureStateCount(3);}", "nl": "Creates new instance"}
{"code": "public ToolsToolBar() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(\"tools.toolbar\"));}", "nl": "Creates new instance"}
{"code": "public Insets2D.Double getInsets() {     double sw = Math.ceil(get(STROKE_WIDTH) / 2);     Insets2D.Double insets = new Insets2D.Double(4, 4, 4, 4);     return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);}", "nl": "Returns the insets used to draw text"}
{"code": "public Tool getTool(Point2D.Double p) {     if (isEditable() && contains(p)) {       TextAreaEditingTool tool = new TextAreaEditingTool(this);       return tool;     }     return null;}", "nl": "Returns a specialized tool for the given coordinate"}
{"code": "public Dimension2DDouble getPreferredTextSize(double maxWidth) {     Rectangle2D.Double textRect = new Rectangle2D.Double();     if (getText() != null) {       Font font = getFont();       boolean isUnderlined = get(FONT_UNDERLINE);       float leftMargin = 0;       float rightMargin = (float) maxWidth - 1;       float verticalPos = 0;       float maxVerticalPos = Float.MAX_VALUE;       if (leftMargin < rightMargin) {         float tabWidth = (float) (getTabSize() * font.getStringBounds(\"m\", getFontRenderContext()).getWidth());         float[] tabStops = new float[(int) (textRect.width / tabWidth)];         for (int i = 0; i < tabStops.length; i++) {           tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));         }         String[] paragraphs = getText().split(\"\\n\");         for (int i = 0; i < paragraphs.length; i++) {           if (paragraphs[i].length() == 0) {             paragraphs[i] = \" \";           }           AttributedString as = new AttributedString(paragraphs[i]);           as.addAttribute(TextAttribute.FONT, font);           if (isUnderlined) {             as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);           }           int tabCount = paragraphs[i].split(\"\\t\").length - 1;           Rectangle2D.Double paragraphBounds = drawParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);           verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);           textRect.add(paragraphBounds);         }       }     }     return new Dimension2DDouble(-Math.min(textRect.x, 0) + textRect.width, -Math.min(textRect.y, 0) + textRect.height);}", "nl": "Returns the preferred text size of the TextAreaFigure"}
{"code": "private ODGFigure readCustomShapeElement(IXMLElement elem)       throws IOException {     String styleName = elem.getAttribute(\"style-name\", DRAWING_NAMESPACE, null);     Map<AttributeKey, Object> a = styles.getAttributes(styleName, \"graphic\");     Rectangle2D.Double figureBounds = new Rectangle2D.Double(         toLength(elem.getAttribute(\"x\", SVG_NAMESPACE, \"0\"), 1),         toLength(elem.getAttribute(\"y\", SVG_NAMESPACE, \"0\"), 1),         toLength(elem.getAttribute(\"width\", SVG_NAMESPACE, \"0\"), 1),         toLength(elem.getAttribute(\"height\", SVG_NAMESPACE, \"0\"), 1));     ODGFigure figure = null;     for (IXMLElement child : elem.getChildrenNamed(\"enhanced-geometry\", DRAWING_NAMESPACE)) {       figure = readEnhancedGeometryElement(child, a, figureBounds);     }     return figure;}", "nl": "A represents a shape that is capable of rendering complex figures"}
{"code": "private ODGFigure createPolylineFigure(       Point2D.Double[] points,       Map<AttributeKey, Object> a)       throws IOException {     ODGPathFigure figure = new ODGPathFigure();     ODGBezierFigure bezier = new ODGBezierFigure();     for (Point2D.Double p : points) {       bezier.addNode(new BezierPath.Node(p.x, p.y));     }     figure.removeAllChildren();     figure.add(bezier);     figure.setAttributes(a);     return figure;}", "nl": "Creates a Polyline figure"}
{"code": "private double toLength(String str, double percentFactor) throws IOException {     double scaleFactor = 1d;     if (str == null || str.length() == 0) {       return 0d;     }     if (str.endsWith(\"%\")) {       str = str.substring(0, str.length() - 1);       scaleFactor = percentFactor;     } else if (str.endsWith(\"px\")) {       str = str.substring(0, str.length() - 2);     } else if (str.endsWith(\"pt\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 1.25;     } else if (str.endsWith(\"pc\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 15;     } else if (str.endsWith(\"mm\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 3.543307;     } else if (str.endsWith(\"cm\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 35.43307;     } else if (str.endsWith(\"in\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 90;     } else {       scaleFactor = 1d;     }     return Double.parseDouble(str) * scaleFactor;}", "nl": "Returns a value as a length"}
{"code": "private byte[] readAllBytes(InputStream in) throws IOException {     ByteArrayOutputStream tmp = new ByteArrayOutputStream();     byte[] buf = new byte[512];     for (int len; -1 != (len = in.read(buf));) {       tmp.write(buf, 0, len);     }     tmp.close();     return tmp.toByteArray();}", "nl": "Reads all bytes from the InputStreams until EOF is reached"}
{"code": "private ODGFigure createPolygonFigure(       Point2D.Double[] points,       Map<AttributeKey, Object> a)       throws IOException {     ODGPathFigure figure = new ODGPathFigure();     ODGBezierFigure bezier = new ODGBezierFigure();     for (Point2D.Double p : points) {       bezier.addNode(new BezierPath.Node(p.x, p.y));     }     bezier.setClosed(true);     figure.removeAllChildren();     figure.add(bezier);     figure.setAttributes(a);     return figure;}", "nl": "Creates a Polygon figure"}
{"code": "public java.util.List<Figure> getFiguresFrontToBack() {     ensureSorted();     return new ReversedList<Figure>(children);}", "nl": "Returns an iterator to iterate in Z - order front to back over the children"}
{"code": "private EnhancedPath toEnhancedPath(String str) throws IOException {     if (DEBUG) {       System.out.println(\"ODGInputFormat toEnhancedPath \" + str);     }     EnhancedPath path = null;     Object x, y;     Object x1, y1, x2, y2, x3, y3;     StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));     tt.resetSyntax();     tt.parseNumbers();     tt.parseExponents();     tt.parsePlusAsNumber();     tt.whitespaceChars(0, ' ');     tt.whitespaceChars(',', ',');      char nextCommand = 'M';     char command = 'M';     Commands:     while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {       if (tt.ttype > 0) {         command = (char) tt.ttype;       } else {         command = nextCommand;         tt.pushBack();       }       nextCommand = command;       switch (command) {         case 'M':                                                       if (path == null) {             path = new EnhancedPath();           }                                 x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.moveTo(x, y);           nextCommand = 'L';           break;         case 'L':                                                       x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.lineTo(x, y);           break;         case 'C':                                                                  x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x2 = nextEnhancedCoordinate(tt, str);           y2 = nextEnhancedCoordinate(tt, str);           x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.curveTo(x1, y1, x2, y2, x, y);           break;         case 'Z':                                                       path.close();           break;         case 'N':                                                                  break;         case 'F':                                            break;         case 'S':                                            break;         case 'T':                                                       x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x2 = nextEnhancedCoordinate(tt, str);           y2 = nextEnhancedCoordinate(tt, str);           path.ellipseTo(x, y, x1, y1, x2, y2);           break;         case 'U':                                            x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x2 = nextEnhancedCoordinate(tt, str);           y2 = nextEnhancedCoordinate(tt, str);           path.moveTo(x1, y1);           path.ellipseTo(x, y, x1, y1, x2, y2);           break;         case 'A':                                                                                        x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x2 = nextEnhancedCoordinate(tt, str);           y2 = nextEnhancedCoordinate(tt, str);           x3 = nextEnhancedCoordinate(tt, str);           y3 = nextEnhancedCoordinate(tt, str);           x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.arcTo(x1, y1, x2, y2, x3, y3, x, y);           break;         case 'B':                                            x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x2 = nextEnhancedCoordinate(tt, str);           y2 = nextEnhancedCoordinate(tt, str);           x3 = nextEnhancedCoordinate(tt, str);           y3 = nextEnhancedCoordinate(tt, str);           x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.moveTo(x1, y1);           path.arcTo(x1, y1, x2, y2, x3, y3, x, y);           break;         case 'W':                                            x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x2 = nextEnhancedCoordinate(tt, str);           y2 = nextEnhancedCoordinate(tt, str);           x3 = nextEnhancedCoordinate(tt, str);           y3 = nextEnhancedCoordinate(tt, str);           x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);           break;         case 'V':                                                       x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x2 = nextEnhancedCoordinate(tt, str);           y2 = nextEnhancedCoordinate(tt, str);           x3 = nextEnhancedCoordinate(tt, str);           y3 = nextEnhancedCoordinate(tt, str);           x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.moveTo(x1, y1);           path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);           break;         case 'X':                                                       x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.quadrantXTo(x, y);           break;         case 'Y':                                                       x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.quadrantYTo(x, y);           break;         case 'Q':                                                       x1 = nextEnhancedCoordinate(tt, str);           y1 = nextEnhancedCoordinate(tt, str);           x = nextEnhancedCoordinate(tt, str);           y = nextEnhancedCoordinate(tt, str);           path.quadTo(x1, y1, x, y);           break;         default:           if (DEBUG) {             System.out.println(\"ODGInputFormat.toEnhancedPath aborting after illegal path command: \" + command + \" found in path \" + str);           }           break Commands;                }     }     return path;}", "nl": "Returns a value as a EnhancedPath array"}
{"code": "private ODGFigure createLineFigure(       Point2D.Double p1, Point2D.Double p2,       Map<AttributeKey, Object> a)       throws IOException {     ODGPathFigure figure = new ODGPathFigure();     figure.setBounds(p1, p2);     figure.setAttributes(a);     return figure;}", "nl": "Creates a Line figure"}
{"code": "private ODGFigure readPolylineElement(IXMLElement elem)       throws IOException {     AffineTransform viewBoxTransform = readViewBoxTransform(elem);     String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute(\"points\", DRAWING_NAMESPACE, null));     Point2D.Double[] points = new Point2D.Double[coords.length / 2];     for (int i = 0; i < coords.length; i += 2) {       Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));       points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);     }     String styleName = elem.getAttribute(\"style-name\", DRAWING_NAMESPACE, null);     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     a.putAll(styles.getAttributes(styleName, \"graphic\"));     readCommonDrawingShapeAttributes(elem, a);     ODGFigure f = createPolylineFigure(points, a);     return f;}", "nl": "The & lt ; draw : polyline & gt ; element represents a polyline drawing shape"}
{"code": "private ODGFigure readLineElement(IXMLElement elem)       throws IOException {     Point2D.Double p1 = new Point2D.Double(         toLength(elem.getAttribute(\"x1\", SVG_NAMESPACE, \"0\"), 1),         toLength(elem.getAttribute(\"y1\", SVG_NAMESPACE, \"0\"), 1));     Point2D.Double p2 = new Point2D.Double(         toLength(elem.getAttribute(\"x2\", SVG_NAMESPACE, \"0\"), 1),         toLength(elem.getAttribute(\"y2\", SVG_NAMESPACE, \"0\"), 1));     String styleName = elem.getAttribute(\"style-name\", DRAWING_NAMESPACE, null);     Map<AttributeKey, Object> a = styles.getAttributes(styleName, \"graphic\");     ODGFigure f = createLineFigure(p1, p2, a);     return f;}", "nl": "The & lt ; draw : line & gt ; element represents a line"}
{"code": "private double toNumber(String str) throws IOException {     return toLength(str, 100);}", "nl": "Returns a value as a number"}
{"code": "private ODGFigure createPathFigure(       BezierPath[] paths,       Map<AttributeKey, Object> a)       throws IOException {     ODGPathFigure figure = new ODGPathFigure();     figure.removeAllChildren();     for (BezierPath p : paths) {       ODGBezierFigure bezier = new ODGBezierFigure();       bezier.setBezierPath(p);       figure.add(bezier);     }     figure.setAttributes(a);     return figure;}", "nl": "Creates a Path figure"}
{"code": "private ODGFigure createEnhancedGeometryRectangleFigure(       Rectangle2D.Double bounds, Map<AttributeKey, Object> a)       throws IOException {     ODGRectFigure figure = new ODGRectFigure();     figure.setBounds(bounds);     figure.setAttributes(a);     return figure;}", "nl": "Creates a Rect figure"}
{"code": "private void readPageElement(IXMLElement elem)       throws IOException {          for (IXMLElement node : elem.getChildren()) {       if (node instanceof IXMLElement) {         IXMLElement child = (IXMLElement) node;         ODGFigure figure = readElement(child);         if (figure != null) {           figures.add(figure);}}}}", "nl": "Reads an ODG draw : page element"}
{"code": "protected Rectangle2D.Double getFigureDrawingArea() {     if (getText() == null) {       return getBounds();     } else {       TextLayout layout = getTextLayout();       Rectangle2D.Double r = new Rectangle2D.Double(           origin.x, origin.y, layout.getAdvance(), layout.getAscent());       Rectangle2D lBounds = layout.getBounds();       if (!lBounds.isEmpty() && !Double.isNaN(lBounds.getX())) {         r.add(new Rectangle2D.Double(             lBounds.getX() + origin.x,             (lBounds.getY() + origin.y + layout.getAscent()),             lBounds.getWidth(),             lBounds.getHeight()));       }              Geom.grow(r, 2d, 2d);       return r;}}", "nl": "Gets the drawing area without taking the decorator into account"}
{"code": "public void setText(String newText) {     set(TEXT, newText);}", "nl": "Sets the text shown by the text figure"}
{"code": "private ODGFigure readElement(IXMLElement elem)       throws IOException {          ODGFigure f = null;     if (elem.getNamespace() == null ||         elem.getNamespace().equals(DRAWING_NAMESPACE)) {       String name = elem.getName();       if (name.equals(\"caption\")) {         f = readCaptionElement(elem);       } else if (name.equals(\"circle\")) {         f = readCircleElement(elem);       } else if (name.equals(\"connector\")) {         f = readCircleElement(elem);       } else if (name.equals(\"custom-shape\")) {         f = readCustomShapeElement(elem);       } else if (name.equals(\"ellipse\")) {         f = readEllipseElement(elem);       } else if (name.equals(\"frame\")) {         f = readFrameElement(elem);       } else if (name.equals(\"g\")) {         f = readGElement(elem);       } else if (name.equals(\"line\")) {         f = readLineElement(elem);       } else if (name.equals(\"measure\")) {         f = readMeasureElement(elem);       } else if (name.equals(\"path\")) {         f = readPathElement(elem);       } else if (name.equals(\"polygon\")) {         f = readPolygonElement(elem);       } else if (name.equals(\"polyline\")) {         f = readPolylineElement(elem);       } else if (name.equals(\"rect\")) {         f = readRectElement(elem);       } else if (name.equals(\"regularPolygon\")) {         f = readRegularPolygonElement(elem);       } else {         if (DEBUG) {           System.out.println(\"ODGInputFormat.readElement(\" + elem + \") not implemented.\");         }       }     }     if (f != null) {       if (f.isEmpty()) {         if (DEBUG) {           System.out.println(\"ODGInputFormat.readElement():null - discarded empty figure \" + f);         }         return null;       }       if (DEBUG) {         System.out.println(\"ODGInputFormat.readElement():\" + f + \".\");       }     }     return f;}", "nl": "Reads an ODG element"}
{"code": "public TextFigure() {     this(ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\").         getString(\"TextFigure.defaultText\"));}", "nl": "Creates a new instance"}
{"code": "public int getTabSize() {     return 8;}", "nl": "Gets the number of characters used to expand tabs"}
{"code": "public RectangleFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public LineFigure() {     addNode(new BezierPath.Node(new Point2D.Double(0,0)));     addNode(new BezierPath.Node(new Point2D.Double(0,0)));     setConnectable(false);}", "nl": "Creates a new instance"}
{"code": "private BezierPath[] toPath(String str) throws IOException {     LinkedList<BezierPath> paths = new LinkedList<BezierPath>();     BezierPath path = null;     Point2D.Double p = new Point2D.Double();     Point2D.Double c1 = new Point2D.Double();     Point2D.Double c2 = new Point2D.Double();     StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));     tt.resetSyntax();     tt.parseNumbers();     tt.parseExponents();     tt.parsePlusAsNumber();     tt.whitespaceChars(0, ' ');     tt.whitespaceChars(',', ',');      char nextCommand = 'M';     char command = 'M';     Commands:     while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {       if (tt.ttype > 0) {         command = (char) tt.ttype;       } else {         command = nextCommand;         tt.pushBack();       }       BezierPath.Node node;       switch (command) {         case 'M':                      if (path != null) {             paths.add(path);           }           path = new BezierPath();           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'M' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'M' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.moveTo(p.x, p.y);           nextCommand = 'L';           break;         case 'm':                      if (path != null) {             paths.add(path);           }           path = new BezierPath();           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'm' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'm' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.moveTo(p.x, p.y);           nextCommand = 'l';           break;         case 'Z':         case 'z':                      p.x = path.get(0).x[0];           p.y = path.get(0).y[0];                                 if (path.size() > 1) {             BezierPath.Node first = path.get(0);             BezierPath.Node last = path.get(path.size() - 1);             if (first.x[0] == last.x[0] &&                 first.y[0] == last.y[0]) {               if ((last.mask & BezierPath.C1_MASK) != 0) {                 first.mask |= BezierPath.C1_MASK;                 first.x[1] = last.x[1];                 first.y[1] = last.y[1];               }               path.remove(path.size() - 1);             }           }           path.setClosed(true);           break;         case 'L':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'L' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'L' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'L';           break;         case 'l':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'l' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'l' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'l';           break;         case 'H':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'H' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'H';           break;         case 'h':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'h' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'h';           break;         case 'V':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'V' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'V';           break;         case 'v':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'v' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'v';           break;         case 'C':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x1 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y1 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x2 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y2 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 'C';           break;         case 'c':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx1 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy1 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx2 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy2 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 'c';           break;         case 'S':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x2 coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y2 coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 'S';           break;         case 's':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx2 coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy2 coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 's';           break;         case 'Q':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x1 coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y1 coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 'Q';           break;         case 'q':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx1 coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy1 coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 'q';           break;         case 'T':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'T' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'T' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 'T';           break;         case 't':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 't' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 't' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 's';           break;          case 'A': {                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"rx coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }                                 double rx = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"ry coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double ry = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x-axis-rotation missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double xAxisRotation = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"large-arc-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean largeArcFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"sweep-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean sweepFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);           nextCommand = 'A';           break;         }         case 'a': {                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"rx coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }                                 double rx = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"ry coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double ry = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x-axis-rotation missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double xAxisRotation = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"large-arc-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean largeArcFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"sweep-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean sweepFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);           nextCommand = 'a';           break;         }         default:           if (DEBUG) {             System.out.println(\"SVGInputFormat.toPath aborting after illegal path command: \" + command + \" found in path \" + str);           }           break Commands;                }     }     if (path != null) {       paths.add(path);     }     return paths.toArray(new BezierPath[paths.size()]);}", "nl": "Returns a value as a BezierPath array"}
{"code": "public void setArc(double width, double height) {     setArcWidth(width);     setArcHeight(height);}", "nl": "Convenience method for setting both the arc width and the arc height"}
{"code": "public boolean contains(Point2D.Double p) {     RoundRectangle2D.Double r = (RoundRectangle2D.Double) roundrect.clone();     double grow = AttributeKeys.getPerpendicularHitGrowth(this);     r.x -= grow;     r.y -= grow;     r.width += grow * 2;     r.height += grow * 2;     r.arcwidth += grow * 2;     r.archeight += grow * 2;     return r.contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public void setArcHeight(double newValue) {     double oldValue = roundrect.archeight;     roundrect.archeight = newValue;     firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);}", "nl": "Sets the arc height"}
{"code": "public void setArcWidth(double newValue) {     double oldValue = roundrect.arcwidth;     roundrect.arcwidth = newValue;     firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);}", "nl": "Sets the arc width"}
{"code": "public double getArcWidth() {     return roundrect.arcwidth;}", "nl": "Gets the arc width"}
{"code": "private ODGFigure readFrameElement(IXMLElement elem) throws IOException {     if (DEBUG) {       System.out.println(\"ODGInputFormat.readFrameElement(\" + elem + \") not implemented.\");     }     return null;}", "nl": "Reads a & lt ; draw : frame & gt ; element from the specified XML element"}
{"code": "public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {     String[] result = str.split(\"(\\\\s*,\\\\s*|\\\\s+)\");     if (result.length == 1 && result[0].equals(\"\")) {       return new String[0];     } else {       return result;}}", "nl": "Returns a value as a String array"}
{"code": "public double getArcHeight() {     return roundrect.archeight;}", "nl": "Gets the arc height"}
{"code": "public static AffineTransform toTransform(String str) throws IOException {     AffineTransform t = new AffineTransform();     AffineTransform t2 = new AffineTransform();     if (str != null) {       StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));       tt.resetSyntax();       tt.wordChars('a', 'z');       tt.wordChars('A', 'Z');       tt.wordChars(128 + 32, 255);       tt.whitespaceChars(0, ' ');       tt.whitespaceChars(',', ',');       tt.parseNumbers();       tt.parseExponents();       while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {         if (tt.ttype != StreamPosTokenizer.TT_WORD) {           throw new IOException(\"Illegal transform \" + str);         }         String type = tt.sval;         if (tt.nextToken() != '(') {           throw new IOException(\"'(' not found in transform \" + str);         }         if (type.equals(\"matrix\")) {           double[] m = new double[6];           for (int i = 0; i < 6; i++) {             if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {               throw new IOException(\"Matrix value \" + i + \" not found in transform \" + str + \" token:\" + tt.ttype + \" \" + tt.sval);             }             m[i] = tt.nval;           }           t.preConcatenate(new AffineTransform(m));         } else if (type.equals(\"translate\")) {           double tx, ty;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"X-translation value not found in transform \" + str);           }           tx = tt.nval;           if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {             tx *= toUnitFactor(tt.sval);           } else {             tt.pushBack();           }           if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {             ty = tt.nval;             if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {               ty *= toUnitFactor(tt.sval);             } else {               tt.pushBack();             }           } else {             tt.pushBack();             ty = 0;           }           t2.setToIdentity();           t2.translate(tx, ty);           t.preConcatenate(t2);         } else if (type.equals(\"scale\")) {           double sx, sy;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"X-scale value not found in transform \" + str);           }           sx = tt.nval;           if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {             sy = tt.nval;           } else {             tt.pushBack();             sy = sx;           }           t2.setToIdentity();           t2.scale(sx, sy);           t.preConcatenate(t2);         } else if (type.equals(\"rotate\")) {           double angle, cx, cy;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"Angle value not found in transform \" + str);           }           angle = tt.nval;           t2.setToIdentity();           t2.rotate(-angle);           t.preConcatenate(t2);          } else if (type.equals(\"skewX\")) {           double angle;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"Skew angle not found in transform \" + str);           }           angle = tt.nval;           t.preConcatenate(new AffineTransform(               1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));         } else if (type.equals(\"skewY\")) {           double angle;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"Skew angle not found in transform \" + str);           }           angle = tt.nval;           t.preConcatenate(new AffineTransform(               1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));         } else {           throw new IOException(\"Unknown transform \" + type + \" in \" + str);         }         if (tt.nextToken() != ')') {           throw new IOException(\"')' not found in transform \" + str);         }       }     }     return t;}", "nl": "Converts an ODG draw : transform attribute value into an AffineTransform"}
{"code": "private Object nextEnhancedCoordinate(StreamPosTokenizer tt, String str) throws IOException {     switch (tt.nextToken()) {       case '?': {         StringBuilder buf = new StringBuilder();         buf.append('?');         int ch = tt.nextChar();         for (; ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9';             ch = tt.nextChar()) {           buf.append((char) ch);         }         tt.pushCharBack(ch);         return buf.toString();       }       case '$': {         StringBuilder buf = new StringBuilder();         buf.append('$');         int ch = tt.nextChar();         for (; ch >= '0' && ch <= '9';             ch = tt.nextChar()) {           buf.append((char) ch);         }         tt.pushCharBack(ch);         return buf.toString();       }       case StreamPosTokenizer.TT_NUMBER:         return tt.nval;       default:         throw new IOException(\"coordinate missing at position\" + tt.getStartPosition() + \" in \" + str);}}", "nl": "Retrieves an enhanced coordinate from the specified tokenizer"}
{"code": "@Override   public void addNotify(Drawing drawing) {     super.addNotify(drawing);     if (getStartConnector() != null && getEndConnector() != null) {       handleConnect(getStartConnector(), getEndConnector());       updateConnection();}}", "nl": "This method is invoked , when the Figure is being removed from a Drawing"}
{"code": "@Override   public void setConnectable(boolean newValue) {     super.setConnectable(false);}", "nl": "ConnectionFigures cannot be connected and always sets connectable to false"}
{"code": "public void transform(AffineTransform tx) {     invalidateTransformedShape();     if (get(TRANSFORM) != null ||         (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {       if (get(TRANSFORM) == null) {         set(TRANSFORM, (AffineTransform) tx.clone());       } else {         AffineTransform t = TRANSFORM.getClone(this);         t.preConcatenate(tx);         set(TRANSFORM, t);       }     } else {       Point2D.Double anchor = getStartPoint();       Point2D.Double lead = getEndPoint();       setBounds(           (Point2D.Double) tx.transform(anchor, anchor),           (Point2D.Double) tx.transform(lead, lead));       if (get(FILL_GRADIENT) != null &&           !get(FILL_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = FILL_GRADIENT.getClone(this);         g.transform(tx);         set(FILL_GRADIENT, g);       }       if (get(STROKE_GRADIENT) != null &&           !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = STROKE_GRADIENT.getClone(this);         g.transform(tx);         set(STROKE_GRADIENT, g);}}}", "nl": "Transforms the figure"}
{"code": "public ODGRectFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public boolean contains(Point2D.Double p) {     return getHitShape().contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public java.util.List<Figure> sort(Collection<? extends Figure> c) {     ensureSorted();     ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());     for (Figure f : children) {       if (c.contains(f)) {         sorted.add(f);       }     }     return sorted;}", "nl": "Implementation note : Sorting can not be done for orphaned children"}
{"code": "private void ensureSorted() {     if (needsSorting) {       Collections.sort(children, FigureLayerComparator.INSTANCE);       needsSorting = false;}}", "nl": "Ensures that the children are sorted in z - order sequence"}
{"code": "public java.util.List<Figure> getFiguresFrontToBack() {     ensureSorted();     return new ReversedList<Figure>(children);}", "nl": "Returns an iterator to iterate in Z - order front to back over the children"}
{"code": "public void dispose() {     setEditor(null);}", "nl": "Frees all resources held by this object , so that it can be garbage collected"}
{"code": "public void setUpdateEnabledState(boolean newValue) {               if (eventHandler != null != newValue) {       if (newValue) {         eventHandler = new EventHandler();         registerEventHandler();       } else {         unregisterEventHandler();         eventHandler = null;       }     }     if (newValue) {       updateEnabledState();}}", "nl": "By default , the enabled state of this action is updated to reflect the enabled state of the active DrawingView"}
{"code": "private void unregisterEventHandler() {     if (editor != null) {       editor.removePropertyChangeListener(eventHandler);     }     if (activeView != null) {       activeView.removePropertyChangeListener(eventHandler);       activeView = null;     }     if (specificView != null) {       specificView.removePropertyChangeListener(eventHandler);}}", "nl": "Unregisters the event handler from the drawing editor and the active drawing view"}
{"code": "public AbstractDrawingViewAction(DrawingView view) {     this.specificView = view;     registerEventHandler();}", "nl": "Creates a view action which acts on the specified view"}
{"code": "public boolean isUpdatEnabledState() {     return eventHandler != null;}", "nl": "Returns true , if this action automatically updates its enabled state to reflect the enabled state of the active DrawingView"}
{"code": "public void updateEnabledState() {     if (getView() != null) {       setEnabled(getView().isEnabled());     } else {       setEnabled(false);}}", "nl": "Updates the enabled state of this action to reflect the enabled state of the active DrawingView"}
{"code": "public AttributeToggler(DrawingEditor editor, AttributeKey<T> key, T value1, T value2) {     this(editor, key, value1, value2, null);}", "nl": "Creates a new instance"}
{"code": "public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {     return new ChopTriangleConnector(this);}", "nl": "Returns the Figures connector for the specified location"}
{"code": "public ApplyAttributesAction(DrawingEditor editor) {     super(editor);     labels.configureAction(this, \"edit.applyAttributes\");     setEnabled(true);}", "nl": "Creates a new instance"}
{"code": "public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {     this(editor, key, value, null, icon);}", "nl": "Creates a new instance"}
{"code": "public AttributeAction(DrawingEditor editor, AttributeKey key, Object value) {     this(editor, key, value, null, null);}", "nl": "Creates a new instance"}
{"code": "public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, String name) {     this(editor, key, value, name, null);}", "nl": "Creates a new instance"}
{"code": "protected void updateEnabledState() {     if (getView() != null) {       setEnabled(getView().isEnabled() &&           getView().getSelectionCount() > 0);     } else {       setEnabled(false);}}", "nl": "Updates the enabled state of this action to reflect the enabled state of the active DrawingView"}
{"code": "public void setUpdateEnabledState(boolean newValue) {               if (eventHandler != null != newValue) {       if (newValue) {         eventHandler = new EventHandler();         registerEventHandler();       } else {         unregisterEventHandler();         eventHandler = null;       }     }     if (newValue) {       updateEnabledState();}}", "nl": "By default , the enabled state of this action is updated to reflect the enabled state of the active DrawingView"}
{"code": "private void unregisterEventHandler() {     if (editor != null) {       editor.removePropertyChangeListener(eventHandler);}}", "nl": "Unregisters the event handler from the drawing editor and the active drawing view"}
{"code": "public AbstractDrawingEditorAction(DrawingEditor editor) {     setEditor(editor);}", "nl": "Creates a new instance"}
{"code": "protected void fireUndoableEditHappened(UndoableEdit edit) {     getDrawing().fireUndoableEditHappened(edit);}", "nl": "Updates the enabled state of this action to reflect the enabled state of the active DrawingView"}
{"code": "public void setUpdateEnabledState(boolean newValue) {               if (eventHandler != null != newValue) {       if (newValue) {         eventHandler = new EventHandler();         registerEventHandler();       } else {         unregisterEventHandler();         eventHandler = null;       }     }     if (newValue) {       updateEnabledState();}}", "nl": "By default , the enabled state of this action is updated to reflect the enabled state of the active DrawingView"}
{"code": "public boolean isUpdatEnabledState() {     return eventHandler != null;}", "nl": "Returns true , if this action automatically updates its enabled state to reflect the enabled state of the active DrawingView"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "protected String getID() {     return \"\";}", "nl": "This should be an abstract method , but the NetBeans GUI builder doesn ' t support abstract beans"}
{"code": "public AbstractToolBar() {     initComponents();     try {       prefs = PreferencesUtil.userNodeForPackage(getClass());     } catch (SecurityException e) {}}", "nl": "Creates new form"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public AlignToolBar() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(getID() + \".toolbar\"));}", "nl": "Creates new instance"}
{"code": "private void initComponents() {     setOpaque(false);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public void transform(AffineTransform tx) {     invalidateTransformedShape();     if (get(TRANSFORM) != null ||         (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {       if (get(TRANSFORM) == null) {         set(TRANSFORM, (AffineTransform) tx.clone());       } else {         AffineTransform t = TRANSFORM.getClone(this);         t.preConcatenate(tx);         set(TRANSFORM, t);       }     } else {       Point2D.Double anchor = getStartPoint();       Point2D.Double lead = getEndPoint();       setBounds(           (Point2D.Double) tx.transform(anchor, anchor),           (Point2D.Double) tx.transform(lead, lead));}}", "nl": "Transforms the figure"}
{"code": "public boolean contains(Point2D.Double p) {     return getHitShape().contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public BufferedImage getBufferedImage() {     if (bufferedImage == null && imageData != null) {              try {         bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));       } catch (Throwable e) {         e.printStackTrace();                                    imageData = null;       }     }     return bufferedImage;}", "nl": "Gets the buffered image"}
{"code": "public void setImage(byte[] imageData, BufferedImage bufferedImage) {     willChange();     this.imageData = imageData;     this.bufferedImage = bufferedImage;     changed();}", "nl": "Sets the image"}
{"code": "public byte[] getImageData() {     if (bufferedImage != null && imageData == null) {       try {         ByteArrayOutputStream bout = new ByteArrayOutputStream();         ImageIO.write(bufferedImage, \"PNG\", bout);         bout.close();         imageData = bout.toByteArray();       } catch (IOException e) {         e.printStackTrace();                                    bufferedImage = null;       }     }     return imageData;}", "nl": "Gets the image data"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public SVGEllipseFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public boolean contains(Point2D.Double p) {     return getHitShape().contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public boolean contains(Point2D.Double p) {     return getHitShape().contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public double getArcWidth() {     return roundrect.arcwidth;}", "nl": "Gets the arc width"}
{"code": "public double getArcHeight() {     return roundrect.archeight;}", "nl": "Gets the arc height"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public void setArc(double width, double height) {     setArcWidth(width);     setArcHeight(height);}", "nl": "Convenience method for setting both the arc width and the arc height"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "private void initComponents() {     setOpaque(false);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public ActionsToolBar() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(getID() + \".toolbar\"));}", "nl": "Creates new instance"}
{"code": "public Tool getTool(Point2D.Double p) {     if (isEditable() && contains(p)) {       TextAreaEditingTool tool = new TextAreaEditingTool(this);       return tool;     }     return null;}", "nl": "Returns a specialized tool for the given coordinate"}
{"code": "private Rectangle2D.Double appendParagraph(Path2D.Double shape,       AttributedCharacterIterator styledText,       float verticalPos, float maxVerticalPos,       float leftMargin, float rightMargin,       float[] tabStops, int tabCount) {               Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);     int[] tabLocations = new int[tabCount + 1];     int i = 0;     for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {       if (c == '\\t') {         tabLocations[i++] = styledText.getIndex();       }     }     tabLocations[tabCount] = styledText.getEndIndex() - 1;                    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());     int currentTab = 0;     while (measurer.getPosition() < styledText.getEndIndex()) {                                                        boolean lineContainsText = false;       boolean lineComplete = false;       float maxAscent = 0, maxDescent = 0;       float horizontalPos = leftMargin;       LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();       LinkedList<Float> penPositions = new LinkedList<Float>();       while (!lineComplete) {         float wrappingWidth = rightMargin - horizontalPos;         TextLayout layout = null;         layout =             measurer.nextLayout(wrappingWidth,             tabLocations[currentTab] + 1,             lineContainsText);                  if (layout != null) {           layouts.add(layout);           penPositions.add(horizontalPos);           horizontalPos += layout.getAdvance();           maxAscent = Math.max(maxAscent, layout.getAscent());           maxDescent = Math.max(maxDescent,               layout.getDescent() + layout.getLeading());         } else {           lineComplete = true;         }         lineContainsText = true;         if (measurer.getPosition() == tabLocations[currentTab] + 1) {           currentTab++;         }         if (measurer.getPosition() == styledText.getEndIndex()) {           lineComplete = true;         } else if (tabStops.length == 0 || horizontalPos >= tabStops[tabStops.length - 1]) {           lineComplete = true;         }         if (!lineComplete) {                      int j;           for (j = 0; horizontalPos >= tabStops[j]; j++) {           }           horizontalPos = tabStops[j];         }       }       verticalPos += maxAscent;       if (verticalPos > maxVerticalPos) {         break;       }       Iterator<TextLayout> layoutEnum = layouts.iterator();       Iterator<Float> positionEnum = penPositions.iterator();              while (layoutEnum.hasNext()) {         TextLayout nextLayout = layoutEnum.next();         float nextPosition = positionEnum.next();         AffineTransform tx = new AffineTransform();         tx.translate(nextPosition, verticalPos);         if (shape != null) {           Shape outline = nextLayout.getOutline(tx);           shape.append(outline, false);         }         Rectangle2D layoutBounds = nextLayout.getBounds();         paragraphBounds.add(new Rectangle2D.Double(layoutBounds.getX() + nextPosition,             layoutBounds.getY() + verticalPos,             layoutBounds.getWidth(),             layoutBounds.getHeight()));       }       verticalPos += maxDescent;     }     return paragraphBounds;}", "nl": "Appends a paragraph of text at the specified y location and returns the bounds of the paragraph"}
{"code": "public boolean contains(Point2D.Double p) {     if (get(TRANSFORM) != null) {       try {         p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());       } catch (NoninvertibleTransformException ex) {         ex.printStackTrace();       }     }     Rectangle2D r = getTextShape().getBounds2D();     return r.isEmpty() ? getBounds().contains(p) : r.contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public void transform(AffineTransform tx) {     if (get(TRANSFORM) != null ||         (tx.getType() &         (AffineTransform.TYPE_TRANSLATION )) !=         tx.getType()) {       if (get(TRANSFORM) == null) {         set(TRANSFORM,  (AffineTransform) tx.clone());       } else {         AffineTransform t = TRANSFORM.getClone(this);         t.preConcatenate(tx);         set(TRANSFORM,  t);       }     } else {       Point2D.Double anchor = getStartPoint();       Point2D.Double lead = getEndPoint();       setBounds(           (Point2D.Double) tx.transform(anchor, anchor),           (Point2D.Double) tx.transform(lead, lead));       if (get(FILL_GRADIENT) != null &&           !get(FILL_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = FILL_GRADIENT.getClone(this);         g.transform(tx);         set(FILL_GRADIENT,  g);       }       if (get(STROKE_GRADIENT) != null &&           !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = STROKE_GRADIENT.getClone(this);         g.transform(tx);         set(STROKE_GRADIENT,  g);       }     }     invalidate();}", "nl": "Transforms the figure"}
{"code": "public SVGTextAreaFigure() {     this(\"Text\");}", "nl": "Creates a new instance"}
{"code": "public boolean isEmpty() {     return getText() == null || getText().length() == 0;}", "nl": "Gets the text shown by the text figure"}
{"code": "public SVGPathOutlineHandle(SVGPathFigure owner) {     this(owner, false);}", "nl": "Creates a new instance"}
{"code": "public SVGPathFigure() {     add(new SVGBezierFigure());     SVGAttributeKeys.setDefaults(this);}", "nl": "Creates a new instance"}
{"code": "@Override   public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {     if (evt.getClickCount() == 2 && view.getHandleDetailLevel() % 2 == 0) {       for (Figure child : getChildren()) {         SVGBezierFigure bf = (SVGBezierFigure) child;         int index = bf.findSegment(p, 5f / view.getScaleFactor());         if (index != -1) {           bf.handleMouseClick(p, evt, view);           evt.consume();           return true;         }       }     }     return false;}", "nl": "Handles a mouse click"}
{"code": "@Override   public void draw(Graphics2D g) {     if (getEditor().getTool().supportsHandleInteraction()) {       drawDiamond(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));     } else {       drawDiamond(g,           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),           (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));}}", "nl": "Draws this handle"}
{"code": "public SVGRectRadiusHandle(Figure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "public boolean contains(Point2D.Double p) {     if (get(TRANSFORM) != null) {       try {         p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());       } catch (NoninvertibleTransformException ex) {         ex.printStackTrace();       }     }     return getTextShape().getBounds2D().contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public String getText() {     return (String) get(TEXT);}", "nl": "Gets the text shown by the text figure"}
{"code": "public void transform(AffineTransform tx) {     if (get(TRANSFORM) != null ||         tx.getType() != (tx.getType() & AffineTransform.TYPE_TRANSLATION)) {       if (get(TRANSFORM) == null) {         set(TRANSFORM,  (AffineTransform) tx.clone());       } else {         AffineTransform t = TRANSFORM.getClone(this);         t.preConcatenate(tx);         set(TRANSFORM,  t);       }     } else {       for (int i=0; i < coordinates.length; i++) {         tx.transform(coordinates[i], coordinates[i]);       }       if (get(FILL_GRADIENT) != null &&           ! get(FILL_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = FILL_GRADIENT.getClone(this);         g.transform(tx);         set(FILL_GRADIENT,  g);       }       if (get(STROKE_GRADIENT) != null &&           ! get(STROKE_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = STROKE_GRADIENT.getClone(this);         g.transform(tx);         set(STROKE_GRADIENT,  g);       }     }     invalidate();}", "nl": "Transforms the figure"}
{"code": "public SVGGroupFigure() {     SVGAttributeKeys.setDefaults(this);}", "nl": "Creates a new instance"}
{"code": "public GridConstrainer getConstrainer() {     return constrainer;}", "nl": "Returns the GridConstrainer currently being edited by this panel"}
{"code": "private void initComponents() {     widthLabel = new javax.swing.JLabel();     heightLabel = new javax.swing.JLabel();     widthField = new org.jhotdraw.gui.JLifeFormattedTextField();     heightField = new org.jhotdraw.gui.JLifeFormattedTextField();     thetaLabel = new javax.swing.JLabel();     thetaField = new org.jhotdraw.gui.JLifeFormattedTextField();     widthLabel.setText(labels.getString(\"view.grid.width.text\"));      heightLabel.setText(labels.getString(\"view.grid.height.text\"));      widthField.setColumns(5);     heightField.setColumns(5);     thetaLabel.setText(labels.getString(\"view.grid.theta.text\"));      thetaField.setColumns(5);     javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);     this.setLayout(layout);     layout.setHorizontalGroup(       layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addContainerGap()         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)           .addComponent(heightLabel, javax.swing.GroupLayout.Alignment.TRAILING)           .addComponent(widthLabel, javax.swing.GroupLayout.Alignment.TRAILING)           .addComponent(thetaLabel, javax.swing.GroupLayout.Alignment.TRAILING))         .addGap(4, 4, 4)         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)           .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)           .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)           .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))         .addContainerGap(67, Short.MAX_VALUE))     );     layout.setVerticalGroup(       layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addContainerGap()         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)           .addComponent(widthLabel)           .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)           .addComponent(heightLabel)           .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))         .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)         .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)           .addComponent(thetaLabel)           .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))         .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public void setConstrainer(GridConstrainer newValue) {     constrainer = newValue;     widthField.setValue(constrainer.getWidth());     heightField.setValue(constrainer.getHeight());     thetaField.setValue(constrainer.getTheta() * 180d / Math.PI);}", "nl": "Sets the GridConstrainer to be edited by this panel"}
{"code": "public IncreaseHandleDetailLevelAction(DrawingEditor editor) {     super(editor);     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "public GroupAction(DrawingEditor editor) {     this(editor, new GroupFigure(), true);}", "nl": "Creates a new instance"}
{"code": "public FontChooserHandler(DrawingEditor editor, AttributeKey<Font> key, JFontChooser fontChooser, JPopupMenu popupMenu) {     super(editor);     this.key = key;     this.fontChooser = fontChooser;     this.popupMenu = popupMenu;     fontChooser.addActionListener(this);     fontChooser.addPropertyChangeListener(this);     updateEnabledState();}", "nl": "Creates a new instance"}
{"code": "public Insets getBorderInsets(Component c) {     return (Insets) borderInsets.clone();}", "nl": "Returns the insets of the border"}
{"code": "public void paintBorder(Component c, Graphics gr, int x, int y, int width, int height) {     if (image == null) return;               Graphics2D g = (Graphics2D) gr;               int top = imageInsets.top;     int left = imageInsets.left;     int bottom = imageInsets.bottom;     int right = imageInsets.right;     int imgWidth = image.getWidth();     int imgHeight = image.getHeight();                    if (fillContentArea) {       if (width == imgWidth && height == imgHeight) {         g.drawImage(image, x, y, c);         return;       }     }               if (width == imgWidth) {       left = imgWidth;       right = 0;     }     if (height == imgHeight) {       top = imgHeight;       bottom = 0;     }               if (width < left + right) {       left = Math.min(left, width / 2);        right = width - left;     }     if (height < top + bottom) {       top = Math.min(top, height / 2);        bottom = height - top;     }               if (top > 0 && left > 0) {       g.drawImage(       image,       x, y, x + left, y + top,       0, 0, left, top,       c       );     }     if (top > 0 && right > 0) {              g.drawImage(       image,       x + width - right, y, x + width, y + top,       imgWidth - right, 0, imgWidth, top,       c       );     }     if (bottom > 0 && left > 0) {       g.drawImage(       image,       x, y + height - bottom, x + left, y + height,       0, imgHeight - bottom, left, imgHeight,       c       );     }     if (bottom > 0 && right > 0) {       g.drawImage(       image,       x + width - right, y + height - bottom, x + width, y + height,       imgWidth - right, imgHeight - bottom, imgWidth, imgHeight,       c       );     }               BufferedImage subImg = null;     TexturePaint paint;               if (top > 0 && left + right < width) {       subImg = image.getSubimage(left, 0, imgWidth - right - left, top);       paint = new TexturePaint(subImg, new Rectangle(x+left, y, imgWidth - left - right, top));       g.setPaint(paint);       g.fillRect(x+left, y, width - left - right, top);     }          if (bottom > 0 && left + right < width) {       subImg = image.getSubimage(left, imgHeight - bottom, imgWidth - right - left, bottom);       paint = new TexturePaint(subImg, new Rectangle(x+left, y + height - bottom, imgWidth - left - right, bottom));       g.setPaint(paint);       g.fillRect(x+left, y + height - bottom, width - left - right, bottom);     }          if (left > 0 && top + bottom < height) {       subImg = image.getSubimage(0, top, left, imgHeight - top - bottom);       paint = new TexturePaint(subImg, new Rectangle(x, y+top, left, imgHeight - top - bottom));       g.setPaint(paint);       g.fillRect(x, y+top, left, height - top - bottom);     }          if (right > 0 && top + bottom < height) {       subImg = image.getSubimage(imgWidth - right, top, right, imgHeight - top - bottom);       paint = new TexturePaint(subImg, new Rectangle(x+width-right, y + top, right, imgHeight - top - bottom));       g.setPaint(paint);       g.fillRect(x+width-right, y + top, right, height - top - bottom);     }               if (fillContentArea) {       g.setColor(Color.yellow);       if (left + right < width       && top + bottom < height) {         subImg = image.getSubimage(left, top, imgWidth - right - left, imgHeight - top - bottom);         paint = new TexturePaint(subImg, new Rectangle(x + left, y + top, imgWidth - right - left, imgHeight - top - bottom));         g.setPaint(paint);         g.fillRect(x+left, y + top, width - right - left, height - top - bottom);}}}", "nl": "Paints the bevel image for the specified component with the specified position and size"}
{"code": "public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets) {     this(img, imageInsets, borderInsets, true);}", "nl": "Creates a new instance with the given image and insets"}
{"code": "public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets, boolean fillContentArea) {     if (img instanceof BufferedImage) {       this.image = (BufferedImage) img;     } else {       Frame f = new Frame();       f.pack();       MediaTracker t = new MediaTracker(f);       t.addImage(img, 0);       try { t.waitForAll(); } catch (InterruptedException e) {}       image = new BufferedImage(img.getWidth(f), img.getHeight(f), BufferedImage.TYPE_INT_ARGB);       Graphics2D imgGraphics = image.createGraphics();       imgGraphics.drawImage(img, 0, 0, f);       imgGraphics.dispose();       f.dispose();     }     this.imageInsets = imageInsets;     this.borderInsets = borderInsets;     this.fillContentArea = fillContentArea;}", "nl": "Creates a new instance with the given image and insets"}
{"code": "public ImageBevelBorder(Image img, Insets borderInsets) {     this(img, borderInsets, borderInsets, true);}", "nl": "Creates a new instance with the given image and insets"}
{"code": "private void updateActions() {     String label;     if (DEBUG) System.out.println(\"UndoRedoManager@\"+hashCode()+\".updateActions \"+         editToBeUndone()         +\" canUndo=\"+canUndo()+\" canRedo=\"+canRedo());     if (canUndo()) {       undoAction.setEnabled(true);       label = getUndoPresentationName();     } else {       undoAction.setEnabled(false);       label = labels.getString(\"edit.undo.text\");     }     undoAction.putValue(Action.NAME, label);     undoAction.putValue(Action.SHORT_DESCRIPTION, label);          if (canRedo()) {       redoAction.setEnabled(true);       label = getRedoPresentationName();     } else {       redoAction.setEnabled(false);       label = labels.getString(\"edit.redo.text\");     }     redoAction.putValue(Action.NAME, label);     redoAction.putValue(Action.SHORT_DESCRIPTION, label);}", "nl": "Updates the properties of the UndoAction and of the RedoAction"}
{"code": "public void discardAllEdits() {     super.discardAllEdits();     updateActions();     setHasSignificantEdits(false);}", "nl": "Discards all edits"}
{"code": "public boolean addEdit(UndoableEdit anEdit) {     if (DEBUG) System.out.println(\"UndoRedoManager@\"+hashCode()+\".add \"+anEdit);     if (undoOrRedoInProgress) {       anEdit.die();       return true;     }     boolean success = super.addEdit(anEdit);     updateActions();     if (success && anEdit.isSignificant() && editToBeUndone() == anEdit) {       setHasSignificantEdits(true);     }     return success;}", "nl": "If inProgress , inserts anEdit at indexOfNextAdd , and removes any old edits that were at indexOfNextAdd or later"}
{"code": "public void undo()   throws CannotUndoException {     undoOrRedoInProgress = true;     try {       super.undo();     } finally {       undoOrRedoInProgress = false;       updateActions();}}", "nl": "Undoes the last edit event"}
{"code": "public boolean hasSignificantEdits() {     return hasSignificantEdits;}", "nl": "Returns true if at least one significant UndoableEdit has been added since the last call to discardAllEdits"}
{"code": "public Action getUndoAction() {     return undoAction;}", "nl": "Gets the undo action for use as an Undo menu item"}
{"code": "public void redo()   throws CannotUndoException {     undoOrRedoInProgress = true;     try {       super.redo();     } finally {       undoOrRedoInProgress = false;       updateActions();}}", "nl": "Redoes the last undone edit event"}
{"code": "public CompositeEdit(String presentationName, boolean isSignificant) {     this.presentationName = presentationName;     this.isSignificant = isSignificant;}", "nl": "Creates a new CompositeEdit which uses the given presentation name and significance"}
{"code": "public String getRedoPresentationName() {     return ((presentationName != null) ? UndoRedoManager.getLabels().getString(\"edit.redo.text\")+\" \"+presentationName : super.getRedoPresentationName());}", "nl": "Returns the redo presentation name"}
{"code": "public String getPresentationName() {     return (presentationName != null) ? presentationName : super.getPresentationName();}", "nl": "Returns the presentation name"}
{"code": "public String getUndoPresentationName() {     return ((presentationName != null) ? UndoRedoManager.getLabels().getString(\"edit.undo.text\")+\" \"+presentationName : super.getUndoPresentationName());}", "nl": "Returns the undo presentation name"}
{"code": "public CompositeEdit() {     isSignificant = true;}", "nl": "Creates a new CompositeEdit which uses CompoundEdit # getPresentationName and is significant"}
{"code": "public boolean isSignificant() {     return (isSignificant) ? super.isSignificant() : false;}", "nl": "Returns false if this edit is insignificant - for example one that maintains the user ' s selection , but does not change any model state"}
{"code": "public static int invokeGetter(Object obj, String methodName, int defaultValue) {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[0]);       Object result = method.invoke(obj, new Object[0]);       return ((Integer) result).intValue();     } catch (NoSuchMethodException e) {       return defaultValue;     } catch (IllegalAccessException e) {       return defaultValue;     } catch (InvocationTargetException e) {       return defaultValue;}}", "nl": "Invokes the specified getter method if it exists"}
{"code": "public static void invokeIfExists(Object obj, String methodName, boolean newValue) {     try {        invoke(obj, methodName, newValue);     } catch (NoSuchMethodException e) {}}", "nl": "Invokes the specified method if it exists"}
{"code": "public static void invokeIfExists(Object obj, String methodName, float newValue) {     try {       invoke(obj, methodName, newValue);     } catch (NoSuchMethodException e) {}}", "nl": "Invokes the specified setter method if it exists"}
{"code": "public static void invokeIfExists(Object obj, String methodName) {     try {        invoke(obj, methodName);     } catch (NoSuchMethodException e) {}}", "nl": "Invokes the specified setter method if it exists"}
{"code": "public static Object invoke(Object obj, String methodName, Class[] clazz, Object... newValue)   throws NoSuchMethodException {     try {       Method method =  obj.getClass().getMethod(methodName,  clazz );       return method.invoke(obj, newValue);     } catch (IllegalAccessException e) {       throw new NoSuchMethodException(methodName+\" is not accessible\");     } catch (InvocationTargetException e) {              InternalError error = new InternalError(e.getMessage());       error.initCause((e.getCause() != null) ? e.getCause() : e);       throw error;}}", "nl": "Invokes the specified setter method if it exists"}
{"code": "public static Object invokeStatic(String clazz, String methodName,   Class[] types, Object[] values, Object defaultValue) {     try {       return invokeStatic(Class.forName(clazz), methodName, types, values);     } catch (ClassNotFoundException e) {       return defaultValue;     } catch (NoSuchMethodException e) {       return defaultValue;}}", "nl": "Invokes the specified parameterless method if it exists"}
{"code": "public static Object invokeGetter(Object obj, String methodName, Object defaultValue) {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[0]);       Object result = method.invoke(obj, new Object[0]);       return result;     } catch (NoSuchMethodException e) {       return defaultValue;     } catch (IllegalAccessException e) {       return defaultValue;     } catch (InvocationTargetException e) {       return defaultValue;}}", "nl": "Invokes the specified getter method if it exists"}
{"code": "public static boolean invokeStaticGetter(Class clazz, String methodName, boolean defaultValue) {     try {       Method method =  clazz.getMethod(methodName,  new Class[0]);       Object result = method.invoke(null, new Object[0]);       return ((Boolean) result).booleanValue();     } catch (NoSuchMethodException e) {       return defaultValue;     } catch (IllegalAccessException e) {       return defaultValue;     } catch (InvocationTargetException e) {       return defaultValue;}}", "nl": "Invokes the specified getter method if it exists"}
{"code": "public static void invokeIfExists(Object obj, String methodName, Class clazz, Object newValue) {     try {        invoke(obj, methodName, clazz, newValue);     } catch (NoSuchMethodException e) {}}", "nl": "Invokes the specified setter method if it exists"}
{"code": "public static Object invoke(Object obj, String methodName, Class clazz, Object newValue)   throws NoSuchMethodException {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[] { clazz } );       return method.invoke(obj, new Object[] { newValue});     } catch (IllegalAccessException e) {       throw new NoSuchMethodException(methodName+\" is not accessible\");     } catch (InvocationTargetException e) {              throw new InternalError(e.getMessage());}}", "nl": "Invokes the specified setter method if it exists"}
{"code": "public static boolean invokeGetter(Object obj, String methodName, boolean defaultValue) {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[0]);       Object result = method.invoke(obj, new Object[0]);       return ((Boolean) result).booleanValue();     } catch (NoSuchMethodException e) {       return defaultValue;     } catch (IllegalAccessException e) {       return defaultValue;     } catch (InvocationTargetException e) {       return defaultValue;}}", "nl": "Invokes the specified getter method if it exists"}
{"code": "public static Object invokeStatic(Class clazz, String methodName)   throws NoSuchMethodException {     try {       Method method =  clazz.getMethod(methodName,  new Class[0]);       Object result = method.invoke(null, new Object[0]);       return result;     } catch (IllegalAccessException e) {       throw new NoSuchMethodException(methodName+\" is not accessible\");     } catch (InvocationTargetException e) {              throw new InternalError(e.getMessage());}}", "nl": "Invokes the specified accessible parameterless method if it exists"}
{"code": "public static BufferedImage[] split(Image image, int count, boolean isHorizontal) {     BufferedImage src = Images.toBufferedImage(image);     if (count == 1) {       return new BufferedImage[]{src};     }     BufferedImage[] parts = new BufferedImage[count];     for (int i = 0; i < count; i++) {       if (isHorizontal) {         parts[i] = src.getSubimage(             src.getWidth() / count * i, 0,             src.getWidth() / count, src.getHeight());       } else {         parts[i] = src.getSubimage(             0, src.getHeight() / count * i,             src.getWidth(), src.getHeight() / count);       }     }     return parts;}", "nl": "Splits an image into count subimages"}
{"code": "public static BufferedImage toBufferedImage(RenderedImage rImg) {     BufferedImage image;     if (rImg instanceof BufferedImage) {       image = (BufferedImage) rImg;     } else {       Raster r = rImg.getData();       WritableRaster wr = WritableRaster.createWritableRaster(           r.getSampleModel(), null);       rImg.copyData(wr);       image = new BufferedImage(           rImg.getColorModel(),           wr,           rImg.getColorModel().isAlphaPremultiplied(),           null);     }     return image;}", "nl": "Converts an Image to BufferedImage"}
{"code": "public static boolean hasAlpha(Image image) {          if (image instanceof BufferedImage) {       BufferedImage bimage = (BufferedImage) image;       return bimage.getColorModel().hasAlpha();     }               PixelGrabber pg = new PixelGrabber(image, 0, 0, 1, 1, false);     try {       pg.grabPixels();     } catch (InterruptedException e) {     }          ColorModel cm = pg.getColorModel();     return cm.hasAlpha();}", "nl": "This method returns true if the specified image has transparent pixels Code taken from the Java Developers Almanac 1"}
{"code": "public KeyStroke getAcceleratorProperty(String key) {     KeyStroke ks = null;     try {       String s;       s = getStringRecursive(key + \".accelerator\");       ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);     } catch (MissingResourceException e) {       if (isVerbose) {         System.err.println(\"Warning ResourceBundleUtil[\" + baseName + \"] \\\"\" + key + \".accelerator\\\" not found.\");                }     } catch (NoSuchElementException e) {     }     return ks;}", "nl": "Gets a KeyStroke for a JavaBeans accelerator property from the ResourceBundle"}
{"code": "public static void removePropertyNameModifier(String name) {     propertyNameModifiers.remove(name);}", "nl": "Removes a property name modifier"}
{"code": "public char getMnemonicProperty(String key) {     String s;     try {       s = getStringRecursive(key + \".mnemonic\");     } catch (MissingResourceException e) {       if (isVerbose) {         System.err.println(\"Warning ResourceBundleUtil[\" + baseName + \"] \\\"\" + key + \".mnemonic\\\" not found.\");                }       s = null;     }     return (s == null || s.length() == 0) ? '\\0' : s.charAt(0);}", "nl": "Gets a char for a JavaBeans mnemonic property from the ResourceBundle"}
{"code": "public static void putPropertyNameModifier(String name, String... fallbackChain) {     propertyNameModifiers.put(name, fallbackChain);}", "nl": "Puts a property name modifier along with a fallback chain"}
{"code": "public ImageIcon getIconProperty(String key, Class baseClass) {     try {       String rsrcName = getStringRecursive(key + \".icon\");       if (rsrcName.equals(\"\")) {         return null;       }       URL url = baseClass.getResource(rsrcName);       if (isVerbose && url == null) {         System.err.println(\"Warning ResourceBundleUtil[\" + baseName + \"].getIconProperty \\\"\" + key + \".icon\\\" resource:\" + rsrcName + \" not found.\");       }       return (url == null) ? null : new ImageIcon(url);     } catch (MissingResourceException e) {       if (isVerbose) {         System.err.println(\"Warning ResourceBundleUtil[\" + baseName + \"].getIconProperty \\\"\" + key + \".icon\\\" not found.\");                }       return null;}}", "nl": "Get an image icon from the ResourceBundle"}
{"code": "public String format(String key, Object... arguments) {          return new Formatter(resource.getLocale()).format(getString(key), arguments).toString();}", "nl": "Returns a formatted string using java . util . Formatter"}
{"code": "public static ResourceBundleUtil getBundle(String baseName)       throws MissingResourceException {     return getBundle(baseName, LocaleUtil.getDefault());}", "nl": "Get the appropriate ResourceBundle subclass"}
{"code": "public String getTextProperty(String key) {     try {       String value = getStringRecursive(key + \".text\");       return value;     } catch (MissingResourceException e) {       if (isVerbose) {         System.err.println(\"Warning ResourceBundleUtil[\" + baseName + \"] \\\"\" + key + \".text\\\" not found.\");                }       return null;}}", "nl": "Get a String for a JavaBeans text property from the ResourceBundle"}
{"code": "private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     toolButtonGroup = new javax.swing.ButtonGroup();     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     jPanel1 = new javax.swing.JPanel();     creationToolbar = new javax.swing.JToolBar();     attributesToolbar = new javax.swing.JToolBar();     setLayout(new java.awt.BorderLayout());     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);     jPanel1.setLayout(new java.awt.GridBagLayout());     creationToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 0;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(creationToolbar, gridBagConstraints);     attributesToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 1;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(attributesToolbar, gridBagConstraints);     add(jPanel1, java.awt.BorderLayout.SOUTH);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "private String getStringRecursive(String key) throws MissingResourceException {     String value = resource.getString(key);          for (int p1 = value.indexOf(\"${\"); p1 != -1; p1 = value.indexOf(\"${\")) {       int p2 = value.indexOf('}', p1 + 2); \t  int p4 = value.indexOf('}', p1 + 2);       if (p2 == -1) {         break;       }       String placeholderKey = value.substring(p1 + 2, p2);       String placeholderFormat;       int p3 = placeholderKey.indexOf(',');       if (p3 != -1) {         placeholderFormat = placeholderKey.substring(p3 + 1);         placeholderKey = placeholderKey.substring(0, p3);       } else {         placeholderFormat = \"string\";       }       ArrayList<String> fallbackKeys = new ArrayList<String>();       generateFallbackKeys(placeholderKey, fallbackKeys);       String placeholderValue = null;       for (String fk : fallbackKeys) {         try {           placeholderValue = getStringRecursive(fk);           break;         } catch (MissingResourceException e) {         }       }       if (placeholderValue == null) {         throw new MissingResourceException(\"\\\"\"+key+\"\\\" not found in \"+baseName, baseName, key);       }              if (placeholderFormat.equals(\"accelerator\")) {                  StringBuilder b = new StringBuilder();         for (String s : placeholderValue.split(\" \")) {           if (acceleratorKeys.contains(s)) {             b.append(getString(\"accelerator.\" + s));           } else {             b.append(s);           }         }         placeholderValue = b.toString();       }              value = value.substring(0, p1) + placeholderValue + value.substring(p2 + 1);     }     return value;}", "nl": "Recursive part of the getString method"}
{"code": "public KeyStroke getKeyStroke(String key) {     KeyStroke ks = null;     try {       String s = getStringRecursive(key);       ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);     } catch (NoSuchElementException e) {     }     return ks;}", "nl": "Get a KeyStroke from the ResourceBundle"}
{"code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {          in.defaultReadObject();          this.resource = ResourceBundle.getBundle(baseName, locale);}", "nl": "Read object from ObjectInputStream and re - establish ResourceBundle"}
{"code": "private void generateFallbackKeys(String key, ArrayList<String> fallbackKeys) {     int p1 = key.indexOf(\"[$\");     if (p1 == -1) {       fallbackKeys.add(key);     } else {       int p2 = key.indexOf(']', p1 + 2);       if (p2 == -1) {         return;       }       String modifierKey = key.substring(p1 + 2, p2);       String[] modifierValues = propertyNameModifiers.get(modifierKey);       if (modifierValues == null) {         modifierValues = new String[]{\"default\"};       }       for (String mv : modifierValues) {         generateFallbackKeys(key.substring(0, p1) + mv + key.substring(p2 + 1), fallbackKeys);}}}", "nl": "Generates fallback keys by processing all property name modifiers in the key"}
{"code": "public ODGDrawingPanel() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     initComponents();     undoManager = new UndoRedoManager();     editor = new DefaultDrawingEditor();     editor.add(view);          addCreationButtonsTo(creationToolbar, editor);     ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);          JPopupButton pb = new JPopupButton();     pb.setItemFont(UIManager.getFont(\"MenuItem.font\"));     labels.configureToolBarButton(pb, \"actions\");     pb.add(new DuplicateAction());     pb.addSeparator();     pb.add(new GroupAction(editor));     pb.add(new UngroupAction(editor));     pb.addSeparator();     pb.add(new BringToFrontAction(editor));     pb.add(new SendToBackAction(editor));     pb.addSeparator();     pb.add(new CutAction());     pb.add(new CopyAction());     pb.add(new PasteAction());     pb.add(new SelectAllAction());     pb.add(new SelectSameAction(editor));     pb.addSeparator();     pb.add(undoManager.getUndoAction());     pb.add(undoManager.getRedoAction());                            JMenu m = new JMenu(labels.getString(\"view.zoomFactor.text\"));     JRadioButtonMenuItem rbmi;     ButtonGroup group = new ButtonGroup();     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));     rbmi.setSelected(true);     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));     group.add(rbmi);     pb.add(m);     pb.setFocusable(false);     creationToolbar.addSeparator();     creationToolbar.add(pb);               DefaultDrawing drawing = new DefaultDrawing();     view.setDrawing(drawing);     drawing.addUndoableEditListener(undoManager);}", "nl": "Creates new instance"}
{"code": "private void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     JButton b;     b = bar.add(new PickAttributesAction(editor));     b.setFocusable(false);     b = bar.add(new ApplyAttributesAction(editor));     b.setFocusable(false);     bar.addSeparator();     addColorButtonsTo(bar, editor);     bar.addSeparator();     addStrokeButtonsTo(bar, editor);     bar.addSeparator();     ButtonFactory.addFontButtonsTo(bar, editor);}", "nl": "Creates toolbar buttons and adds them to the specified JToolBar"}
{"code": "public NodeFigure() {     RectangleFigure rf = new RectangleFigure();     setDecorator(rf);     createConnectors();     set(DECORATOR_INSETS, new Insets2D.Double(6, 10, 6, 10));     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.net.Labels\");     setText(labels.getString(\"nodeDefaultName\"));     setAttributeEnabled(DECORATOR_INSETS, false);}", "nl": "Creates a new instance"}
{"code": "public static Preferences userNodeForPackage(Class<?> c) {     if (userNodes != null) {       if (!userNodes.containsKey(c.getPackage())) {         userNodes.put(c.getPackage(), new PreferencesUtil(false));       }       return userNodes.get(c.getPackage());     }     try {       return Preferences.userNodeForPackage(c);     } catch (Throwable t) {       if (userNodes == null) {         userNodes = new HashMap<Package, Preferences>();       }       return userNodeForPackage(c);}}", "nl": "Gets the user node for the package of the class if permitted , gets a proxy otherwise"}
{"code": "public static Preferences systemNodeForPackage(Class<?> c) {     if (systemNodes != null) {       if (!systemNodes.containsKey(c.getPackage())) {         systemNodes.put(c.getPackage(), new PreferencesUtil(false));       }       return systemNodes.get(c.getPackage());     }      try {       return Preferences.systemNodeForPackage(c);     } catch (Throwable t) {       if (systemNodes == null) {         systemNodes = new HashMap<Package, Preferences>();       }       return systemNodeForPackage(c);}}", "nl": "Gets the system node for the package of the class if permitted , gets a proxy otherwise"}
{"code": "public static void installToolBarPrefsHandler(final Preferences prefs, final String name, JToolBar toolbar) {     new ToolBarPrefsHandler(toolbar, name, prefs);}", "nl": "Installs a toolbar preferences handler"}
{"code": "public static void installPalettePrefsHandler(final Preferences prefs, final String name, Window window) {     installPalettePrefsHandler(prefs, name, window, 0);}", "nl": "Installs a palette preferences handler"}
{"code": "public static void installFramePrefsHandler(final Preferences prefs, final String name, Window window) {     installFramePrefsHandler(prefs, name, window, new Dimension(400, 300));}", "nl": "Installs a frame preferences handler"}
{"code": "private void initComponents() {     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     setLayout(new java.awt.BorderLayout());     scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);     scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public void setDrawingEditor(DrawingEditor newValue) {     if (editor != null) {       editor.remove(view);     }     editor = newValue;     if (editor != null) {       editor.add(view);}}", "nl": "Sets a drawing editor for the view"}
{"code": "protected Drawing createDrawing() {     DefaultDrawing drawing = new DefaultDrawing();     DOMStorableInputOutputFormat ioFormat =         new DOMStorableInputOutputFormat(new NetFactory());     drawing.addInputFormat(ioFormat);     drawing.addInputFormat(new TextInputFormat(new NodeFigure()));     drawing.addOutputFormat(ioFormat);     drawing.addOutputFormat(new ImageOutputFormat());     return drawing;}", "nl": "Creates a new Drawing for this view"}
{"code": "public DrawingEditor getDrawingEditor() {     return editor;}", "nl": "Gets the drawing editor of the view"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public static Paint getStrokePaint(Figure f) {     double opacity = f.get(STROKE_OPACITY);     if (f.get(STROKE_GRADIENT) != null) {       return f.get(STROKE_GRADIENT).getPaint(f, opacity);     }     Color color = f.get(STROKE_COLOR);     if (color != null) {       if (opacity != 1) {         color = new Color(             (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,             true);       }     }     return color;}", "nl": "Gets the stroke paint for the specified figure based on the attributes STROKE _ GRADIENT , STROKE _ OPACITY , STROKE _ PAINT and the bounds of the figure"}
{"code": "@Override   public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "@Override   public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "@Override   public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "@Override   public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "@Override   public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public LinkToolBar() {     labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(getID() + \".toolbar\"));     setDisclosureStateCount(3);}", "nl": "Creates new instance"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "@Override   public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "@Override   public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "@Override   public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "@Override   public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "@Override   public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public FigureToolBar() {     labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(getID() + \".toolbar\"));     setDisclosureStateCount(3);}", "nl": "Creates new instance"}
{"code": "public void save(Writer out) throws IOException {     if (doctype != null) {       out.write(\"<!DOCTYPE \");       out.write(doctype);       out.write(\">\\n\");     }     XMLWriter writer = new XMLWriter(out);     writer.write((XMLElement) document.getChildren().get(0));}", "nl": "Writes the contents of the DOMOutput into the specified writer"}
{"code": "public void save(OutputStream out) throws IOException {     Writer w = new OutputStreamWriter(out, \"UTF8\");     save(w);     w.flush();}", "nl": "Writes the contents of the DOMOutput into the specified output stream"}
{"code": "public NanoXMLDOMOutput(DOMFactory factory) {     this.factory = factory;     objectids = new HashMap<Object,String>();     document = new XMLElement();     current = document;     stack = new Stack<XMLElement>();     stack.push(current);}", "nl": "Creates a new instance"}
{"code": "public void addAttribute(String name, String value) {     if (value != null) {       current.setAttribute(name, value);}}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public void addAttribute(String name, double value) {          String str = Double.toString(value);     if (str.endsWith(\".0\")) str = str.substring(0, str.length() - 2);     current.setAttribute(name, str);}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public void closeElement() {     current = (XMLElement) stack.pop();}", "nl": "Closes the current element of the DOM Document"}
{"code": "public void print(PrintWriter out) {     XMLWriter writer = new XMLWriter(out);          try {              writer.write((XMLElement) document.getChildren().get(0), true);     } catch (IOException e) {       InternalError error = new InternalError();       error.initCause(e);       throw error;}}", "nl": "Prints the contents of the DOMOutput into the specified print writer"}
{"code": "public void addAttribute(String name, float value) {          String str = Float.toString(value);     if (str.endsWith(\".0\")) str = str.substring(0, str.length() - 2);     current.setAttribute(name, str);}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public void addAttribute(String name, boolean value) {     current.setAttribute(name, new Boolean(value).toString());}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public int getElementCount(String tagName) {     int count = 0;     NodeList list = current.getChildNodes();     for (int i=0; i < list.getLength(); i++) {       Node node = list.item(i);       if ((node instanceof Element)       && ((Element) node).getTagName().equals(tagName)) {         count++;       }     }     return count;}", "nl": "Returns the number of child elements with the specified tag name of the current element"}
{"code": "public Object readObject() throws IOException {     return readObject(0);}", "nl": "Reads an object from the current element"}
{"code": "public boolean getAttribute(String name, boolean defaultValue) {     String value = ((Element) current).getAttribute(name);     return (value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public int getElementCount() {     int count = 0;     NodeList list = current.getChildNodes();     for (int i=0; i < list.getLength(); i++) {       Node node = list.item(i);       if ((node instanceof Element)) {         count++;       }     }     return count;}", "nl": "Returns the number of child elements of the current element"}
{"code": "public String getText(String defaultValue) {     if (current.getChildNodes().getLength() == 0) return defaultValue;          StringBuilder buf = new StringBuilder();     getText(current, buf);          return buf.toString();}", "nl": "Gets the text of the current element of the DOM Document"}
{"code": "public double getAttribute(String name, double defaultValue) {     String value = ((Element) current).getAttribute(name);     return (value.length() == 0) ? defaultValue : Double.parseDouble(value);}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public java.util.List<String> getInheritedAttribute(String name) {     LinkedList<String> values = new LinkedList<String>();     Node node = current;     while (node != null) {       String value = (String) ((Element) node).getAttribute(name);       values.addFirst(value);       node = node.getParentNode();     }     return values;}", "nl": "Gets an attribute of the current element of the DOM Document and of all parent DOM elements"}
{"code": "public String getText() {     return getText(null);}", "nl": "Gets the text of the current element of the DOM Document"}
{"code": "public String getTagName() {     return ((Element) current).getTagName();}", "nl": "Returns the tag name of the current element"}
{"code": "public void closeElement() {          current = current.getParentNode();}", "nl": "Closes the current element of the DOM Document"}
{"code": "public void openElement(String tagName, int index) {     int count = 0;     NodeList list = current.getChildNodes();     int len = list.getLength();     for (int i=0; i < len; i++) {       Node node = list.item(i);       if ((node instanceof Element)       && ((Element) node).getTagName().equals(tagName)) {         if (count++ == index) {           current = node;           return;         }       }     }     throw new IllegalArgumentException(\"no such child \"+tagName+\"[\"+index+\"]\");}", "nl": "Opens the element with the specified name and index and makes it the current node"}
{"code": "public void addAttribute(String name, boolean value) {     ((Element) current).setAttribute(name, Boolean.toString(value));}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public void addText(String text) {     current.appendChild(document.createTextNode(text));}", "nl": "Adds a text to current element of the DOM Document"}
{"code": "public void addComment(String comment) {     current.appendChild(document.createComment(comment));}", "nl": "Adds a comment to the current element of the DOM Document"}
{"code": "public void save(Writer out) throws IOException {     reset();     try {       if (doctype != null) {         out.write(\"<!DOCTYPE \");         out.write(doctype);         out.write(\">\\n\");       }       Transformer t = TransformerFactory.newInstance().newTransformer();       t.transform(new DOMSource(document), new StreamResult(out));     } catch (TransformerException e) {       IOException error = new IOException(e.getMessage());       error.initCause(e);       throw error;}}", "nl": "Writes the contents of the DOMOutput into the specified output stream"}
{"code": "public void addAttribute(String name, double value) {          String str = Double.toString(value);     if (str.endsWith(\".0\")) str = str.substring(0, str.length() - 2);     ((Element) current).setAttribute(name, str);}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public void closeElement() {          current = current.getParentNode();}", "nl": "Closes the current element of the DOM Document"}
{"code": "public void addAttribute(String name, String value) {     if (value != null) {       ((Element) current).setAttribute(name, value);}}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public void addAttribute(String name, float value) {          String str = Float.toString(value);     if (str.endsWith(\".0\")) str = str.substring(0, str.length() - 2);     ((Element) current).setAttribute(name, str);}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public String getText() {     return getText(null);}", "nl": "Gets the text of the current element of the DOM Document"}
{"code": "public java.util.List<String> getInheritedAttribute(String name) {     LinkedList<String> values = new LinkedList<String>();     for (XMLElement node: stack) {       String value = (String) node.getAttribute(name);       values.add(value);     }     String value = (String) current.getAttribute(name);     values.add(value);     return values;}", "nl": "Gets an attribute of the current element of the DOM Document and of all parent DOM elements"}
{"code": "public boolean getAttribute(String name, boolean defaultValue) {     String value = (String) current.getAttribute(name);     return (value == null || value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public void openElement(String tagName, int index) throws IOException {     int count = 0;     ArrayList list = current.getChildren();     for (int i=0; i < list.size(); i++) {       XMLElement node = (XMLElement) list.get(i);       if (node.getName().equals(tagName)) {         if (count++ == index) {           stack.push(current);           current = node;           return;         }       }     }     throw new IOException(\"no such element:\"+tagName+\" at index:\"+index);}", "nl": "Opens the element with the specified name and index and makes it the current node"}
{"code": "public int getAttribute(String name, int defaultValue) {     String value = (String) current.getAttribute(name);     return (value == null || value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public void openElement(String tagName) throws IOException {     ArrayList list = current.getChildren();     for (int i=0; i < list.size(); i++) {       XMLElement node = (XMLElement) list.get(i);       if (node.getName().equals(tagName)) {         stack.push(current);         current = node;         return;       }     }     throw new IOException(\"no such element:\"+tagName);}", "nl": "Opens the last element with the specified name and makes it the current node"}
{"code": "public void openElement(int index) {     stack.push(current);     ArrayList list = current.getChildren();     current = (XMLElement) list.get(index);}", "nl": "Opens the element with the specified index and makes it the current node"}
{"code": "public String getText(String defaultValue) {     String value = current.getContent();     return (value == null) ? defaultValue : value;}", "nl": "Gets the text of the current element of the DOM Document"}
{"code": "public void closeElement() {     current = (XMLElement) stack.pop();}", "nl": "Closes the current element of the DOM Document"}
{"code": "public int getElementCount() {     return current.getChildrenCount();}", "nl": "Returns the number of child elements of the current element"}
{"code": "public double getAttribute(String name, double defaultValue) {     String value = (String) current.getAttribute(name);     return (value == null || value.length() == 0) ? defaultValue : Double.parseDouble(value);}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public Object readObject() throws IOException {     return readObject(0);}", "nl": "Reads an object from the current element"}
{"code": "public InputStream post(String raw_cookies, Map parameters) throws IOException {   setCookies(raw_cookies);   postCookies();   setParameters(parameters);   return doPost();}", "nl": "posts the requests to the server , with all the cookies and parameters that were added before , and with cookies and parameters that are passed in the arguments raw _ cookies request cookies parameters @ return input stream with the server response IOException # setParameters # setCookies"}
{"code": "public void setParameters(Object[] parameters) throws IOException {   if (parameters != null) {     for (int i = 0; i < parameters.length - 1; i += 2) {     setParameter(parameters[i].toString(), parameters[i + 1]);}}}", "nl": "adds parameters to the request ; if a value is a file , the file is uploaded , otherwise it is stringified and sent in the request IOException"}
{"code": "public void setCookies(Map<String,String> cookies) throws IOException {   if (cookies == null) return;   this._cookies.putAll(cookies);}", "nl": "adds cookies to the request name - to - value map IOException"}
{"code": "public InputStream post(String name, Object value) throws IOException {   postCookies();   setParameter(name, value);   return doPost();}", "nl": "post the POST request to the server , with the specified parameter name value @ return input stream with the server response IOException # setParameter"}
{"code": "public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3, String name4, Object value4) throws IOException {   postCookies();   setParameter(name1, value1);   setParameter(name2, value2);   setParameter(name3, value3);   setParameter(name4, value4);   return doPost();}", "nl": "post the POST request to the server , with the specified parameters name1 first parameter name value1 first parameter value name2 second parameter name value2 second parameter value name3 third parameter name value3 third parameter value name4 fourth parameter name value4 fourth parameter value @ return input stream with the server response IOException # setParameter"}
{"code": "public static InputStream post(URL url, Map<String,String> cookies, Map parameters) throws IOException {   return new ClientHttpRequest(url).post(cookies, parameters);}", "nl": "posts a new request to specified URL , with cookies and parameters that are passed in the argument cookies parameters @ return input stream with the server response IOException # setCookies # setParameters"}
{"code": "private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     toolButtonGroup = new javax.swing.ButtonGroup();     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     jPanel1 = new javax.swing.JPanel();     creationToolbar = new javax.swing.JToolBar();     attributesToolbar = new javax.swing.JToolBar();     setLayout(new java.awt.BorderLayout());     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);     jPanel1.setLayout(new java.awt.GridBagLayout());     creationToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 0;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(creationToolbar, gridBagConstraints);     attributesToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 1;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(attributesToolbar, gridBagConstraints);     add(jPanel1, java.awt.BorderLayout.SOUTH);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public void setParameters(Map parameters) throws IOException {   if (parameters != null) {     for (Iterator i = parameters.entrySet().iterator(); i.hasNext();) {     Map.Entry entry = (Map.Entry)i.next();     setParameter(entry.getKey().toString(), entry.getValue());}}}", "nl": "adds parameters to the request name - to - value map of parameters ; if a value is a file , the file is uploaded , otherwise it is stringified and sent in the request IOException"}
{"code": "public void setCookie(String name, String value) throws IOException {     _cookies.put(name, value);}", "nl": "adds a cookie to the requst name value IOException"}
{"code": "public InputStream post(String name1, Object value1, String name2, Object value2) throws IOException {   postCookies();   setParameter(name1, value1);   setParameter(name2, value2);   return doPost();}", "nl": "post the POST request to the server , with the specified parameters name1 first parameter name value1 first parameter value name2 second parameter name value2 second parameter value @ return input stream with the server response IOException # setParameter"}
{"code": "public InputStream post(Map parameters) throws IOException {   postCookies();   setParameters(parameters);   return doPost();}", "nl": "posts the requests to the server , with all the cookies and parameters that were added before , and with parameters that are passed in the argument parameters @ return input stream with the server response IOException # setParameters"}
{"code": "public void setParameter(String name, Object object) throws IOException {   if (object instanceof File) {     setParameter(name, (File) object);   } else {     setParameter(name, object.toString());}}", "nl": "adds a parameter to the request ; if the parameter is a File , the file is uploaded , otherwise the string value of the parameter is passed in the request name value , a File or anything else that can be stringified IOException"}
{"code": "private InputStream doPost() throws IOException {   boundary();   writeln(\"--\");   _os.close();   return _connection.getInputStream();}", "nl": "posts the requests to the server , with all the cookies and parameters that were added @ return input stream with the server response IOException"}
{"code": "public void setCookies(String rawCookies) throws IOException {   this._rawCookies = (rawCookies == null) ? \"\" : rawCookies;   _cookies.clear();}", "nl": "adds a cookie to the requst data"}
{"code": "public DependencyFigure() {     set(STROKE_COLOR, new Color(0x000099));     set(STROKE_WIDTH, 1d);     set(END_DECORATION, new ArrowTip());          setAttributeEnabled(END_DECORATION, false);     setAttributeEnabled(START_DECORATION, false);     setAttributeEnabled(STROKE_DASHES, false);     setAttributeEnabled(FONT_ITALIC, false);     setAttributeEnabled(FONT_UNDERLINE, false);}", "nl": "Creates a new instance"}
{"code": "public InputStream post() throws IOException {       postCookies();     return doPost();}", "nl": "posts the requests to the server , with all the cookies and parameters that were added @ return input stream with the server response IOException"}
{"code": "public void setCookies(String[] cookies) throws IOException {   if (cookies == null) return;   for (int i = 0; i < cookies.length - 1; i+=2) {     setCookie(cookies[i], cookies[i+1]);}}", "nl": "adds cookies to the request IOException"}
{"code": "@Override protected void handleDisconnect(Connector start, Connector end) {     TaskFigure sf = (TaskFigure) start.getOwner();     TaskFigure ef = (TaskFigure) end.getOwner();          sf.removeDependency(this);     ef.removeDependency(this);}", "nl": "Handles the disconnection of a connection"}
{"code": "public InputStream post(Map<String,String> cookies, Map parameters) throws IOException {   setCookies(cookies);   postCookies();   setParameters(parameters);   return doPost();}", "nl": "posts the requests to the server , with all the cookies and parameters that were added before , and with cookies and parameters that are passed in the arguments cookies parameters @ return input stream with the server response IOException # setParameters # setCookies"}
{"code": "public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {   postCookies();   setParameter(name1, value1);   setParameter(name2, value2);   setParameter(name3, value3);   return doPost();}", "nl": "post the POST request to the server , with the specified parameters name1 first parameter name value1 first parameter value name2 second parameter name value2 second parameter value name3 third parameter name value3 third parameter value @ return input stream with the server response IOException # setParameter"}
{"code": "public ClientHttpRequest(URL url) throws IOException {   this(url.openConnection());}", "nl": "Creates a new multipart POST HTTP request for a specified URL to IOException"}
{"code": "public static InputStream post(URL url, String[] cookies, Object[] parameters) throws IOException {   return new ClientHttpRequest(url).post(cookies, parameters);}", "nl": "posts a new request to specified URL , with cookies and parameters that are passed in the argument URL cookies parameters @ return input stream with the server response IOException # setCookies # setParameters"}
{"code": "public static InputStream post(URL url, String name1, Object value1) throws IOException {   return new ClientHttpRequest(url).post(name1, value1);}", "nl": "post the POST request specified URL , with the specified parameter URL name1 parameter name value1 parameter value @ return input stream with the server response IOException # setParameter"}
{"code": "public static InputStream post(URL url, String name1, Object value1, String name2, Object value2) throws IOException {   return new ClientHttpRequest(url).post(name1, value1, name2, value2);}", "nl": "post the POST request to specified URL , with the specified parameters name1 first parameter name value1 first parameter value name2 second parameter name value2 second parameter value @ return input stream with the server response IOException # setParameter"}
{"code": "public String getParameter(String name) {     try {       return super.getParameter(name);     } catch (NullPointerException e) {       return null;}}", "nl": "We override getParameter to make it work even if we have no Applet context"}
{"code": "private void initDrawing(Drawing d) {     LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();     LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();     DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(         new PertFactory());     inputFormats.add(ioFormat);     outputFormats.add(ioFormat);     outputFormats.add(new ImageOutputFormat());     d.setInputFormats(inputFormats);     d.setOutputFormats(outputFormats);}", "nl": "Configure Drawing object to support copy and paste"}
{"code": "private void initComponents() {     toolButtonGroup = new javax.swing.ButtonGroup();}", "nl": "This method is called from within the init method to initialize the form"}
{"code": "public TaskFigure() {     super(new RectangleFigure());     setLayouter(new VerticalLayouter());     RectangleFigure nameCompartmentPF = new RectangleFigure();     nameCompartmentPF.set(STROKE_COLOR, null);     nameCompartmentPF.setAttributeEnabled(STROKE_COLOR, false);     nameCompartmentPF.set(FILL_COLOR, null);     nameCompartmentPF.setAttributeEnabled(FILL_COLOR, false);     ListFigure nameCompartment = new ListFigure(nameCompartmentPF);     ListFigure attributeCompartment = new ListFigure();     SeparatorLineFigure separator1 = new SeparatorLineFigure();     applyAttributes(getPresentationFigure());     add(nameCompartment);     add(separator1);     add(attributeCompartment);     Insets2D.Double insets = new Insets2D.Double(4, 8, 4, 8);     nameCompartment.set(LAYOUT_INSETS, insets);     attributeCompartment.set(LAYOUT_INSETS, insets);     TextFigure nameFigure;     nameCompartment.add(nameFigure = new TextFigure());     nameFigure.set(FONT_BOLD, true);     nameFigure.setAttributeEnabled(FONT_BOLD, false);     TextFigure durationFigure;     attributeCompartment.add(durationFigure = new TextFigure());     durationFigure.set(FONT_BOLD, true);     durationFigure.setText(\"0\");     durationFigure.setAttributeEnabled(FONT_BOLD, false);     TextFigure startTimeFigure;     attributeCompartment.add(startTimeFigure = new TextFigure());     startTimeFigure.setEditable(false);     startTimeFigure.setText(\"0\");     startTimeFigure.setAttributeEnabled(FONT_BOLD, false);     applyAttributes(this);     setAttributeEnabled(STROKE_DASHES, false);     ResourceBundleUtil labels =         ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.pert.Labels\");     setName(labels.getString(\"pert.task.defaultName\"));     setDuration(0);     dependencies = new HashSet<DependencyFigure>();     nameFigure.addFigureListener(new NameAdapter(this));     durationFigure.addFigureListener(new DurationAdapter(this));}", "nl": "Creates a new instance"}
{"code": "private boolean writeRectAttributes(IXMLElement elem, SVGFigure f, Rectangle2D.Double rect) {     AffineTransform t = TRANSFORM.getClone(f);     if (t == null) {       t = drawingTransform;     } else {       t.preConcatenate(drawingTransform);     }     if ((t.getType() &         (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==         t.getType()) {       Point2D.Double start = new Point2D.Double(rect.x, rect.y);       Point2D.Double end = new Point2D.Double(rect.x + rect.width, rect.y + rect.height);       t.transform(start, start);       t.transform(end, end);       Rectangle r = new Rectangle(           (int) Math.min(start.x, end.x),           (int) Math.min(start.y, end.y),           (int) Math.abs(start.x - end.x),           (int) Math.abs(start.y - end.y));       elem.setAttribute(\"shape\", \"rect\");       elem.setAttribute(\"coords\",           r.x + \",\" +           r.y + \",\" +           (r.x + r.width) + \",\" +           (r.y + r.height));       writeHrefAttribute(elem, f);       return bounds.intersects(r);     } else {       return writePolyAttributes(elem, f, (Shape) rect);}}", "nl": "Writes the shape , coords , href , nohref Attribute for the specified figure and rectangle"}
{"code": "public void write(OutputStream out, java.util.List<Figure> figures,       AffineTransform drawingTransform, Dimension imageSize) throws IOException {     this.drawingTransform = (drawingTransform == null) ? new AffineTransform() : drawingTransform;     this.bounds = (imageSize == null) ? new Rectangle(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE) : new Rectangle(0, 0, imageSize.width, imageSize.height);     XMLElement document = new XMLElement(\"map\");          for (Figure f : new ReversedList<Figure>(figures)) {       writeElement(document, f);     }               if (!isIncludeNohref) {       for (int i = document.getChildrenCount() - 1; i >= 0; i--) {         XMLElement child = (XMLElement) document.getChildAtIndex(i);         if (child.hasAttribute(\"nohref\")) {           document.removeChildAtIndex(i);         }       }     }           PrintWriter writer = new PrintWriter(         new OutputStreamWriter(out, \"UTF-8\"));          for (Object o : document.getChildren()) {       XMLElement child = (XMLElement) o;       new XMLWriter(writer).write(child);     }          writer.flush();}", "nl": "Writes the figures to the specified output stream"}
{"code": "public void write(OutputStream out, Drawing drawing,       AffineTransform drawingTransform, Dimension imageSize) throws IOException {     write(out, drawing.getChildren(), drawingTransform, imageSize);}", "nl": "Writes the drawing to the specified output stream"}
{"code": "private boolean writeCircleAttributes(IXMLElement elem, SVGFigure f, Ellipse2D.Double ellipse) {     AffineTransform t = TRANSFORM.getClone(f);     if (t == null) {       t = drawingTransform;     } else {       t.preConcatenate(drawingTransform);     }     if ((t.getType() &         (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==         t.getType() &&         ellipse.width == ellipse.height) {       Point2D.Double start = new Point2D.Double(ellipse.x, ellipse.y);       Point2D.Double end = new Point2D.Double(ellipse.x + ellipse.width, ellipse.y + ellipse.height);       t.transform(start, start);       t.transform(end, end);       ellipse.x = Math.min(start.x, end.x);       ellipse.y = Math.min(start.y, end.y);       ellipse.width = Math.abs(start.x - end.x);       ellipse.height = Math.abs(start.y - end.y);       elem.setAttribute(\"shape\", \"circle\");       elem.setAttribute(\"coords\",           (int) (ellipse.x + ellipse.width / 2d) + \",\" +           (int) (ellipse.y + ellipse.height / 2d) + \",\" +           (int) (ellipse.width / 2d));       writeHrefAttribute(elem, f);       return bounds.intersects(ellipse.getBounds());     } else {       return writePolyAttributes(elem, f, (Shape) ellipse);}}", "nl": "Writes the shape , coords , href , nohref Attribute for the specified figure and ellipse"}
{"code": "public void write(OutputStream out, java.util.List<Figure> figures) throws IOException {     Rectangle2D.Double drawingRect = null;     for (Figure f : figures) {       if (drawingRect == null) {         drawingRect = f.getBounds();       } else {         drawingRect.add(f.getBounds());       }     }     AffineTransform drawingTransform = new AffineTransform();     drawingTransform.translate(         -Math.min(0, drawingRect.x),         -Math.min(0, drawingRect.y));     write(out, figures, drawingTransform,         new Dimension(         (int) (Math.abs(drawingRect.x) + drawingRect.width),         (int) (Math.abs(drawingRect.y) + drawingRect.height)));}", "nl": "All other write methods delegate their work to here"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "private void readStylesElement(IXMLElement elem) throws IOException {     readStylesChildren(elem, commonStyles);}", "nl": "Reads a & lt ; styles & gt ; element from the specified XML element"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "private void readMasterStylesElement(IXMLElement elem) throws IOException {     readStylesChildren(elem, masterStyles);}", "nl": "Reads a & lt ; master - styles & gt ; element from the specified XML element"}
{"code": "public void read(IXMLElement root) throws IOException {     String name = root.getName();     String ns = root.getNamespace();     if (name.equals(\"document-content\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {       readDocumentContentElement(root);     } else if (name.equals(\"document-styles\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {       readDocumentStylesElement(root);     } else {       if (DEBUG) {         System.out.println(\"ODGStylesReader unsupported root element \" + root);}}}", "nl": "Reads a & lt ; document - styles & gt ; element from the specified XML element"}
{"code": "private void readGraphicPropertiesElement(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {                    if (elem.hasAttribute(\"stroke\", DRAWING_NAMESPACE)) {       STROKE_STYLE.put(a, (StrokeStyle) elem.getAttribute(\"stroke\", DRAWING_NAMESPACE, STROKE_STYLES, null));     }               if (elem.hasAttribute(\"stroke-width\", SVG_NAMESPACE)) {       STROKE_WIDTH.put(a, toLength(elem.getAttribute(\"stroke-width\", SVG_NAMESPACE, null)));     }               if (elem.hasAttribute(\"stroke-color\", SVG_NAMESPACE)) {       STROKE_COLOR.put(a, toColor(elem.getAttribute(\"stroke-color\", SVG_NAMESPACE, null)));     }                                                                                          if (elem.hasAttribute(\"fill\", DRAWING_NAMESPACE)) {       FILL_STYLE.put(a, (FillStyle) elem.getAttribute(\"fill\", DRAWING_NAMESPACE, FILL_STYLES, null));     }                    if (elem.hasAttribute(\"fill-color\", DRAWING_NAMESPACE)) {       FILL_COLOR.put(a, toColor(elem.getAttribute(\"fill-color\", DRAWING_NAMESPACE, null)));     }                         for (IXMLElement child : elem.getChildren()) {       String ns = child.getNamespace();       String name = child.getName();}}", "nl": "Reads a & lt ; style : graphic - properties & gt ; element from the specified XML element"}
{"code": "private void readListStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {     if (DEBUG) {       System.out.println(\"ODGStylesReader unsupported <\" + elem.getName() + \"> element.\");}}", "nl": "Reads a & lt ; text : list - style & gt ; element from the specified XML element"}
{"code": "public void read(File file) throws IOException {     BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));     try {       read(in);     } finally {       in.close();}}", "nl": "Reads a & lt ; document - styles & gt ; element from the specified XML file"}
{"code": "public void read(InputStream in) throws IOException {     IXMLParser parser;     try {       parser = XMLParserFactory.createDefaultXMLParser();     } catch (Exception ex) {       InternalError e = new InternalError(\"Unable to instantiate NanoXML Parser\");       e.initCause(ex);       throw e;     }     IXMLReader reader = new StdXMLReader(in);     parser.setReader(reader);     IXMLElement document;     try {       document = (IXMLElement) parser.parse();     } catch (XMLException ex) {       IOException e = new IOException(ex.getMessage());       e.initCause(ex);       throw e;     }     read(document);}", "nl": "Reads a & lt ; document - styles & gt ; element from the specified input stream"}
{"code": "private double toLength(String str) throws IOException {     double scaleFactor = 1d;     if (str == null || str.length() == 0) {       return 0d;     }     if (str.endsWith(\"cm\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 35.43307;     } else if (str.endsWith(\"mm\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 3.543307;     } else if (str.endsWith(\"in\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 90;     } else if (str.endsWith(\"pt\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 1.25;     } else if (str.endsWith(\"pc\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 15;     } else if (str.endsWith(\"px\")) {       str = str.substring(0, str.length() - 2);     }     return Double.parseDouble(str) * scaleFactor;}", "nl": "Returns a value as a length"}
{"code": "private void readDocumentContentElement(IXMLElement elem) throws IOException {     if (DEBUG) {       System.out.println(\"ODGStylesReader <\" + elem.getName() + \" ...>\");     }     for (IXMLElement child : elem.getChildren()) {       String ns = child.getNamespace();       String name = child.getName();       if (name.equals(\"automatic-styles\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {         readAutomaticStylesElement(child);       } else if (name.equals(\"master-styles\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {         readStylesElement(child);       } else if (name.equals(\"styles\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {         readStylesElement(child);       }     }     if (DEBUG) {       System.out.println(\"ODGStylesReader </\" + elem.getName() + \">\");}}", "nl": "Reads a & lt ; document - content & gt ; element from the specified XML element"}
{"code": "private void readDefaultStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {     String styleName = elem.getAttribute(\"family\", STYLE_NAMESPACE, null);     String family = elem.getAttribute(\"family\", STYLE_NAMESPACE, null);     String parentStyleName = elem.getAttribute(\"parent-style-name\", STYLE_NAMESPACE, null);     if (DEBUG) {       System.out.println(\"ODGStylesReader <default-style family=\" + styleName + \" ...>...</>\");     }     if (styleName != null) {       Style a = styles.get(styleName);       if (a == null) {         a = new Style();         a.name = styleName;         a.family = family;         a.parentName = parentStyleName;         styles.put(styleName, a);       }       for (IXMLElement child : elem.getChildren()) {         String ns = child.getNamespace();         String name = child.getName();         if (name.equals(\"drawing-page-properties\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {           readDrawingPagePropertiesElement(child, a);         } else if (name.equals(\"graphic-properties\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {           readGraphicPropertiesElement(child, a);         } else if (name.equals(\"paragraph-properties\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {           readParagraphPropertiesElement(child, a);         } else if (name.equals(\"text-properties\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {           readTextPropertiesElement(child, a);         } else {           if (DEBUG) {             System.out.println(\"ODGStylesReader unsupported <\" + elem.getName() + \"> child \" + child);}}}}}", "nl": "Reads a & lt ; default - style & gt ; element from the specified XML element"}
{"code": "private void readStylesChildren(IXMLElement elem,       HashMap<String, Style> styles) throws IOException {     for (IXMLElement child : elem.getChildren()) {       String ns = child.getNamespace();       String name = child.getName();       if (name.equals(\"default-style\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {         readDefaultStyleElement(child, styles);       } else if (name.equals(\"layer-set\") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {         readLayerSetElement(child, styles);       } else if (name.equals(\"list-style\") && (ns == null || ns.equals(TEXT_NAMESPACE))) {         readListStyleElement(child, styles);       } else if (name.equals(\"marker\") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {         readMarkerElement(child, styles);       } else if (name.equals(\"master-page\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {         readMasterPageElement(child, styles);       } else if (name.equals(\"page-layout\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {         readPageLayoutElement(child, styles);                         } else if (name.equals(\"style\") && (ns == null || ns.equals(STYLE_NAMESPACE))) {         readStyleElement(child, styles);                         } else {         if (DEBUG) {           System.out.println(\"ODGStylesReader unsupported <\" + elem.getName() + \"> child: \" + child);}}}}", "nl": "Reads the children of a styles element"}
{"code": "private void readAutomaticStylesElement(IXMLElement elem) throws IOException {     readStylesChildren(elem, automaticStyles);}", "nl": "Reads a & lt ; automatic - styles & gt ; element from the specified XML element"}
{"code": "private void readDocumentStylesElement(IXMLElement elem) throws IOException {     if (DEBUG) {       System.out.println(\"ODGStylesReader <\" + elem.getName() + \" ...>\");     }     for (IXMLElement child : elem.getChildren()) {       String ns = child.getNamespace();       String name = child.getName();       if (name.equals(\"styles\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {         readStylesElement(child);       } else if (name.equals(\"automatic-styles\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {         readAutomaticStylesElement(child);       } else if (name.equals(\"master-styles\") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {         readMasterStylesElement(child);       } else {         if (DEBUG) {           System.out.println(\"ODGStylesReader unsupported <\" + elem.getName() + \"> child \" + child);         }       }     }     if (DEBUG) {       System.out.println(\"ODGStylesReader </\" + elem.getName() + \">\");}}", "nl": "Reads a & lt ; document - styles & gt ; element from the specified XML element"}
{"code": "public int findNext(int startIndex) {     this.startIndex = startIndex;     return findNext();}", "nl": "Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern , starting at the specified index"}
{"code": "public int findNext() {          if (findString.length() == 0 ||     document.getLength() - findString.length() < startIndex) {       return -1;     }          try {       int nextMatch = 0;                      Segment text = new Segment();       text.setPartialReturn(true);       int offset = startIndex;       int nleft = document.getLength() - startIndex;       while (nleft > 0) {         document.getText(offset, nleft, text);                           char next = text.first();         for (text.first(); next != Segment.DONE; next = text.next()) {                                            char current = text.current();           if (current == matchUpperCase[nextMatch] ||           current == matchLowerCase[nextMatch]) {             nextMatch++;                                       if (nextMatch == matchLowerCase.length) {               int foundIndex = text.getIndex() - text.getBeginIndex() + offset -               matchLowerCase.length + 1;               if (matchType == MatchType.CONTAINS) {                 return foundIndex;                                } else if (matchType == MatchType.STARTS_WITH) {                 if (! isWordChar(foundIndex - 1)) {                   return foundIndex;                 }               } else if (matchType == MatchType.FULL_WORD) {                 if (! isWordChar(foundIndex - 1) &&                 ! isWordChar(foundIndex + matchLowerCase.length)) {                   return foundIndex;                 }               }               nextMatch = 0;             }           } else {             nextMatch = 0;           }         }                           nleft -= text.count;         offset += text.count;       }       return -1;     } catch (BadLocationException e) {       throw new IndexOutOfBoundsException();}}", "nl": "Attempts to find the next subsequence of the input sequence that matches the pattern"}
{"code": "public int findPrevious(int startIndex) {     this.startIndex = startIndex;     return findPrevious();}", "nl": "Resets this matcher and then attempts to find the previous subsequence of the input sequence that matches the pattern , starting at the specified index"}
{"code": "public Pageable createPageable() {     return new DrawingPageable(view.getDrawing());}", "nl": "Creates a Pageable object for printing this view"}
{"code": "private void initActions() {     getActionMap().put(UndoAction.ID, undo.getUndoAction());     getActionMap().put(RedoAction.ID, undo.getRedoAction());}", "nl": "Initializes view specific actions"}
{"code": "public int findPrevious() {          if (findString.length() == 0 ||     startIndex < findString.length() - 1) {              return -1;     }          try {       int nextMatch = matchLowerCase.length - 1;                             Segment text = new Segment();       text.setPartialReturn(false);       document.getText(0, startIndex + 1, text);                     char previous = text.last();              for (text.last(); previous != Segment.DONE; previous = text.previous()) {                                    char current = text.current();         if (current == matchUpperCase[nextMatch] ||         current == matchLowerCase[nextMatch]) {           nextMatch--;                                 if (nextMatch == -1) {             int foundIndex = text.getIndex() - text.getBeginIndex();                          if (matchType == MatchType.CONTAINS) {               return foundIndex;             } else if (matchType == MatchType.STARTS_WITH) {               if (! isWordChar(foundIndex - 1)) {                 return foundIndex;               }             } else if (matchType == MatchType.FULL_WORD) {               if (! isWordChar(foundIndex - 1) &&               ! isWordChar(foundIndex + matchLowerCase.length)) {                 return foundIndex;               }             }             nextMatch = matchLowerCase.length - 1;           }         } else {           nextMatch = matchLowerCase.length - 1;         }       }              return -1;     } catch (BadLocationException e) {       throw new IndexOutOfBoundsException();}}", "nl": "Attempts to find the previous subsequence of the input sequence that matches the pattern"}
{"code": "public void setStartIndex(int newValue) {     startIndex = newValue;}", "nl": "Sets the start index for the findNext , findPrevious methods"}
{"code": "protected Drawing createDrawing() {     DefaultDrawing drawing = new DefaultDrawing();     DOMStorableInputOutputFormat ioFormat =         new DOMStorableInputOutputFormat(new PertFactory());     LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();     inputFormats.add(ioFormat);     drawing.setInputFormats(inputFormats);     LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();     outputFormats.add(ioFormat);     outputFormats.add(new ImageOutputFormat());     drawing.setOutputFormats(outputFormats);     return drawing;}", "nl": "Creates a new Drawing for this view"}
{"code": "public double getScaleFactor() {     return scaleFactor;}", "nl": "Returns the scale factor of the number formatter"}
{"code": "public Comparable getMinimum() {     return min;}", "nl": "Returns the minimum permissible value"}
{"code": "public void setMinimum(Comparable minimum) {     if (getValueClass() == null && minimum != null) {       setValueClass(minimum.getClass());     }     min = minimum;}", "nl": "Sets the minimum permissible value"}
{"code": "public void setMaximum(Comparable max) {     if (getValueClass() == null && max != null) {       setValueClass(max.getClass());     }     this.max = max;}", "nl": "Sets the maximum permissible value"}
{"code": "@SuppressWarnings(\"unchecked\")   boolean isValidValue(Object value, boolean wantsCCE) {     Comparable min = getMinimum();     try {       if (min != null && min.compareTo(value) > 0) {         return false;       }     } catch (ClassCastException cce) {       if (wantsCCE) {         throw cce;       }       return false;     }     Comparable max = getMaximum();     try {       if (max != null && max.compareTo(value) < 0) {         return false;       }     } catch (ClassCastException cce) {       if (wantsCCE) {         throw cce;       }       return false;     }     return true;}", "nl": "Returns true if value is between the min max"}
{"code": "public boolean getAllowsNullValue() {     return allowsNullValue;}", "nl": "Returns true if null values are allowed"}
{"code": "public Comparable getMaximum() {     return max;}", "nl": "Returns the maximum permissible value"}
{"code": "public JavaNumberFormatter(double min, double max, double scaleFactor) {     this(min, max, scaleFactor, false, true);}", "nl": "Creates a NumberFormatter with the specified Format instance"}
{"code": "public void setScaleFactor(double newValue) {     scaleFactor = newValue;}", "nl": "Changes the scale factor of the number formatter"}
{"code": "public boolean getAppendsDotZero() {     return appendsDotZero;}", "nl": "Returns true if null values are allowed"}
{"code": "public void setAllowsNullValue(boolean newValue) {     allowsNullValue = newValue;}", "nl": "Allows Disallows null values"}
{"code": "public void write(int c) throws IOException {     switch (c) {       case '\\r':         out.write(lineSeparator);         skipLF = true;         break;       case '\\n':         if (!skipLF) out.write(lineSeparator);         skipLF = false;         break;       default :         out.write(c);         skipLF = false;         break;}}", "nl": "Write a single character"}
{"code": "public void write(char cbuf[], int off, int len) throws IOException {     int end = off + len;     for (int i=off; i < end; i++) {       switch (cbuf[i]) {         case '\\r':           out.write(cbuf, off, i - off);           off = i + 1;           out.write(lineSeparator);           skipLF = true;           break;         case '\\n':           out.write(cbuf, off, i - off);           off = i + 1;           if (skipLF) {             skipLF = false;           } else {             out.write(lineSeparator);           }           break;         default :           skipLF = false;           break;       }     }     if (off < end) out.write(cbuf, off, end - off);}", "nl": "Write a portion of an array of characters"}
{"code": "public static AbstractFormatterFactory createFormatterFactory() {     return createFormatterFactory(false);}", "nl": "Convenience method for creating a formatter factory with a FontFormatter"}
{"code": "public boolean getAllowsUnknownFont() {     return allowsUnknownFont;}", "nl": "Returns true , if unknown font names are allowed"}
{"code": "public void clearGenericFontFamilies() {     genericFontFamilies = null;}", "nl": "Clears the generic font families map"}
{"code": "public boolean getAllowsNullValue() {     return allowsNullValue;}", "nl": "Returns true , if null value is allowed"}
{"code": "public void putGenericFontFamily(String familyName, Font font) {     genericFontFamilies.put(familyName.toLowerCase(), font);}", "nl": "Adds a generic font family"}
{"code": "public void setAllowsNullValue(boolean newValue) {     allowsNullValue = newValue;}", "nl": "Sets whether a null value is allowed"}
{"code": "public void setAllowsUnknownFont(boolean newValue) {     allowsUnknownFont = newValue;}", "nl": "Sets whether unknown font names are allowed"}
{"code": "private Figure readCircleElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readShapeAttributes(elem, a);     double cx = toWidth(elem, readAttribute(elem, \"cx\", \"0\"));     double cy = toHeight(elem, readAttribute(elem, \"cy\", \"0\"));     double r = toWidth(elem, readAttribute(elem, \"r\", \"0\"));     Figure figure = factory.createCircle(cx, cy, r, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG circle element"}
{"code": "private Figure readPathElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readShapeAttributes(elem, a);     BezierPath[] beziers = toPath(elem, readAttribute(elem, \"d\", \"\"));     Figure figure = factory.createPath(beziers, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG path element"}
{"code": "public static String[] toQuotedAndCommaSeparatedArray(String str) throws IOException {     LinkedList<String> values = new LinkedList<String>();     StreamTokenizer tt = new StreamTokenizer(new StringReader(str));     tt.wordChars('a', 'z');     tt.wordChars('A', 'Z');     tt.wordChars(128 + 32, 255);     tt.whitespaceChars(0, ' ');     tt.quoteChar('\"');     tt.quoteChar('\\'');     while (tt.nextToken() != StreamTokenizer.TT_EOF) {       switch (tt.ttype) {         case StreamTokenizer.TT_WORD:         case '\"':         case '\\'':           values.add(tt.sval);           break;       }     }     return values.toArray(new String[values.size()]);}", "nl": "Returns a value as a String array"}
{"code": "private void readTextFlowAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)       throws IOException {     Object value;                                                  value = readInheritAttribute(elem, \"line-increment\", \"auto\");     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented line-increment=\" + value);}}", "nl": "Reads text flow attributes as listed in http : www . w3 . org TR SVGMobile12 feature . html # TextFlow"}
{"code": "private void readOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> a)       throws IOException {                                                                           double value = toDouble(elem, readAttribute(elem, \"opacity\", \"1\"), 1, 0, 1);     OPACITY.put(a, value);}", "nl": "Reads object group opacity as described in http : www . w3 . org TR SVGMobile12 painting . html # groupOpacity"}
{"code": "private double toWidth(IXMLElement elem, String str) throws IOException {          return toLength(elem, str,         viewportStack.peek().widthPercentFactor);}", "nl": "Returns a value as a width"}
{"code": "@SuppressWarnings(\"unchecked\")   private Figure readUseElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     HashMap<AttributeKey, Object> a2 = new HashMap<AttributeKey, Object>();     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a2);     readUseShapeAttributes(elem, a2);     readFontAttributes(elem, a2);     String href = readAttribute(elem, \"xlink:href\", null);     if (href != null && href.startsWith(\"#\")) {       IXMLElement refElem = identifiedElements.get(href.substring(1));       if (refElem == null) {         if (DEBUG) {           System.out.println(\"SVGInputFormat couldn't find href for <use> element:\" + href);         }       } else {         Object obj = readElement(refElem);         if (obj instanceof Figure) {           Figure figure = (Figure) ((Figure) obj).clone();           for (Map.Entry<AttributeKey, Object> entry : a2.entrySet()) {             figure.set(entry.getKey(), entry.getValue());           }           AffineTransform tx =               (TRANSFORM.get(a) == null) ? new AffineTransform() : TRANSFORM.get(a);           double x = toNumber(elem, readAttribute(elem, \"x\", \"0\"));           double y = toNumber(elem, readAttribute(elem, \"y\", \"0\"));           tx.translate(x, y);           figure.transform(tx);           return figure;         }       }     }     return null;}", "nl": "Reads an SVG use element"}
{"code": "private void readViewportAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)       throws IOException {     Object value;     Double doubleValue;          value = readAttribute(elem, \"width\", null);     if (DEBUG) {       System.out.println(\"SVGInputFormat READ viewport w/h factors:\" + viewportStack.peek().widthPercentFactor + \",\" + viewportStack.peek().heightPercentFactor);     }     if (value != null) {       doubleValue = toLength(elem, (String) value, viewportStack.peek().widthPercentFactor);       VIEWPORT_WIDTH.put(a, doubleValue);     }          value = readAttribute(elem, \"height\", null);     if (value != null) {       doubleValue = toLength(elem, (String) value, viewportStack.peek().heightPercentFactor);       VIEWPORT_HEIGHT.put(a, doubleValue);     }                                                  value = toPaint(elem, readInheritColorAttribute(elem, \"viewport-fill\", \"none\"));     if (value == null || (value instanceof Color)) {       VIEWPORT_FILL.put(a, (Color) value);     }                                                  doubleValue = toDouble(elem, readAttribute(elem, \"viewport-fill-opacity\", \"1.0\"));     VIEWPORT_FILL_OPACITY.put(a, doubleValue);}", "nl": "Reads viewport attributes"}
{"code": "private void readTSpanElement(IXMLElement elem, DefaultStyledDocument doc)       throws IOException {     try {       if (elem.getContent() != null) {         doc.insertString(doc.getLength(), toText(elem, elem.getContent()), null);       } else {         for (IXMLElement node : elem.getChildren()) {           if (node instanceof IXMLElement) {             IXMLElement child = (IXMLElement) node;             if (node.getName() != null && node.getName().equals(\"tspan\")) {               readTSpanElement((IXMLElement) node, doc);             } else {               if (DEBUG) {                 System.out.println(\"SVGInputFormat unknown text node \" + node.getName());               }             }           } else {             if (node.getName() == null) {               doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);             }           }         }       }     } catch (BadLocationException e) {       InternalError ex = new InternalError(e.getMessage());       ex.initCause(e);       throw ex;}}", "nl": "Reads an SVG tspan element"}
{"code": "private Figure readEllipseElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readShapeAttributes(elem, a);     double cx = toWidth(elem, readAttribute(elem, \"cx\", \"0\"));     double cy = toHeight(elem, readAttribute(elem, \"cy\", \"0\"));     double rx = toWidth(elem, readAttribute(elem, \"rx\", \"0\"));     double ry = toHeight(elem, readAttribute(elem, \"ry\", \"0\"));     Figure figure = factory.createEllipse(cx, cy, rx, ry, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG ellipse element"}
{"code": "private double readInheritFontSizeAttribute(IXMLElement elem, String attributeName, String defaultValue)       throws IOException {     String value = null;     if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {       value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);     } else if (elem.hasAttribute(attributeName)) {       value = elem.getAttribute(attributeName, null);     } else if (elem.getParent() != null &&         (elem.getParent().getNamespace() == null ||         elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {       return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);     } else {       value = defaultValue;     }     if (value.equals(\"inherit\")) {       return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);     } else if (SVG_ABSOLUTE_FONT_SIZES.containsKey(value)) {       return SVG_ABSOLUTE_FONT_SIZES.get(value);     } else if (SVG_RELATIVE_FONT_SIZES.containsKey(value)) {       return SVG_RELATIVE_FONT_SIZES.get(value) * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);     } else if (value.endsWith(\"%\")) {       double factor = Double.valueOf(value.substring(0, value.length() - 1));       return factor * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);     } else {              return toNumber(elem, value);}}", "nl": "Reads a font size attribute that is inherited"}
{"code": "private Point2D.Double[] toPoints(IXMLElement elem, String str) throws IOException {     StringTokenizer tt = new StringTokenizer(str, \" ,\");     Point2D.Double[] points = new Point2D.Double[tt.countTokens() / 2];     for (int i = 0; i < points.length; i++) {       points[i] = new Point2D.Double(           toNumber(elem, tt.nextToken()),           toNumber(elem, tt.nextToken()));     }     return points;}", "nl": "Returns a value as a Point2D . Double array"}
{"code": "public SVGInputFormat() {     this(new DefaultSVGFigureFactory());}", "nl": "Creates a new instance"}
{"code": "private String readInheritAttribute(IXMLElement elem, String attributeName, String defaultValue) {     if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {       String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);       if (value.equals(\"inherit\")) {         return readInheritAttribute(elem.getParent(), attributeName, defaultValue);       } else {         return value;       }     } else if (elem.hasAttribute(attributeName)) {       String value = elem.getAttribute(attributeName);       if (value.equals(\"inherit\")) {         return readInheritAttribute(elem.getParent(), attributeName, defaultValue);       } else {         return value;       }     } else if (elem.getParent() != null &&         (elem.getParent().getNamespace() == null ||         elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {       return readInheritAttribute(elem.getParent(), attributeName, defaultValue);     } else {       return defaultValue;}}", "nl": "Reads an attribute that is inherited"}
{"code": "private double toNumber(IXMLElement elem, String str) throws IOException {     return toLength(elem, str, viewportStack.peek().numberFactor);}", "nl": "Returns a value as a number"}
{"code": "private void readTextAttributes(IXMLElement elem, Map<AttributeKey, Object> a)       throws IOException {     Object value;                                                  value = readInheritAttribute(elem, \"text-anchor\", \"start\");     if (SVG_TEXT_ANCHORS.get(value) != null) {       TEXT_ANCHOR.put(a, SVG_TEXT_ANCHORS.get(value));     }                                                  value = readInheritAttribute(elem, \"display-align\", \"auto\");          if (!value.equals(\"auto\")) {       if (value.equals(\"center\")) {         TEXT_ANCHOR.put(a, TextAnchor.MIDDLE);       } else if (value.equals(\"before\")) {         TEXT_ANCHOR.put(a, TextAnchor.END);       }     }                                             value = readInheritAttribute(elem, \"text-align\", \"start\");          if (!value.equals(\"start\")) {       TEXT_ALIGN.put(a, SVG_TEXT_ALIGNS.get(value));}}", "nl": "Reads text attributes as listed in http : www . w3 . org TR SVGMobile12 feature . html # Text"}
{"code": "private String toText(IXMLElement elem, String value) throws IOException {     String space = readInheritAttribute(elem, \"xml:space\", \"default\");     if (space.equals(\"default\")) {       return value.trim().replaceAll(\"\\\\s++\", \" \");     } else  {       return value;}}", "nl": "Reads a text attribute"}
{"code": "private void readUseShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)       throws IOException {     Object objectValue;     String value;     double doubleValue;                                                                                                                                                                          objectValue = readInheritColorAttribute(elem, \"fill\", null);     if (objectValue != null) {       objectValue = toPaint(elem, (String) objectValue);       if (objectValue instanceof Color) {         FILL_COLOR.put(a, (Color) objectValue);       } else if (objectValue instanceof Gradient) {         FILL_GRADIENT.put(a, (Gradient) objectValue);       } else if (objectValue == null) {         FILL_COLOR.put(a, null);       } else {         FILL_COLOR.put(a, null);         if (DEBUG) {           System.out.println(\"SVGInputFormat not implemented  fill=\" + objectValue);         }       }     }                                                  objectValue = readInheritAttribute(elem, \"fill-opacity\", null);     if (objectValue != null) {       FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));     }                                                  value = readInheritAttribute(elem, \"fill-rule\", null);     if (value != null) {       WINDING_RULE.put(a, SVG_FILL_RULES.get(value));     }                                                       objectValue = toPaint(elem, readInheritColorAttribute(elem, \"stroke\", null));     if (objectValue != null) {       if (objectValue instanceof Color) {         STROKE_COLOR.put(a, (Color) objectValue);       } else if (objectValue instanceof Gradient) {         STROKE_GRADIENT.put(a, (Gradient) objectValue);       }     }                                                  value = readInheritAttribute(elem, \"stroke-dasharray\", null);     if (value != null && !value.equals(\"none\")) {       String[] values = toCommaSeparatedArray(value);       double[] dashes = new double[values.length];       for (int i = 0; i < values.length; i++) {         dashes[i] = toNumber(elem, values[i]);       }       STROKE_DASHES.put(a, dashes);     }                                                  objectValue = readInheritAttribute(elem, \"stroke-dashoffset\", null);     if (objectValue != null) {       doubleValue = toNumber(elem, (String) objectValue);       STROKE_DASH_PHASE.put(a, doubleValue);       IS_STROKE_DASH_FACTOR.put(a, false);     }                                                  value = readInheritAttribute(elem, \"stroke-linecap\", null);     if (value != null) {       STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));     }                                                  value = readInheritAttribute(elem, \"stroke-linejoin\", null);     if (value != null) {       STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));     }                                                  objectValue = readInheritAttribute(elem, \"stroke-miterlimit\", null);     if (objectValue != null) {       doubleValue = toDouble(elem, (String) objectValue, 4d, 1d, Double.MAX_VALUE);       STROKE_MITER_LIMIT.put(a, doubleValue);       IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);     }                                                  objectValue = readInheritAttribute(elem, \"stroke-opacity\", null);     if (objectValue != null) {       STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));     }                                                  objectValue = readInheritAttribute(elem, \"stroke-width\", null);     if (objectValue != null) {       doubleValue = toNumber(elem, (String) objectValue);       STROKE_WIDTH.put(a, doubleValue);}}", "nl": "Reads shape attributes for the SVG use element"}
{"code": "private double toHeight(IXMLElement elem, String str) throws IOException {          return toLength(elem, str,         viewportStack.peek().heightPercentFactor);}", "nl": "Returns a value as a height"}
{"code": "private void flattenStyles(IXMLElement elem)       throws IOException {     if (elem.getName() != null && elem.getName().equals(\"style\") &&         readAttribute(elem, \"type\", \"\").equals(\"text/css\") &&         elem.getContent() != null) {       CSSParser cssParser = new CSSParser();       cssParser.parse(elem.getContent(), styleManager);     } else {       if (elem.getNamespace() == null ||           elem.getNamespace().equals(SVG_NAMESPACE)) {         String style = readAttribute(elem, \"style\", null);         if (style != null) {           for (String styleProperty : style.split(\";\")) {             String[] stylePropertyElements = styleProperty.split(\":\");             if (stylePropertyElements.length == 2 &&                 !elem.hasAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE)) {                              elem.setAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE, stylePropertyElements[1].trim());             }           }         }         styleManager.applyStylesTo(elem);         for (IXMLElement node : elem.getChildren()) {           if (node instanceof IXMLElement) {             IXMLElement child = (IXMLElement) node;             flattenStyles(child);}}}}}", "nl": "Flattens all CSS styles"}
{"code": "public static AffineTransform toTransform(IXMLElement elem, String str) throws IOException {     AffineTransform t = new AffineTransform();     if (str != null && !str.equals(\"none\")) {       StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));       tt.resetSyntax();       tt.wordChars('a', 'z');       tt.wordChars('A', 'Z');       tt.wordChars(128 + 32, 255);       tt.whitespaceChars(0, ' ');       tt.whitespaceChars(',', ',');       tt.parseNumbers();       tt.parseExponents();       while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {         if (tt.ttype != StreamPosTokenizer.TT_WORD) {           throw new IOException(\"Illegal transform \" + str);         }         String type = tt.sval;         if (tt.nextToken() != '(') {           throw new IOException(\"'(' not found in transform \" + str);         }         if (type.equals(\"matrix\")) {           double[] m = new double[6];           for (int i = 0; i < 6; i++) {             if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {               throw new IOException(\"Matrix value \" + i + \" not found in transform \" + str + \" token:\" + tt.ttype + \" \" + tt.sval);             }             m[i] = tt.nval;           }           t.concatenate(new AffineTransform(m));         } else if (type.equals(\"translate\")) {           double tx, ty;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"X-translation value not found in transform \" + str);           }           tx = tt.nval;           if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {             ty = tt.nval;           } else {             tt.pushBack();             ty = 0;           }           t.translate(tx, ty);         } else if (type.equals(\"scale\")) {           double sx, sy;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"X-scale value not found in transform \" + str);           }           sx = tt.nval;           if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {             sy = tt.nval;           } else {             tt.pushBack();             sy = sx;           }           t.scale(sx, sy);         } else if (type.equals(\"rotate\")) {           double angle, cx, cy;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"Angle value not found in transform \" + str);           }           angle = tt.nval;           if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {             cx = tt.nval;             if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {               throw new IOException(\"Y-center value not found in transform \" + str);             }             cy = tt.nval;           } else {             tt.pushBack();             cx = cy = 0;           }           t.rotate(angle * Math.PI / 180d, cx, cy);          } else if (type.equals(\"skewX\")) {           double angle;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"Skew angle not found in transform \" + str);           }           angle = tt.nval;           t.concatenate(new AffineTransform(               1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));         } else if (type.equals(\"skewY\")) {           double angle;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"Skew angle not found in transform \" + str);           }           angle = tt.nval;           t.concatenate(new AffineTransform(               1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));         } else if (type.equals(\"ref\")) {           System.err.println(\"SVGInputFormat warning: ignored ref(...) transform attribute in element \" + elem);           while (tt.nextToken() != ')' && tt.ttype != StreamPosTokenizer.TT_EOF) {                        }           tt.pushBack();         } else {           throw new IOException(\"Unknown transform \" + type + \" in \" + str + \" in element \" + elem);         }         if (tt.nextToken() != ')') {           throw new IOException(\"')' not found in transform \" + str);         }       }     }     return t;}", "nl": "Converts an SVG transform attribute value into an AffineTransform as specified in http : www . w3 . org TR SVGMobile12 coords . html # TransformAttribute"}
{"code": "private String readInheritColorAttribute(IXMLElement elem, String attributeName, String defaultValue) {     String value = null;     if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {       value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);       if (value.equals(\"inherit\")) {         return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);       }     } else if (elem.hasAttribute(attributeName)) {       value = elem.getAttribute(attributeName);       if (value.equals(\"inherit\")) {         return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);       }     } else if (elem.getParent() != null &&         (elem.getParent().getNamespace() == null ||         elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {       value = readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);     } else {       value = defaultValue;     }     if (value != null && value.toLowerCase().equals(\"currentcolor\") && !attributeName.equals(\"color\")) {              value = readInheritColorAttribute(elem, \"color\", \"defaultValue\");     }     return value;}", "nl": "Reads a color attribute that is inherited"}
{"code": "private Figure readPolygonElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readShapeAttributes(elem, a);     Point2D.Double[] points = toPoints(elem, readAttribute(elem, \"points\", \"\"));     Figure figure = factory.createPolygon(points, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG polygon element"}
{"code": "private Figure readRectElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readShapeAttributes(elem, a);     double x = toNumber(elem, readAttribute(elem, \"x\", \"0\"));     double y = toNumber(elem, readAttribute(elem, \"y\", \"0\"));     double w = toWidth(elem, readAttribute(elem, \"width\", \"0\"));     double h = toHeight(elem, readAttribute(elem, \"height\", \"0\"));     String rxValue = readAttribute(elem, \"rx\", \"none\");     String ryValue = readAttribute(elem, \"ry\", \"none\");     if (rxValue.equals(\"none\")) {       rxValue = ryValue;     }     if (ryValue.equals(\"none\")) {       ryValue = rxValue;     }     double rx = toNumber(elem, rxValue.equals(\"none\") ? \"0\" : rxValue);     double ry = toNumber(elem, ryValue.equals(\"none\") ? \"0\" : ryValue);     Figure figure = factory.createRect(x, y, w, h, rx, ry, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG rect element"}
{"code": "private Color toColor(IXMLElement elem, String value) throws IOException {     String str = value;     if (str == null) {       return null;     }     str = str.trim().toLowerCase();     if (str.equals(\"currentcolor\")) {       String currentColor = readInheritAttribute(elem, \"color\", \"black\");       if (currentColor == null || currentColor.trim().toLowerCase().equals(\"currentColor\")) {         return null;       } else {         return toColor(elem, currentColor);       }     } else if (SVG_COLORS.containsKey(str)) {       return SVG_COLORS.get(str);     } else if (str.startsWith(\"#\") && str.length() == 7) {       return new Color(Integer.decode(str));     } else if (str.startsWith(\"#\") && str.length() == 4) {              int th = Integer.decode(str);       return new Color(           (th & 0xf) | ((th & 0xf) << 4) |           ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |           ((th & 0xf00) << 8) | ((th & 0xf00) << 12));     } else if (str.startsWith(\"rgb\")) {       try {         StringTokenizer tt = new StringTokenizer(str, \"() ,\");         tt.nextToken();         String r = tt.nextToken();         String g = tt.nextToken();         String b = tt.nextToken();         Color c = new Color(             r.endsWith(\"%\") ? (int) (Integer.decode(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),             g.endsWith(\"%\") ? (int) (Integer.decode(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),             b.endsWith(\"%\") ? (int) (Integer.decode(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));         return c;       } catch (Exception e) {         if (DEBUG) {           System.out.println(\"SVGInputFormat.toColor illegal RGB value \" + str);         }         return null;       }     } else if (str.startsWith(\"url\")) {              if (DEBUG) {         System.out.println(\"SVGInputFormat.toColor not implemented for \" + str);       }       return null;     } else {       return null;}}", "nl": "Reads a color style attribute"}
{"code": "private void readSolidColorElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);                                                  Color color = toColor(elem, readAttribute(elem, \"solid-color\", \"black\"));                                                  double opacity = toDouble(elem, readAttribute(elem, \"solid-opacity\", \"1\"), 1, 0, 1);     if (opacity != 1) {       color = new Color(((int) (255 * opacity) << 24) | (0xffffff & color.getRGB()), true);     }     elementObjects.put(elem, color);}", "nl": "Reads solid color attributes"}
{"code": "private Figure readGElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readOpacityAttribute(elem, a);     CompositeFigure g = factory.createG(a);     for (IXMLElement node : elem.getChildren()) {       if (node instanceof IXMLElement) {         IXMLElement child = (IXMLElement) node;         Figure childFigure = readElement(child);                  if (readAttribute(child, \"visibility\", \"visible\").equals(\"visible\") &&             !readAttribute(child, \"display\", \"inline\").equals(\"none\")) {           if (childFigure != null) {             g.basicAdd(childFigure);           }         }       }     }     readTransformAttribute(elem, a);     if (TRANSFORM.get(a) != null) {       g.transform(TRANSFORM.get(a));     }     return g;}", "nl": "Reads an SVG g element"}
{"code": "private void readShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)       throws IOException {     Object objectValue;     String value;     double doubleValue;                                                                                                                                                                          objectValue = toPaint(elem, readInheritColorAttribute(elem, \"fill\", \"black\"));     if (objectValue instanceof Color) {       FILL_COLOR.put(a, (Color) objectValue);     } else if (objectValue instanceof Gradient) {       FILL_GRADIENT.putClone(a, (Gradient) objectValue);     } else if (objectValue == null) {       FILL_COLOR.put(a, null);     } else {       FILL_COLOR.put(a, null);       if (DEBUG) {         System.out.println(\"SVGInputFormat not implemented  fill=\" + objectValue);       }     }                                                  objectValue = readInheritAttribute(elem, \"fill-opacity\", \"1\");     FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));                                                  value = readInheritAttribute(elem, \"fill-rule\", \"nonzero\");     WINDING_RULE.put(a, SVG_FILL_RULES.get(value));                                                       objectValue = toPaint(elem, readInheritColorAttribute(elem, \"stroke\", \"none\"));     if (objectValue instanceof Color) {       STROKE_COLOR.put(a, (Color) objectValue);     } else if (objectValue instanceof Gradient) {       STROKE_GRADIENT.putClone(a, (Gradient) objectValue);     } else if (objectValue == null) {       STROKE_COLOR.put(a, null);     } else {       STROKE_COLOR.put(a, null);       if (DEBUG) {         System.out.println(\"SVGInputFormat not implemented  stroke=\" + objectValue);       }     }                                                  value = readInheritAttribute(elem, \"stroke-dasharray\", \"none\");     if (!value.equals(\"none\")) {       String[] values = toWSOrCommaSeparatedArray(value);       double[] dashes = new double[values.length];       for (int i = 0; i < values.length; i++) {         dashes[i] = toNumber(elem, values[i]);       }       STROKE_DASHES.put(a, dashes);     }                                                  doubleValue = toNumber(elem, readInheritAttribute(elem, \"stroke-dashoffset\", \"0\"));     STROKE_DASH_PHASE.put(a, doubleValue);     IS_STROKE_DASH_FACTOR.put(a, false);                                                  value = readInheritAttribute(elem, \"stroke-linecap\", \"butt\");     STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));                                                   value = readInheritAttribute(elem, \"stroke-linejoin\", \"miter\");     STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));                                                  doubleValue = toDouble(elem, readInheritAttribute(elem, \"stroke-miterlimit\", \"4\"), 4d, 1d, Double.MAX_VALUE);     STROKE_MITER_LIMIT.put(a, doubleValue);     IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);                                                  objectValue = readInheritAttribute(elem, \"stroke-opacity\", \"1\");     STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));                                                  doubleValue = toNumber(elem, readInheritAttribute(elem, \"stroke-width\", \"1\"));     STROKE_WIDTH.put(a, doubleValue);}", "nl": "Reads shape attributes"}
{"code": "private void readLinearGradientElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     double x1 = toLength(elem, readAttribute(elem, \"x1\", \"0\"), 0.01);     double y1 = toLength(elem, readAttribute(elem, \"y1\", \"0\"), 0.01);     double x2 = toLength(elem, readAttribute(elem, \"x2\", \"1\"), 0.01);     double y2 = toLength(elem, readAttribute(elem, \"y2\", \"0\"), 0.01);     boolean isRelativeToFigureBounds = readAttribute(elem, \"gradientUnits\", \"objectBoundingBox\").equals(\"objectBoundingBox\");     ArrayList<IXMLElement> stops = elem.getChildrenNamed(\"stop\", SVG_NAMESPACE);     if (stops.size() == 0) {       stops = elem.getChildrenNamed(\"stop\");     }     if (stops.size() == 0) {              String xlink = readAttribute(elem, \"xlink:href\", \"\");       if (xlink.startsWith(\"#\") &&           identifiedElements.get(xlink.substring(1)) != null) {         stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(\"stop\", SVG_NAMESPACE);         if (stops.size() == 0) {           stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(\"stop\");         }       }     }     if (stops.size() == 0) {       if (DEBUG) {         System.out.println(\"SVGInpuFormat: Warning no stops in linearGradient \" + elem);       }     }     double[] stopOffsets = new double[stops.size()];     Color[] stopColors = new Color[stops.size()];     double[] stopOpacities = new double[stops.size()];     for (int i = 0; i < stops.size(); i++) {       IXMLElement stopElem = stops.get(i);       String offsetStr = readAttribute(stopElem, \"offset\", \"0\");       if (offsetStr.endsWith(\"%\")) {         stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;       } else {         stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);       }                                                                      stopColors[i] = toColor(stopElem, readAttribute(stopElem, \"stop-color\", \"black\"));       if (stopColors[i] == null) {         stopColors[i] = new Color(0x0, true);                }                                                                      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, \"stop-opacity\", \"1\"), 1, 0, 1);     }     AffineTransform tx = toTransform(elem, readAttribute(elem, \"gradientTransform\", \"none\"));     Gradient gradient = factory.createLinearGradient(         x1, y1, x2, y2,         stopOffsets, stopColors, stopOpacities,         isRelativeToFigureBounds, tx);     elementObjects.put(elem, gradient);}", "nl": "Reads an SVG linearGradient element"}
{"code": "private double toDouble(IXMLElement elem, String value) throws IOException {     return toDouble(elem, value, 0, Double.MIN_VALUE, Double.MAX_VALUE);}", "nl": "Reads a double attribute"}
{"code": "private Figure readElement(IXMLElement elem)       throws IOException {     if (DEBUG) {       System.out.println(\"SVGInputFormat.readElement \" + elem.getName() + \" line:\" + elem.getLineNr());     }     Figure f = null;     if (elem.getNamespace() == null ||         elem.getNamespace().equals(SVG_NAMESPACE)) {       String name = elem.getName();       if (name == null) {         if (DEBUG) {           System.err.println(\"SVGInputFormat warning: skipping nameless element at line \" + elem.getLineNr());         }       } else if (name.equals(\"a\")) {         f = readAElement(elem);       } else if (name.equals(\"circle\")) {         f = readCircleElement(elem);       } else if (name.equals(\"defs\")) {         readDefsElement(elem);         f = null;       } else if (name.equals(\"ellipse\")) {         f = readEllipseElement(elem);       } else if (name.equals(\"g\")) {         f = readGElement(elem);       } else if (name.equals(\"image\")) {         f = readImageElement(elem);       } else if (name.equals(\"line\")) {         f = readLineElement(elem);       } else if (name.equals(\"linearGradient\")) {         readLinearGradientElement(elem);         f = null;       } else if (name.equals(\"path\")) {         f = readPathElement(elem);       } else if (name.equals(\"polygon\")) {         f = readPolygonElement(elem);       } else if (name.equals(\"polyline\")) {         f = readPolylineElement(elem);       } else if (name.equals(\"radialGradient\")) {         readRadialGradientElement(elem);         f = null;       } else if (name.equals(\"rect\")) {         f = readRectElement(elem);       } else if (name.equals(\"solidColor\")) {         readSolidColorElement(elem);         f = null;       } else if (name.equals(\"svg\")) {         f = readSVGElement(elem);                } else if (name.equals(\"switch\")) {         f = readSwitchElement(elem);       } else if (name.equals(\"text\")) {         f = readTextElement(elem);       } else if (name.equals(\"textArea\")) {         f = readTextAreaElement(elem);       } else if (name.equals(\"title\")) {                         } else if (name.equals(\"use\")) {         f = readUseElement(elem);       } else if (name.equals(\"style\")) {                         } else {         if (DEBUG) {           System.out.println(\"SVGInputFormat not implemented for <\" + name + \">\");         }       }     }     if (f instanceof SVGFigure) {       if (((SVGFigure) f).isEmpty()) {                  return null;       }     } else if (f != null) {       if (DEBUG) {         System.out.println(\"SVGInputFormat warning: not an SVGFigure \" + f);       }     }     return f;}", "nl": "Reads an SVG element of any kind"}
{"code": "private Object toPaint(IXMLElement elem, String value) throws IOException {     String str = value;     if (str == null) {       return null;     }     str = str.trim().toLowerCase();     if (str.equals(\"none\")) {       return null;     } else if (str.equals(\"currentcolor\")) {       String currentColor = readInheritAttribute(elem, \"color\", \"black\");       if (currentColor == null || currentColor.trim().toLowerCase().equals(\"currentColor\")) {         return null;       } else {         return toPaint(elem, currentColor);       }     } else if (SVG_COLORS.containsKey(str)) {       return SVG_COLORS.get(str);     } else if (str.startsWith(\"#\") && str.length() == 7) {       return new Color(Integer.decode(str));     } else if (str.startsWith(\"#\") && str.length() == 4) {              int th = Integer.decode(str);       return new Color(           (th & 0xf) | ((th & 0xf) << 4) |           ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |           ((th & 0xf00) << 8) | ((th & 0xf00) << 12));     } else if (str.startsWith(\"rgb\")) {       try {         StringTokenizer tt = new StringTokenizer(str, \"() ,\");         tt.nextToken();         String r = tt.nextToken();         String g = tt.nextToken();         String b = tt.nextToken();         Color c = new Color(             r.endsWith(\"%\") ? (int) (Double.parseDouble(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),             g.endsWith(\"%\") ? (int) (Double.parseDouble(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),             b.endsWith(\"%\") ? (int) (Double.parseDouble(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));         return c;       } catch (Exception e) {          System.out.println(\"SVGInputFormat.toPaint illegal RGB value \" + str);         e.printStackTrace();         return null;       }     } else if (str.startsWith(\"url\")) {       String href = value.substring(4, value.length() - 1);       if (identifiedElements.containsKey(href.substring(1)) &&           elementObjects.containsKey(identifiedElements.get(href.substring(1)))) {         Object obj = elementObjects.get(identifiedElements.get(href.substring(1)));         return obj;       }              if (DEBUG) {         System.out.println(\"SVGInputFormat.toPaint not implemented for \" + href);       }       return null;     } else {       return null;}}", "nl": "Reads a paint style attribute"}
{"code": "private Figure readLineElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readLineAttributes(elem, a);                    if (FILL_COLOR.get(a) != null && STROKE_COLOR.get(a) == null) {       STROKE_COLOR.put(a, FILL_COLOR.get(a));     }     if (FILL_GRADIENT.get(a) != null && STROKE_GRADIENT.get(a) == null) {       STROKE_GRADIENT.put(a, FILL_GRADIENT.get(a));     }     FILL_COLOR.put(a, null);     FILL_GRADIENT.put(a, null);     double x1 = toNumber(elem, readAttribute(elem, \"x1\", \"0\"));     double y1 = toNumber(elem, readAttribute(elem, \"y1\", \"0\"));     double x2 = toNumber(elem, readAttribute(elem, \"x2\", \"0\"));     double y2 = toNumber(elem, readAttribute(elem, \"y2\", \"0\"));     Figure figure = factory.createLine(x1, y1, x2, y2, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG line element"}
{"code": "private Figure readTextElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readShapeAttributes(elem, a);     readFontAttributes(elem, a);     readTextAttributes(elem, a);     String[] xStr = toCommaSeparatedArray(readAttribute(elem, \"x\", \"0\"));     String[] yStr = toCommaSeparatedArray(readAttribute(elem, \"y\", \"0\"));     Point2D.Double[] coordinates = new Point2D.Double[Math.max(xStr.length, yStr.length)];     double lastX = 0;     double lastY = 0;     for (int i = 0; i < coordinates.length; i++) {       if (xStr.length > i) {         try {           lastX = toNumber(elem, xStr[i]);         } catch (NumberFormatException ex) {         }       }       if (yStr.length > i) {         try {           lastY = toNumber(elem, yStr[i]);         } catch (NumberFormatException ex) {         }       }       coordinates[i] = new Point2D.Double(lastX, lastY);     }      String[] rotateStr = toCommaSeparatedArray(readAttribute(elem, \"rotate\", \"\"));     double[] rotate = new double[rotateStr.length];     for (int i = 0; i < rotateStr.length; i++) {       try {         rotate[i] = toDouble(elem, rotateStr[i]);       } catch (NumberFormatException ex) {         rotate[i] = 0;       }     }     DefaultStyledDocument doc = new DefaultStyledDocument();     try {       if (elem.getContent() != null) {         doc.insertString(0, toText(elem, elem.getContent()), null);       } else {         for (IXMLElement node : elem.getChildren()) {           if (node.getName() == null) {             doc.insertString(0, toText(elem, node.getContent()), null);           } else if (node.getName().equals(\"tspan\")) {             readTSpanElement((IXMLElement) node, doc);           } else {             if (DEBUG) {               System.out.println(\"SVGInputFormat unsupported text node <\" + node.getName() + \">\");             }           }         }       }     } catch (BadLocationException e) {       InternalError ex = new InternalError(e.getMessage());       ex.initCause(e);       throw ex;     }     Figure figure = factory.createText(coordinates, rotate, doc, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG text element"}
{"code": "private void readGraphicsAttributes(IXMLElement elem, Figure f)       throws IOException {     Object value;                                                                                value = readAttribute(elem, \"display\", \"inline\");     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented display=\" + value);     }                                                   value = readInheritAttribute(elem, \"image-rendering\", \"auto\");     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented image-rendering=\" + value);     }                                                       value = readInheritAttribute(elem, \"pointer-events\", \"visiblePainted\");     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented pointer-events=\" + value);     }                                                       value = readInheritAttribute(elem, \"shape-rendering\", \"auto\");     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented shape-rendering=\" + value);     }                                                       value = readInheritAttribute(elem, \"text-rendering\", \"auto\");     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented text-rendering=\" + value);     }                                                  value = readAttribute(elem, \"vector-effect\", \"none\");     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented vector-effect=\" + value);     }                                                       value = readInheritAttribute(elem, \"visibility\", null);     if (DEBUG) {       System.out.println(\"SVGInputFormat not implemented visibility=\" + value);}}", "nl": "Reads graphics attributes as listed in http : www . w3 . org TR SVGMobile12 feature . html # GraphicsAttribute"}
{"code": "private Figure readImageElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     double x = toNumber(elem, readAttribute(elem, \"x\", \"0\"));     double y = toNumber(elem, readAttribute(elem, \"y\", \"0\"));     double w = toWidth(elem, readAttribute(elem, \"width\", \"0\"));     double h = toHeight(elem, readAttribute(elem, \"height\", \"0\"));     String href = readAttribute(elem, \"xlink:href\", null);     if (href == null) {       href = readAttribute(elem, \"href\", null);     }     byte[] imageData = null;     if (href != null) {       if (href.startsWith(\"data:\")) {         int semicolonPos = href.indexOf(';');         if (semicolonPos != -1) {           if (href.indexOf(\";base64,\") == semicolonPos) {             imageData = Base64.decode(href.substring(semicolonPos + 8));           } else {             throw new IOException(\"Unsupported encoding in data href in image element:\" + href);           }         } else {           throw new IOException(\"Unsupported data href in image element:\" + href);         }       } else {         URL imageUrl = new URL(url, href);                           if (imageUrl.getFile().endsWith(\"svg\")) {           SVGInputFormat svgImage = new SVGInputFormat(factory);           Drawing svgDrawing = new DefaultDrawing();           svgImage.read(imageUrl, svgDrawing, true);           CompositeFigure svgImageGroup = factory.createG(a);           for (Figure f : svgDrawing.getChildren()) {             svgImageGroup.add(f);           }           svgImageGroup.setBounds(new Point2D.Double(x, y), new Point2D.Double(x + w, y + h));           return svgImageGroup;         }                  ByteArrayOutputStream bout = new ByteArrayOutputStream();         byte[] buf = new byte[512];         int len = 0;         try {           InputStream in = imageUrl.openStream();           try {             while ((len = in.read(buf)) > 0) {               bout.write(buf, 0, len);             }             imageData = bout.toByteArray();           } finally {             in.close();           }         } catch (FileNotFoundException e) {                    }       }     }          BufferedImage bufferedImage = null;     if (imageData != null) {       try {         bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));       } catch (IIOException e) {         System.err.println(\"SVGInputFormat warning: skipped unsupported image format.\");         e.printStackTrace();       }     }          if (bufferedImage == null) {       imageData = null;            }          Figure figure = factory.createImage(x, y, w, h, imageData, bufferedImage, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG image element"}
{"code": "public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {     document = new XMLElement(\"svg\", SVG_NAMESPACE);     document.setAttribute(\"version\", \"1.2\");     document.setAttribute(\"baseProfile\", \"tiny\");     writeViewportAttributes(document, drawing.getAttributes());     initStorageContext(document);     defs = new XMLElement(\"defs\");     document.addChild(defs);     for (Figure f : figures) {       writeElement(document, f);     }          PrintWriter writer = new PrintWriter(         new OutputStreamWriter(out, \"UTF-8\"));     writer.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");          XMLWriter xmlWriter = new XMLWriter(writer);     xmlWriter.write(document, isPrettyPrint);          writer.flush();     document.dispose();}", "nl": "All other write methods delegate their work to here"}
{"code": "public static String toNumber(double number) {     String str = (isFloatPrecision) ? Float.toString((float) number) : Double.toString(number);     if (str.endsWith(\".0\")) {       str = str.substring(0, str.length() - 2);     }     return str;}", "nl": "Returns a double array as a number attribute value"}
{"code": "protected void writeTransformAttribute(IXMLElement elem, Map<AttributeKey, Object> a)       throws IOException {     AffineTransform t = TRANSFORM.get(a);     if (t != null) {       writeAttribute(elem, \"transform\", toTransform(t), \"none\");}}", "nl": "Writes the transform attribute as specified in http : www . w3 . org TR SVGMobile12 coords . html # TransformAttribute"}
{"code": "private void writeFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a)       throws IOException {     String value;     double doubleValue;                                                            writeAttribute(elem, \"font-family\", FONT_FACE.get(a).getFontName(), \"Dialog\");                                                       writeAttribute(elem, \"font-size\", FONT_SIZE.get(a), 0d);                                                  writeAttribute(elem, \"font-style\", (FONT_ITALIC.get(a)) ? \"italic\" : \"normal\", \"normal\");                                                        writeAttribute(elem, \"font-variant\", \"normal\", \"normal\");                                                                 writeAttribute(elem, \"font-weight\", (FONT_BOLD.get(a)) ? \"bold\" : \"normal\", \"normal\");                                                  writeAttribute(elem, \"text-decoration\", (FONT_UNDERLINE.get(a)) ? \"underline\" : \"none\", \"none\");}", "nl": "Writes font attributes as listed in http : www . w3 . org TR SVGMobile12 feature . html # Font"}
{"code": "protected void writeOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> m)       throws IOException {                                                                           writeAttribute(elem, \"opacity\", OPACITY.get(m), 1d);}", "nl": "Writes the opacity attribute"}
{"code": "protected void writeShapeAttributes(IXMLElement elem, Map<AttributeKey, Object> m)       throws IOException {     Color color;     String value;     int intValue;                                                                                                                                                                Gradient gradient = FILL_GRADIENT.get(m);     if (gradient != null) {       String id;       if (gradientToIDMap.containsKey(gradient)) {         id = gradientToIDMap.get(gradient);       } else {         IXMLElement gradientElem;         if (gradient instanceof LinearGradient) {           LinearGradient lg = (LinearGradient) gradient;           gradientElem = createLinearGradient(document,               lg.getX1(), lg.getY1(),               lg.getX2(), lg.getY2(),               lg.getStopOffsets(),               lg.getStopColors(),               lg.getStopOpacities(),               lg.isRelativeToFigureBounds(),               lg.getTransform());         } else  {           RadialGradient rg = (RadialGradient) gradient;           gradientElem = createRadialGradient(document,               rg.getCX(), rg.getCY(),               rg.getFX(), rg.getFY(),               rg.getR(),               rg.getStopOffsets(),               rg.getStopColors(),               rg.getStopOpacities(),               rg.isRelativeToFigureBounds(),               rg.getTransform());         }         id = getId(gradientElem);         gradientElem.setAttribute(\"id\", \"xml\", id);         defs.addChild(gradientElem);         gradientToIDMap.put(gradient, id);       }       writeAttribute(elem, \"fill\", \"url(#\" + id + \")\", \"#000\");     } else {       writeAttribute(elem, \"fill\", toColor(FILL_COLOR.get(m)), \"#000\");     }                                                   writeAttribute(elem, \"fill-opacity\", FILL_OPACITY.get(m), 1d);                                                  if (WINDING_RULE.get(m) != WindingRule.NON_ZERO) {       writeAttribute(elem, \"fill-rule\", \"evenodd\", \"nonzero\");     }                                                       gradient = STROKE_GRADIENT.get(m);     if (gradient != null) {       String id;       if (gradientToIDMap.containsKey(gradient)) {         id = gradientToIDMap.get(gradient);       } else {         IXMLElement gradientElem;         if (gradient instanceof LinearGradient) {           LinearGradient lg = (LinearGradient) gradient;           gradientElem = createLinearGradient(document,               lg.getX1(), lg.getY1(),               lg.getX2(), lg.getY2(),               lg.getStopOffsets(),               lg.getStopColors(),               lg.getStopOpacities(),               lg.isRelativeToFigureBounds(),               lg.getTransform());         } else  {           RadialGradient rg = (RadialGradient) gradient;           gradientElem = createRadialGradient(document,               rg.getCX(), rg.getCY(),               rg.getFX(), rg.getFY(),               rg.getR(),               rg.getStopOffsets(),               rg.getStopColors(),               rg.getStopOpacities(),               rg.isRelativeToFigureBounds(),               rg.getTransform());         }         id = getId(gradientElem);         gradientElem.setAttribute(\"id\", \"xml\", id);         defs.addChild(gradientElem);         gradientToIDMap.put(gradient, id);       }       writeAttribute(elem, \"stroke\", \"url(#\" + id + \")\", \"none\");     } else {       writeAttribute(elem, \"stroke\", toColor(STROKE_COLOR.get(m)), \"none\");     }                                                  double[] dashes = STROKE_DASHES.get(m);     if (dashes != null) {       StringBuilder buf = new StringBuilder();       for (int i = 0; i < dashes.length; i++) {         if (i != 0) {           buf.append(',');         }         buf.append(toNumber(dashes[i]));       }       writeAttribute(elem, \"stroke-dasharray\", buf.toString(), null);     }                                                  writeAttribute(elem, \"stroke-dashoffset\", STROKE_DASH_PHASE.get(m), 0d);                                                  writeAttribute(elem, \"stroke-linecap\", strokeLinecapMap.get(STROKE_CAP.get(m)), \"butt\");                                                  writeAttribute(elem, \"stroke-linejoin\", strokeLinejoinMap.get(STROKE_JOIN.get(m)), \"miter\");                                                  writeAttribute(elem, \"stroke-miterlimit\", STROKE_MITER_LIMIT.get(m), 4d);                                                  writeAttribute(elem, \"stroke-opacity\", STROKE_OPACITY.get(m), 1d);                                                  writeAttribute(elem, \"stroke-width\", STROKE_WIDTH.get(m), 1d);}", "nl": "Writes shape attributes"}
{"code": "public static String toPoints(Point2D.Double[] points) throws IOException {     StringBuilder buf = new StringBuilder();     for (int i = 0; i < points.length; i++) {       if (i != 0) {         buf.append(\", \");       }       buf.append(toNumber(points[i].x));       buf.append(',');       buf.append(toNumber(points[i].y));     }     return buf.toString();}", "nl": "Returns a Point2D . Double array as a Points attribute value"}
{"code": "public ViewToolBar() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(getID() + \".toolbar\"));     setDisclosureStateCount(3);}", "nl": "Creates new instance"}
{"code": "public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {     if (this.flavor.equals(flavor)) {       return new ByteArrayInputStream(data);     } else {       throw new UnsupportedFlavorException(flavor);}}", "nl": "Returns an object which represents the data to be transferred"}
{"code": "public DataFlavor[] getTransferDataFlavors() {     return new DataFlavor[] {flavor};}", "nl": "Returns an array of DataFlavor objects indicating the flavors the data can be provided in"}
{"code": "public XMLTransferable(byte[] data, String mimeType, String humanPresentableName) {     this.data = data;     this.flavor = new DataFlavor(mimeType, humanPresentableName);}", "nl": "Creates new XMLTransferable"}
{"code": "public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {     this(pathPrototype, bezierPrototype, null);}", "nl": "Creates a new instance"}
{"code": "protected Drawing createDrawing() {     DefaultDrawing drawing = new DefaultDrawing();     drawing.addInputFormat(new SVGZInputFormat());     drawing.addInputFormat(new ImageInputFormat(new SVGImageFigure()));     drawing.addOutputFormat(new SVGOutputFormat());     drawing.addOutputFormat(new SVGZOutputFormat());     drawing.addOutputFormat(new ImageOutputFormat());     drawing.addOutputFormat(new ImageOutputFormat(\"JPG\", \"Joint Photographics Experts Group (JPEG)\", \"jpg\", BufferedImage.TYPE_INT_RGB));     drawing.addOutputFormat(new ImageOutputFormat(\"BMP\", \"Windows Bitmap (BMP)\", \"bmp\", BufferedImage.TYPE_BYTE_INDEXED));     return drawing;}", "nl": "Creates the drawing"}
{"code": "public String getParameter(String name, String defaultValue) {     try {       String value = super.getParameter(name);       return (value == null) ? defaultValue : value;     } catch (NullPointerException e) {       return defaultValue;}}", "nl": "Same as Applet . getParameter but doesn ' t throw a NullPointerException when used without an Applet context"}
{"code": "private Drawing getDrawing() {     return drawingComponent.getDrawing();}", "nl": "Gets the drawing from the drawing panel"}
{"code": "@Override   public String getAppletInfo() {     return getName() +         \"\\nVersion \" + getVersion() +         \"\\n\\nCopyright 1996-2010 (c) by the original authors of JHotDraw and all its contributors\" +         \"\\nThis software is licensed under LGPL or\" +         \"\\nCreative Commons 2.5 BY\";}", "nl": "Returns information about the applet"}
{"code": "protected Drawing loadDrawing(ProgressIndicator progress) throws IOException {     Drawing drawing = createDrawing();     if (getParameter(\"datafile\") != null) {       ByteArrayOutputStream buf = new ByteArrayOutputStream();       URL url = new URL(getDocumentBase(), getParameter(\"datafile\"));       URLConnection uc = url.openConnection();                                   if (uc instanceof HttpURLConnection) {         ((HttpURLConnection) uc).setUseCaches(false);       }              int contentLength = uc.getContentLength();       InputStream in = uc.getInputStream();       try {         if (contentLength != -1) {           in = new BoundedRangeInputStream(in);           ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);           progress.setProgressModel((BoundedRangeModel) in);           progress.setIndeterminate(false);         }         BufferedInputStream bin = new BufferedInputStream(in);         bin.mark(512);                           final ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");         IOException formatException = null;         for (InputFormat format : drawing.getInputFormats()) {           try {             bin.reset();           } catch (IOException e) {             uc = url.openConnection();             in = uc.getInputStream();             in = new BoundedRangeInputStream(in);             ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);             progress.setProgressModel((BoundedRangeModel) in);             bin = new BufferedInputStream(in);             bin.mark(512);           }           try {             bin.reset();             format.read(bin, drawing, true);             formatException = null;             break;           } catch (IOException e) {             formatException = e;           }         }         if (formatException != null) {           throw formatException;         }       } finally {         in.close();       }     }     return drawing;}", "nl": "Loads the drawing"}
{"code": "protected SVGDrawingPanel createDrawingComponent() {     SVGDrawingPanel p = new SVGDrawingPanel();     DefaultDrawingEditor editor = new DefaultDrawingEditor();     p.setEditor(new DefaultDrawingEditor());     return p;}", "nl": "Creates the drawing component"}
{"code": "protected void close() {     AppletContext appletContext;     try {       appletContext = getAppletContext();     } catch (Throwable e) {       appletContext = null;     }     if (appletContext == null) {       System.exit(0);     } else {       try {         appletContext.showDocument(new URL(getDocumentBase(), getParameter(\"PageURL\")));       } catch (MalformedURLException ex) {         ex.printStackTrace();}}}", "nl": "Closes the applet"}
{"code": "public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype, Map<AttributeKey, Object> attributes) {     super(imagePrototype, attributes);     this.groupPrototype = groupPrototype;     this.imagePrototype = imagePrototype;}", "nl": "Creates a new instance"}
{"code": "public ConvexHullOutlineHandle(SVGPathFigure owner, boolean isTransformHandle, boolean isHoverHandle) {     super(owner);     if (isTransformHandle) {       if (isHoverHandle) {         stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;         strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;         stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;         strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;       } else {         stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;         strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;         stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;         strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;       }       stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;       strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;       stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;       strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;     } else {       if (isHoverHandle) {         stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;         strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;         stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;         strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;       } else {         stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;         strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;         stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;         strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;       }       stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;       strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;       stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;       strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;}}", "nl": "Creates a bounds outline handle for resizing or transforming a component"}
{"code": "public ConvexHullOutlineHandle(SVGPathFigure owner) {     this(owner, false, false);}", "nl": "Creates a bounds outline handle for resizing a component"}
{"code": "public ConvexHullOutlineHandle(SVGPathFigure owner,        AttributeKey<Stroke> stroke1Enabled, AttributeKey<Color> strokeColor1Enabled,       AttributeKey<Stroke> stroke2Enabled, AttributeKey<Color> strokeColor2Enabled,       AttributeKey<Stroke> stroke1Disabled, AttributeKey<Color> strokeColor1Disabled,       AttributeKey<Stroke> stroke2Disabled, AttributeKey<Color> strokeColor2Disabled       ) {     super(owner);     this.stroke1Enabled = stroke1Enabled;     this.strokeColor1Enabled = strokeColor1Enabled;     this.stroke2Enabled = stroke2Enabled;     this.strokeColor2Enabled = strokeColor2Enabled;     this.stroke1Disabled = stroke1Disabled;     this.strokeColor1Disabled = strokeColor1Disabled;     this.stroke2Disabled = stroke2Disabled;     this.strokeColor2Disabled = strokeColor2Disabled;}", "nl": "Creates a bounds outline handle for resizing or transforming a component"}
{"code": "public LinkHandle(Figure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "@Override public void draw(Graphics2D g) {     Figure o = getOwner();     if (o.get(LINK)!=null&&o.get(LINK).trim().length()>0) {       g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));       Rectangle r = basicGetBounds();       g.drawLine(r.x+(r.width/2)-1, r.y, r.x, r.y);       g.drawLine(r.x, r.y, r.x, r.y+r.height-1);       g.drawLine(r.x, r.y+r.height-1, r.x+(r.width/2)-1, r.y+r.height-1);       g.drawLine(r.x+(r.width/3), r.y+r.height/2, r.x+r.width-1, r.y+r.height/2);       g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.25));       g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.75));}}", "nl": "Draws this handle"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public ViewSourceAction(Application app, View view) {     super(app, view);     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "public Drawing createDrawing() {     Drawing drawing = new QuadTreeDrawing();     LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();     inputFormats.add(new SVGZInputFormat());     inputFormats.add(new ImageInputFormat(new SVGImageFigure(), \"PNG\", \"Portable Network Graphics (PNG)\", \"png\", \"image/png\"));     inputFormats.add(new ImageInputFormat(new SVGImageFigure(), \"JPG\", \"Joint Photographics Experts Group (JPEG)\", \"jpg\",\"image/jpg\"));     inputFormats.add(new ImageInputFormat(new SVGImageFigure(), \"GIF\", \"Graphics Interchange Format (GIF)\", \"gif\", \"image/gif\"));     inputFormats.add(new TextInputFormat(new SVGTextFigure()));     drawing.setInputFormats(inputFormats);     LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();     outputFormats.add(new SVGOutputFormat());     outputFormats.add(new SVGZOutputFormat());     outputFormats.add(new ImageOutputFormat());     outputFormats.add(new ImageOutputFormat(\"JPG\", \"Joint Photographics Experts Group (JPEG)\", \"jpg\", BufferedImage.TYPE_INT_RGB));     outputFormats.add(new ImageOutputFormat(\"BMP\", \"Windows Bitmap (BMP)\", \"bmp\", BufferedImage.TYPE_BYTE_INDEXED));     outputFormats.add(new ImageMapOutputFormat());     drawing.setOutputFormats(outputFormats);     return drawing;}", "nl": "Creates a new Drawing object which can be used with this SVGDrawingPanel"}
{"code": "private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     toolButtonGroup = new javax.swing.ButtonGroup();     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     toolsPanel = new javax.swing.JPanel();     toolsScrollPane = new javax.swing.JScrollPane();     toolsPane = new javax.swing.JPanel();     creationToolBar = new org.jhotdraw.samples.svg.gui.ToolsToolBar();     actionToolBar = new org.jhotdraw.samples.svg.gui.ActionsToolBar();     fillToolBar = new org.jhotdraw.samples.svg.gui.FillToolBar();     strokeToolBar = new org.jhotdraw.samples.svg.gui.StrokeToolBar();     fontToolBar = new org.jhotdraw.samples.svg.gui.FontToolBar();     arrangeToolBar = new org.jhotdraw.samples.svg.gui.ArrangeToolBar();     alignToolBar = new org.jhotdraw.samples.svg.gui.AlignToolBar();     figureToolBar = new org.jhotdraw.samples.svg.gui.FigureToolBar();     linkToolBar = new org.jhotdraw.samples.svg.gui.LinkToolBar();     canvasToolBar = new org.jhotdraw.samples.svg.gui.CanvasToolBar();     viewToolBar = new org.jhotdraw.samples.svg.gui.ViewToolBar();     setBackground(new java.awt.Color(255, 255, 255));     setLayout(new java.awt.BorderLayout());     scrollPane.setBorder(null);     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);     toolsPanel.setBackground(new java.awt.Color(255, 255, 255));     toolsPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));     toolsPanel.setOpaque(true);     toolsPanel.setLayout(new java.awt.GridBagLayout());     toolsScrollPane.setBorder(PaletteLookAndFeel.getInstance().getBorder(\"Ribbon.border\"));     toolsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);     toolsScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);     toolsScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));     toolsPane.setForeground(new java.awt.Color(153, 153, 153));     toolsPane.add(creationToolBar);     toolsPane.add(actionToolBar);     toolsPane.add(fillToolBar);     strokeToolBar.setMargin(new java.awt.Insets(0, 10, 0, 0));     toolsPane.add(strokeToolBar);     toolsPane.add(fontToolBar);     toolsPane.add(arrangeToolBar);     toolsPane.add(alignToolBar);     toolsPane.add(figureToolBar);     toolsPane.add(linkToolBar);     toolsPane.add(canvasToolBar);     toolsPane.add(viewToolBar);     toolsScrollPane.setViewportView(toolsPane);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;     gridBagConstraints.weightx = 1.0;     gridBagConstraints.weighty = 1.0;     toolsPanel.add(toolsScrollPane, gridBagConstraints);     add(toolsPanel, java.awt.BorderLayout.SOUTH);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public CombineAction(DrawingEditor editor) {     this(editor, new SVGPathFigure(true), true);}", "nl": "Creates a new instance"}
{"code": "public SVGBezierFigure() {     this(false);}", "nl": "Creates a new instance"}
{"code": "@Override   public int findSegment(Point2D.Double find, double tolerance) {          if (get(TRANSFORM) != null) {       try {         find = (Point2D.Double) get(TRANSFORM).inverseTransform(find, new Point2D.Double());       } catch (NoninvertibleTransformException ex) {         System.err.println(\"Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.\");       }     }     return getBezierPath().findSegment(find, tolerance);}", "nl": "Gets the segment of the polyline that is hit by the given Point2D . Double"}
{"code": "@Override   public boolean joinSegments(Point2D.Double join, double tolerance) {          if (get(TRANSFORM) != null) {       try {         join = (Point2D.Double) get(TRANSFORM).inverseTransform(join, new Point2D.Double());       } catch (NoninvertibleTransformException ex) {         System.err.println(\"Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.\");       }     }     int i = getBezierPath().findSegment(join, tolerance);     if (i != -1 && i > 1) {       removeNode(i);       return true;     }     return false;}", "nl": "Joins two segments into one if the given Point2D . Double hits a node of the polyline"}
{"code": "private void initComponents() {     svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();     setLayout(new java.awt.BorderLayout());     add(svgPanel, java.awt.BorderLayout.CENTER);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "private void initActions() {     getActionMap().put(UndoAction.ID, undo.getUndoAction());     getActionMap().put(RedoAction.ID, undo.getRedoAction());}", "nl": "Initializes view specific actions"}
{"code": "public void write(URI uri, URIChooser chooser) throws IOException {     new SVGOutputFormat().write(new File(uri), svgPanel.getDrawing());}", "nl": "Writes the view to the specified uri"}
{"code": "public DateTitle() {     this(DateFormat.LONG);}", "nl": "Default constructor - builds a new DateTitle that displays the current date in the default format for the locale , positioned to the bottom right of the chart"}
{"code": "public DateTitle(int dateStyle, Locale locale, Font font, Paint paint) {     this(dateStyle, locale, font, paint, AbstractTitle.BOTTOM, AbstractTitle.RIGHT,        AbstractTitle.MIDDLE, new Insets(2, 2, 2, 2));}", "nl": "Standard constructor - builds a new DateTitle object with the specified attributes and the following defaults : location = BOTTOM , alignment = RIGHT , insets = new Insets"}
{"code": "public DateTitle(int dateStyle, Locale locale, Font font, Paint paint, int position,            int horizontalAlignment, int verticalAlignment, Insets insets) {      super(DateFormat.getDateInstance(dateStyle, locale).format(new Date()),         font, paint, position, horizontalAlignment, verticalAlignment, insets);}", "nl": "Full constructor - builds a new DateTitle with the specified attributes"}
{"code": "public static JFreeChart createXYChart(String title, String xAxisLabel, String yAxisLabel,                          XYDataset data, boolean legend) {      JFreeChart chart = null;    try {       NumberAxis xAxis = new HorizontalNumberAxis(xAxisLabel);       xAxis.setAutoRangeIncludesZero(false);     Axis yAxis = new VerticalNumberAxis(yAxisLabel);       XYPlot plot = new XYPlot(xAxis, yAxis);       plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createXYChart(...) : axis not compatible.\");   }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createXYChart(...) : plot not compatible.\");   }      return chart;}", "nl": "Creates an XY plot with default settings"}
{"code": "public static JFreeChart createStackedHorizontalBarChart(String title, String categoryAxisLabel,                             String valueAxisLabel, CategoryDataset data,                             boolean legend) {      JFreeChart chart = null;      try {       Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);       Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);       HorizontalBarPlot plot = new HorizontalBarPlot(valueAxis, categoryAxis);       plot.setRenderer(new StackedHorizontalBarRenderer());       chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);     }   catch (AxisNotCompatibleException e) {            System.err.println(         \"ChartFactory.createStackedHorizontalBarChart(...) : axis not compatible.\");     }   catch (PlotNotCompatibleException e) {            System.err.println(         \"ChartFactory.createStackedHorizontalBarChart(...) : plot not compatible.\");     }      return chart;}", "nl": "Creates a stacked horizontal bar chart with default settings"}
{"code": "public static JFreeChart createVerticalXYBarChart(String title, String xAxisLabel,                             String yAxisLabel, IntervalXYDataset data,                             boolean legend) {      JFreeChart chart = null;    try {     HorizontalDateAxis timeAxis = new HorizontalDateAxis(xAxisLabel);     Axis valueAxis = new VerticalNumberAxis(yAxisLabel);     Plot plot = new VerticalXYBarPlot(timeAxis, valueAxis, new Insets(0,0,0,0), Color.white,       new BasicStroke(), Color.gray);     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createVerticalXYBarChart(...) : axis not compatible.\");   }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createVerticalXYBarChart(...) : plot not compatible.\");   }      return chart;}", "nl": "Creates and returns a default instance of a VerticalXYBarChart based on the specified dataset"}
{"code": "public static JFreeChart createPieChart(String title, PieDataset data, boolean legend) {      JFreeChart chart = null;      try {     Plot plot = new PiePlot();     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createPieChart(...) : axis not compatible.\");   }     catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createPieChart(...) : plot not compatible.\");   }      return chart;}", "nl": "Creates a pie chart with default settings"}
{"code": "public static JFreeChart createVerticalBarChart3D(String title, String categoryAxisLabel,                           String valueAxisLabel, CategoryDataset data,                           boolean legend) {      JFreeChart chart = null;      try {       Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);       Axis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);       VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);                     plot.setInsets(new Insets(20, 2, 2, 2));       plot.setRenderer(new VerticalBarRenderer3D());       chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);     }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createVerticalBarChart3D(...) : axis not compatible.\");     }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createVerticalBarChart3D(...) : plot not compatible.\");     }      return chart;}", "nl": "Creates a vertical 3D - effect bar chart with default settings"}
{"code": "public static JFreeChart createStackedVerticalBarChart3D(String title, String categoryAxisLabel,                             String valueAxisLabel, CategoryDataset data,                             boolean legend) {      JFreeChart chart = null;      try {       Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);       Axis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);       VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);                     plot.setInsets(new Insets(20, 2, 2, 2));       plot.setRenderer(new StackedVerticalBarRenderer3D());       chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);     }   catch (AxisNotCompatibleException e) {            System.err.println(         \"ChartFactory.createStackedVerticalBarChart3D(...) : axis not compatible.\");     }   catch (PlotNotCompatibleException e) {            System.err.println(         \"ChartFactory.createStackedVerticalBarChart3D(...) : plot not compatible.\");     }      return chart;}", "nl": "Creates a stacked vertical bar chart with default settings"}
{"code": "public static JFreeChart createTimeSeriesChart(String title, String timeAxisLabel,                            String valueAxisLabel, XYDataset data,                            boolean legend) {      JFreeChart chart = null;    try {       Axis timeAxis = new HorizontalDateAxis(timeAxisLabel);     NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);       valueAxis.setAutoRangeIncludesZero(false);       XYPlot plot = new XYPlot(timeAxis, valueAxis);       plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createTimeSeriesChart(...) : axis not compatible.\");   }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createTimeSeriesChart(...) : axis not compatible.\");   }      return chart;}", "nl": "Creates and returns a time series chart"}
{"code": "public static JFreeChart createHorizontalBarChart(String title, String categoryAxisLabel,                             String valueAxisLabel, CategoryDataset data,                             boolean legend) {      JFreeChart chart = null;      try {     Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);     Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);     Plot plot = new HorizontalBarPlot(valueAxis, categoryAxis);     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createHorizontalBarChart(...) : axis not compatible.\");     }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createHorizontalBarChart(...) : plot not compatible.\");     }      return chart;}", "nl": "Creates a horizontal bar chart with default settings"}
{"code": "public BarPlot(Axis horizontalAxis, Axis verticalAxis) throws AxisNotCompatibleException,                                   PlotNotCompatibleException   {   this(horizontalAxis, verticalAxis,        new Insets(2, 2, 2, 2),        DEFAULT_INTRO_GAP_PERCENT,        DEFAULT_TRAIL_GAP_PERCENT,        DEFAULT_CATEGORY_GAPS_PERCENT,        DEFAULT_ITEM_GAPS_PERCENT);}", "nl": "Constructs a bar plot with the specified axes"}
{"code": "public double getItemGapsPercent() {   return itemGapsPercent;}", "nl": "Returns the gap between one bar and the next within the same category , measured in Java 2D User Space units"}
{"code": "public void setIntroGapPercent(double percent) {   if (this.introGapPercent!=percent) {       this.introGapPercent = Math.min(percent, MAX_INTRO_GAP_PERCENT);     notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the gap before the first bar on the chart , and notifies registered listeners that the plot has been modified"}
{"code": "public void setVerticalAxis(Axis axis) throws AxisNotCompatibleException {   super.setVerticalAxis(axis);}", "nl": "Sets the vertical axis for the plot"}
{"code": "public void setCategoryGapsPercent(double percent) {   if (this.categoryGapsPercent!=percent) {       this.categoryGapsPercent=Math.min(percent, MAX_CATEGORY_GAPS_PERCENT);     notifyListeners(new PlotChangeEvent(this));}}", "nl": "incoherencetype"}
{"code": "public double getIntroGapPercent() {   return introGapPercent;}", "nl": "Returns the gap before the first bar on the chart , as a percentage of the available drawing space"}
{"code": "public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {   super.setHorizontalAxis(axis);}", "nl": "Sets the horizontal axis for the plot"}
{"code": "public double getCategoryGapsPercent() {   return categoryGapsPercent;}", "nl": "Returns the percentage of the drawing space that is allocated to providing gaps between the categories"}
{"code": "public java.util.List getCategories() {   return getDataset().getCategories();}", "nl": "A convenience method that returns a list of the categories in the data source"}
{"code": "public void setLabelFont(Font font) {           if (font==null) {       throw new IllegalArgumentException(\"Axis.setLabelFont(...): null not permitted.\");     }         if (!this.labelFont.equals(font)) {     this.labelFont = font;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the font for the axis label"}
{"code": "public void setTickMarksVisible(boolean flag) {    if (flag!=tickMarksVisible) {     tickMarksVisible = flag;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag that indicates whether or not the tick marks are showing"}
{"code": "public Insets getTickLabelInsets() {   return this.tickLabelInsets;}", "nl": "Returns the insets for the tick labels"}
{"code": "public void setLabel(String label) {      String existing = this.label;     if (existing!=null) {     if (!existing.equals(label)) {       this.label = label;       notifyListeners(new AxisChangeEvent(this));     }     }     else {       if (label!=null) {       this.label = label;       notifyListeners(new AxisChangeEvent(this));}}}", "nl": "Sets the label for the axis"}
{"code": "public void setTickLabelFont(Font font) {           if (font==null) {       throw new IllegalArgumentException(\"Axis.setTickLabelFont(...): null not permitted.\");     }         if (!this.tickLabelFont.equals(font)) {     this.tickLabelFont = font;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the font for the tick labels"}
{"code": "public void addChangeListener(AxisChangeListener listener) {   listeners.add(listener);}", "nl": "Registers an object for notification of changes to the axis"}
{"code": "public Insets getLabelInsets() {   return this.labelInsets;}", "nl": "Returns the insets for the label"}
{"code": "public Stroke getTickMarkStroke() {   return tickMarkStroke;}", "nl": "Returns the pen brush used to draw tick marks"}
{"code": "public boolean isTickMarksVisible() {   return tickMarksVisible;}", "nl": "Returns the flag that indicates whether or not the tick marks are showing"}
{"code": "protected void notifyListeners(AxisChangeEvent event) {   java.util.Iterator iterator = listeners.iterator();   while (iterator.hasNext()) {     AxisChangeListener listener = (AxisChangeListener)iterator.next();     listener.axisChanged(event);}}", "nl": "Notifies all registered listeners that the axis has changed"}
{"code": "protected void drawVerticalString(String text, Graphics2D g2, float x, float y) {    AffineTransform saved = g2.getTransform();       AffineTransform rotate = AffineTransform.getRotateInstance(-Math.PI/2, x, y);   g2.transform(rotate);   g2.drawString(text, x, y);    g2.setTransform(saved);}", "nl": "A utility method for drawing text vertically"}
{"code": "protected Axis(String label,            Font labelFont, Paint labelPaint, Insets labelInsets,        boolean tickLabelsVisible,            Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,        boolean tickMarkVisible, Stroke tickMarkStroke) {    this.label = label;   this.labelFont = labelFont;   this.labelPaint = labelPaint;   this.labelInsets = labelInsets;   this.tickLabelsVisible = tickLabelsVisible;   this.tickLabelFont = tickLabelFont;   this.tickLabelPaint = tickLabelPaint;   this.tickLabelInsets = tickLabelInsets;   this.tickMarksVisible = tickMarksVisible;   this.tickMarkStroke = tickMarkStroke;    this.ticks = new java.util.ArrayList();   this.listeners = new java.util.ArrayList();}", "nl": "Constructs an axis"}
{"code": "public Plot getPlot() {   return plot;}", "nl": "Returns the plot that the axis is assigned to"}
{"code": "public Paint getTickLabelPaint() {   return this.tickLabelPaint;}", "nl": "Returns the color shade used for the tick labels"}
{"code": "public void setLabelPaint(Paint paint) {           if (paint==null) {       throw new IllegalArgumentException(\"Axis.setLabelPaint(...): null not permitted.\");     }         if (!this.labelPaint.equals(paint)) {     this.labelPaint = paint;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the color shade used to draw the axis label"}
{"code": "public void setTickLabelInsets(Insets insets) {           if (insets==null) {       throw new IllegalArgumentException(\"Axis.setTickLabelInsets(...): null not permitted.\");     }         if (!this.tickLabelInsets.equals(insets)) {     this.tickLabelInsets = insets;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the insets for the tick labels , and notifies registered listeners that the axis has been modified"}
{"code": "public Paint getLabelPaint() {   return this.labelPaint;}", "nl": "Returns the color shade used to draw the axis label"}
{"code": "public void setLabelInsets(Insets insets) {   if (!insets.equals(this.labelInsets)) {     this.labelInsets = insets;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the insets for the axis label , and notifies registered listeners that the axis has been modified"}
{"code": "protected Axis(String label) {    this(label,        DEFAULT_AXIS_LABEL_FONT,        DEFAULT_AXIS_LABEL_PAINT,        DEFAULT_AXIS_LABEL_INSETS,        true,          DEFAULT_TICK_LABEL_FONT,        DEFAULT_TICK_LABEL_PAINT,        DEFAULT_TICK_LABEL_INSETS,        true,          DEFAULT_TICK_STROKE);}", "nl": "Constructs an axis , using default values where necessary"}
{"code": "public void setTickLabelPaint(Paint paint) {           if (paint==null) {       throw new IllegalArgumentException(\"Axis.setTickLabelPaint(...): null not permitted.\");     }         if (!this.tickLabelPaint.equals(paint)) {     this.tickLabelPaint = paint;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the color shade used to draw tick labels"}
{"code": "public Paint getFillPaint() {   return fillPaint;}", "nl": "Returns the Paint object used to fill the bar"}
{"code": "public Bar(double x, double y, double width, double height) {   this(x, y, width, height, new BasicStroke(), Color.gray, Color.green);}", "nl": "Standard constructor : returns a new Bar object , with some default attributes"}
{"code": "public Rectangle2D getArea() {   return area;}", "nl": "Returns the rectangle that is the outline of the bar"}
{"code": "public Paint getOutlinePaint() {   return outlinePaint;}", "nl": "Returns the Paint object used to draw the outline of the bar"}
{"code": "public Bar(double x, double y, double width, double height,        Stroke outlineStroke, Paint outlinePaint, Paint fillPaint)   {   this.area = new Rectangle2D.Double(x, y, width, height);   this.outlineStroke = outlineStroke;   this.outlinePaint = outlinePaint;   this.fillPaint = fillPaint;}", "nl": "Full constructor : returns a new Bar object with attributes as defined by the caller"}
{"code": "public Stroke getOutlineStroke() {   return outlineStroke;}", "nl": "Returns the Stroke object used to draw the outline of the bar"}
{"code": "protected Date nextStandardDate(Date date, int field, int units) {   Date previous = previousStandardDate(date, field, units);   Calendar calendar = Calendar.getInstance();   calendar.setTime(previous);   calendar.add(field, units);   return calendar.getTime();}", "nl": "Returns the first standard date"}
{"code": "public void setTickUnit(DateUnit unit) {   this.tickUnit = unit;   this.notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the tick unit for the axis"}
{"code": "public DateAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,       boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,       boolean showTickMarks, Stroke tickMarkStroke,       boolean autoRange, Date minimumDate, Date maximumDate,       boolean autoTickUnit, DateUnit tickUnit, SimpleDateFormat tickLabelFormatter,       boolean showGridLines, Stroke gridStroke, Paint gridPaint) {    super(label, labelFont, labelPaint, labelInsets,       showTickLabels, tickLabelFont, tickLabelPaint, tickLabelInsets,       showTickMarks, tickMarkStroke, autoRange,       autoTickUnit, showGridLines, gridStroke, gridPaint);    this.minimumDate = minimumDate;   this.maximumDate = maximumDate;   this.tickUnit = tickUnit;   this.tickLabelFormatter = tickLabelFormatter;}", "nl": "Full constructor - initialises the attributes for a ValueAxis"}
{"code": "public void setMaximumDate(Date maximumDate) {   this.maximumDate = maximumDate;   this.notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the maximum date visible on the axis"}
{"code": "public void setMinimumDate(Date minimumDate) {   this.minimumDate = minimumDate;   this.notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the minimum date visible on the axis"}
{"code": "public DateAxis(String label) {   super(label);   this.minimumDate = new Date();   this.maximumDate = new Date();   this.tickUnit = new DateUnit(Calendar.DATE, 1);   this.tickLabelFormatter = new SimpleDateFormat();}", "nl": "Standard constructor : builds a DateAxis with mostly default attributes"}
{"code": "protected int findAxisMagnitudeIndex() {   long axisMagnitude = this.maximumDate.getTime()-this.minimumDate.getTime();   int index = 0;   while(index<standardTickUnitMagnitudes.length-1) {     if (axisMagnitude<standardTickUnitMagnitudes[index]) break;     index++;   }   return Math.max(0, index-1);}", "nl": "Returns the index of the largest tick unit that will fit within the axis range"}
{"code": "public DateUnit getTickUnit() {   return tickUnit;}", "nl": "Returns the tick unit for the axis ; @ return The tick unit for the axis"}
{"code": "public Date calculateLowestVisibleTickValue(DateUnit unit) {   return this.nextStandardDate(minimumDate, unit.getField(), unit.getCount());}", "nl": "Calculates and returns the value of the lowest visible tick on the axis"}
{"code": "protected AbstractTitle(int position, int horizontalAlignment, int verticalAlignment) {     this(position, horizontalAlignment, verticalAlignment, new Insets(2, 2, 2, 2));}", "nl": "Standard constrcutor - builds an abstract title with the specified position and alignment , with a default inset of 2 pixels around the title"}
{"code": "public void addChangeListener(TitleChangeListener listener) {     listeners.add(listener);}", "nl": "Registers an object for notification of changes to the title"}
{"code": "public void removeChangeListener(TitleChangeListener listener) {     listeners.remove(listener);}", "nl": "Unregisters an object for notification of changes to the chart title"}
{"code": "public void setNotify(boolean flag) {     this.notify = flag;}", "nl": "Sets the flag that indicates whether or not the notification mechanism is enabled"}
{"code": "public void setPosition(int position) {     if (this.position!=position) {              this.position = position;       notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the position for the title"}
{"code": "public int getPosition() {     return this.position;}", "nl": "Returns the relative position of the title - - - represented by one of four integer constants defined in this class : TOP , BOTTOM , RIGHT or LEFT"}
{"code": "public Object clone() {     AbstractTitle duplicate = null;     try {       duplicate = (AbstractTitle)(super.clone());     }     catch (CloneNotSupportedException e) {              throw new RuntimeException(\"AbstractTitle.clone()\");     }      duplicate.setNotify(false);     duplicate.setInsets((Insets)this.getInsets().clone());     duplicate.setNotify(true);     return duplicate;}", "nl": "Returns a clone of the title"}
{"code": "public int getVerticalAlignment() {     return this.verticalAlignment;}", "nl": "Returns the vertical alignment of the title"}
{"code": "protected AbstractTitle() {     this(TOP, CENTER, MIDDLE);}", "nl": "Default constructor - builds an AbstractTitle positioned at the top of the page , centered horizontally and vertically within its space"}
{"code": "public int getHorizontalAlignment() {     return this.horizontalAlignment;}", "nl": "Returns the horizontal alignment of the title"}
{"code": "public Insets getInsets() {     return this.insets;}", "nl": "Returns the insets for this title"}
{"code": "protected AbstractTitle(int position, int horizontalAlignment, int verticalAlignment,               Insets insets) {           if (!this.isValidPosition(position)) {       throw new IllegalArgumentException(\"AbstractTitle: Invalid position.\");     }           if ((horizontalAlignment!=LEFT) &&       (horizontalAlignment!=CENTER) &&       (horizontalAlignment!=RIGHT)) {       throw new IllegalArgumentException(\"AbstractTitle: Invalid horizontal alignment.\");     }      if ((verticalAlignment!=TOP) &&       (verticalAlignment!=BOTTOM) &&       (verticalAlignment!=MIDDLE)) {       throw new IllegalArgumentException(\"AbstractTitle: Invalid vertical alignment.\");     }      this.position = position;     this.horizontalAlignment = horizontalAlignment;     this.verticalAlignment = verticalAlignment;     this.insets = insets;     this.listeners = new java.util.ArrayList();     this.notify = true;}", "nl": "Full constructor - builds an abstract title with the specified position and alignment"}
{"code": "public VerticalNumberAxis(String label,                 Font labelFont, Paint labelPaint, Insets labelInsets,           boolean labelDrawnVertical,           boolean tickLabelsVisible, Font tickLabelFont, Paint tickLabelPaint,                 Insets tickLabelInsets,           boolean tickMarksVisible, Stroke tickMarkStroke,           boolean autoRange, boolean autoRangeIncludesZero,                 Number autoRangeMinimum,           Number minimumAxisValue, Number maximumAxisValue,           boolean autoTickUnitSelection,                 NumberTickUnit tickUnit,            boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint) {   super(label,         labelFont, labelPaint, labelInsets,         tickLabelsVisible,         tickLabelFont, tickLabelPaint, tickLabelInsets,         tickMarksVisible,         tickMarkStroke,       autoRange, autoRangeIncludesZero, autoRangeMinimum,       minimumAxisValue, maximumAxisValue,         autoTickUnitSelection, tickUnit,         gridLinesVisible, gridStroke, gridPaint);   this.labelDrawnVertical = labelDrawnVertical;}", "nl": "Constructs a vertical number axis"}
{"code": "private void selectAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {          FontRenderContext frc = g2.getFontRenderContext();     double tickLabelHeight = tickLabelFont.getLineMetrics(\"123\", frc).getHeight()                  +this.tickLabelInsets.top+this.tickLabelInsets.bottom;        double zero = this.translatedValue(Plot.ZERO, plotArea);          NumberTickUnit candidate1              = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(this.tickUnit);     double y = this.translatedValue(candidate1.getValue(), plotArea);     double unitHeight = Math.abs(y-zero);          double bestguess = (tickLabelHeight/unitHeight) * candidate1.value.doubleValue();     NumberTickUnit guess = new NumberTickUnit(new Double(bestguess), null);     NumberTickUnit candidate2                = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(guess);     this.tickUnit = candidate2;}", "nl": "Selects an appropriate tick value for the axis"}
{"code": "public double translatedValue(Number dataValue, Rectangle2D plotArea) {   double value = dataValue.doubleValue();   double axisMin = minimumAxisValue.doubleValue();   double axisMax = maximumAxisValue.doubleValue();   double maxY = plotArea.getMaxY();   double minY = plotArea.getMinY();   return maxY - (((value - axisMin)/(axisMax - axisMin)) * (maxY - minY));}", "nl": "Translates the data value to the display coordinates of the chart"}
{"code": "public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {      double labelWidth = 0.0;   if (label!=null) {     Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());     labelWidth = labelInsets.left+labelInsets.right;     if (this.labelDrawnVertical) {     labelWidth = labelWidth + labelBounds.getHeight();       }     else {     labelWidth = labelWidth + labelBounds.getWidth();     }   }      double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;   if (tickLabelsVisible) {     this.refreshTicks(g2, drawArea, drawArea);     tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);   }   return labelWidth+tickLabelWidth;}", "nl": "Returns the width required to draw the axis in the specified draw area"}
{"code": "public VerticalNumberAxis(String label, Font labelFont,           Number minimumAxisValue, Number maximumAxisValue) {   this(label,        labelFont,        Axis.DEFAULT_AXIS_LABEL_PAINT,        Axis.DEFAULT_AXIS_LABEL_INSETS,        true,         true,         Axis.DEFAULT_TICK_LABEL_FONT,        Axis.DEFAULT_TICK_LABEL_PAINT,        Axis.DEFAULT_TICK_LABEL_INSETS,      true,         Axis.DEFAULT_TICK_STROKE,        true,         true,         NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,      minimumAxisValue,        maximumAxisValue,      true,         NumberAxis.DEFAULT_TICK_UNIT,      true,         ValueAxis.DEFAULT_GRID_LINE_STROKE,        ValueAxis.DEFAULT_GRID_LINE_PAINT);}", "nl": "Constructs a vertical number axis"}
{"code": "public void autoAdjustRange() {   if (plot!=null) {     if (plot instanceof VerticalValuePlot) {     VerticalValuePlot vvp = (VerticalValuePlot)plot;         Number u = vvp.getMaximumVerticalDataValue();         double upper = this.DEFAULT_MAXIMUM_AXIS_VALUE.doubleValue();         if (u!=null) {       upper = u.doubleValue();         }         Number l = vvp.getMinimumVerticalDataValue();         double lower = this.DEFAULT_MINIMUM_AXIS_VALUE.doubleValue();         if (l!=null) {       lower = l.doubleValue();         }     double range = upper-lower;              double minRange = this.autoRangeMinimumSize.doubleValue();     if (range<minRange) {       upper = (upper+lower+minRange)/2;       lower = (upper+lower-minRange)/2;     }     if (this.autoRangeIncludesZero()) {       if (upper!=0.0) upper = Math.max(0.0, upper+upperMargin*range);       if (lower!=0.0) lower = Math.min(0.0, lower-lowerMargin*range);     }     else {       if (upper!=0.0) upper = upper+upperMargin*range;       if (lower!=0.0) lower = lower-lowerMargin*range;     }     this.minimumAxisValue=new Double(lower);     this.maximumAxisValue=new Double(upper);}}}", "nl": "Rescales the axis to ensure that all data is visible"}
{"code": "public boolean isLabelDrawnVertical() {   return this.labelDrawnVertical;}", "nl": "Returns a flag that indicates whether or not the axis label is drawn with a vertical orientation"}
{"code": "public void configure() {   if (isAutoRange()) {     autoAdjustRange();}}", "nl": "Configures the axis to work with the specified plot"}
{"code": "public void setLabelDrawnVertical(boolean flag) {     if (this.labelDrawnVertical!=flag) {     this.labelDrawnVertical = flag;     this.notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag that controls whether or not the axis label is drawn with a vertical orientation"}
{"code": "public ValueAxis getDomainAxis() {     return (ValueAxis)horizontalAxis;}", "nl": "A convenience method that returns the horizontal axis cast as a ValueAxis"}
{"code": "public Number getMinimumHorizontalDataValue() {     Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumDomainValue(data);   }   else return null;}", "nl": "Returns the minimum value in either the domain or the range , whichever is displayed against the horizontal axis for the particular type of plot implementing this interface"}
{"code": "public VerticalXYBarPlot(Axis horizontalAxis, Axis verticalAxis, Insets insets,       Paint background, Stroke outlineStroke, Paint outlinePaint)       throws AxisNotCompatibleException, PlotNotCompatibleException   {     super(horizontalAxis, verticalAxis, insets, background, outlineStroke, outlinePaint);}", "nl": "Standard constructor"}
{"code": "public Number getMinimumVerticalDataValue()  {     Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumRangeValue(data);   }   else return null;}", "nl": "Returns the minimum Y value from the datasource"}
{"code": "public Number getMaximumVerticalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMaximumRangeValue(data);   }   else return null;}", "nl": "Returns the maximum Y value from the datasource"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {     if (axis instanceof VerticalNumberAxis) return true;     else return false;}", "nl": "Returns true if the specified axis is compatible with the plot with regard to operating as the vertical axis"}
{"code": "public VerticalNumberAxis getRangeAxis() {     return (VerticalNumberAxis)verticalAxis;}", "nl": "A convenience method that returns the vertical axis cast as a VerticalNumberAxis"}
{"code": "public Number getMaximumHorizontalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMaximumDomainValue(data);   }   else return null;}", "nl": "Returns the maximum value in either the domain or the range , whichever is displayed against the horizontal axis for the particular type of plot implementing this interface"}
{"code": "public String getName() { return \"Linear Fit\"; }", "nl": "@ return The name that you want to see in the legend"}
{"code": "public int barWidthsPerCategory(CategoryDataset data) {     return data.getSeriesCount();}", "nl": "This will be a method in the renderer that tells whether there is one bar width per category or onebarwidth per series per category"}
{"code": "public void drawBar(Graphics2D g2, Rectangle2D plotArea, BarPlot plot, ValueAxis valueAxis,             CategoryDataset data, int series, Object category, int categoryIndex,             double translatedZero, double itemWidth,             double categorySpan, double categoryGapSpan,             double itemSpan, double itemGapSpan) {          Number value = data.getValue(series, category);     if (value!=null) {              double rectX = plotArea.getX()                                + plotArea.getWidth()*plot.getIntroGapPercent()                                + categoryIndex*categorySpan/data.getCategoryCount()                                + (categoryIndex*categoryGapSpan/(data.getCategoryCount()-1))                                + (series*itemSpan/(data.getCategoryCount()*data.getSeriesCount()))                + (series*itemGapSpan/(data.getCategoryCount()*(data.getSeriesCount()-1)));              double translatedValue = valueAxis.translatedValue(value, plotArea);       double rectY = Math.min(translatedZero, translatedValue);              double rectWidth = itemWidth;              double rectHeight = Math.abs(translatedValue-translatedZero);       Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);       Paint seriesPaint = plot.getSeriesPaint(series);       g2.setPaint(seriesPaint);       g2.fill(bar);       GeneralPath bar3dRight = null;       GeneralPath bar3dTop = null;       double effect3d = 0.00;       VerticalAxis vAxis = plot.getVerticalAxis();       if (rectHeight != 0 && vAxis instanceof VerticalNumberAxis3D) {         effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();         bar3dRight = new GeneralPath();         bar3dRight.moveTo((float)(rectX+rectWidth), (float)rectY);         bar3dRight.lineTo((float)(rectX+rectWidth), (float)(rectY+rectHeight));         bar3dRight.lineTo((float)(rectX+rectWidth+effect3d),                   (float)(rectY+rectHeight-effect3d));         bar3dRight.lineTo((float)(rectX+rectWidth+effect3d), (float)(rectY-effect3d));         if (seriesPaint instanceof Color) {           g2.setPaint( ((Color) seriesPaint).darker());         }         g2.fill(bar3dRight);         bar3dTop = new GeneralPath();         bar3dTop.moveTo( (float) rectX, (float) rectY);         bar3dTop.lineTo((float) (rectX+effect3d), (float) (rectY-effect3d));         bar3dTop.lineTo((float) (rectX+rectWidth+effect3d), (float) (rectY-effect3d));         bar3dTop.lineTo((float) (rectX+rectWidth), (float) (rectY) );         if (seriesPaint instanceof Color) {           g2.setPaint( ((Color) seriesPaint));          }         g2.fill(bar3dTop);       }       if (itemWidth>3) {         g2.setStroke(plot.getSeriesOutlineStroke(series));                  g2.setPaint(plot.getSeriesOutlinePaint(series));         g2.draw(bar);         if (bar3dRight != null) {           g2.draw(bar3dRight);         }         if (bar3dTop != null) {           g2.draw(bar3dTop);}}}}", "nl": "Renders an individual bar"}
{"code": "public boolean hasItemGaps() {     return true;}", "nl": "Returns true , since there are gaps between bars in this representation"}
{"code": "public VerticalCategoryAxis(String label, Font labelFont,         Paint labelPaint, Insets labelInsets,         boolean verticalLabel,         boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,         boolean showTickMarks, Stroke tickMarkStroke) {   super(label, labelFont, labelPaint, labelInsets,       showTickLabels, tickLabelFont, tickLabelPaint, tickLabelInsets,       showTickMarks, tickMarkStroke);   this.verticalLabel = verticalLabel;}", "nl": "incoherencetype"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {   if (axis instanceof VerticalNumberAxis3D) {     return true;   }   else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {   VerticalAxis vAxis = getVerticalAxis();   double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();     GeneralPath backgroundPlotArea = new GeneralPath();     backgroundPlotArea.moveTo((float) plotArea.getX(), (float)plotArea.getY());     backgroundPlotArea.lineTo((float)(plotArea.getX()+effect3d),                   (float)(plotArea.getY()-effect3d));     backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),                   (float)(plotArea.getY()-effect3d));     backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),                   (float)(plotArea.getY()+plotArea.getHeight()-effect3d));     backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()-effect3d),                   (float)(plotArea.getY()+plotArea.getHeight()));     backgroundPlotArea.lineTo((float) plotArea.getX(),                   (float)(plotArea.getY()+plotArea.getHeight()));     backgroundPlotArea.lineTo((float) plotArea.getX(),                   (float) plotArea.getY());     return backgroundPlotArea;}", "nl": "Returns the shape of the background for the 3D - effect bar plot"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {      g2.setFont(labelFont);   g2.setPaint(labelPaint);   FontRenderContext frc = g2.getFontRenderContext();   LineMetrics metrics = labelFont.getLineMetrics(label, frc);   Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);   if (verticalLabel) {     double xx = drawArea.getX()+labelInsets.left+metrics.getHeight()-metrics.getDescent()     -metrics.getLeading();     double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);     drawVerticalString(label, g2, (float)xx, (float)yy);   }   else {     double xx = drawArea.getX()+labelInsets.left;     double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;     g2.drawString(label, (float)xx, (float)yy);   }      if (this.tickLabelsVisible) {     g2.setFont(tickLabelFont);     g2.setPaint(tickLabelPaint);     this.refreshTicks(g2, drawArea, plotArea);     Iterator iterator = ticks.iterator();     while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     g2.drawString(tick.getText(), tick.getX(), tick.getY());}}}", "nl": "Draws the CategoryAxis on a Java 2D graphics device"}
{"code": "protected boolean isCompatiblePlot(Plot plot) {     if (plot instanceof CategoryPlot) return true;     else return false;}", "nl": "Returns true if the specified plot is compatible with the axis , and false otherwise"}
{"code": "protected void drawBars(Graphics2D g2, Shape backgroundPlotArea, Rectangle2D plotArea) {     VerticalAxis vAxis = getVerticalAxis();   double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();        if ((outlineStroke!=null) && (outlinePaint!=null)) {     g2.setStroke(outlineStroke);     g2.setPaint(outlinePaint);     g2.draw(new Line2D.Double(plotArea.getX()+effect3d, plotArea.getY()-effect3d,               plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));     g2.draw(new Line2D.Double(plotArea.getX(), plotArea.getY()+plotArea.getHeight(),               plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));     g2.draw(new Line2D.Double(plotArea.getX()+effect3d,                     plotArea.getY()+plotArea.getHeight()-effect3d,                     plotArea.getX()+plotArea.getWidth(),                     plotArea.getY()+plotArea.getHeight()-effect3d));   }   super.drawBars(g2, backgroundPlotArea, plotArea);}", "nl": "Draws the bars"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,              double reservedHeight) {      Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());   double labelWidth = this.labelInsets.left+labelInsets.right;   if (this.verticalLabel) {     labelWidth = labelWidth + labelBounds.getHeight();     }   else {     labelWidth = labelWidth + labelBounds.getWidth();   }      double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;   if (tickLabelsVisible) {     this.refreshTicks(g2, drawArea, drawArea);     tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);   }   return new Rectangle2D.Double(drawArea.getX(), drawArea.getY(), labelWidth+tickLabelWidth,             drawArea.getHeight()-reservedHeight);}", "nl": "Returns the area required to draw the axis in the specified draw area"}
{"code": "double calculateBarWidth(Rectangle2D plotArea) {   CategoryDataset data = getDataset();      int categoryCount = data.getCategoryCount();   int seriesCount = data.getSeriesCount();   int barCount = renderer.barWidthsPerCategory(data)*categoryCount;        double usable = plotArea.getWidth() *                   (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);     if (renderer.barWidthsPerCategory(data)>1) {     }      return usable/barCount;}", "nl": "Returns the width of each bar in the chart"}
{"code": "public void addVerticalLine(Number location, Paint color) {     if (verticalLines == null) {       verticalLines = new ArrayList();       verticalColors = new ArrayList();     }     verticalColors.add(color);     verticalLines.add(location);}", "nl": "Adds a vertical of the given color at location with the given color"}
{"code": "public ValueAxis getHorizontalValueAxis() {   return (ValueAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a ValueAxis"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea) {        if (insets!=null) {     drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,               drawArea.getY()+insets.top,               drawArea.getWidth()-insets.left-insets.right,               drawArea.getHeight()-insets.top-insets.bottom);   }      HorizontalAxis hAxis = getHorizontalAxis();   VerticalAxis vAxis = getVerticalAxis();   double hAxisAreaHeight = hAxis.reserveHeight(g2, this, drawArea);   Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);        Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),                 drawArea.getY(),                 drawArea.getWidth()-vAxisArea.getWidth(),                 drawArea.getHeight()-hAxisAreaHeight);        drawOutlineAndBackground(g2, plotArea);   this.horizontalAxis.draw(g2, drawArea, plotArea);   this.verticalAxis.draw(g2, drawArea, plotArea);               XYDataset data = this.getDataset();     if (data!=null) {     Shape originalClip = g2.getClip();     g2.clip(plotArea);       drawVerticalLines(g2, plotArea);       drawHorizontalLines(g2, plotArea);       double transRangeZero = this.getVerticalValueAxis().translatedValue(Plot.ZERO, plotArea);       int seriesCount = data.getSeriesCount();       for (int series=0; series<seriesCount; series++) {         int itemCount = data.getItemCount(series);         for (int item=0; item<itemCount; item++) {           renderer.drawItem(g2, plotArea, this, (ValueAxis)hAxis, (ValueAxis)vAxis,                     data, series, item, transRangeZero);         }       }       g2.setClip(originalClip);}}", "nl": "Draws the XY plot on a Java 2D graphics device"}
{"code": "protected void drawBars(Graphics2D g2, Shape backgroundPlotArea, Rectangle2D plotArea) {          CategoryDataset data = this.getDataset();     if (data!=null) {       Shape savedClip = g2.getClip();       g2.clip(backgroundPlotArea);       int seriesCount = data.getSeriesCount();       int categoryCount = data.getCategoryCount();       int barCount = renderer.barWidthsPerCategory(data);       double translatedZero = getValueAxis().translatedValue(Plot.ZERO, plotArea);              double categorySpan = 0.0;       double categoryGapSpan = 0.0;       if (categoryCount>1) {         categorySpan = plotArea.getWidth()                  * (1-introGapPercent-trailGapPercent-categoryGapsPercent);         categoryGapSpan = plotArea.getWidth()*categoryGapsPercent;       }       else {         categorySpan = plotArea.getWidth()*(1-introGapPercent-trailGapPercent);       }              double itemSpan = categorySpan;       double itemGapSpan = 0.0;       if (seriesCount>1) {         if (renderer.hasItemGaps()) {           itemGapSpan = plotArea.getWidth()*itemGapsPercent;           itemSpan = itemSpan - itemGapSpan;         }       }       double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));       int categoryIndex = 0;     Iterator iterator = data.getCategories().iterator();     while (iterator.hasNext()) {     Object category = iterator.next();     for (int series=0; series<seriesCount; series++) {           renderer.drawBar(g2, plotArea, this, getValueAxis(), data, series,                    category, categoryIndex,                    translatedZero, itemWidth, categorySpan, categoryGapSpan,                    itemSpan, itemGapSpan);         }         categoryIndex++;       }              Line2D baseline = new Line2D.Double(plotArea.getX(), translatedZero,                         plotArea.getMaxX(), translatedZero);       g2.setStroke(new BasicStroke());       g2.draw(baseline);       g2.setClip(savedClip);}}", "nl": "Draws charts bars g2 The graphics device ; clipped drawn"}
{"code": "private void drawVerticalLines(Graphics2D g2, Rectangle2D plotArea) {          if (verticalLines != null) {       for (int i=0; i<verticalLines.size(); i++) {         g2.setPaint((Paint)verticalColors.get(i));         g2.setStroke(new BasicStroke(1));         g2.drawLine((int)getHorizontalValueAxis().translatedValue((Number)verticalLines.get(i), plotArea),               0,               (int)getHorizontalValueAxis().translatedValue((Number)verticalLines.get(i), plotArea),               (int)(plotArea.getHeight()));}}}", "nl": "Support method for the draw"}
{"code": "public double getCategoryCoordinate(int category, Rectangle2D area) {          double result = area.getX() + (area.getWidth()*introGapPercent);        int categoryCount = getDataset().getCategoryCount();     if (categoryCount>1) {     double categorySpan = area.getWidth()                   * (1-introGapPercent-trailGapPercent-categoryGapsPercent);       double categoryGapSpan = area.getWidth()*categoryGapsPercent;       result = result            + (category+0.5)*(categorySpan/categoryCount)            + (category)*(categoryGapSpan/(categoryCount-1));     }     else {       result = result            + (category+0.5)*area.getWidth()*(1-introGapPercent-trailGapPercent);     }     return result;}", "nl": "Returns the x - coordinate of the center of the specified category"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea) {        if (insets!=null) {     drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,               drawArea.getY()+insets.top,               drawArea.getWidth()-insets.left-insets.right,               drawArea.getHeight()-insets.top-insets.bottom);   }     if ((drawArea.getWidth()>=MINIMUM_WIDTH_TO_DRAW) && (drawArea.getHeight()>=MINIMUM_HEIGHT_TO_DRAW)) {              HorizontalAxis hAxis = getHorizontalAxis();       VerticalAxis vAxis = getVerticalAxis();       double hAxisAreaHeight = hAxis.reserveHeight(g2, this, drawArea);       Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);              Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),                               drawArea.getY(),                               drawArea.getWidth()-vAxisArea.getWidth(),                               drawArea.getHeight()-hAxisAreaHeight);       Shape backgroundPlotArea = calculateBackgroundPlotArea(plotArea);              drawOutlineAndBackground(g2, backgroundPlotArea);       getCategoryAxis().draw(g2, drawArea, plotArea);       getValueAxis().draw(g2, drawArea, plotArea);       drawBars(g2, backgroundPlotArea, plotArea);}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public Number getMaximumHorizontalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMaximumDomainValue(data);   }   else return null;}", "nl": "Returns the maximum value in the domain , since this is plotted against the horizontal axis for an XYPlot"}
{"code": "public void setRenderer(VerticalBarRenderer renderer) {     this.renderer = renderer;     this.notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the renderer for the bar plot"}
{"code": "public Number getMinimumVerticalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumRangeValue(data);   }   else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the vertical axis for an XYPlot"}
{"code": "public CategoryAxis getCategoryAxis() {   return (CategoryAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a CategoryAxis"}
{"code": "public Number getMinimumHorizontalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumDomainValue(data);   }   else return null;}", "nl": "Returns the minimum value in the domain , since this is plotted against the horizontal axis for an XYPlot"}
{"code": "public VerticalBarPlot(Axis horizontalAxis, Axis verticalAxis)     throws AxisNotCompatibleException, PlotNotCompatibleException   {   super(horizontalAxis, verticalAxis);     this.renderer = new VerticalBarRenderer();}", "nl": "Standard constructor - builds a VerticalBarPlot with mostly default attributes"}
{"code": "protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {     return plotArea;}", "nl": "Returns chart ' s backgroud area"}
{"code": "private void drawHorizontalLines(Graphics2D g2, Rectangle2D plotArea) {          if (horizontalLines != null) {       for (int i=0; i<horizontalLines.size(); i++) {         g2.setPaint((Paint)horizontalColors.get(i));         g2.setStroke(new BasicStroke(1));         g2.drawLine(0,               (int)getVerticalValueAxis().translatedValue((Number)horizontalLines.get(i), plotArea),               (int)(plotArea.getWidth()),               (int)getVerticalValueAxis().translatedValue((Number)horizontalLines.get(i), plotArea));}}}", "nl": "Support method for the draw"}
{"code": "public void addHorizontalLine(Number location) {     addHorizontalLine(location, Color.red);}", "nl": "Adds a horizontal line at location with default color red"}
{"code": "public VerticalBarPlot(Axis horizontal, Axis vertical, Insets insets,          double introGapPercent, double trailGapPercent,                double categoryGapPercent, double seriesGapPercent)     throws AxisNotCompatibleException, PlotNotCompatibleException   {   super(horizontal, vertical, insets,       introGapPercent, trailGapPercent, categoryGapPercent, seriesGapPercent);     this.renderer = new VerticalBarRenderer();}", "nl": "incoherencetype"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {   if (axis instanceof HorizontalNumberAxis) {     return true;   }   else if (axis instanceof HorizontalDateAxis) {     return true;   }   else return false;}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public XYItemRenderer getItemRenderer() {     return this.renderer;}", "nl": "Returns a reference to the current item renderer"}
{"code": "public CategoryDataset getDataset() {   return (CategoryDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as a CategoryDataset"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {   if (axis instanceof VerticalNumberAxis) {     return true;   }   else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public XYDataset getDataset() {   return (XYDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as an XYDataset"}
{"code": "public java.util.List getCategories() {   return getDataset().getCategories();}", "nl": "A convenience method that returns a list of the categories in the dataset"}
{"code": "public void drawOutlineAndBackground(Graphics2D g2, Shape area) {   if (backgroundPaint!=null) {     g2.setPaint(backgroundPaint);     g2.fill(area);   }   if ((outlineStroke!=null) && (outlinePaint!=null)) {     g2.setStroke(outlineStroke);     g2.setPaint(outlinePaint);     g2.draw(area);}}", "nl": "Draws the plot outline and background"}
{"code": "public VerticalNumberAxis getValueAxis() {   return (VerticalNumberAxis)verticalAxis;}", "nl": "A convenience method that returns a reference to the vertical axis cast as a VerticalNumberAxis"}
{"code": "public int barWidthsPerCategory(CategoryDataset data) {     return data.getSeriesCount();}", "nl": "Returns the number of bar - widths displayed in each category"}
{"code": "public boolean hasItemGaps() {     return true;}", "nl": "Returns true , since for this renderer there are gaps between the items in one category"}
{"code": "public ValueAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,        boolean tickLabelsVisible,            Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,        boolean tickMarksVisible, Stroke tickMarkStroke,        boolean autoRange, boolean autoTickUnit,        boolean showGridLines, Stroke gridStroke, Paint gridPaint) {   super(label, labelFont, labelPaint, labelInsets,       tickLabelsVisible, tickLabelFont, tickLabelPaint, tickLabelInsets,       tickMarksVisible, tickMarkStroke);   this.autoRange = autoRange;   this.autoTickUnit = autoTickUnit;   this.showGridLines = showGridLines;   this.gridStroke = gridStroke;   this.gridPaint = gridPaint;}", "nl": "Constructs a value axis"}
{"code": "public void setGridStroke(Stroke stroke) {   gridStroke = stroke;   notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the Stroke used to draw the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "public boolean isShowGridLines() {   return showGridLines;}", "nl": "Returns true if the grid lines are visible for this axis , and false otherwise"}
{"code": "public void setShowGridLines(boolean show) {   showGridLines = show;   notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the visibility of the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "public void setAutoTickValue(boolean flag) {     if (this.autoTickUnit!=flag) {       this.autoTickUnit = flag;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets a flag indicating whether or not the tick unit is automatically selected from a range of standard tick units"}
{"code": "public ValueAxis(String label) {   super(label);   this.autoRange = true;   this.autoTickUnit = true;   this.showGridLines = true;   this.gridStroke = ValueAxis.DEFAULT_GRID_LINE_STROKE;     this.gridPaint = Color.gray;}", "nl": "Constructs a value axis"}
{"code": "public Stroke getGridStroke() {   return gridStroke;}", "nl": "Returns the Stroke used to draw the grid lines"}
{"code": "public boolean isAutoRange() {   return autoRange;}", "nl": "Returns true if the axis range is automatically adjusted to fit the data , and false otherwise"}
{"code": "public VerticalNumberAxis3D(String label, Font labelFont, Paint labelPaint, Insets labelInsets,           boolean verticalLabel,           boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint,                 Insets tickLabelInsets,           boolean showTickMarks, Stroke tickMarkStroke,           boolean autoRange, boolean autoRangeIncludesZero,                 Number autoRangeMinimum,           Number minimumAxisValue, Number maximumAxisValue,           boolean autoTickUnit, NumberTickUnit tickUnit,                            boolean showGridLines, Stroke gridStroke, Paint gridPaint,                 double effect3d) {   super(label, labelFont, labelPaint, labelInsets, verticalLabel, showTickLabels,         tickLabelFont, tickLabelPaint,       tickLabelInsets, showTickMarks, tickMarkStroke,       autoRange, autoRangeIncludesZero, autoRangeMinimum,       minimumAxisValue, maximumAxisValue,         autoTickUnit, tickUnit,                  showGridLines, gridStroke, gridPaint);   this.effect3d = effect3d;}", "nl": "Full constructor : returns a new VerticalValueAxis"}
{"code": "public VerticalNumberAxis3D(String label) {   super(label);}", "nl": "Standard constructor - builds a VerticalValueAxis with mostly default attributes"}
{"code": "public void setTitle(String text) {   this.title = text;}", "nl": "Sets the title to the specified text and notifies registered listeners that the title has been modified"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {      if (this.label!=null) {     g2.setFont(labelFont);     g2.setPaint(labelPaint);     Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());     if (labelDrawnVertical) {     double xx = drawArea.getX()+labelInsets.left+labelBounds.getHeight();     double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);     drawVerticalString(label, g2, (float)xx, (float)yy);     }     else {     double xx = drawArea.getX()+labelInsets.left;     double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;     g2.drawString(label, (float)xx, (float)yy);     }   }      this.refreshTicks(g2, drawArea, plotArea);   double xx = plotArea.getX();   g2.setFont(tickLabelFont);   Iterator iterator = ticks.iterator();   while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     float yy = (float)this.translatedValue(tick.getNumericalValue(), plotArea);     if (tickLabelsVisible) {     g2.setPaint(this.tickLabelPaint);     g2.drawString(tick.getText(), tick.getX(), tick.getY());     }     if (tickMarksVisible) {     g2.setStroke(this.getTickMarkStroke());     Line2D mark = new Line2D.Double(plotArea.getX()-2, yy,             plotArea.getX(), yy);     g2.draw(mark);     }     if (showGridLines) {     g2.setStroke(gridStroke);     g2.setPaint(gridPaint);     Line2D gridline = new Line2D.Double(xx+effect3d, yy-effect3d,               plotArea.getMaxX(), yy-effect3d);     g2.draw(gridline);     Line2D grid3Dline = new Line2D.Double(xx, yy,               xx+effect3d, yy-effect3d);     g2.draw(grid3Dline);}}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public void removeChangeListener(TitleChangeListener listener) {   listeners.remove(listener);}", "nl": "Unregisters an object for notification of changes to the chart title"}
{"code": "protected Title(String title) {   this.title = title;   this.listeners = new java.util.ArrayList();}", "nl": "Standard constructor - builds a Title object"}
{"code": "public void addChangeListener(TitleChangeListener listener) {   listeners.add(listener);}", "nl": "Registers an object for notification of changes to the title"}
{"code": "public static Title createInstance(String title, Font font) {   return new StandardTitle(title, font);}", "nl": "Static factory method that returns a concrete subclass of Title"}
{"code": "public String getText() {   return text;}", "nl": "Returns the text version of the tick value"}
{"code": "public Tick(String text, float x, float y) {   this(text, text, x, y);}", "nl": "incoherencetype"}
{"code": "public Tick(Object value, String text, float x, float y) {   this.value = value;   this.text = text;   this.x=x;   this.y=y;}", "nl": "incoherencetype"}
{"code": "public float getX() {   return x;}", "nl": "Returns the x - coordinate of the tick"}
{"code": "public Number getNumericalValue() {   if (value instanceof Number) {     return (Number)value;   }   else if (value instanceof Date) {     return new Long(((Date)value).getTime());   }   else return null;}", "nl": "Returns the numerical value of the tick , or null if the value is not a Number"}
{"code": "public double getPreferredWidth(Graphics2D g2) {     g2.setFont(font);     FontRenderContext frc = g2.getFontRenderContext();     Rectangle2D titleBounds = font.getStringBounds(text, frc);     double titleWidth = insets.left+titleBounds.getWidth()+insets.right;     return titleWidth;}", "nl": "Returns the preferred width of the title"}
{"code": "public void setPaint(Paint paint) {     if (!this.paint.equals(paint)) {       this.paint = paint;       notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the Paint used to display the title and notifies registered listeners that the title has been modified"}
{"code": "public TextTitle(String text) {     this(text, new Font(\"Dialog\", Font.PLAIN, 12));}", "nl": "Default constructor - builds a TextTitle with some default attributes"}
{"code": "public void setText(String text) {     if (!this.text.equals(text)) {       this.text = text;       notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the title to the specified text"}
{"code": "public boolean isValidPosition(int position) {     if ((position==AbstractTitle.TOP) || (position==AbstractTitle.BOTTOM)) return true;     else return false;}", "nl": "Returns true for the positions that are valid for TextTitle and false for all other positions"}
{"code": "public TextTitle(String text, Font font, Paint paint, int position, int horizontalAlignment,            int verticalAlignment, Insets insets) {     super(position, horizontalAlignment, verticalAlignment, insets);     this.text = text;     this.font = font;     this.paint = paint;}", "nl": "Full constructor - builds a TextTitle with the specified properties"}
{"code": "public TextTitle(String text, Font font) {     this(text, font, Color.black);}", "nl": "Default constructor - builds a TextTitle with some default attributes"}
{"code": "public double getPreferredHeight(Graphics2D g2) {     g2.setFont(font);     FontRenderContext frc = g2.getFontRenderContext();     LineMetrics lineMetrics = font.getLineMetrics(text, frc);     double titleHeight = insets.top+lineMetrics.getHeight()+insets.bottom;     return titleHeight;}", "nl": "Returns the preferred height of the title"}
{"code": "public String getText() {     return text;}", "nl": "Returns the title text"}
{"code": "public JFreeChart getChart() {     return chart;}", "nl": "Returns a reference to the chart that generated the change event"}
{"code": "public void setChart(JFreeChart chart) {     this.chart = chart;}", "nl": "Sets the chart that generated the change event"}
{"code": "public int getType() {     return this.type;}", "nl": "Returns the event type"}
{"code": "public ChartChangeEvent(Object source, JFreeChart chart, int type) {     super(source);     this.chart = chart;     this.type = type;}", "nl": "Full constructor : returns a new ChartChangeEvent object with the specified type"}
{"code": "public ChartChangeEvent(Object source) {     this(source, null, GENERAL);}", "nl": "Standard constructor : returns a new ChartChangeEvent object , type GENERAL"}
{"code": "public StandardXYItemRenderer() {     this.plotShapes = true;     this.plotLines = false;}", "nl": "Default constructor"}
{"code": "public void drawItem(Graphics2D g2, Rectangle2D plotArea,              Plot plot, ValueAxis horizontalAxis, ValueAxis verticalAxis,              XYDataset data, int series, int item,              double translatedRangeZero) {     Paint seriesPaint = plot.getSeriesPaint(series);     Stroke seriesStroke = plot.getSeriesStroke(series);     g2.setPaint(seriesPaint);     g2.setStroke(seriesStroke);          Number x1 = data.getXValue(series, item);     Number y1 = data.getYValue(series, item);     double transX1 = horizontalAxis.translatedValue(x1, plotArea);     double transY1 = verticalAxis.translatedValue(y1, plotArea);     if (this.plotShapes) {       Shape shape = plot.getShape(series, item, transX1, transY1, shapeScale);       g2.draw(shape);     }     if (this.plotLines) {       if (item>0) {                  Number x0 = data.getXValue(series, item-1);         Number y0 = data.getYValue(series, item-1);         double transX0 = horizontalAxis.translatedValue(x0, plotArea);         double transY0 = verticalAxis.translatedValue(y0, plotArea);         Line2D line = new Line2D.Double(transX0, transY0, transX1, transY1);         g2.draw(line);}}}", "nl": "Draws the visual representation of a single data item"}
{"code": "public AxisChangeEvent(Axis axis) {     super(axis);     this.axis = axis;}", "nl": "Default constructor : returns a new AxisChangeEvent"}
{"code": "public boolean getPlotLines() {     return this.plotLines;}", "nl": "Returns true if lines are being plotted by the renderer"}
{"code": "public TickUnit getNearestTickUnit(TickUnit unit) {     int index = Collections.binarySearch(units, unit);     if (index>=0) {       return (TickUnit)units.get(index);     }     else {       index = -(index + 1);       return (TickUnit)units.get(Math.min(index, units.size()));}}", "nl": "Returns the tick unit in the collection that is closest in size to the specified unit"}
{"code": "public int barWidthsPerCategory(CategoryDataset data) {     return data.getSeriesCount();}", "nl": "This renderer shows each series within a category as a separate bar"}
{"code": "public boolean hasItemGaps() {     return true;}", "nl": "Returns true , since for this renderer there are gaps between the items in one category"}
{"code": "public SampleXYDataset() {     this.translate = 0.0;}", "nl": "Default constructor"}
{"code": "private double getMaxTickLabelHeight(Graphics2D g2, Rectangle2D drawArea, boolean vertical) {   Font font = getTickLabelFont();   g2.setFont(font);   FontRenderContext frc = g2.getFontRenderContext();   double maxHeight = 0.0;   if (vertical) {     Iterator iterator = this.ticks.iterator();     while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);     if (labelBounds.getWidth()>maxHeight) {       maxHeight = labelBounds.getWidth();     }     }   }   else {     LineMetrics metrics = font.getLineMetrics(\"Sample\", frc);     maxHeight = metrics.getHeight();   }   return maxHeight;}", "nl": "A utility method for determining the height of the tallest tick label"}
{"code": "public int getSeriesCount() {     return 2;}", "nl": "Returns the number of series in the data source"}
{"code": "public Number getYValue(int series, int item) {     if (series==0) {       return new Double(Math.cos(-10.0+translate+(item/10.0)));     }     else return new Double(2*(Math.sin(-10.0+translate+(item/10.0))));}", "nl": "Returns the y - value for the specified series and item"}
{"code": "private boolean tickLabelsFit(int index,           Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {       SimpleDateFormat dateFormatter = new SimpleDateFormat(standardTickFormats[index]);   DateUnit units = new DateUnit(this.standardTickUnits[index][0], this.standardTickUnits[index][1]);   double lastLabelExtent = Double.NEGATIVE_INFINITY;   double labelExtent;   boolean labelsFit = true;   Date tickDate = this.calculateLowestVisibleTickValue(units);   while (tickDate.before(this.maximumDate) && labelsFit) {     double xx = this.translatedValue(tickDate, plotArea);     String tickLabel = dateFormatter.format(tickDate);     Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,                   g2.getFontRenderContext());     if (this.verticalTickLabels) {     labelExtent = xx-(tickLabelBounds.getHeight()/2);     if (labelExtent<lastLabelExtent) labelsFit = false;     lastLabelExtent = xx+(tickLabelBounds.getHeight()/2);     }     else {     labelExtent = xx-(tickLabelBounds.getWidth()/2);     if (labelExtent<lastLabelExtent) labelsFit = false;     lastLabelExtent = xx+(tickLabelBounds.getWidth()/2);     }     tickDate = units.addToDate(tickDate);   }    return labelsFit;}", "nl": "Determines whether or not the tick labels fit given the available space"}
{"code": "private void calculateAutoTickUnits(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {       int index = this.findAxisMagnitudeIndex();   boolean labelsFit = true;   while (labelsFit && index>0) {     index=index-1;     labelsFit = tickLabelsFit(index, g2, drawArea, plotArea);   }    if (labelsFit) {     this.autoTickIndex=index;   }   else {     this.autoTickIndex=Math.min(index+1, this.standardTickUnitMagnitudes.length);   }    this.tickLabelFormatter.applyPattern(this.standardTickFormats[autoTickIndex]);   this.tickUnit = new DateUnit(this.standardTickUnits[autoTickIndex][0],            this.standardTickUnits[autoTickIndex][1]);}", "nl": "Determines an appropriate tick value for the axis"}
{"code": "public void configure() {   if (isAutoRange()) {     this.autoAdjustRange();}}", "nl": "Configures the axis to work with the specified plot"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,              double reservedWidth) {       LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());   double labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;       double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;   if (tickLabelsVisible) {     g2.setFont(tickLabelFont);     this.refreshTicks(g2, drawArea, drawArea);     tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,                   this.verticalTickLabels);   }    return new Rectangle2D.Double(drawArea.getX(), drawArea.getMaxY(),             drawArea.getWidth()-reservedWidth,             labelHeight+tickLabelHeight);}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public HorizontalDateAxis(String label, Font labelFont,           Paint labelPaint, Insets labelInsets,           boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,           boolean verticalTickLabels,           boolean showTickMarks, Stroke tickMarkStroke,           boolean autoRange, Date minimumDate, Date maximumDate,           boolean autoUnits, DateUnit tickUnits, SimpleDateFormat tickLabelFormatter,           boolean showGridLines, Stroke gridStroke, Paint gridPaint) {    super(label, labelFont, labelPaint, labelInsets,       showTickLabels, tickLabelFont, tickLabelPaint, tickLabelInsets,       showTickMarks, tickMarkStroke,       autoRange, minimumDate, maximumDate, autoUnits, tickUnits, tickLabelFormatter,       showGridLines, gridStroke, gridPaint);    this.verticalTickLabels = verticalTickLabels;}", "nl": "Full constructor : returns a new HorizontalDateAxis with attributes as specified by the caller"}
{"code": "public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {       double labelHeight = 0.0;   if (label!=null) {     LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());     labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;   }       double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;   if (tickLabelsVisible) {     g2.setFont(tickLabelFont);     this.refreshTicks(g2, drawArea, drawArea);     tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,                   this.verticalTickLabels);   }   return labelHeight+tickLabelHeight;}", "nl": "Returns the height required to draw the axis in the specified draw area"}
{"code": "public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {   this.ticks.clear();   g2.setFont(tickLabelFont);   if (this.autoTickUnit) {     calculateAutoTickUnits(g2, drawArea, plotArea);   }    Date tickDate = this.calculateLowestVisibleTickValue(tickUnit);   while (tickDate.before(this.maximumDate)) {          double xx = this.translatedValue(tickDate, plotArea);     String tickLabel = this.tickLabelFormatter.format(tickDate);     Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,                   g2.getFontRenderContext());     float x = 0.0f;     float y = 0.0f;     if (this.verticalTickLabels) {     x = (float)(xx+tickLabelBounds.getHeight()/2);     y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getWidth());     }     else {     x = (float)(xx-tickLabelBounds.getWidth()/2);     y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getHeight());     }     Tick tick = new Tick(tickDate, tickLabel, x, y);     ticks.add(tick);     tickDate = this.tickUnit.addToDate(tickDate);}}", "nl": "Recalculates the ticks for the date axis"}
{"code": "public void autoAdjustRange() {   if (plot!=null) {     if (plot instanceof HorizontalValuePlot) {     HorizontalValuePlot hvp = (HorizontalValuePlot)plot;          Number u = hvp.getMaximumHorizontalDataValue();         long upper = new Date().getTime()+24L*60L*60L*1000L;         if (u!=null) {       upper = u.longValue();         }          Number l = hvp.getMinimumHorizontalDataValue();         long lower = new Date().getTime();         if (l!=null) {       lower = l.longValue();         }      long range = upper-lower;     upper = upper+(range/20);     lower = lower-(range/20);     this.minimumDate=new Date(lower);     this.maximumDate=new Date(upper);}}}", "nl": "Rescales the axis to ensure that all data is visible"}
{"code": "public boolean getVerticalTickLabels() {   return this.verticalTickLabels;}", "nl": "Returns a flag indicating whether the tick labels are drawn ' vertically '"}
{"code": "public HorizontalDateAxis() {   super(null);   this.verticalTickLabels = false;}", "nl": "Default constructor"}
{"code": "public void setDrawOpenCloseTicks(boolean draw) {   if (drawOpenClose != draw) {     drawOpenClose = draw;       notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the property that tells this plot to draw open close marks"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {   if (axis instanceof HorizontalNumberAxis) {     return true;   }   else if (axis instanceof HorizontalDateAxis) {     return true;   }     else return false;}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "private java.util.List getLines(Rectangle2D plotArea) {   ArrayList elements = new ArrayList();   HighLowDataset data = getDataset();   if (data != null) {     int seriesCount = data.getSeriesCount();      for (int series=0; series<seriesCount; series++) {       int itemCount = data.getItemCount(series);                      for(int itemIndex = 0; itemIndex < itemCount; itemIndex++) {         Number x = data.getXValue(series, itemIndex);         Number yHigh  = data.getHighValue(series,itemIndex);         Number yLow   = data.getLowValue(series,itemIndex);         Number yOpen  = data.getOpenValue(series,itemIndex);         Number yClose = data.getCloseValue(series,itemIndex);          double xx = getHorizontalValueAxis().translatedValue(x, plotArea);         double yyHigh = getVerticalValueAxis().translatedValue(yHigh, plotArea);         double yyLow = getVerticalValueAxis().translatedValue(yLow, plotArea);         double yyOpen = getVerticalValueAxis().translatedValue(yOpen, plotArea);         double yyClose = getVerticalValueAxis().translatedValue(yClose, plotArea);          Paint p = this.getSeriesPaint(series);         Stroke s = this.getSeriesStroke(series);          elements.add(new HighLow(xx, yyHigh, yyLow, yyOpen, yyClose, s, p));       }     }   }   return elements;}", "nl": "Returns a list of HighLow elements that will fit inside the specified area"}
{"code": "public Number getMaximumHorizontalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMaximumDomainValue(data);   }   else return null;}", "nl": "Returns the maximum value in the domain , since this is plotted against the horizontal axis for a HighLowPlot"}
{"code": "public boolean getDrawOpenCloseTicks() {   return drawOpenClose;}", "nl": "Returns true if this plot draws open close marks"}
{"code": "public HighLowPlot(Axis horizontalAxis, Axis verticalAxis) throws AxisNotCompatibleException,                                     PlotNotCompatibleException   {   super(horizontalAxis, verticalAxis);}", "nl": "Standard constructor : returns an HiLowPlot with attributes specified by the caller"}
{"code": "public HighLowDataset getDataset() {   return (HighLowDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as an HighLowDataset"}
{"code": "public String getPlotType() {   return \"HiLow Plot\";}", "nl": "Returns the plot type as a string"}
{"code": "public Number getMinimumVerticalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumRangeValue(data);   }   else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the vertical axis for a HighLowPlot"}
{"code": "public Number getMinimumHorizontalDataValue() {    Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumDomainValue(data);   }   else return null;}", "nl": "Returns the minimum value in the domain , since this is plotted against the horizontal axis for a HighLowPlot"}
{"code": "public void setRenderer(HorizontalBarRenderer renderer) {     this.renderer = renderer;     this.notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the renderer for the bar plot"}
{"code": "public double getCategoryCoordinate(int category, Rectangle2D area) {           double result = area.getY()+(area.getHeight()*introGapPercent);            int categoryCount = getDataset().getCategoryCount();     if (categoryCount>1) {      double categorySpan = area.getHeight()                   *(1-introGapPercent-trailGapPercent-categoryGapsPercent);       double categoryGapSpan = area.getHeight()*categoryGapsPercent;       result = result            + (category+0.5)*(categorySpan/categoryCount)            + (category)*(categoryGapSpan/(categoryCount-1));      }     else {       result = result            + (category+0.5)*area.getHeight()*(1-introGapPercent-trailGapPercent);     }      return result;}", "nl": "Returns the x - coordinate of the center of the specified category"}
{"code": "public CategoryDataset getDataset() {   return (CategoryDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as a CategoryDataset"}
{"code": "double calculateBarWidth(Rectangle2D plotArea) {    CategoryDataset data = getDataset();       int categoryCount = data.getCategoryCount();   int seriesCount = data.getSeriesCount();   int barCount = renderer.barWidthsPerCategory(data)*categoryCount;       double usable = plotArea.getHeight() *                   (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);      if (renderer.barWidthsPerCategory(data)>1) {     }       return usable/barCount;}", "nl": "Returns the width of each bar in the chart"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {   if (axis instanceof HorizontalNumberAxis) {     return true;   }   else return false;}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public CategoryAxis getCategoryAxis() {   return (CategoryAxis)verticalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a CategoryAxis"}
{"code": "public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis, Insets insets,          double introGapPercent, double trailGapPercent,                double categoryGapPercent, double seriesGapPercent)     throws AxisNotCompatibleException, PlotNotCompatibleException   {    super(horizontalAxis, verticalAxis, insets,         introGapPercent, trailGapPercent, categoryGapPercent, seriesGapPercent);     this.renderer = new HorizontalBarRenderer();}", "nl": "Standard constructor : returns a BarPlot with attributes specified by the caller"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea) {         if (insets!=null) {     drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,               drawArea.getY()+insets.top,               drawArea.getWidth()-insets.left-insets.right,               drawArea.getHeight()-insets.top-insets.bottom);   }       VerticalAxis vAxis = getVerticalAxis();   HorizontalAxis hAxis = getHorizontalAxis();   double vAxisAreaWidth = vAxis.reserveWidth(g2, this, drawArea);   Rectangle2D hAxisArea = hAxis.reserveAxisArea(g2, this, drawArea, vAxisAreaWidth);       Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisAreaWidth,                 drawArea.getY(),                 drawArea.getWidth()-vAxisAreaWidth,                 drawArea.getHeight()-hAxisArea.getHeight());         drawOutlineAndBackground(g2, plotArea);   getCategoryAxis().draw(g2, drawArea, plotArea);   getValueAxis().draw(g2, drawArea, plotArea);           CategoryDataset data = this.getDataset();     if (data!=null) {       Shape savedClip = g2.getClip();       g2.clip(plotArea);               double translatedZero = getValueAxis().translatedValue(Plot.ZERO, plotArea);       Line2D baseline = new Line2D.Double(translatedZero, plotArea.getY(),                         translatedZero, plotArea.getMaxY());       g2.setStroke(new BasicStroke());       g2.draw(baseline);        int seriesCount = data.getSeriesCount();       int categoryCount = data.getCategoryCount();       int barCount = renderer.barWidthsPerCategory(data);               double categorySpan = 0.0;       double categoryGapSpan = 0.0;       if (categoryCount>1) {         categorySpan = plotArea.getHeight()*                  (1-introGapPercent-trailGapPercent-categoryGapsPercent);         categoryGapSpan = plotArea.getHeight()*categoryGapsPercent;       }       else {         categorySpan = plotArea.getHeight()*(1-introGapPercent-trailGapPercent);       }               double itemSpan = categorySpan;       double itemGapSpan = 0.0;       if (seriesCount>1) {         if (renderer.hasItemGaps()) {           itemGapSpan = plotArea.getHeight()*itemGapsPercent;           itemSpan = itemSpan - itemGapSpan;         }       }       double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));        int categoryIndex = 0;       Iterator iterator = data.getCategories().iterator();       while (iterator.hasNext()) {          Object category = iterator.next();         for (int series=0; series<seriesCount; series++) {           renderer.drawBar(g2, plotArea, this, this.getValueAxis(), data, series,                    category, categoryIndex,                    translatedZero, itemWidth, categorySpan, categoryGapSpan,                    itemSpan, itemGapSpan);         }         categoryIndex++;        }        g2.setClip(savedClip);}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public HorizontalNumberAxis getValueAxis() {   return (HorizontalNumberAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the vertical axis cast as a VerticalValueAxis"}
{"code": "public String getPlotType() {   return \"Horizontal Bar Plot\";}", "nl": "Returns a short string describing the type of plot"}
{"code": "public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis)       throws AxisNotCompatibleException, PlotNotCompatibleException   {      super(horizontalAxis, verticalAxis);     this.renderer = new HorizontalBarRenderer();}", "nl": "Constructs a horizontal bar plot with the specified axes"}
{"code": "public double getTickSize() {   return tickSize;}", "nl": "Returns the width of the open close tick"}
{"code": "public HighLow(double x, double high, double low, double open, double close,        Stroke stroke, Paint paint) {      this.line = new Line2D.Double(x, high, x, low);   this.open = open;   this.close = close;   this.stroke = stroke;   this.paint = paint;}", "nl": "Constructs a high - low item"}
{"code": "public Line2D getOpenTickLine() {   return getTickLine(getLine().getX1(), getValue(OPEN), (-1) * getTickSize());}", "nl": "Returns the line for open tick"}
{"code": "public double getValue(int valueType) {   if (valueType == OPEN)     return open;   else     return close;}", "nl": "Returns either OPEN or Close value depending on the valueType"}
{"code": "public Stroke getStroke() {   return stroke;}", "nl": "Returns the Stroke object used to draw the line"}
{"code": "public Line2D getLine() {   return line;}", "nl": "Returns the line"}
{"code": "public HighLow(double x, double high, double low) {   this(x, high, low, high, low, new BasicStroke(), Color.blue);}", "nl": "Constructs a high - low item , with default values for the open close and colors"}
{"code": "public int getField() {   return this.field;}", "nl": "Returns the field used for this DateUnit"}
{"code": "public boolean getVerticalTickLabels() {   return this.verticalTickLabels;}", "nl": "Returns a flag indicating whether the tick labels are drawn ' vertically '"}
{"code": "public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {       LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());   double labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;       double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;   if (tickLabelsVisible) {     g2.setFont(tickLabelFont);     this.refreshTicks(g2, drawArea, drawArea);     tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,                   this.verticalTickLabels);   }   return labelHeight+tickLabelHeight;}", "nl": "Returns the height required to draw the axis in the specified draw area"}
{"code": "public void autoAdjustRange() {    if (plot!=null) {     if (plot instanceof HorizontalValuePlot) {     HorizontalValuePlot hvp = (HorizontalValuePlot)plot;          Number u = hvp.getMaximumHorizontalDataValue();         double upper = this.DEFAULT_MAXIMUM_AXIS_VALUE.doubleValue();         if (u!=null) {       upper = u.doubleValue();         }          Number l = hvp.getMinimumHorizontalDataValue();         double lower = this.DEFAULT_MINIMUM_AXIS_VALUE.doubleValue();         if (l!=null) {       lower = l.doubleValue();         }      double range = upper-lower;               double minRange = this.autoRangeMinimumSize.doubleValue();     if (range<minRange) {       upper = (upper+lower+minRange)/2;       lower = (upper+lower-minRange)/2;     }      if (this.autoRangeIncludesZero()) {       if (upper!=0.0) upper = Math.max(0.0, upper+upperMargin*range);       if (lower!=0.0) lower = Math.min(0.0, lower-lowerMargin*range);     }     else {       if (upper!=0.0) upper = upper+upperMargin*range;       if (lower!=0.0) lower = lower-lowerMargin*range;     }      this.minimumAxisValue=new Double(lower);     this.maximumAxisValue=new Double(upper);}}}", "nl": "Rescales the axis to ensure that all data is visible"}
{"code": "public void setVerticalTickLabels(boolean flag) {   this.verticalTickLabels = flag;   this.notifyListeners(new com.jrefinery.chart.event.AxisChangeEvent(this));}", "nl": "Sets the flag that determines whether the tick labels are drawn ' vertically '"}
{"code": "public double translatedValue(Number dataValue, Rectangle2D plotArea) {   double value = dataValue.doubleValue();   double axisMin = minimumAxisValue.doubleValue();   double axisMax = maximumAxisValue.doubleValue();   double plotX = plotArea.getX();   double plotMaxX = plotArea.getMaxX();   return plotX + ((value - axisMin)/(axisMax - axisMin)) * (plotMaxX - plotX);}", "nl": "Translates the data value to the display coordinates of the chart"}
{"code": "public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {    this.ticks.clear();    g2.setFont(tickLabelFont);    if (this.autoTickUnit) {     selectAutoTickUnit(g2, drawArea, plotArea);   }    double size = this.tickUnit.getValue().doubleValue();   int count = this.calculateVisibleTickCount();   double lowestTickValue = this.calculateLowestVisibleTickValue();      for (int i=0; i<count; i++) {     Number currentTickValue = new Double(lowestTickValue+(i*size));     double xx = this.translatedValue(currentTickValue, plotArea);     String tickLabel = this.valueToString(currentTickValue);     Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,                   g2.getFontRenderContext());     float x = 0.0f;     float y = 0.0f;     if (this.verticalTickLabels) {     x = (float)(xx+tickLabelBounds.getHeight()/2);     y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getWidth());     }     else {     x = (float)(xx-tickLabelBounds.getWidth()/2);     y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getHeight());     }     Tick tick = new Tick(currentTickValue, tickLabel, x, y);     ticks.add(tick);}}", "nl": "Calculates the positions of the tick labels for the axis , storing the results in the tick label list"}
{"code": "private double getMaxTickLabelHeight(Graphics2D g2, Rectangle2D drawArea, boolean vertical) {   Font font = getTickLabelFont();   g2.setFont(font);   FontRenderContext frc = g2.getFontRenderContext();   double maxHeight = 0.0;   if (vertical) {     Iterator iterator = this.ticks.iterator();     while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);     if (labelBounds.getWidth()>maxHeight) {       maxHeight = labelBounds.getWidth();     }     }   }   else {     LineMetrics metrics = font.getLineMetrics(\"Sample\", frc);     maxHeight = metrics.getHeight();   }   return maxHeight;}", "nl": "A utility method for determining the height of the tallest tick label"}
{"code": "public void configure() {   if (isAutoRange()) {     autoAdjustRange();}}", "nl": "Configures the axis to work with the specified plot"}
{"code": "public HorizontalNumberAxis(String label, Font labelFont,         Number minimumAxisValue, Number maximumAxisValue) {    this(label,        labelFont,        Axis.DEFAULT_AXIS_LABEL_PAINT,        Axis.DEFAULT_AXIS_LABEL_INSETS,      true,          Axis.DEFAULT_TICK_LABEL_FONT,        Axis.DEFAULT_TICK_LABEL_PAINT,        Axis.DEFAULT_TICK_LABEL_INSETS,      false,          true,          Axis.DEFAULT_TICK_STROKE,      false,         true,          NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,        minimumAxisValue, maximumAxisValue,      true,          NumberAxis.DEFAULT_TICK_UNIT,      true,          ValueAxis.DEFAULT_GRID_LINE_STROKE,        ValueAxis.DEFAULT_GRID_LINE_PAINT);}", "nl": "Constructs a horizontal number axis"}
{"code": "public HorizontalNumberAxis(String label) {      this(label,        Axis.DEFAULT_AXIS_LABEL_FONT,        NumberAxis.DEFAULT_MINIMUM_AXIS_VALUE,        NumberAxis.DEFAULT_MAXIMUM_AXIS_VALUE);      this.autoRange = true;}", "nl": "Constructs a horizontal number axis , using default values where necessary"}
{"code": "private void selectAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {           FontRenderContext frc = g2.getFontRenderContext();      double tickLabelWidth = this.tickLabelInsets.left+this.tickLabelInsets.right;     if (this.verticalTickLabels) {     tickLabelWidth += tickLabelFont.getStringBounds(\"123\", frc).getHeight();     }     else {      double w1 = tickLabelFont.getStringBounds                     (this.valueToString(this.minimumAxisValue), frc).getWidth();     double w2 = tickLabelFont.getStringBounds                     (this.valueToString(this.maximumAxisValue), frc).getWidth();        tickLabelWidth += Math.max(w1, w2);     }                    double zero = this.translatedValue(Plot.ZERO, plotArea);           NumberTickUnit candidate1              = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(this.tickUnit);     double x = this.translatedValue(candidate1.getValue(), plotArea);     double unitWidth = Math.abs(x-zero);           double bestguess = (tickLabelWidth/unitWidth) * candidate1.value.doubleValue();     NumberTickUnit guess = new NumberTickUnit(new Double(bestguess), null);     NumberTickUnit candidate2                = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(guess);      this.tickUnit = candidate2;}", "nl": "Selects an appropriate tick value for the axis"}
{"code": "public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {       Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());   double labelHeight = this.labelInsets.top+labelInsets.bottom+labelBounds.getHeight();       double tickLabelHeight = 0.0;   if (tickLabelsVisible) {     g2.setFont(tickLabelFont);     this.refreshTicks(g2, drawArea, drawArea);     tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom+     getMaxTickLabelHeight(g2, drawArea, this.verticalCategoryLabels);   }   return labelHeight+tickLabelHeight;}", "nl": "Estimates the height required for the axis , given a specific drawing area , without any information about the width of the vertical axis"}
{"code": "public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {   this.ticks.clear();   CategoryPlot categoryPlot = (CategoryPlot)plot;     Dataset data = categoryPlot.getDataset();     if (data!=null) {     FontRenderContext frc = g2.getFontRenderContext();     Font font = this.getTickLabelFont();     g2.setFont(font);     int categoryIndex = 0;     float xx = 0.0f;     float yy = 0.0f;     Iterator iterator = categoryPlot.getDataset().getCategories().iterator();     while (iterator.hasNext()) {       Object category = iterator.next();       String label = category.toString();       Rectangle2D labelBounds = font.getStringBounds(label, frc);       LineMetrics metrics = font.getLineMetrics(label, frc);       if (this.verticalCategoryLabels) {       xx = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)+           labelBounds.getHeight()/2);       yy = (float)(plotArea.getMaxY()+tickLabelInsets.top+labelBounds.getWidth());       }       else {       xx = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)-          labelBounds.getWidth()/2);       yy = (float)(plotArea.getMaxY()+tickLabelInsets.top+metrics.getHeight()          -metrics.getDescent());       }       Tick tick = new Tick(category, label, xx, yy);       ticks.add(tick);         categoryIndex = categoryIndex+1;}}}", "nl": "Creates a temporary list of ticks that can be used when drawing the axis"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,              double reservedWidth) {       Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());   double labelHeight = this.labelInsets.top+labelInsets.bottom+labelBounds.getHeight();       double tickLabelHeight = 0.0;   if (tickLabelsVisible) {     g2.setFont(tickLabelFont);     this.refreshTicks(g2, drawArea, drawArea);     tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom+     getMaxTickLabelHeight(g2, drawArea, this.verticalCategoryLabels);   }   return new Rectangle2D.Double(drawArea.getX(),                     drawArea.getMaxY()-labelHeight-tickLabelHeight,             drawArea.getWidth()-reservedWidth,                     labelHeight+tickLabelHeight);}", "nl": "Returns the area required to draw the axis in the specified draw area"}
{"code": "private double getMaxTickLabelHeight(Graphics2D g2, Rectangle2D drawArea, boolean vertical) {   Font font = getTickLabelFont();   g2.setFont(font);   FontRenderContext frc = g2.getFontRenderContext();   double maxHeight = 0.0;   if (vertical) {     Iterator iterator = this.ticks.iterator();     while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);     if (labelBounds.getWidth()>maxHeight) {       maxHeight = labelBounds.getWidth();     }     }   }   else {     LineMetrics metrics = font.getLineMetrics(\"Sample\", frc);     maxHeight = metrics.getHeight();   }   return maxHeight;}", "nl": "A utility method for determining the height of the tallest tick label"}
{"code": "public HorizontalCategoryAxis(String label, Font labelFont, Paint labelPaint,                   Insets labelInsets,                   boolean showCategoryLabels, boolean verticalCategoryLabels,           Font categoryLabelFont, Paint categoryLabelPaint,                   Insets categoryLabelInsets,           boolean showTickMarks, Stroke tickMarkStroke) {    super(label, labelFont, labelPaint, labelInsets,       showCategoryLabels, categoryLabelFont, categoryLabelPaint, categoryLabelInsets,       showTickMarks, tickMarkStroke);    this.verticalCategoryLabels = verticalCategoryLabels;}", "nl": "Full constructor : returns a new HorizontalCategoryAxis with attributes as specified by the caller"}
{"code": "public void setVerticalCategoryLabels(boolean flag) {   this.verticalCategoryLabels = flag;   this.notifyListeners(new com.jrefinery.chart.event.AxisChangeEvent(this));}", "nl": "Sets the flag that determines whether the category labels are drawn ' vertically '"}
{"code": "protected boolean isCompatiblePlot(Plot plot) {     if (plot instanceof CategoryPlot) return true;     else return false;}", "nl": "Returns true if the specified plot is compatible with the axis , and false otherwise"}
{"code": "private Date createDateTime(int year, int month, int day, int hour, int minute) {     GregorianCalendar calendar = new GregorianCalendar(year, month, day, hour, minute);     return calendar.getTime();}", "nl": "Returns a java . util . Date for the specified year , month , day , hour and minute"}
{"code": "private void displayXYPlotZeroData() {      if (xyPlotZeroDataFrame==null) {               String title = \"XY Plot (zero series)\";       String xAxisLabel = \"X Axis\";       String yAxisLabel = \"Y Axis\";       XYDataset data = new EmptyXYDataset();       JFreeChart chart = ChartFactory.createXYChart(title, xAxisLabel, yAxisLabel, data, true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));               xyPlotZeroDataFrame = new JFreeChartFrame(\"XYPlot\", chart);       xyPlotZeroDataFrame.pack();       SwingRefinery.positionFrameRandomly(xyPlotZeroDataFrame);       xyPlotZeroDataFrame.show();      }     else {       xyPlotZeroDataFrame.show();       xyPlotZeroDataFrame.requestFocus();}}", "nl": "Displays an XYPlot in its own frame"}
{"code": "public static void main(String[] args) {     JFreeChartDemo f = new JFreeChartDemo();     f.pack();      SwingRefinery.centerFrameOnScreen(f);           f.show();}", "nl": "The starting point for the demonstration application"}
{"code": "public CategoryDataset createSingleSeriesCategoryDataset() {      Number[][] data = new Integer[][]       { { new Integer(10), new Integer(-4), new Integer(15), new Integer(14) } };      return new DefaultCategoryDataset(data);}", "nl": "Creates and returns a category dataset for the demo charts"}
{"code": "private void displayVerticalBarChart() {      if (verticalBarChartFrame==null) {        CategoryDataset categoryData = createCategoryDataset();       JFreeChart chart = ChartFactory.createVerticalBarChart(\"Vertical Bar Chart\",                    \"Categories\", \"Values\", categoryData, true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));       Plot plot = chart.getPlot();       HorizontalCategoryAxis hAxis = (HorizontalCategoryAxis)plot.getAxis(Plot.HORIZONTAL_AXIS);         hAxis.setVerticalCategoryLabels(true);               verticalBarChartFrame = new JFreeChartFrame(\"Vertical Bar Chart\", chart);       verticalBarChartFrame.pack();       SwingRefinery.positionFrameRandomly(verticalBarChartFrame);       verticalBarChartFrame.show();      }     else {       verticalBarChartFrame.show();       verticalBarChartFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "private void displayScatterPlot() {      if (scatterPlotFrame==null) {               String title = \"Scatter Plot\";       String xAxisLabel = \"X Axis\";       String yAxisLabel = \"Y Axis\";       XYDataset scatterData = new SampleXYDataset2();       JFreeChart chart = ChartFactory.createScatterPlot(title, xAxisLabel,                               yAxisLabel, scatterData, true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.green));               scatterPlotFrame = new JFreeChartFrame(\"XYPlot\", chart);       scatterPlotFrame.pack();       SwingRefinery.positionFrameRandomly(scatterPlotFrame);       scatterPlotFrame.show();      }     else {       scatterPlotFrame.show();       scatterPlotFrame.requestFocus();}}", "nl": "Displays a scatter plot in its own frame"}
{"code": "private void displayVerticalStacked3DBarChart() {      if (verticalStacked3DBarChartFrame==null) {               String title = \"Vertical Stacked 3D Bar Chart\";       String categoryAxisLabel = \"Categories\";       String valueAxisLabel = \"Values\";       CategoryDataset categoryData = createCategoryDataset();       JFreeChart chart = ChartFactory.createStackedVerticalBarChart3D(title, categoryAxisLabel,                                  valueAxisLabel, categoryData, true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));       Plot plot = chart.getPlot();       VerticalNumberAxis valueAxis = (VerticalNumberAxis)plot.getAxis(Plot.VERTICAL_AXIS);              valueAxis.setMinimumAxisValue(new Double(-32.0));       valueAxis.setMaximumAxisValue(new Double(85.0));               verticalStacked3DBarChartFrame = new JFreeChartFrame(\"Vertical Stacked 3D Bar Chart\", chart);       verticalStacked3DBarChartFrame.pack();       SwingRefinery.positionFrameRandomly(verticalStacked3DBarChartFrame);       verticalStacked3DBarChartFrame.show();      }     else {       verticalStacked3DBarChartFrame.show();       verticalStacked3DBarChartFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "private JTabbedPane createTabbedPane() {      JTabbedPane tabs = new JTabbedPane();     Font font = new Font(\"Dialog\", Font.PLAIN, 12);      JPanel barPanel = new JPanel(new LCBLayout(20));     barPanel.setPreferredSize(new Dimension(360, 20));     barPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));      JPanel piePanel = new JPanel(new LCBLayout(20));     piePanel.setPreferredSize(new Dimension(360, 20));     piePanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));      JPanel xyPanel = new JPanel(new LCBLayout(20));     xyPanel.setPreferredSize(new Dimension(360, 20));     xyPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));      JPanel timeSeriesPanel = new JPanel(new LCBLayout(20));     timeSeriesPanel.setPreferredSize(new Dimension(360, 20));     timeSeriesPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));      JPanel otherPanel = new JPanel(new LCBLayout(20));     otherPanel.setPreferredSize(new Dimension(360, 20));     otherPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));      JPanel testPanel = new JPanel(new LCBLayout(20));     testPanel.setPreferredSize(new Dimension(360, 20));     testPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));      barPanel.add(SwingRefinery.createJLabel(\"Horizontal Bar Chart: \", font));     barPanel.add(new DescriptionPanel(new JTextArea(\"Displays horizontal bars, representing data from a CategoryDataset.\")));     JButton b1 = SwingRefinery.createJButton(\"Display\", font);     b1.setActionCommand(\"HORIZONTAL_BAR_CHART\");     b1.addActionListener(this);     barPanel.add(b1);       barPanel.add(SwingRefinery.createJLabel(\"Horizontal Stacked Bar Chart: \", font));     barPanel.add(new DescriptionPanel(new JTextArea(\"Displays stacked horizontal bars, representing data from a CategoryDataset.\")));     JButton b2 = SwingRefinery.createJButton(\"Display\", font);     b2.setActionCommand(\"HORIZONTAL_STACKED_BAR_CHART\");     b2.addActionListener(this);     barPanel.add(b2);      barPanel.add(SwingRefinery.createJLabel(\"Vertical Bar Chart: \", font));     barPanel.add(new DescriptionPanel(new JTextArea(\"Displays vertical bars, representing data from a CategoryDataset.\")));     JButton b3 = SwingRefinery.createJButton(\"Display\", font);     b3.setActionCommand(\"VERTICAL_BAR_CHART\");     b3.addActionListener(this);     barPanel.add(b3);      barPanel.add(SwingRefinery.createJLabel(\"Vertical 3D Bar Chart: \", font));     barPanel.add(new DescriptionPanel(new JTextArea(\"Displays stacked vertical bars with a 3D effect, representing data from a CategoryDataset.\")));     JButton b6 = SwingRefinery.createJButton(\"Display\", font);     b6.setActionCommand(\"VERTICAL_3D_BAR_CHART\");     b6.addActionListener(this);     barPanel.add(b6);      barPanel.add(SwingRefinery.createJLabel(\"Vertical Stacked Bar Chart: \", font));     barPanel.add(new DescriptionPanel(new JTextArea(\"Displays stacked vertical bars, representing data from a CategoryDataset.\")));     JButton b4 = SwingRefinery.createJButton(\"Display\", font);     b4.setActionCommand(\"VERTICAL_STACKED_BAR_CHART\");     b4.addActionListener(this);     barPanel.add(b4);      barPanel.add(SwingRefinery.createJLabel(\"Vertical Stacked 3D Bar Chart: \", font));     barPanel.add(new DescriptionPanel(new JTextArea(\"Displays stacked vertical bars with a 3D effect, representing data from a CategoryDataset.\")));     JButton b5 = SwingRefinery.createJButton(\"Display\", font);     b5.setActionCommand(\"VERTICAL_STACKED_3D_BAR_CHART\");     b5.addActionListener(this);     barPanel.add(b5);      otherPanel.add(SwingRefinery.createJLabel(\"Line Chart: \", font));     otherPanel.add(new DescriptionPanel(new JTextArea(\"A chart displaying lines and or shapes, representing data in a CategoryDataset.\")));     JButton b8 = SwingRefinery.createJButton(\"Display\", font);     b8.setActionCommand(\"LINE_CHART\");     b8.addActionListener(this);     otherPanel.add(b8);      piePanel.add(SwingRefinery.createJLabel(\"Pie Chart: \", font));     piePanel.add(new DescriptionPanel(new JTextArea(\"A pie chart showing one section exploded.\")));     JButton b9 = SwingRefinery.createJButton(\"Display\", font);     b9.setActionCommand(\"PIE_CHART_1\");     b9.addActionListener(this);     piePanel.add(b9);      piePanel.add(SwingRefinery.createJLabel(\"Pie Chart 2: \", font));     piePanel.add(new DescriptionPanel(new JTextArea(\"A pie chart showing percentage labels.\")));     JButton b10 = SwingRefinery.createJButton(\"Display\", font);     b10.setActionCommand(\"PIE_CHART_2\");     b10.addActionListener(this);     piePanel.add(b10);      otherPanel.add(SwingRefinery.createJLabel(\"Scatter Plot: \", font));     otherPanel.add(new DescriptionPanel(new JTextArea(\"A scatter plot, based on data from an XYDataset.\")));     JButton b11 = SwingRefinery.createJButton(\"Display\", font);     b11.setActionCommand(\"SCATTER_PLOT\");     b11.addActionListener(this);     otherPanel.add(b11);      xyPanel.add(SwingRefinery.createJLabel(\"XY Plot: \", font));     xyPanel.add(new DescriptionPanel(new JTextArea(\"A line chart, based on data from an XYDataset.\")));     JButton b12 = SwingRefinery.createJButton(\"Display\", font);     b12.setActionCommand(\"XY_PLOT\");     b12.addActionListener(this);     xyPanel.add(b12);      testPanel.add(SwingRefinery.createJLabel(\"Null Data: \", font));     testPanel.add(new DescriptionPanel(new JTextArea(\"A chart with a null dataset.\")));     JButton b13 = SwingRefinery.createJButton(\"Display\", font);     b13.setActionCommand(\"XY_PLOT_NULL\");     b13.addActionListener(this);     testPanel.add(b13);      testPanel.add(SwingRefinery.createJLabel(\"Zero Data: \", font));     testPanel.add(new DescriptionPanel(new JTextArea(\"A chart with a dataset containing zero series..\")));     JButton b14 = SwingRefinery.createJButton(\"Display\", font);     b14.setActionCommand(\"XY_PLOT_ZERO\");     b14.addActionListener(this);     testPanel.add(b14);      timeSeriesPanel.add(SwingRefinery.createJLabel(\"Time Series Chart: \", font));     timeSeriesPanel.add(new DescriptionPanel(new JTextArea(\"A time series chart, based on data from an XYDataset.\")));     JButton b15 = SwingRefinery.createJButton(\"Display\", font);     b15.setActionCommand(\"TIME_SERIES_CHART\");     b15.addActionListener(this);     timeSeriesPanel.add(b15);      timeSeriesPanel.add(SwingRefinery.createJLabel(\"Time Series 2: \", font));     timeSeriesPanel.add(new DescriptionPanel(new JTextArea(\"A time series chart with a moving average, based on data from an XYDataset.\")));     JButton b16 = SwingRefinery.createJButton(\"Display\", font);     b16.setActionCommand(\"TIME_SERIES_WITH_MA_CHART\");     b16.addActionListener(this);     timeSeriesPanel.add(b16);      testPanel.add(SwingRefinery.createJLabel(\"Chart in JScrollPane: \", font));     testPanel.add(new DescriptionPanel(new JTextArea(\"A chart embedded in a JScrollPane.\")));     JButton b18 = SwingRefinery.createJButton(\"Display\", font);     b18.setActionCommand(\"TIME_SERIES_CHART_SCROLL\");     b18.addActionListener(this);     testPanel.add(b18);      timeSeriesPanel.add(SwingRefinery.createJLabel(\"High/Low/Open/Close Chart: \", font));     timeSeriesPanel.add(new DescriptionPanel(new JTextArea(\"A high/low/open/close chart based on data in HighLowDataset.\")));     JButton b19 = SwingRefinery.createJButton(\"Display\", font);     b19.setActionCommand(\"HIGH_LOW_CHART\");     b19.addActionListener(this);     timeSeriesPanel.add(b19);      otherPanel.add(SwingRefinery.createJLabel(\"Vertical XY Bar Chart: \", font));     otherPanel.add(new DescriptionPanel(new JTextArea(\"A chart showing vertical bars, based on data in an IntervalXYDataset.\")));     JButton b7 = SwingRefinery.createJButton(\"Display\", font);     b7.setActionCommand(\"VERTICAL_XY_BAR_CHART\");     b7.addActionListener(this);     otherPanel.add(b7);      testPanel.add(SwingRefinery.createJLabel(\"Dynamic Chart: \", font));     testPanel.add(new DescriptionPanel(new JTextArea(\"A dynamic chart, to test the event notification mechanism.\")));     JButton b20 = SwingRefinery.createJButton(\"Display\", font);     b20.setActionCommand(\"DYNAMIC_CHART\");     b20.addActionListener(this);     testPanel.add(b20);      tabs.add(\"Bar Charts\", new JScrollPane(barPanel));     tabs.add(\"Pie Charts\", new JScrollPane(piePanel));     tabs.add(\"XY Charts\", new JScrollPane(xyPanel));     tabs.add(\"Time Series Charts\", new JScrollPane(timeSeriesPanel));     tabs.add(\"Other Charts\", new JScrollPane(otherPanel));     tabs.add(\"Test Charts\", new JScrollPane(testPanel));     return tabs;}", "nl": "Creates a tabbed pane containing descriptions of the demo charts"}
{"code": "private void displayNullXYPlot() {      if (this.xyPlotNullDataFrame==null) {               String title = \"XY Plot (null data)\";       String xAxisLabel = \"X Axis\";       String yAxisLabel = \"Y Axis\";       XYDataset data = null;       JFreeChart chart = ChartFactory.createXYChart(title, xAxisLabel, yAxisLabel, data, true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));               xyPlotNullDataFrame = new JFreeChartFrame(\"XY Plot with NULL data\", chart);       xyPlotNullDataFrame.pack();       SwingRefinery.positionFrameRandomly(xyPlotNullDataFrame);       xyPlotNullDataFrame.show();      }     else {       xyPlotNullDataFrame.show();       xyPlotNullDataFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "public XYDataset createHighLowDataset() {      Object[][][] data = new Object[][][] { {       { createDate(1999, Calendar.JANUARY,4), new Double(47) },       { createDate(1999, Calendar.JANUARY,4), new Double(33) },       { createDate(1999, Calendar.JANUARY,4), new Double(35) },       { createDate(1999, Calendar.JANUARY,4), new Double(33) },        { createDate(1999, Calendar.JANUARY,5), new Double(47) },       { createDate(1999, Calendar.JANUARY,5), new Double(32) },       { createDate(1999, Calendar.JANUARY,5), new Double(41) },       { createDate(1999, Calendar.JANUARY,5), new Double(37) },        { createDate(1999, Calendar.JANUARY,6), new Double(49) },       { createDate(1999, Calendar.JANUARY,6), new Double(43) },       { createDate(1999, Calendar.JANUARY,6), new Double(46) },       { createDate(1999, Calendar.JANUARY,6), new Double(48) },        { createDate(1999, Calendar.JANUARY,7), new Double(51) },       { createDate(1999, Calendar.JANUARY,7), new Double(39) },       { createDate(1999, Calendar.JANUARY,7), new Double(40) },       { createDate(1999, Calendar.JANUARY,7), new Double(47) },        { createDate(1999, Calendar.JANUARY,8), new Double(60) },       { createDate(1999, Calendar.JANUARY,8), new Double(40) },       { createDate(1999, Calendar.JANUARY,8), new Double(46) },       { createDate(1999, Calendar.JANUARY,8), new Double(53) },        { createDate(1999, Calendar.JANUARY,9), new Double(62) },       { createDate(1999, Calendar.JANUARY,9), new Double(55) },       { createDate(1999, Calendar.JANUARY,9), new Double(57) },       { createDate(1999, Calendar.JANUARY,9), new Double(61) },        { createDate(1999, Calendar.JANUARY,10), new Double(65) },       { createDate(1999, Calendar.JANUARY,10), new Double(56) },       { createDate(1999, Calendar.JANUARY,10), new Double(62) },       { createDate(1999, Calendar.JANUARY,10), new Double(59) },        { createDate(1999, Calendar.JANUARY,11), new Double(55) },       { createDate(1999, Calendar.JANUARY,11), new Double(43) },       { createDate(1999, Calendar.JANUARY,11), new Double(45) },       { createDate(1999, Calendar.JANUARY,11), new Double(47) },        { createDate(1999, Calendar.JANUARY,12), new Double(54) },       { createDate(1999, Calendar.JANUARY,12), new Double(33) },       { createDate(1999, Calendar.JANUARY,12), new Double(40) },       { createDate(1999, Calendar.JANUARY,12), new Double(51) },        { createDate(1999, Calendar.JANUARY,13), new Double(58) },       { createDate(1999, Calendar.JANUARY,13), new Double(42) },       { createDate(1999, Calendar.JANUARY,13), new Double(44) },       { createDate(1999, Calendar.JANUARY,13), new Double(57) },        { createDate(1999, Calendar.JANUARY,14), new Double(54) },       { createDate(1999, Calendar.JANUARY,14), new Double(38) },       { createDate(1999, Calendar.JANUARY,14), new Double(43) },       { createDate(1999, Calendar.JANUARY,14), new Double(52) },        { createDate(1999, Calendar.JANUARY,15), new Double(48) },       { createDate(1999, Calendar.JANUARY,15), new Double(41) },       { createDate(1999, Calendar.JANUARY,15), new Double(44) },       { createDate(1999, Calendar.JANUARY,15), new Double(41) },        { createDate(1999, Calendar.JANUARY,17), new Double(60) },       { createDate(1999, Calendar.JANUARY,17), new Double(30) },       { createDate(1999, Calendar.JANUARY,17), new Double(34) },       { createDate(1999, Calendar.JANUARY,17), new Double(44) },        { createDate(1999, Calendar.JANUARY,18), new Double(58) },       { createDate(1999, Calendar.JANUARY,18), new Double(44) },       { createDate(1999, Calendar.JANUARY,18), new Double(54) },       { createDate(1999, Calendar.JANUARY,18), new Double(56) },        { createDate(1999, Calendar.JANUARY,19), new Double(54) },       { createDate(1999, Calendar.JANUARY,19), new Double(32) },       { createDate(1999, Calendar.JANUARY,19), new Double(42) },       { createDate(1999, Calendar.JANUARY,19), new Double(53) },        { createDate(1999, Calendar.JANUARY,20), new Double(53) },       { createDate(1999, Calendar.JANUARY,20), new Double(39) },       { createDate(1999, Calendar.JANUARY,20), new Double(50) },       { createDate(1999, Calendar.JANUARY,20), new Double(49) },        { createDate(1999, Calendar.JANUARY,21), new Double(47) },       { createDate(1999, Calendar.JANUARY,21), new Double(38) },       { createDate(1999, Calendar.JANUARY,21), new Double(41) },       { createDate(1999, Calendar.JANUARY,21), new Double(40) },        { createDate(1999, Calendar.JANUARY,22), new Double(55) },       { createDate(1999, Calendar.JANUARY,22), new Double(37) },       { createDate(1999, Calendar.JANUARY,22), new Double(43) },       { createDate(1999, Calendar.JANUARY,22), new Double(45) },        { createDate(1999, Calendar.JANUARY,23), new Double(54) },       { createDate(1999, Calendar.JANUARY,23), new Double(42) },       { createDate(1999, Calendar.JANUARY,23), new Double(50) },       { createDate(1999, Calendar.JANUARY,23), new Double(42) },        { createDate(1999, Calendar.JANUARY,24), new Double(48) },       { createDate(1999, Calendar.JANUARY,24), new Double(37) },       { createDate(1999, Calendar.JANUARY,24), new Double(37) },       { createDate(1999, Calendar.JANUARY,24), new Double(47) },        { createDate(1999, Calendar.JANUARY,25), new Double(58) },       { createDate(1999, Calendar.JANUARY,25), new Double(33) },       { createDate(1999, Calendar.JANUARY,25), new Double(39) },       { createDate(1999, Calendar.JANUARY,25), new Double(41) },        { createDate(1999, Calendar.JANUARY,26), new Double(47) },       { createDate(1999, Calendar.JANUARY,26), new Double(31) },       { createDate(1999, Calendar.JANUARY,26), new Double(36) },       { createDate(1999, Calendar.JANUARY,26), new Double(41) },        { createDate(1999, Calendar.JANUARY,27), new Double(58) },       { createDate(1999, Calendar.JANUARY,27), new Double(44) },       { createDate(1999, Calendar.JANUARY,27), new Double(49) },       { createDate(1999, Calendar.JANUARY,27), new Double(44) },        { createDate(1999, Calendar.JANUARY,28), new Double(46) },       { createDate(1999, Calendar.JANUARY,28), new Double(41) },       { createDate(1999, Calendar.JANUARY,28), new Double(43) },       { createDate(1999, Calendar.JANUARY,28), new Double(44) },        { createDate(1999, Calendar.JANUARY,29), new Double(56) },       { createDate(1999, Calendar.JANUARY,29), new Double(39) },       { createDate(1999, Calendar.JANUARY,29), new Double(39) },       { createDate(1999, Calendar.JANUARY,29), new Double(51) },        { createDate(1999, Calendar.JANUARY,30), new Double(56) },       { createDate(1999, Calendar.JANUARY,30), new Double(39) },       { createDate(1999, Calendar.JANUARY,30), new Double(47) },       { createDate(1999, Calendar.JANUARY,30), new Double(49) },        { createDate(1999, Calendar.JANUARY,31), new Double(53) },       { createDate(1999, Calendar.JANUARY,31), new Double(39) },       { createDate(1999, Calendar.JANUARY,31), new Double(52) },       { createDate(1999, Calendar.JANUARY,31), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,1), new Double(51) },       { createDate(1999, Calendar.FEBRUARY,1), new Double(30) },       { createDate(1999, Calendar.FEBRUARY,1), new Double(45) },       { createDate(1999, Calendar.FEBRUARY,1), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,2), new Double(47) },       { createDate(1999, Calendar.FEBRUARY,2), new Double(30) },       { createDate(1999, Calendar.FEBRUARY,2), new Double(34) },       { createDate(1999, Calendar.FEBRUARY,2), new Double(46) },        { createDate(1999, Calendar.FEBRUARY,3), new Double(57) },       { createDate(1999, Calendar.FEBRUARY,3), new Double(37) },       { createDate(1999, Calendar.FEBRUARY,3), new Double(44) },       { createDate(1999, Calendar.FEBRUARY,3), new Double(56) },        { createDate(1999, Calendar.FEBRUARY,4), new Double(49) },       { createDate(1999, Calendar.FEBRUARY,4), new Double(40) },       { createDate(1999, Calendar.FEBRUARY,4), new Double(47) },       { createDate(1999, Calendar.FEBRUARY,4), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,5), new Double(46) },       { createDate(1999, Calendar.FEBRUARY,5), new Double(38) },       { createDate(1999, Calendar.FEBRUARY,5), new Double(43) },       { createDate(1999, Calendar.FEBRUARY,5), new Double(40) },        { createDate(1999, Calendar.FEBRUARY,6), new Double(55) },       { createDate(1999, Calendar.FEBRUARY,6), new Double(38) },       { createDate(1999, Calendar.FEBRUARY,6), new Double(39) },       { createDate(1999, Calendar.FEBRUARY,6), new Double(53) },        { createDate(1999, Calendar.FEBRUARY,7), new Double(50) },       { createDate(1999, Calendar.FEBRUARY,7), new Double(33) },       { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },       { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },        { createDate(1999, Calendar.FEBRUARY,8), new Double(59) },       { createDate(1999, Calendar.FEBRUARY,8), new Double(34) },       { createDate(1999, Calendar.FEBRUARY,8), new Double(57) },       { createDate(1999, Calendar.FEBRUARY,8), new Double(43) },        { createDate(1999, Calendar.FEBRUARY,9), new Double(48) },       { createDate(1999, Calendar.FEBRUARY,9), new Double(39) },       { createDate(1999, Calendar.FEBRUARY,9), new Double(46) },       { createDate(1999, Calendar.FEBRUARY,9), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,10), new Double(55) },       { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },       { createDate(1999, Calendar.FEBRUARY,10), new Double(37) },       { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },        { createDate(1999, Calendar.FEBRUARY,11), new Double(60) },       { createDate(1999, Calendar.FEBRUARY,11), new Double(32) },       { createDate(1999, Calendar.FEBRUARY,11), new Double(56) },       { createDate(1999, Calendar.FEBRUARY,11), new Double(36) },        { createDate(1999, Calendar.FEBRUARY,12), new Double(56) },       { createDate(1999, Calendar.FEBRUARY,12), new Double(42) },       { createDate(1999, Calendar.FEBRUARY,12), new Double(53) },       { createDate(1999, Calendar.FEBRUARY,12), new Double(54) },        { createDate(1999, Calendar.FEBRUARY,13), new Double(49) },       { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },       { createDate(1999, Calendar.FEBRUARY,13), new Double(45) },       { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,14), new Double(55) },       { createDate(1999, Calendar.FEBRUARY,14), new Double(42) },       { createDate(1999, Calendar.FEBRUARY,14), new Double(47) },       { createDate(1999, Calendar.FEBRUARY,14), new Double(54) },        { createDate(1999, Calendar.FEBRUARY,15), new Double(49) },       { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },       { createDate(1999, Calendar.FEBRUARY,15), new Double(38) },       { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },        { createDate(1999, Calendar.FEBRUARY,16), new Double(47) },       { createDate(1999, Calendar.FEBRUARY,16), new Double(38) },       { createDate(1999, Calendar.FEBRUARY,16), new Double(43) },       { createDate(1999, Calendar.FEBRUARY,16), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,17), new Double(53) },       { createDate(1999, Calendar.FEBRUARY,17), new Double(42) },       { createDate(1999, Calendar.FEBRUARY,17), new Double(47) },       { createDate(1999, Calendar.FEBRUARY,17), new Double(48) },        { createDate(1999, Calendar.FEBRUARY,18), new Double(47) },       { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },       { createDate(1999, Calendar.FEBRUARY,18), new Double(46) },       { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,19), new Double(46) },       { createDate(1999, Calendar.FEBRUARY,19), new Double(40) },       { createDate(1999, Calendar.FEBRUARY,19), new Double(43) },       { createDate(1999, Calendar.FEBRUARY,19), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,20), new Double(48) },       { createDate(1999, Calendar.FEBRUARY,20), new Double(41) },       { createDate(1999, Calendar.FEBRUARY,20), new Double(46) },       { createDate(1999, Calendar.FEBRUARY,20), new Double(41) } }     };      return new DefaultXYDataset(new String[] { \"IBM\" }, data);}", "nl": "Creates and returns a sample high - low dataset for the demo"}
{"code": "private void displayHighLowChart() {      if (this.highLowChartFrame==null) {               String title = \"High-Low/Open-Close Chart\";       String timeAxisLabel = \"Date\";       String valueAxisLabel = \"Price ($ per share)\";       HighLowDataset data = new SampleHighLowDataset();       JFreeChart chart = ChartFactory.createHighLowChart(title, timeAxisLabel, valueAxisLabel,                                data, true);               TextTitle subtitle = new TextTitle(\"IBM Stock Price\", new Font(\"Arial\", Font.BOLD, 12));       chart.addTitle(subtitle);       chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 0, 1000, Color.magenta));                highLowChartFrame = new JFreeChartFrame(\"High/Low/Open/Close Chart\", chart);       highLowChartFrame.pack();       SwingRefinery.positionFrameRandomly(highLowChartFrame);       highLowChartFrame.show();      }     else {       highLowChartFrame.show();       highLowChartFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "private void displayVerticalXYBarChart() {      if (verticalXYBarChartFrame==null) {               String title = \"Time Series Bar Chart\";       String xAxisLabel = \"X Axis\";       String yAxisLabel = \"Y Axis\";       TimeSeriesCollection data = createTestTimeSeriesCollection1();       JFreeChart chart = ChartFactory.createVerticalXYBarChart(title, xAxisLabel, yAxisLabel,                                    data, true);                chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.blue));               verticalXYBarChartFrame = new JFreeChartFrame(\"Vertical XY Bar Chart\", chart);       verticalXYBarChartFrame.pack();       SwingRefinery.positionFrameRandomly(verticalXYBarChartFrame);       verticalXYBarChartFrame.show();      }     else {       verticalXYBarChartFrame.show();       verticalXYBarChartFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "private void attemptExit() {     int result = JOptionPane.showConfirmDialog(this,              \"Are you sure you want to exit?\", \"Confirmation...\",              JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);     if (result==JOptionPane.YES_OPTION) {       dispose();       System.exit(0);}}", "nl": "Exits the application , but only if the user agrees"}
{"code": "private void displayVerticalStackedBarChart() {      if (verticalStackedBarChartFrame==null) {               String title = \"Vertical Stacked Bar Chart\";       String categoryAxisLabel = \"Categories\";       String valueAxisLabel = \"Values\";       CategoryDataset categoryData = createCategoryDataset();       JFreeChart chart = ChartFactory.createStackedVerticalBarChart(title, categoryAxisLabel,                                  valueAxisLabel, categoryData, true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));       Plot plot = chart.getPlot();       VerticalNumberAxis valueAxis = (VerticalNumberAxis)plot.getAxis(Plot.VERTICAL_AXIS);       valueAxis.setMinimumAxisValue(new Double(-32.0));       valueAxis.setMaximumAxisValue(new Double(85.0));               verticalStackedBarChartFrame = new JFreeChartFrame(\"Vertical Stacked Bar Chart\", chart);       verticalStackedBarChartFrame.pack();       SwingRefinery.positionFrameRandomly(verticalStackedBarChartFrame);       verticalStackedBarChartFrame.show();      }     else {       verticalStackedBarChartFrame.show();       verticalStackedBarChartFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "public void actionPerformed(ActionEvent event) {     String command = event.getActionCommand();     if (command.equals(\"exitItem\")) {       attemptExit();     }     else if (command.equals(\"DYNAMIC_CHART\")) {       displayDynamicXYChart();     }     else if (command.equals(\"aboutItem\")) {       about();     }     else if (command.equals(\"VERTICAL_BAR_CHART\")) {       displayVerticalBarChart();     }     else if (command.equals(\"VERTICAL_STACKED_BAR_CHART\")) {       displayVerticalStackedBarChart();     }     else if (command.equals(\"VERTICAL_XY_BAR_CHART\")) {       displayVerticalXYBarChart();     }     else if (command.equals(\"VERTICAL_3D_BAR_CHART\")) {       displayVertical3DBarChart();     }     else if (command.equals(\"VERTICAL_STACKED_3D_BAR_CHART\")) {       displayVerticalStacked3DBarChart();     }     else if (command.equals(\"HORIZONTAL_BAR_CHART\")) {       displayHorizontalBarChart();     }     else if (command.equals(\"HORIZONTAL_STACKED_BAR_CHART\")) {       displayHorizontalStackedBarChart();     }     else if (command.equals(\"LINE_CHART\")) {       displayLineChart();     }     else if (command.equals(\"PIE_CHART_1\")) {       displayPieChartOne();     }     else if (command.equals(\"PIE_CHART_2\")) {       displayPieChartTwo();     }     else if (command.equals(\"XY_PLOT\")) {       displayXYPlot();     }     else if (command.equals(\"SCATTER_PLOT\")) {       displayScatterPlot();     }     else if (command.equals(\"TIME_SERIES_CHART\")) {       displayTimeSeriesChart();     }     else if (command.equals(\"TIME_SERIES_WITH_MA_CHART\")) {       displayTimeSeriesWithMAChart();     }     else if (command.equals(\"TIME_SERIES_CHART_SCROLL\")) {       displayTimeSeriesChartInScrollPane();     }     else if (command.equals(\"HIGH_LOW_CHART\")) {       displayHighLowChart();     }     else if (command.equals(\"XY_PLOT_NULL\")) {       displayNullXYPlot();     }     else if (command.equals(\"XY_PLOT_ZERO\")) {       displayXYPlotZeroData();}}", "nl": "Handles menu selections by passing control to an appropriate method"}
{"code": "public XYDataset createXYDataset() {      GregorianCalendar calendar = new GregorianCalendar(1999, Calendar.JANUARY, 4);      Object[][][] data = new Object[][][] { {       { createDate(1999, Calendar.JANUARY,4), new Double(1.6581) },       { createDate(1999, Calendar.JANUARY,5), new Double(1.6566) },       { createDate(1999, Calendar.JANUARY,6), new Double(1.6547) },       { createDate(1999, Calendar.JANUARY,7), new Double(1.6495) },       { createDate(1999, Calendar.JANUARY,8), new Double(1.6405) },       { createDate(1999, Calendar.JANUARY,11), new Double(1.6375) },       { createDate(1999, Calendar.JANUARY,12), new Double(1.6308) },       { createDate(1999, Calendar.JANUARY,13), new Double(1.6493) },       { createDate(1999, Calendar.JANUARY,14), new Double(1.6530) },       { createDate(1999, Calendar.JANUARY,15), new Double(1.6500) },       { createDate(1999, Calendar.JANUARY,19), new Double(1.6550) },       { createDate(1999, Calendar.JANUARY,20), new Double(1.6467) },       { createDate(1999, Calendar.JANUARY,21), new Double(1.6516) },       { createDate(1999, Calendar.JANUARY,22), new Double(1.6560) },       { createDate(1999, Calendar.JANUARY,25), new Double(1.6563) },       { createDate(1999, Calendar.JANUARY,26), new Double(1.6585) },       { createDate(1999, Calendar.JANUARY,27), new Double(1.6485) },       { createDate(1999, Calendar.JANUARY,28), new Double(1.6470) },       { createDate(1999, Calendar.JANUARY,29), new Double(1.6457) },       { createDate(1999, Calendar.FEBRUARY,1), new Double(1.6410) },       { createDate(1999, Calendar.FEBRUARY,2), new Double(1.6430) },       { createDate(1999, Calendar.FEBRUARY,3), new Double(1.6375) },       { createDate(1999, Calendar.FEBRUARY,4), new Double(1.6395) },       { createDate(1999, Calendar.FEBRUARY,5), new Double(1.6370) },       { createDate(1999, Calendar.FEBRUARY,8), new Double(1.6380) },       { createDate(1999, Calendar.FEBRUARY,9), new Double(1.6355) },       { createDate(1999, Calendar.FEBRUARY,10), new Double(1.6290) },       { createDate(1999, Calendar.FEBRUARY,11), new Double(1.6244) },       { createDate(1999, Calendar.FEBRUARY,12), new Double(1.6311) },       { createDate(1999, Calendar.FEBRUARY,16), new Double(1.6317) },       { createDate(1999, Calendar.FEBRUARY,17), new Double(1.6338) },       { createDate(1999, Calendar.FEBRUARY,18), new Double(1.6338) },       { createDate(1999, Calendar.FEBRUARY,19), new Double(1.6255) },       { createDate(1999, Calendar.FEBRUARY,22), new Double(1.6238) },       { createDate(1999, Calendar.FEBRUARY,23), new Double(1.6138) },       { createDate(1999, Calendar.FEBRUARY,24), new Double(1.5980) },       { createDate(1999, Calendar.FEBRUARY,25), new Double(1.6060) },       { createDate(1999, Calendar.FEBRUARY,26), new Double(1.6027) },       { createDate(1999, Calendar.MARCH,1), new Double(1.6058) },       { createDate(1999, Calendar.MARCH,2), new Double(1.6135) },       { createDate(1999, Calendar.MARCH,3), new Double(1.6134) },       { createDate(1999, Calendar.MARCH,4), new Double(1.6065) },       { createDate(1999, Calendar.MARCH,5), new Double(1.6073) },       { createDate(1999, Calendar.MARCH,8), new Double(1.6085) },       { createDate(1999, Calendar.MARCH,9), new Double(1.6148) },       { createDate(1999, Calendar.MARCH,10), new Double(1.6267) },       { createDate(1999, Calendar.MARCH,11), new Double(1.6270) },       { createDate(1999, Calendar.MARCH,12), new Double(1.6335) },       { createDate(1999, Calendar.MARCH,15), new Double(1.6223) },       { createDate(1999, Calendar.MARCH,16), new Double(1.6240) },       { createDate(1999, Calendar.MARCH,17), new Double(1.6302) },       { createDate(1999, Calendar.MARCH,18), new Double(1.6290) },       { createDate(1999, Calendar.MARCH,19), new Double(1.6303) },       { createDate(1999, Calendar.MARCH,22), new Double(1.6280) },       { createDate(1999, Calendar.MARCH,23), new Double(1.6372) },       { createDate(1999, Calendar.MARCH,24), new Double(1.6410) },       { createDate(1999, Calendar.MARCH,25), new Double(1.6314) },       { createDate(1999, Calendar.MARCH,26), new Double(1.6205) },       { createDate(1999, Calendar.MARCH,29), new Double(1.6140) },       { createDate(1999, Calendar.MARCH,30), new Double(1.6115) },       { createDate(1999, Calendar.MARCH,31), new Double(1.6140) },       { createDate(1999, Calendar.APRIL,1), new Double(1.6063) },       { createDate(1999, Calendar.APRIL,2), new Double(1.6023) },       { createDate(1999, Calendar.APRIL,5), new Double(1.6015) },       { createDate(1999, Calendar.APRIL,6), new Double(1.5920) },       { createDate(1999, Calendar.APRIL,7), new Double(1.5975) },       { createDate(1999, Calendar.APRIL,8), new Double(1.6083) },       { createDate(1999, Calendar.APRIL,9), new Double(1.6068) },       { createDate(1999, Calendar.APRIL,12), new Double(1.6127) },       { createDate(1999, Calendar.APRIL,13), new Double(1.6135) },       { createDate(1999, Calendar.APRIL,14), new Double(1.6124) },       { createDate(1999, Calendar.APRIL,15), new Double(1.6103) },       { createDate(1999, Calendar.APRIL,16), new Double(1.6112) },       { createDate(1999, Calendar.APRIL,19), new Double(1.6075) },       { createDate(1999, Calendar.APRIL,20), new Double(1.6135) },       { createDate(1999, Calendar.APRIL,21), new Double(1.6074) },       { createDate(1999, Calendar.APRIL,22), new Double(1.6117) },       { createDate(1999, Calendar.APRIL,23), new Double(1.6170) },       { createDate(1999, Calendar.APRIL,26), new Double(1.6113) },       { createDate(1999, Calendar.APRIL,27), new Double(1.6177) },       { createDate(1999, Calendar.APRIL,28), new Double(1.6148) },       { createDate(1999, Calendar.APRIL,29), new Double(1.6105) },       { createDate(1999, Calendar.APRIL,30), new Double(1.6085) },       { createDate(1999, Calendar.MAY,3), new Double(1.6083) },       { createDate(1999, Calendar.MAY,4), new Double(1.6210) },       { createDate(1999, Calendar.MAY,5), new Double(1.6337) },       { createDate(1999, Calendar.MAY,6), new Double(1.6377) },       { createDate(1999, Calendar.MAY,7), new Double(1.6350) },       { createDate(1999, Calendar.MAY,10), new Double(1.6300) },       { createDate(1999, Calendar.MAY,11), new Double(1.6215) },       { createDate(1999, Calendar.MAY,12), new Double(1.6193) },       { createDate(1999, Calendar.MAY,13), new Double(1.6190) },       { createDate(1999, Calendar.MAY,14), new Double(1.6175) },       { createDate(1999, Calendar.MAY,17), new Double(1.6193) },       { createDate(1999, Calendar.MAY,18), new Double(1.6203) },       { createDate(1999, Calendar.MAY,19), new Double(1.6175) },       { createDate(1999, Calendar.MAY,20), new Double(1.6122) },       { createDate(1999, Calendar.MAY,21), new Double(1.6020) },       { createDate(1999, Calendar.MAY,24), new Double(1.5978) },       { createDate(1999, Calendar.MAY,25), new Double(1.6021) },       { createDate(1999, Calendar.MAY,26), new Double(1.5963) },       { createDate(1999, Calendar.MAY,27), new Double(1.5957) },       { createDate(1999, Calendar.MAY,28), new Double(1.6020) },       { createDate(1999, Calendar.JUNE,1), new Double(1.6150) },       { createDate(1999, Calendar.JUNE,2), new Double(1.6075) },       { createDate(1999, Calendar.JUNE,3), new Double(1.6055) },       { createDate(1999, Calendar.JUNE,4), new Double(1.6074) },       { createDate(1999, Calendar.JUNE,7), new Double(1.6010) },       { createDate(1999, Calendar.JUNE,8), new Double(1.6050) },       { createDate(1999, Calendar.JUNE,9), new Double(1.6001) },       { createDate(1999, Calendar.JUNE,10), new Double(1.6002) },       { createDate(1999, Calendar.JUNE,11), new Double(1.6085) },       { createDate(1999, Calendar.JUNE,14), new Double(1.6075) },       { createDate(1999, Calendar.JUNE,15), new Double(1.5950) },       { createDate(1999, Calendar.JUNE,16), new Double(1.5862) },       { createDate(1999, Calendar.JUNE,17), new Double(1.5925) },       { createDate(1999, Calendar.JUNE,18), new Double(1.5924) },       { createDate(1999, Calendar.JUNE,21), new Double(1.5890) },       { createDate(1999, Calendar.JUNE,22), new Double(1.5895) },       { createDate(1999, Calendar.JUNE,23), new Double(1.5787) },       { createDate(1999, Calendar.JUNE,24), new Double(1.5833) },       { createDate(1999, Calendar.JUNE,25), new Double(1.5893) },       { createDate(1999, Calendar.JUNE,28), new Double(1.5822) },       { createDate(1999, Calendar.JUNE,29), new Double(1.5781) },       { createDate(1999, Calendar.JUNE,30), new Double(1.5765) },       { createDate(1999, Calendar.JULY,1), new Double(1.5765) },       { createDate(1999, Calendar.JULY,2), new Double(1.5792) },       { createDate(1999, Calendar.JULY,6), new Double(1.5688) },       { createDate(1999, Calendar.JULY,7), new Double(1.5602) },       { createDate(1999, Calendar.JULY,8), new Double(1.5577) },       { createDate(1999, Calendar.JULY,9), new Double(1.5515) },       { createDate(1999, Calendar.JULY,12), new Double(1.5558) },       { createDate(1999, Calendar.JULY,13), new Double(1.5566) },       { createDate(1999, Calendar.JULY,14), new Double(1.5635) },       { createDate(1999, Calendar.JULY,15), new Double(1.5665) },       { createDate(1999, Calendar.JULY,16), new Double(1.5622) },       { createDate(1999, Calendar.JULY,19), new Double(1.5630) },       { createDate(1999, Calendar.JULY,20), new Double(1.5700) },       { createDate(1999, Calendar.JULY,21), new Double(1.5766) },       { createDate(1999, Calendar.JULY,22), new Double(1.5835) },       { createDate(1999, Calendar.JULY,23), new Double(1.5780) },       { createDate(1999, Calendar.JULY,26), new Double(1.5905) },       { createDate(1999, Calendar.JULY,27), new Double(1.5895) },       { createDate(1999, Calendar.JULY,28), new Double(1.5935) },       { createDate(1999, Calendar.JULY,29), new Double(1.6130) },       { createDate(1999, Calendar.JULY,30), new Double(1.6207) },       { createDate(1999, Calendar.AUGUST,2), new Double(1.6145) },       { createDate(1999, Calendar.AUGUST,3), new Double(1.6185) },       { createDate(1999, Calendar.AUGUST,4), new Double(1.6200) },       { createDate(1999, Calendar.AUGUST,5), new Double(1.6198) },       { createDate(1999, Calendar.AUGUST,6), new Double(1.6147) },       { createDate(1999, Calendar.AUGUST,9), new Double(1.6000) },       { createDate(1999, Calendar.AUGUST,10), new Double(1.6180) },       { createDate(1999, Calendar.AUGUST,11), new Double(1.6107) },       { createDate(1999, Calendar.AUGUST,12), new Double(1.6090) },       { createDate(1999, Calendar.AUGUST,13), new Double(1.6057) },       { createDate(1999, Calendar.AUGUST,16), new Double(1.6011) },       { createDate(1999, Calendar.AUGUST,17), new Double(1.6036) },       { createDate(1999, Calendar.AUGUST,18), new Double(1.6004) },       { createDate(1999, Calendar.AUGUST,19), new Double(1.6180) },       { createDate(1999, Calendar.AUGUST,20), new Double(1.6133) },       { createDate(1999, Calendar.AUGUST,23), new Double(1.6076) },       { createDate(1999, Calendar.AUGUST,24), new Double(1.5946) },       { createDate(1999, Calendar.AUGUST,25), new Double(1.5865) },       { createDate(1999, Calendar.AUGUST,26), new Double(1.5876) },       { createDate(1999, Calendar.AUGUST,27), new Double(1.5885) },       { createDate(1999, Calendar.AUGUST,30), new Double(1.5875) },       { createDate(1999, Calendar.AUGUST,31), new Double(1.6086) },       { createDate(1999, Calendar.SEPTEMBER,1), new Double(1.6023) },       { createDate(1999, Calendar.SEPTEMBER,2), new Double(1.6091) },       { createDate(1999, Calendar.SEPTEMBER,3), new Double(1.6028) },       { createDate(1999, Calendar.SEPTEMBER,7), new Double(1.6057) },       { createDate(1999, Calendar.SEPTEMBER,8), new Double(1.6185) },       { createDate(1999, Calendar.SEPTEMBER,9), new Double(1.6332) },       { createDate(1999, Calendar.SEPTEMBER,10), new Double(1.6183) },       { createDate(1999, Calendar.SEPTEMBER,13), new Double(1.6090) },       { createDate(1999, Calendar.SEPTEMBER,14), new Double(1.6085) },       { createDate(1999, Calendar.SEPTEMBER,15), new Double(1.6110) },       { createDate(1999, Calendar.SEPTEMBER,16), new Double(1.6250) },       { createDate(1999, Calendar.SEPTEMBER,17), new Double(1.6222) },       { createDate(1999, Calendar.SEPTEMBER,20), new Double(1.6230) },       { createDate(1999, Calendar.SEPTEMBER,21), new Double(1.6310) },       { createDate(1999, Calendar.SEPTEMBER,22), new Double(1.6363) },       { createDate(1999, Calendar.SEPTEMBER,23), new Double(1.6375) },       { createDate(1999, Calendar.SEPTEMBER,24), new Double(1.6428) },       { createDate(1999, Calendar.SEPTEMBER,27), new Double(1.6455) },       { createDate(1999, Calendar.SEPTEMBER,28), new Double(1.6485) },       { createDate(1999, Calendar.SEPTEMBER,29), new Double(1.6425) },       { createDate(1999, Calendar.SEPTEMBER,30), new Double(1.6457) },       { createDate(1999, Calendar.OCTOBER,1), new Double(1.6550) },       { createDate(1999, Calendar.OCTOBER,4), new Double(1.6555) },       { createDate(1999, Calendar.OCTOBER,5), new Double(1.6525) },       { createDate(1999, Calendar.OCTOBER,6), new Double(1.6560) },       { createDate(1999, Calendar.OCTOBER,7), new Double(1.6520) },       { createDate(1999, Calendar.OCTOBER,8), new Double(1.6520) },       { createDate(1999, Calendar.OCTOBER,12), new Double(1.6535) },       { createDate(1999, Calendar.OCTOBER,13), new Double(1.6532) },       { createDate(1999, Calendar.OCTOBER,14), new Double(1.6575) },       { createDate(1999, Calendar.OCTOBER,15), new Double(1.6684) },       { createDate(1999, Calendar.OCTOBER,18), new Double(1.6720) },       { createDate(1999, Calendar.OCTOBER,19), new Double(1.6708) },       { createDate(1999, Calendar.OCTOBER,20), new Double(1.6643) },       { createDate(1999, Calendar.OCTOBER,21), new Double(1.6765) },       { createDate(1999, Calendar.OCTOBER,22), new Double(1.6584) },       { createDate(1999, Calendar.OCTOBER,25), new Double(1.6631) },       { createDate(1999, Calendar.OCTOBER,26), new Double(1.6525) },       { createDate(1999, Calendar.OCTOBER,27), new Double(1.6477) },       { createDate(1999, Calendar.OCTOBER,28), new Double(1.6400) },       { createDate(1999, Calendar.OCTOBER,29), new Double(1.6425) },       { createDate(1999, Calendar.NOVEMBER,1), new Double(1.6404) },       { createDate(1999, Calendar.NOVEMBER,2), new Double(1.6445) },       { createDate(1999, Calendar.NOVEMBER,3), new Double(1.6440) },       { createDate(1999, Calendar.NOVEMBER,4), new Double(1.6375) },       { createDate(1999, Calendar.NOVEMBER,5), new Double(1.6205) },       { createDate(1999, Calendar.NOVEMBER,8), new Double(1.6150) },       { createDate(1999, Calendar.NOVEMBER,9), new Double(1.6210) },       { createDate(1999, Calendar.NOVEMBER,10), new Double(1.6250) },       { createDate(1999, Calendar.NOVEMBER,12), new Double(1.6131) },       { createDate(1999, Calendar.NOVEMBER,15), new Double(1.6230) },       { createDate(1999, Calendar.NOVEMBER,16), new Double(1.6164) },       { createDate(1999, Calendar.NOVEMBER,17), new Double(1.6231) },       { createDate(1999, Calendar.NOVEMBER,18), new Double(1.6150) },       { createDate(1999, Calendar.NOVEMBER,19), new Double(1.6160) },       { createDate(1999, Calendar.NOVEMBER,22), new Double(1.6205) },       { createDate(1999, Calendar.NOVEMBER,23), new Double(1.6236) },       { createDate(1999, Calendar.NOVEMBER,24), new Double(1.6090) },       { createDate(1999, Calendar.NOVEMBER,26), new Double(1.6062) },       { createDate(1999, Calendar.NOVEMBER,29), new Double(1.6024) },       { createDate(1999, Calendar.NOVEMBER,30), new Double(1.5935) },       { createDate(1999, Calendar.DECEMBER,1), new Double(1.5960) },       { createDate(1999, Calendar.DECEMBER,2), new Double(1.5972) },       { createDate(1999, Calendar.DECEMBER,3), new Double(1.6015) },       { createDate(1999, Calendar.DECEMBER,6), new Double(1.6230) },       { createDate(1999, Calendar.DECEMBER,7), new Double(1.6233) },       { createDate(1999, Calendar.DECEMBER,8), new Double(1.6255) },       { createDate(1999, Calendar.DECEMBER,9), new Double(1.6230) },       { createDate(1999, Calendar.DECEMBER,10), new Double(1.6225) },       { createDate(1999, Calendar.DECEMBER,13), new Double(1.6232) },       { createDate(1999, Calendar.DECEMBER,14), new Double(1.6110) },       { createDate(1999, Calendar.DECEMBER,15), new Double(1.6085) },       { createDate(1999, Calendar.DECEMBER,16), new Double(1.6123) },       { createDate(1999, Calendar.DECEMBER,17), new Double(1.6070) },       { createDate(1999, Calendar.DECEMBER,20), new Double(1.6035) },       { createDate(1999, Calendar.DECEMBER,21), new Double(1.6103) },       { createDate(1999, Calendar.DECEMBER,22), new Double(1.6060) },       { createDate(1999, Calendar.DECEMBER,23), new Double(1.6161) },       { createDate(1999, Calendar.DECEMBER,24), new Double(1.6154) },       { createDate(1999, Calendar.DECEMBER,27), new Double(1.6173) },       { createDate(1999, Calendar.DECEMBER,28), new Double(1.6165) },       { createDate(1999, Calendar.DECEMBER,29), new Double(1.6168) },       { createDate(1999, Calendar.DECEMBER,30), new Double(1.6130) },       { createDate(1999, Calendar.DECEMBER,31), new Double(1.6150) },       { createDate(2000, Calendar.JANUARY,3), new Double(1.6270) },       { createDate(2000, Calendar.JANUARY,4), new Double(1.6370) },       { createDate(2000, Calendar.JANUARY,5), new Double(1.6415) },       { createDate(2000, Calendar.JANUARY,6), new Double(1.6475) },       { createDate(2000, Calendar.JANUARY,7), new Double(1.6384) },       { createDate(2000, Calendar.JANUARY,10), new Double(1.6374) },       { createDate(2000, Calendar.JANUARY,11), new Double(1.6480) },       { createDate(2000, Calendar.JANUARY,12), new Double(1.6465) },       { createDate(2000, Calendar.JANUARY,13), new Double(1.6482) },       { createDate(2000, Calendar.JANUARY,14), new Double(1.6353) },       { createDate(2000, Calendar.JANUARY,18), new Double(1.6380) },       { createDate(2000, Calendar.JANUARY,19), new Double(1.6438) },       { createDate(2000, Calendar.JANUARY,20), new Double(1.6538) },       { createDate(2000, Calendar.JANUARY,21), new Double(1.6504) },       { createDate(2000, Calendar.JANUARY,24), new Double(1.6520) },       { createDate(2000, Calendar.JANUARY,25), new Double(1.6482) },       { createDate(2000, Calendar.JANUARY,26), new Double(1.6395) },       { createDate(2000, Calendar.JANUARY,27), new Double(1.6363) },       { createDate(2000, Calendar.JANUARY,28), new Double(1.6210) },       { createDate(2000, Calendar.JANUARY,31), new Double(1.6182) },       { createDate(2000, Calendar.FEBRUARY,1), new Double(1.6150) },       { createDate(2000, Calendar.FEBRUARY,2), new Double(1.6060) },       { createDate(2000, Calendar.FEBRUARY,3), new Double(1.6025) },       { createDate(2000, Calendar.FEBRUARY,4), new Double(1.5915) },       { createDate(2000, Calendar.FEBRUARY,7), new Double(1.5917) },       { createDate(2000, Calendar.FEBRUARY,8), new Double(1.6105) },       { createDate(2000, Calendar.FEBRUARY,9), new Double(1.6115) },       { createDate(2000, Calendar.FEBRUARY,10), new Double(1.6057) },       { createDate(2000, Calendar.FEBRUARY,11), new Double(1.5923) },       { createDate(2000, Calendar.FEBRUARY,14), new Double(1.5890) },       { createDate(2000, Calendar.FEBRUARY,15), new Double(1.5950) },       { createDate(2000, Calendar.FEBRUARY,16), new Double(1.6040) },       { createDate(2000, Calendar.FEBRUARY,17), new Double(1.6050) },       { createDate(2000, Calendar.FEBRUARY,18), new Double(1.5984) },       { createDate(2000, Calendar.FEBRUARY,22), new Double(1.6165) },       { createDate(2000, Calendar.FEBRUARY,23), new Double(1.6047) },       { createDate(2000, Calendar.FEBRUARY,24), new Double(1.5981) },       { createDate(2000, Calendar.FEBRUARY,25), new Double(1.5908) },       { createDate(2000, Calendar.FEBRUARY,28), new Double(1.5935) },       { createDate(2000, Calendar.FEBRUARY,29), new Double(1.5780) },       { createDate(2000, Calendar.MARCH,1), new Double(1.5849) },       { createDate(2000, Calendar.MARCH,2), new Double(1.5765) },       { createDate(2000, Calendar.MARCH,3), new Double(1.5810) },       { createDate(2000, Calendar.MARCH,6), new Double(1.5732) },       { createDate(2000, Calendar.MARCH,7), new Double(1.5772) },       { createDate(2000, Calendar.MARCH,8), new Double(1.5855) },       { createDate(2000, Calendar.MARCH,9), new Double(1.5815) },       { createDate(2000, Calendar.MARCH,10), new Double(1.5793) },       { createDate(2000, Calendar.MARCH,13), new Double(1.5782) },       { createDate(2000, Calendar.MARCH,14), new Double(1.5725) },       { createDate(2000, Calendar.MARCH,15), new Double(1.5730) },       { createDate(2000, Calendar.MARCH,16), new Double(1.5747) },       { createDate(2000, Calendar.MARCH,17), new Double(1.5705) } } };      return new DefaultXYDataset(new String[] { \"USD\" }, data);}", "nl": "Creates and returns a XYDataset for the demo charts"}
{"code": "public void windowClosed(WindowEvent e) {                          if (e.getWindow()==this.aboutFrame) {       aboutFrame=null;}}", "nl": "Clears the reference to the print preview frames when they are closed"}
{"code": "private JMenuBar createMenuBar() {           JMenuBar menuBar = new JMenuBar();           JMenu fileMenu = new JMenu(\"File\", true);     fileMenu.setMnemonic('F');       JMenuItem exitItem = new JMenuItem(\"Exit\", 'x');     exitItem.setActionCommand(\"exitItem\");     exitItem.addActionListener(this);     fileMenu.add(exitItem);           JMenu helpMenu = new JMenu(\"Help\");     helpMenu.setMnemonic('H');      JMenuItem aboutItem = new JMenuItem(\"About...\", 'A');     aboutItem.setActionCommand(\"aboutItem\");     aboutItem.addActionListener(this);     helpMenu.add(aboutItem);           menuBar.add(fileMenu);     menuBar.add(helpMenu);      return menuBar;}", "nl": "Creates a menubar"}
{"code": "private void displayVertical3DBarChart() {      if (vertical3DBarChartFrame==null) {           String title = \"Vertical Bar Chart (3D Effect)\";     String categoryAxisLabel = \"Categories\";     String valueAxisLabel = \"Values\";     CategoryDataset categoryData = createCategoryDataset();     JFreeChart chart = ChartFactory.createVerticalBarChart3D(title, categoryAxisLabel,                                  valueAxisLabel, categoryData, true);           chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.blue));     Plot plot = chart.getPlot();               vertical3DBarChartFrame = new JFreeChartFrame(\"Vertical 3D Bar Chart\", chart);       vertical3DBarChartFrame.pack();       SwingRefinery.positionFrameRandomly(vertical3DBarChartFrame);       vertical3DBarChartFrame.show();      }     else {       vertical3DBarChartFrame.show();       vertical3DBarChartFrame.requestFocus();}}", "nl": "Displays a vertical 3D bar chart in its own frame"}
{"code": "private void displayTimeSeriesWithMAChart() {      if (this.timeSeriesWithMAChartFrame==null) {               String title = \"Moving Average\";       String timeAxisLabel = \"Date\";       String valueAxisLabel = \"USD per GBP\";       XYDataset data = createXYDataset();       MovingAveragePlotFitAlgorithm mavg = new MovingAveragePlotFitAlgorithm();     mavg.setPeriod(30);       PlotFit pf = new PlotFit(data, mavg);       data = pf.getFit();       JFreeChart chart = ChartFactory.createTimeSeriesChart(title, timeAxisLabel, valueAxisLabel,                                 data, true);               TextTitle subtitle = new TextTitle(\"30 day moving average of GBP\", new Font(\"Arial\", Font.BOLD, 12));       chart.addTitle(subtitle);       chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.blue));                timeSeriesWithMAChartFrame = new JFreeChartFrame(\"Time Series Chart\", chart);       timeSeriesWithMAChartFrame.pack();       SwingRefinery.positionFrameRandomly(timeSeriesWithMAChartFrame);       timeSeriesWithMAChartFrame.show();      }     else {       timeSeriesWithMAChartFrame.show();       timeSeriesWithMAChartFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "private void displayHorizontalBarChart() {      if (horizontalBarChartFrame==null) {               String title = \"Horizontal Bar Chart\";       String categoryAxisLabel = \"Categories\";       String valueAxisLabel = \"Values\";       CategoryDataset categoryData = createCategoryDataset();       JFreeChart chart = ChartFactory.createHorizontalBarChart(title, categoryAxisLabel,                                  valueAxisLabel, categoryData,                                  true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.orange));               horizontalBarChartFrame = new JFreeChartFrame(\"Horizontal Bar Chart\", chart);       horizontalBarChartFrame.pack();       SwingRefinery.positionFrameRandomly(horizontalBarChartFrame);       horizontalBarChartFrame.show();      }     else {       horizontalBarChartFrame.show();       horizontalBarChartFrame.requestFocus();}}", "nl": "Displays a horizontal bar chart in its own frame"}
{"code": "private void about() {      if (aboutFrame==null) {       aboutFrame = new AboutFrame(\"About...\",                     \"JFreeChart\",                     \"Version \"+JFreeChart.VERSION,                     Licences.LGPL);       aboutFrame.pack();       SwingRefinery.centerFrameOnScreen(aboutFrame);     }     aboutFrame.show();     aboutFrame.requestFocus();}", "nl": "Displays information about the application"}
{"code": "private void displayTimeSeriesChartInScrollPane() {      if (this.timeSeriesChartScrollFrame==null) {               String title = \"Time Series Chart\";       String xAxisLabel = \"Date\";       String yAxisLabel = \"USD per GBP\";       XYDataset data = createXYDataset();       JFreeChart chart = ChartFactory.createTimeSeriesChart(title, xAxisLabel, yAxisLabel, data,                                 true);               TextTitle subtitle = new TextTitle(\"Value of GBP\", new Font(\"Arial\", Font.BOLD, 12));       chart.addTitle(subtitle);       chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.gray));       Plot plot = chart.getPlot();               timeSeriesChartScrollFrame = new JFreeChartFrame(\"Time Series Chart\", chart, true);       timeSeriesChartScrollFrame.pack();       SwingRefinery.positionFrameRandomly(timeSeriesChartScrollFrame);       timeSeriesChartScrollFrame.show();      }     else {       timeSeriesChartScrollFrame.show();       timeSeriesChartScrollFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "public Object[][][] getResults() {           alg.setXYDataset(dataset);           int arraysize = 0;     int seriescount = dataset.getSeriesCount();     for(int i = 0; i < seriescount; i++) {       if(dataset.getItemCount(i) > arraysize) {         arraysize = dataset.getItemCount(i);       }     }           Object[][][] newdata = new Object[seriescount * 2][arraysize][2];           for(int i = 0; i < seriescount; i++) {       for(int j = 0; j < dataset.getItemCount(i); j++) {         Number x = dataset.getXValue(i,j);         newdata[i][j][0] = x;         newdata[i][j][1] = dataset.getYValue(i,j);         Number y = alg.getY(i, x);                           if(y != null) {           newdata[i + seriescount][j][0] = x;           newdata[i + seriescount][j][1] = y;         }         else {           newdata[i + seriescount][j][0] = null;           newdata[i + seriescount][j][1] = null;       }       }     }     return newdata;}", "nl": "Returns a three - dimensional array based on algorithm calculations"}
{"code": "public void setPlotFitAlgorithm(PlotFitAlgorithm alg) {     this.alg = alg;}", "nl": "Sets the algorithm used to generate the new dataset"}
{"code": "public PlotFit(XYDataset data, PlotFitAlgorithm alg) {     this.dataset = data;     this.alg = alg;}", "nl": "Standard constructor"}
{"code": "public void setXYDataset(XYDataset data) {     this.dataset = data;}", "nl": "Sets the underlying dataset"}
{"code": "public Number getXValue(int series, int item) {     return null;}", "nl": "Returns the x - value for the specified series and item"}
{"code": "public Number getYValue(int series, int item) {     return null;}", "nl": "Returns the y - value for the specified series and item"}
{"code": "public int getSeriesCount() {     return 0;}", "nl": "Returns the number of series in the data source"}
{"code": "public int getSeriesCount() {     return SERIES_COUNT;}", "nl": "Returns the number of series in the data source"}
{"code": "public SampleXYDataset2() {      for (int series=0; series<SERIES_COUNT; series++) {       for (int item=0; item<ITEM_COUNT; item++) {         double x = (Math.random()-0.5) * RANGE;         xValues[series][item] = new Double(x);         yValues[series][item] = new Double((Math.random() - 0.5) * x * x);}}}", "nl": "Default constructor"}
{"code": "public Number getXValue(int series, int item) {     return xValues[series][item];}", "nl": "Returns the x - value for the specified series and item"}
{"code": "public Number getOpenValue(int series, int item) {     if (series==0) {       return opens[item];     }     else return null;}", "nl": "Returns the open - value for the specified series and item"}
{"code": "private void initialiseData() {      dates = new Date[47];     highs = new Double[47];     lows = new Double[47];     opens = new Double[47];     closes = new Double[47];      dates[0]  = createDate(1999, Calendar.JANUARY,4);     highs[0]  = new Double(47.0);     lows[0]   = new Double(33.0);     opens[0]  = new Double(35.0);     closes[0] = new Double(33.0);      dates[1]  = createDate(1999, Calendar.JANUARY,5);     highs[1]  = new Double(47.0);     lows[1]   = new Double(32.0);     opens[1]  = new Double(41.0);     closes[1] = new Double(37.0);      dates[2]  = createDate(1999, Calendar.JANUARY,6);     highs[2]  = new Double(49.0);     lows[2]   = new Double(43.0);     opens[2]  = new Double(46.0);     closes[2] = new Double(48.0);      dates[3]  = createDate(1999, Calendar.JANUARY,7);     highs[3]  = new Double(51.0);     lows[3]   = new Double(39.0);     opens[3]  = new Double(40.0);     closes[3] = new Double(47.0);      dates[4]  = createDate(1999, Calendar.JANUARY,8);     highs[4]  = new Double(60.0);     lows[4]   = new Double(40.0);     opens[4]  = new Double(46.0);     closes[4] = new Double(53.0);      dates[5]  = createDate(1999, Calendar.JANUARY,9);     highs[5]  = new Double(62.0);     lows[5]   = new Double(55.0);     opens[5]  = new Double(57.0);     closes[5] = new Double(61.0);      dates[6]  = createDate(1999, Calendar.JANUARY,10);     highs[6]  = new Double(65.0);     lows[6]   = new Double(56.0);     opens[6]  = new Double(62.0);     closes[6] = new Double(59.0);      dates[7]  = createDate(1999, Calendar.JANUARY,11);     highs[7]  = new Double(55.0);     lows[7]   = new Double(43.0);     opens[7]  = new Double(45.0);     closes[7] = new Double(47.0);      dates[8]  = createDate(1999, Calendar.JANUARY,12);     highs[8]  = new Double(54.0);     lows[8]   = new Double(33.0);     opens[8]  = new Double(40.0);     closes[8] = new Double(51.0);      dates[9]  = createDate(1999, Calendar.JANUARY,13);     highs[9]  = new Double(47.0);     lows[9]   = new Double(33.0);     opens[9]  = new Double(35.0);     closes[9] = new Double(33.0);      dates[10]  = createDate(1999, Calendar.JANUARY,14);     highs[10]  = new Double(54.0);     lows[10]   = new Double(38.0);     opens[10]  = new Double(43.0);     closes[10] = new Double(52.0);      dates[11]  = createDate(1999, Calendar.JANUARY,15);     highs[11]  = new Double(48.0);     lows[11]   = new Double(41.0);     opens[11]  = new Double(44.0);     closes[11] = new Double(41.0);      dates[12]  = createDate(1999, Calendar.JANUARY,17);     highs[12]  = new Double(60.0);     lows[12]   = new Double(30.0);     opens[12]  = new Double(34.0);     closes[12] = new Double(44.0);      dates[13]  = createDate(1999, Calendar.JANUARY,18);     highs[13]  = new Double(58.0);     lows[13]   = new Double(44.0);     opens[13]  = new Double(54.0);     closes[13] = new Double(56.0);      dates[14]  = createDate(1999, Calendar.JANUARY,19);     highs[14]  = new Double(54.0);     lows[14]   = new Double(32.0);     opens[14]  = new Double(42.0);     closes[14] = new Double(53.0);      dates[15]  = createDate(1999, Calendar.JANUARY,20);     highs[15]  = new Double(53.0);     lows[15]   = new Double(39.0);     opens[15]  = new Double(50.0);     closes[15] = new Double(49.0);      dates[16]  = createDate(1999, Calendar.JANUARY,21);     highs[16]  = new Double(47.0);     lows[16]   = new Double(33.0);     opens[16]  = new Double(41.0);     closes[16] = new Double(40.0);      dates[17]  = createDate(1999, Calendar.JANUARY,22);     highs[17]  = new Double(55.0);     lows[17]   = new Double(37.0);     opens[17]  = new Double(43.0);     closes[17] = new Double(45.0);      dates[18]  = createDate(1999, Calendar.JANUARY,23);     highs[18]  = new Double(54.0);     lows[18]   = new Double(42.0);     opens[18]  = new Double(50.0);     closes[18] = new Double(42.0);      dates[19]  = createDate(1999, Calendar.JANUARY,24);     highs[19]  = new Double(48.0);     lows[19]   = new Double(37.0);     opens[19]  = new Double(37.0);     closes[19] = new Double(47.0);      dates[20]  = createDate(1999, Calendar.JANUARY,25);     highs[20]  = new Double(58.0);     lows[20]   = new Double(33.0);     opens[20]  = new Double(39.0);     closes[20] = new Double(41.0);      dates[21]  = createDate(1999, Calendar.JANUARY,26);     highs[21]  = new Double(47.0);     lows[21]   = new Double(31.0);     opens[21]  = new Double(36.0);     closes[21] = new Double(41.0);      dates[22]  = createDate(1999, Calendar.JANUARY,27);     highs[22]  = new Double(58.0);     lows[22]   = new Double(44.0);     opens[22]  = new Double(49.0);     closes[22] = new Double(44.0);      dates[23]  = createDate(1999, Calendar.JANUARY,28);     highs[23]  = new Double(46.0);     lows[23]   = new Double(41.0);     opens[23]  = new Double(43.0);     closes[23] = new Double(44.0);      dates[24]  = createDate(1999, Calendar.JANUARY,29);     highs[24]  = new Double(56.0);     lows[24]   = new Double(39.0);     opens[24]  = new Double(39.0);     closes[24] = new Double(51.0);      dates[25]  = createDate(1999, Calendar.JANUARY,30);     highs[25]  = new Double(56.0);     lows[25]   = new Double(39.0);     opens[25]  = new Double(47.0);     closes[25] = new Double(49.0);      dates[26]  = createDate(1999, Calendar.JANUARY,31);     highs[26]  = new Double(53.0);     lows[26]   = new Double(39.0);     opens[26]  = new Double(52.0);     closes[26] = new Double(47.0);      dates[27]  = createDate(1999, Calendar.FEBRUARY,1);     highs[27]  = new Double(51.0);     lows[27]   = new Double(30.0);     opens[27]  = new Double(45.0);     closes[27] = new Double(47.0);      dates[28]  = createDate(1999, Calendar.FEBRUARY,2);     highs[28]  = new Double(47.0);     lows[28]   = new Double(30.0);     opens[28]  = new Double(34.0);     closes[28] = new Double(46.0);      dates[29]  = createDate(1999, Calendar.FEBRUARY,3);     highs[29]  = new Double(57.0);     lows[29]   = new Double(37.0);     opens[29]  = new Double(44.0);     closes[29] = new Double(56.0);      dates[30]  = createDate(1999, Calendar.FEBRUARY,4);     highs[30]  = new Double(49.0);     lows[30]   = new Double(40.0);     opens[30]  = new Double(47.0);     closes[30] = new Double(44.0);      dates[31]  = createDate(1999, Calendar.FEBRUARY,5);     highs[31]  = new Double(46.0);     lows[31]   = new Double(38.0);     opens[31]  = new Double(43.0);     closes[31] = new Double(40.0);      dates[32]  = createDate(1999, Calendar.FEBRUARY,6);     highs[32]  = new Double(55.0);     lows[32]   = new Double(38.0);     opens[32]  = new Double(39.0);     closes[32] = new Double(53.0);      dates[33]  = createDate(1999, Calendar.FEBRUARY,7);     highs[33]  = new Double(50.0);     lows[33]   = new Double(33.0);     opens[33]  = new Double(37.0);     closes[33] = new Double(37.0);      dates[34]  = createDate(1999, Calendar.FEBRUARY,8);     highs[34]  = new Double(59.0);     lows[34]   = new Double(34.0);     opens[34]  = new Double(57.0);     closes[34] = new Double(43.0);      dates[35]  = createDate(1999, Calendar.FEBRUARY,9);     highs[35]  = new Double(48.0);     lows[35]   = new Double(39.0);     opens[35]  = new Double(46.0);     closes[35] = new Double(47.0);      dates[36]  = createDate(1999, Calendar.FEBRUARY,10);     highs[36]  = new Double(55.0);     lows[36]   = new Double(30.0);     opens[36]  = new Double(37.0);     closes[36] = new Double(30.0);      dates[37]  = createDate(1999, Calendar.FEBRUARY,11);     highs[37]  = new Double(60.0);     lows[37]   = new Double(32.0);     opens[37]  = new Double(56.0);     closes[37] = new Double(36.0);      dates[38]  = createDate(1999, Calendar.FEBRUARY,12);     highs[38]  = new Double(56.0);     lows[38]   = new Double(42.0);     opens[38]  = new Double(53.0);     closes[38] = new Double(54.0);      dates[39]  = createDate(1999, Calendar.FEBRUARY,13);     highs[39]  = new Double(49.0);     lows[39]   = new Double(42.0);     opens[39]  = new Double(45.0);     closes[39] = new Double(42.0);      dates[40]  = createDate(1999, Calendar.FEBRUARY,14);     highs[40]  = new Double(55.0);     lows[40]   = new Double(42.0);     opens[40]  = new Double(47.0);     closes[40] = new Double(54.0);       dates[41]  = createDate(1999, Calendar.FEBRUARY,15);     highs[41]  = new Double(49.0);     lows[41]   = new Double(35.0);     opens[41]  = new Double(38.0);     closes[41] = new Double(35.0);      dates[42]  = createDate(1999, Calendar.FEBRUARY,16);     highs[42]  = new Double(47.0);     lows[42]   = new Double(38.0);     opens[42]  = new Double(43.0);     closes[42] = new Double(42.0);      dates[43]  = createDate(1999, Calendar.FEBRUARY,17);     highs[43]  = new Double(53.0);     lows[43]   = new Double(42.0);     opens[43]  = new Double(47.0);     closes[43] = new Double(48.0);      dates[44]  = createDate(1999, Calendar.FEBRUARY,18);     highs[44]  = new Double(47.0);     lows[44]   = new Double(44.0);     opens[44]  = new Double(46.0);     closes[44] = new Double(44.0);      dates[45]  = createDate(1999, Calendar.FEBRUARY,19);     highs[45]  = new Double(46.0);     lows[45]   = new Double(40.0);     opens[45]  = new Double(43.0);     closes[45] = new Double(44.0);      dates[46]  = createDate(1999, Calendar.FEBRUARY,20);     highs[46]  = new Double(48.0);     lows[46]   = new Double(41.0);     opens[46]  = new Double(46.0);     closes[46] = new Double(41.0);}", "nl": "Sets up the data for the sample data source"}
{"code": "public Number getHighValue(int series, int item) {     if (series==0) {       return highs[item];     }     else return null;}", "nl": "Returns the high - value for the specified series and item"}
{"code": "public int getItemCount(int series) {     return 47;}", "nl": "Returns the number of items in the specified series"}
{"code": "public Number getLowValue(int series, int item) {     if (series==0) {       return lows[item];     }     else return null;}", "nl": "Returns the low - value for the specified series and item"}
{"code": "public Number getXValue(int series, int item) {     return new Long(dates[item].getTime());}", "nl": "Returns the x - value for the specified series and item"}
{"code": "public SampleHighLowDataset() {     this.initialiseData();}", "nl": "Default constructor"}
{"code": "public Number getCloseValue(int series, int item) {     if (series==0) {       return closes[item];     }     else return null;}", "nl": "Returns the close - value for the specified series and item"}
{"code": "public void setPeriod(int period) {     this.period = period;}", "nl": "Sets the period for this moving average algorithm"}
{"code": "public void actionPerformed(ActionEvent event) {     String command = event.getActionCommand();     if (command.equals(\"SelectLabelFont\")) {       attemptLabelFontSelection();     }     else if (command.equals(\"SelectLabelPaint\")) {       attemptModifyLabelPaint();     }     else if (command.equals(\"SelectTickLabelFont\")) {       attemptTickLabelFontSelection();     }     else if (command.equals(\"LabelInsets\"))     {       editLabelInsets();     }     else if (command.equals(\"TickLabelInsets\"))     {       editTickLabelInsets();}}", "nl": "Handles user interaction with the property panel"}
{"code": "public String getName() {     return \"Moving Average\";}", "nl": "@ return the name that you want to see in the legend"}
{"code": "private void editTickLabelInsets() {     InsetsChooserPanel panel = new InsetsChooserPanel(_tickLabelInsets);     int result =       JOptionPane.showConfirmDialog(this, panel, \"Edit Insets\",                       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       _tickLabelInsets = panel.getInsets();       tickLabelInsetsTextField.setInsets(_tickLabelInsets);}}", "nl": "Presents insets chooser panel allowing user to modify tick label ' s individual insets values"}
{"code": "public Number getY(int series, Number x) {           double[][] mavg = ((ArrayHolder)plots.elementAt(series)).getArray();     for(int j = 0; j < mavg.length; j++) {               if(mavg[j][0] == x.doubleValue()) {         return new Double(mavg[j][1]);       }     }          return null;}", "nl": "Returns the y - value for any x - value"}
{"code": "public JTabbedPane getOtherTabs() {     return otherTabs;}", "nl": "Returns a reference to the tabbed pane"}
{"code": "public Insets getTickLabelInsets() {     return (_tickLabelInsets == null) ? new Insets(0,0,0,0) : _tickLabelInsets;}", "nl": "Returns the current tick label insets value"}
{"code": "private void attemptLabelFontSelection() {      FontChooserPanel panel = new FontChooserPanel(labelFont);     int result = JOptionPane.showConfirmDialog(this, panel, \"Font Selection\",       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       labelFont = panel.getSelectedFont();       labelFontField.setText(labelFont.getFontName()+\" \"+labelFont.getSize());}}", "nl": "Presents a font selection dialog to the user"}
{"code": "public static AxisPropertyEditPanel getInstance(Axis axis) {      if (axis!=null) {              if (axis instanceof NumberAxis) {         return new NumberAxisPropertyEditPanel((NumberAxis)axis);       }       else return new AxisPropertyEditPanel(axis);     }     else return null;}", "nl": "A static method that returns a panel that is appropriate for the axis type"}
{"code": "public Insets getLabelInsets() {     return (_labelInsets == null) ? new Insets(0,0,0,0) : _labelInsets;}", "nl": "Returns the current label insets value"}
{"code": "public String getLabel() {     return label.getText();}", "nl": "Returns the current axis label"}
{"code": "private void attemptModifyLabelPaint() {     Color c;     c = JColorChooser.showDialog(this, \"Label Color\", Color.blue);     if (c!=null) {       labelPaintSample.setPaint(c);}}", "nl": "Allows the user the opportunity to change the outline paint"}
{"code": "public Paint getTickLabelPaint() {     return tickLabelPaintSample.getPaint();}", "nl": "Returns the current tick label paint"}
{"code": "public Paint getLabelPaint() {     return labelPaintSample.getPaint();}", "nl": "Returns the current label paint"}
{"code": "private void editLabelInsets() {     InsetsChooserPanel panel = new InsetsChooserPanel(_labelInsets);     int result =       JOptionPane.showConfirmDialog(this, panel, \"Edit Insets\",                     JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       _labelInsets = panel.getInsets();       labelInsetsTextField.setInsets(_labelInsets);}}", "nl": "Presents insets chooser panel allowing user to modify label ' s individual insets values"}
{"code": "public AxisPropertyEditPanel(Axis axis) {      labelFont = axis.getLabelFont();     labelPaintSample = new PaintSample(axis.getLabelPaint());     tickLabelFont = axis.getTickLabelFont();     tickLabelPaintSample = new PaintSample(axis.getTickLabelPaint());           _tickLabelInsets = axis.getTickLabelInsets();     _labelInsets = axis.getLabelInsets();      setLayout(new BorderLayout());      JPanel general = new JPanel(new BorderLayout());     general.setBorder(BorderFactory.createTitledBorder(               BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(5));     interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));     interior.add(new JLabel(\"Label:\"));     label = new JTextField(axis.getLabel());     interior.add(label);     interior.add(new JPanel());      interior.add(new JLabel(\"Font:\"));     labelFontField = new FontDisplayField(labelFont);     interior.add(labelFontField);     JButton b = new JButton(\"Select...\");     b.setActionCommand(\"SelectLabelFont\");     b.addActionListener(this);     interior.add(b);      interior.add(new JLabel(\"Paint:\"));     interior.add(labelPaintSample);     b = new JButton(\"Select...\");     b.setActionCommand(\"SelectLabelPaint\");     b.addActionListener(this);     interior.add(b);      interior.add(new JLabel(\"Label Insets:\"));     b = new JButton(\"Edit...\");     b.setActionCommand(\"LabelInsets\");     b.addActionListener(this);     labelInsetsTextField = new InsetsTextField(_labelInsets);     interior.add(labelInsetsTextField);     interior.add(b);      interior.add(new JLabel(\"Tick Label Insets:\"));     b = new JButton(\"Edit...\");     b.setActionCommand(\"TickLabelInsets\");     b.addActionListener(this);     tickLabelInsetsTextField = new InsetsTextField(_tickLabelInsets);     interior.add(tickLabelInsetsTextField);     interior.add(b);      general.add(interior);      add(general, BorderLayout.NORTH);      slot1 = new JPanel(new BorderLayout());      JPanel other = new JPanel(new BorderLayout());     other.setBorder(BorderFactory.createTitledBorder(                BorderFactory.createEtchedBorder(), \"Other:\"));      otherTabs = new JTabbedPane();     otherTabs.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      JPanel ticks = new JPanel(new LCBLayout(3));     ticks.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));      showTickLabelsCheckBox = new JCheckBox(\"Show tick labels\", axis.isTickLabelsVisible());     ticks.add(showTickLabelsCheckBox);     ticks.add(new JPanel());     ticks.add(new JPanel());      ticks.add(new JLabel(\"Tick label font:\"));     tickLabelFontField = new FontDisplayField(tickLabelFont);     ticks.add(tickLabelFontField);     b = new JButton(\"Select...\");     b.setActionCommand(\"SelectTickLabelFont\");     b.addActionListener(this);     ticks.add(b);      showTickMarksCheckBox = new JCheckBox(\"Show tick marks\", axis.isTickMarksVisible());     ticks.add(showTickMarksCheckBox);     ticks.add(new JPanel());     ticks.add(new JPanel());      otherTabs.add(\"Ticks\", ticks);      other.add(otherTabs);      slot1.add(other);      slot2 = new JPanel(new BorderLayout());     slot2.add(slot1, BorderLayout.NORTH);     add(slot2);}", "nl": "Standard constructor : builds a panel for displaying editing the properties of the specified axis"}
{"code": "private void attemptGridPaintSelection() {     Color c;     c = JColorChooser.showDialog(this, \"Grid Color\", Color.blue);     if (c!=null) {       gridPaintSample.setPaint(c);}}", "nl": "Handle a grid paint selection"}
{"code": "public NumberAxisPropertyEditPanel(NumberAxis axis) {      super(axis);      autoRange = axis.isAutoRange();     minimumValue = axis.getMinimumAxisValue();     maximumValue = axis.getMaximumAxisValue();      gridPaintSample = new PaintSample(axis.getGridPaint());     gridStrokeSample = new StrokeSample(axis.getGridStroke());      availableStrokeSamples = new StrokeSample[3];     availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));     availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));     availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));      JTabbedPane other = getOtherTabs();      JPanel range = new JPanel(new LCBLayout(3));     range.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));      range.add(new JPanel());     autoRangeCheckBox = new JCheckBox(\"Auto-adjust range:\", autoRange);     autoRangeCheckBox.setActionCommand(\"AutoRangeOnOff\");     autoRangeCheckBox.addActionListener(this);     range.add(autoRangeCheckBox);     range.add(new JPanel());      range.add(new JLabel(\"Minimum range value:\"));     minimumRangeValue = new JTextField(minimumValue.toString());     minimumRangeValue.setEnabled(!autoRange);     minimumRangeValue.setActionCommand(\"MinimumRange\");     minimumRangeValue.addActionListener(this);     minimumRangeValue.addFocusListener(this);     range.add(minimumRangeValue);     range.add(new JPanel());      range.add(new JLabel(\"Maximum range value:\"));     maximumRangeValue = new JTextField(maximumValue.toString());     maximumRangeValue.setEnabled(!autoRange);     maximumRangeValue.setActionCommand(\"MaximumRange\");     maximumRangeValue.addActionListener(this);     maximumRangeValue.addFocusListener(this);     range.add(maximumRangeValue);     range.add(new JPanel());      other.add(\"Range\", range);      JPanel grid = new JPanel(new LCBLayout(3));     grid.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));      grid.add(new JPanel());     showGridLinesCheckBox = new JCheckBox(\"Show grid lines\", axis.isShowGridLines());     grid.add(showGridLinesCheckBox);     grid.add(new JPanel());      grid.add(new JLabel(\"Grid stroke:\"));     JButton button = new JButton(\"Set stroke...\");     button.setActionCommand(\"GridStroke\");     button.addActionListener(this);     grid.add(gridStrokeSample);     grid.add(button);      grid.add(new JLabel(\"Grid paint:\"));     button = new JButton(\"Set paint...\");     button.setActionCommand(\"GridPaint\");     button.addActionListener(this);     grid.add(gridPaintSample);     grid.add(button);      other.add(\"Grid\", grid);}", "nl": "Standard constructor : builds a property panel for the specified axis"}
{"code": "public Number getMaximumValue() {     return maximumValue;}", "nl": "Returns the current setting of the maximum value in the axis range"}
{"code": "private void attemptModifySeriesPaint() {     Color c;     c = JColorChooser.showDialog(this, \"Series Label Color\", Color.blue);     if (c!=null) {       seriesPaint.setPaint(c);}}", "nl": "Allows the user the opportunity to change the series label paint"}
{"code": "public LegendPropertyEditPanel(Legend legend) {      StandardLegend l = (StandardLegend)legend;     outlineStroke = new StrokeSample(l.getOutlineStroke());     outlinePaint = new PaintSample(l.getOutlinePaint());     backgroundPaint = new PaintSample(l.getBackgroundPaint());     seriesFont = l.getSeriesFont();     seriesPaint = new PaintSample(l.getSeriesPaint());      availableStrokeSamples = new StrokeSample[4];     availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));     availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));     availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));     availableStrokeSamples[3] = new StrokeSample(new BasicStroke(4.0f));      setLayout(new BorderLayout());      JPanel general = new JPanel(new BorderLayout());     general.setBorder(BorderFactory.createTitledBorder(                 BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(5));     interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));     JLabel titleLabel = new JLabel(\"Text:\");      interior.add(new JLabel(\"Outline:\"));     interior.add(outlineStroke);     JButton button = new JButton(\"Select...\");     button.setActionCommand(\"OutlineStroke\");     button.addActionListener(this);     interior.add(button);      interior.add(new JLabel(\"Outline Paint:\"));     button = new JButton(\"Select...\");     button.setActionCommand(\"OutlinePaint\");     button.addActionListener(this);     interior.add(outlinePaint);     interior.add(button);      interior.add(new JLabel(\"Background:\"));     button = new JButton(\"Select...\");     button.setActionCommand(\"BackgroundPaint\");     button.addActionListener(this);     interior.add(backgroundPaint);     interior.add(button);      interior.add(new JLabel(\"Series label font:\"));     button = new JButton(\"Select...\");     button.setActionCommand(\"SeriesFont\");     button.addActionListener(this);     interior.add(new FontDisplayField(seriesFont));     interior.add(button);      interior.add(new JLabel(\"Series label paint:\")) ;     button = new JButton(\"Select...\");     button.setActionCommand(\"SeriesPaint\");     button.addActionListener(this);     interior.add(seriesPaint) ;     interior.add(button) ;      general.add(interior);     add(general, BorderLayout.NORTH);}", "nl": "Standard constructor : builds a panel based on the specified legend"}
{"code": "public Font getSeriesFont() {     return seriesFont;}", "nl": "Returns the current series label font"}
{"code": "public void attemptModifySeriesFont() {      FontChooserPanel panel = new FontChooserPanel(seriesFont);     int result = JOptionPane.showConfirmDialog(this, panel, \"Font Selection\",       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       seriesFont = panel.getSelectedFont();}}", "nl": "Allows the user the opportunity to change the series label font"}
{"code": "private void attemptModifyBackgroundPaint() {     Color c;     c = JColorChooser.showDialog(this, \"Background Color\", Color.blue);     if (c!=null) {       backgroundPaint.setPaint(c);}}", "nl": "Allows the user the opportunity to change the background paint"}
{"code": "public Paint getBackgroundPaint() {     return backgroundPaint.getPaint();}", "nl": "Returns the current background paint"}
{"code": "public Paint getOutlinePaint() {     return outlinePaint.getPaint();}", "nl": "Returns the current outline paint"}
{"code": "public Stroke getOutlineStroke() {     return outlineStroke.getStroke();}", "nl": "Returns the current outline stroke"}
{"code": "public void setLegendProperties(Legend legend) {     if (legend instanceof StandardLegend) {         StandardLegend standard = (StandardLegend)legend;       standard.setOutlineStroke(this.getOutlineStroke());       standard.setOutlinePaint(this.getOutlinePaint());       standard.setBackgroundPaint(this.getBackgroundPaint());       standard.setSeriesFont(this.getSeriesFont());       standard.setSeriesPaint(this.getSeriesPaint());}}", "nl": "Sets the properties of the specified legend to match the properties defined on this panel"}
{"code": "private void attemptModifyOutlinePaint() {     Color c;     c = JColorChooser.showDialog(this, \"Outline Color\", Color.blue);     if (c!=null) {       outlinePaint.setPaint(c);}}", "nl": "Allows the user the opportunity to change the outline paint"}
{"code": "public void updatePlotProperties(Plot plot) {           plot.setOutlinePaint(this.getOutlinePaint());     plot.setOutlineStroke(this.getOutlineStroke());     plot.setBackgroundPaint(this.getBackgroundPaint());     plot.setInsets(this.getPlotInsets());           if (this.horizontalAxisPropertyPanel!=null) {       this.horizontalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.HORIZONTAL_AXIS));     }      if (this.verticalAxisPropertyPanel!=null) {       this.verticalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.VERTICAL_AXIS));}}", "nl": "Updates the plot properties to match the properties defined on the panel"}
{"code": "private void editInsets() {     InsetsChooserPanel panel = new InsetsChooserPanel(_insets);     int result =       JOptionPane.showConfirmDialog(this, panel, \"Edit Insets\",                       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       _insets = panel.getInsets();       insetsTextField.setInsets(_insets);}}", "nl": "Allow the user to edit the individual insets ' values"}
{"code": "public Paint getBackgroundPaint() {     return backgroundPaintSample.getPaint();}", "nl": "Returns the current background paint"}
{"code": "public PlotPropertyEditPanel(Plot plot) {      _insets = plot.getInsets();     backgroundPaintSample = new PaintSample(plot.getBackgroundPaint());     outlineStrokeSample = new StrokeSample(plot.getOutlineStroke());     outlinePaintSample = new PaintSample(plot.getOutlinePaint());      setLayout(new BorderLayout());      availableStrokeSamples = new StrokeSample[3];     availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));     availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));     availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));           JPanel panel = new JPanel(new BorderLayout());     panel.setBorder(BorderFactory.createTitledBorder(               BorderFactory.createEtchedBorder(), plot.getPlotType()+\":\"));      JPanel general = new JPanel(new BorderLayout());     general.setBorder(BorderFactory.createTitledBorder(                 BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(4));     interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      interior.add(new JLabel(\"Insets:\"));     JButton button = new JButton(\"Edit...\");     button.setActionCommand(\"Insets\");     button.addActionListener(this);      insetsTextField = new InsetsTextField(_insets);     insetsTextField.setEnabled(false);     interior.add(insetsTextField);     interior.add(button);      interior.add(new JLabel(\"Outline stroke:\"));     button = new JButton(\"Select...\");     button.setActionCommand(\"OutlineStroke\");     button.addActionListener(this);     interior.add(outlineStrokeSample);     interior.add(button);      interior.add(new JLabel(\"Outline paint:\"));     button = new JButton(\"Select...\");     button.setActionCommand(\"OutlinePaint\");     button.addActionListener(this);     interior.add(outlinePaintSample);     interior.add(button);      interior.add(new JLabel(\"Background paint:\"));     button = new JButton(\"Select...\");     button.setActionCommand(\"BackgroundPaint\");     button.addActionListener(this);     interior.add(backgroundPaintSample);     interior.add(button);      general.add(interior, BorderLayout.NORTH);      JPanel appearance = new JPanel(new BorderLayout());     appearance.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));     appearance.add(general, BorderLayout.NORTH);      JTabbedPane tabs = new JTabbedPane();     tabs.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      verticalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.VERTICAL_AXIS));     if (verticalAxisPropertyPanel!=null) {       verticalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));       tabs.add(\"Vertical Axis\", verticalAxisPropertyPanel);     }     horizontalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.HORIZONTAL_AXIS));     if (horizontalAxisPropertyPanel!=null) {       horizontalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));       tabs.add(\"Horizontal Axis\", horizontalAxisPropertyPanel);     }     tabs.add(\"Appearance\", appearance);     panel.add(tabs);      add(panel);}", "nl": "Standard constructor - constructs a panel for editing the properties of the specified plot"}
{"code": "public AxisPropertyEditPanel getVerticalAxisPropertyEditPanel() {     return verticalAxisPropertyPanel;}", "nl": "Returns a reference to the panel for editing the properties of the vertical axis"}
{"code": "public void actionPerformed(ActionEvent event) {     String command = event.getActionCommand();     if (command.equals(\"BackgroundPaint\")) {       attemptBackgroundPaintSelection();     }     else if (command.equals(\"OutlineStroke\")) {       attemptOutlineStrokeSelection();     }     else if (command.equals(\"OutlinePaint\")) {       attemptOutlinePaintSelection();     }     else if (command.equals(\"Insets\")) {       editInsets();}}", "nl": "Handles user actions generated within the panel"}
{"code": "public Paint getOutlinePaint() {     return outlinePaintSample.getPaint();}", "nl": "Returns the current outline paint"}
{"code": "public Insets getPlotInsets() {     if (_insets == null)       _insets = new Insets(0,0,0,0);     return _insets;}", "nl": "Returns the current plot insets"}
{"code": "private void attemptOutlineStrokeSelection() {     StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);     int result = JOptionPane.showConfirmDialog(this, panel, \"Stroke Selection\",       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       outlineStrokeSample.setStroke(panel.getSelectedStroke());}}", "nl": "Allow the user to change the outline stroke"}
{"code": "public ChartPropertyEditPanel(JFreeChart chart) {     setLayout(new BorderLayout());      JPanel other = new JPanel(new BorderLayout());     other.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));      JPanel general = new JPanel(new BorderLayout());     general.setBorder(BorderFactory.createTitledBorder(                 BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(6));     interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      antialias = new JCheckBox(\"Draw anti-aliased\");     antialias.setSelected(chart.getAntiAlias());     interior.add(antialias);     interior.add(new JLabel(\"\"));     interior.add(new JLabel(\"\"));     interior.add(new JLabel(\"Background paint:\"));     background = new PaintSample(chart.getChartBackgroundPaint());     interior.add(background);     JButton button = new JButton(\"Select...\");     button.setActionCommand(\"BackgroundPaint\");     button.addActionListener(this);     interior.add(button);      interior.add(new JLabel(\"Series Paint:\"));     JTextField info = new JTextField(\"No editor implemented\");     info.setEnabled(false);     interior.add(info);     button = new JButton(\"Edit...\");     button.setEnabled(false);     interior.add(button);      interior.add(new JLabel(\"Series Stroke:\"));     info = new JTextField(\"No editor implemented\");     info.setEnabled(false);     interior.add(info);     button = new JButton(\"Edit...\");     button.setEnabled(false);     interior.add(button);      interior.add(new JLabel(\"Series Outline Paint:\"));     info = new JTextField(\"No editor implemented\");     info.setEnabled(false);     interior.add(info);     button = new JButton(\"Edit...\");     button.setEnabled(false);     interior.add(button);      interior.add(new JLabel(\"Series Outline Stroke:\"));     info = new JTextField(\"No editor implemented\");     info.setEnabled(false);     interior.add(info);     button = new JButton(\"Edit...\");     button.setEnabled(false);     interior.add(button);      general.add(interior, BorderLayout.NORTH);     other.add(general, BorderLayout.NORTH);      JPanel parts = new JPanel(new BorderLayout());           Legend legend = chart.getLegend();     Plot plot = chart.getPlot();      JTabbedPane tabs = new JTabbedPane();                           if (legend!=null) {       legendPropertiesPanel = new LegendPropertyEditPanel(legend);       legendPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));       tabs.addTab(\"Legend\", legendPropertiesPanel);     }      plotPropertiesPanel = new PlotPropertyEditPanel(plot);     plotPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));     tabs.addTab(\"Plot\", plotPropertiesPanel);      tabs.add(\"Other\", other);     parts.add(tabs, BorderLayout.NORTH);     add(parts);}", "nl": "Standard constructor - the property panel is made up of a number of sub - panels that are displayed in the tabbed pane"}
{"code": "public void actionPerformed(ActionEvent event) {     String command = event.getActionCommand();     if (command.equals(\"BackgroundPaint\")) {       attemptModifyBackgroundPaint();}}", "nl": "Handles user interactions with the panel"}
{"code": "public Paint getBackgroundPaint() {     return background.getPaint();}", "nl": "Returns the current background paint"}
{"code": "private void attemptModifyBackgroundPaint() {     Color c;     c = JColorChooser.showDialog(this, \"Background Color\", Color.blue);     if (c!=null) {       background.setPaint(c);}}", "nl": "Allows the user the opportunity to select a new background paint"}
{"code": "public TitlePropertyEditPanel getTitlePropertyEditPanel() {     return titlePropertiesPanel;}", "nl": "Returns a reference to the title property sub - panel"}
{"code": "public PlotPropertyEditPanel getPlotPropertyEditPanel() {     return plotPropertiesPanel;}", "nl": "Returns a reference to the plot property sub - panel"}
{"code": "public void actionPerformed(ActionEvent event) {      String command = event.getActionCommand();      if (command.equals(\"SelectFont\")) {       attemptFontSelection();     }     else if (command.equals(\"SelectPaint\")) {       attemptPaintSelection();}}", "nl": "Handles button clicks by passing control to an appropriate handler method"}
{"code": "public String getTitle() {     return titleField.getText();}", "nl": "Returns the title entered in the panel"}
{"code": "public Font getTitleFont() {     return titleFont;}", "nl": "Returns the font selected in the panel"}
{"code": "public void attemptPaintSelection() {     Color c = JColorChooser.showDialog(this, \"Title Color\", Color.blue);     if (c!=null) {       titlePaint.setPaint(c);}}", "nl": "Allow the user the opportunity to select a Paint object"}
{"code": "public TitlePropertyEditPanel(StandardTitle title) {           titleFont = title.getTitleFont();     titlePaint = new PaintSample(title.getTitlePaint());      setLayout(new BorderLayout());      JPanel general = new JPanel(new BorderLayout());     general.setBorder(BorderFactory.createTitledBorder(               BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(3));     interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));     JLabel titleLabel = new JLabel(\"Text:\");     titleField = new JTextField(title.getTitle());     interior.add(titleLabel);     interior.add(titleField);     interior.add(new JPanel());     interior.add(new JLabel(\"Font:\"));      fontfield = new FontDisplayField(titleFont);     JButton b = new JButton(\"Select...\");     b.setActionCommand(\"SelectFont\");     b.addActionListener(this);      interior.add(fontfield);     interior.add(b);      interior.add(new JLabel(\"Color:\"));      titlePaint = new PaintSample(title.getTitlePaint());     b = new JButton(\"Select...\");     b.setActionCommand(\"SelectPaint\");     b.addActionListener(this);     interior.add(titlePaint);     interior.add(b);      general.add(interior);     add(general, BorderLayout.NORTH);}", "nl": "Standard constructor : builds a panel for displaying editing the properties of the specified title"}
{"code": "public HighLow(double x, double high, double low) {    this(x, high, low, high, low, new BasicStroke(), Color.blue);}", "nl": "Constructs a high - low item , with default values for the open close and colors"}
{"code": "public void setValue(int valueType, double newValue) {    if (valueType == OPEN)      open = newValue;    else      close = newValue;}", "nl": "Sets either OPEN or Close value depending on the valueType"}
{"code": "public Line2D getCloseTickLine() {    return getTickLine(getLine().getX1(), getValue(CLOSE), getTickSize());}", "nl": "Returns the line"}
{"code": "public HighLow(double x, double high, double low, double open, double close) {    this(x, high, low, open, close, new BasicStroke(), Color.blue);}", "nl": "Constructs a high - low item , with default values for the colors"}
{"code": "public Line2D getLine() {    return line;}", "nl": "Returns the line"}
{"code": "public Stroke getStroke() {    return stroke;}", "nl": "Returns the Stroke object used to draw the line"}
{"code": "public double getTickSize() {    return tickSize;}", "nl": "Returns the width of the open close tick"}
{"code": "public HighLow(double x, double high, double low, double open, double close,         Stroke stroke, Paint paint) {      this.line = new Line2D.Double(x, high, x, low);    this.open = open;    this.close = close;    this.stroke = stroke;    this.paint = paint;}", "nl": "Constructs a high - low item"}
{"code": "protected static boolean isValidHorizontalAlignment(int code) {      switch(code) {        case AbstractTitle.LEFT:   return true;        case AbstractTitle.MIDDLE: return true;        case AbstractTitle.RIGHT:  return true;        default: return false;}}", "nl": "Utility method for checking a horizontal alignment code"}
{"code": "public int getVerticalAlignment() {      return this.verticalAlignment;}", "nl": "Returns the vertical alignment of the title"}
{"code": "protected AbstractTitle(int position,                int horizontalAlignment, int verticalAlignment, Insets insets) {            if (!this.isValidPosition(position)) {        throw new IllegalArgumentException(\"AbstractTitle(): Invalid position.\");      }      if (!AbstractTitle.isValidHorizontalAlignment(horizontalAlignment)) {        throw new IllegalArgumentException(\"AbstractTitle(): Invalid horizontal alignment.\");      }      if (!AbstractTitle.isValidVerticalAlignment(verticalAlignment)) {        throw new IllegalArgumentException(\"AbstractTitle(): Invalid vertical alignment.\");      }            this.position = position;      this.horizontalAlignment = horizontalAlignment;      this.verticalAlignment = verticalAlignment;      this.insets = insets;      this.listeners = new java.util.ArrayList();      this.notify = true;}", "nl": "Constructs a title"}
{"code": "public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis) {      this(horizontalAxis,         verticalAxis,         Plot.DEFAULT_INSETS,         BarPlot.DEFAULT_INTRO_GAP_PERCENT,         BarPlot.DEFAULT_TRAIL_GAP_PERCENT,         BarPlot.DEFAULT_CATEGORY_GAPS_PERCENT,         BarPlot.DEFAULT_ITEM_GAPS_PERCENT,         null);      this.renderer = new HorizontalBarRenderer();}", "nl": "Constructs a horizontal bar plot"}
{"code": "public Number getMaximumHorizontalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMaximumRangeValue(data);    }    else return null;}", "nl": "Returns the maximum value in the range , since this is plotted against the horizontal axis for a HorizontalBarPlot"}
{"code": "public void setInsets(Insets insets) {      if (!this.insets.equals(insets)) {        this.insets = insets;        notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the insets for the title , and notifies registered listeners of the change"}
{"code": "public java.util.List getCategories() {    return getDataset().getCategories();}", "nl": "A convenience method that returns a list of the categories in the data source"}
{"code": "public Insets getInsets() {      return this.insets;}", "nl": "Returns the insets for this title"}
{"code": "public void setNotify(boolean flag) {      this.notify = flag;}", "nl": "Sets the flag that indicates whether or not the notification mechanism is enabled"}
{"code": "protected AbstractTitle(int position, int horizontalAlignment, int verticalAlignment) {      this(position,         horizontalAlignment, verticalAlignment,         AbstractTitle.DEFAULT_INSETS);}", "nl": "Constructs a title"}
{"code": "public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis,                 Insets insets,           double introGapPercent, double trailGapPercent,                 double categoryGapPercent, double itemGapPercent,                 CategoryToolTipGenerator toolTipGenerator) {    super(horizontalAxis, verticalAxis,          insets,          introGapPercent, trailGapPercent, categoryGapPercent, itemGapPercent,          toolTipGenerator);      this.renderer = new HorizontalBarRenderer();}", "nl": "Constructs a horizontal bar plot"}
{"code": "public String getPlotType() {    return \"Horizontal Bar Plot\";}", "nl": "Returns a short string describing the type of plot"}
{"code": "public void addChangeListener(TitleChangeListener listener) {      listeners.add(listener);}", "nl": "Registers an object for notification of changes to the title"}
{"code": "public CategoryAxis getCategoryAxis() {    return (CategoryAxis)verticalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a CategoryAxis"}
{"code": "public boolean getNotify() {      return this.notify;}", "nl": "Returns the flag that indicates whether or not the notification mechanism is enabled"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {    if (axis instanceof HorizontalNumberAxis) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public Object clone() {      AbstractTitle duplicate = null;      try {        duplicate = (AbstractTitle)(super.clone());      }      catch (CloneNotSupportedException e) {                throw new RuntimeException(\"AbstractTitle.clone()\");      }      duplicate.setNotify(false);      duplicate.setInsets((Insets)this.getInsets().clone());      duplicate.setNotify(true);      return duplicate;}", "nl": "Returns a clone of the title"}
{"code": "public int getHorizontalAlignment() {      return this.horizontalAlignment;}", "nl": "Returns the horizontal alignment of the title"}
{"code": "public void draw(Graphics2D g2, Rectangle2D plotArea, DrawInfo info) {            ToolTipsCollection tooltips = null;      if (info!=null) {        info.setPlotArea(plotArea);        tooltips = info.getToolTipsCollection();      }          if (insets!=null) {      plotArea.setRect(plotArea.getX()+insets.left,           plotArea.getY()+insets.top,                 plotArea.getWidth()-insets.left-insets.right,           plotArea.getHeight()-insets.top-insets.bottom);    }        VerticalAxis vAxis = getVerticalAxis();    HorizontalAxis hAxis = getHorizontalAxis();    double vAxisAreaWidth = vAxis.reserveWidth(g2, this, plotArea);    Rectangle2D hAxisArea = hAxis.reserveAxisArea(g2, this, plotArea, vAxisAreaWidth);        Rectangle2D dataArea = new Rectangle2D.Double(plotArea.getX()+vAxisAreaWidth,                  plotArea.getY(),                  plotArea.getWidth()-vAxisAreaWidth,                  plotArea.getHeight()-hAxisArea.getHeight());      if (info!=null) {        info.setDataArea(dataArea);      }          drawOutlineAndBackground(g2, dataArea);    getCategoryAxis().draw(g2, plotArea, dataArea);    getRangeAxis().draw(g2, plotArea, dataArea);            CategoryDataset data = this.getDataset();      if (data!=null) {        Shape savedClip = g2.getClip();        g2.clip(dataArea);                double translatedZero = getRangeAxis().translateValueToJava2D(0.0, dataArea);        Line2D baseline = new Line2D.Double(translatedZero, dataArea.getY(),                          translatedZero, dataArea.getMaxY());        g2.setStroke(new BasicStroke());        g2.draw(baseline);        int seriesCount = data.getSeriesCount();        int categoryCount = data.getCategoryCount();        int barCount = renderer.barWidthsPerCategory(data);                double categorySpan = 0.0;        double categoryGapSpan = 0.0;        if (categoryCount>1) {          categorySpan = dataArea.getHeight()*                   (1-introGapPercent-trailGapPercent-categoryGapsPercent);          categoryGapSpan = dataArea.getHeight()*categoryGapsPercent;        }        else {          categorySpan = dataArea.getHeight()*(1-introGapPercent-trailGapPercent);        }                double itemSpan = categorySpan;        double itemGapSpan = 0.0;        if (seriesCount>1) {          if (renderer.hasItemGaps()) {            itemGapSpan = plotArea.getHeight()*itemGapsPercent;            itemSpan = itemSpan - itemGapSpan;          }        }        double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));        int categoryIndex = 0;        Iterator iterator = data.getCategories().iterator();        while (iterator.hasNext()) {          Object category = iterator.next();          for (int series=0; series<seriesCount; series++) {            Shape tooltipArea = renderer.drawBar(g2, dataArea, this,                               this.getRangeAxis(), data, series,                               category, categoryIndex,                               translatedZero, itemWidth,                               categorySpan, categoryGapSpan,                               itemSpan, itemGapSpan);                        if (tooltips!=null) {              if (this.toolTipGenerator==null) {                toolTipGenerator = new StandardCategoryToolTipGenerator();              }              String tip = this.toolTipGenerator.generateToolTip(data, series, category);              if (tooltipArea!=null) {                tooltips.addToolTip(tip, tooltipArea);              }            }          }          categoryIndex++;        }                ValueAxis hva = this.getRangeAxis();        if (hva.isCrosshairVisible()) {          this.drawVerticalLine(g2, dataArea, hva.getCrosshairValue(),                      hva.getCrosshairStroke(),                      hva.getCrosshairPaint());        }        g2.setClip(savedClip);}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public Shape drawItem(Graphics2D g2, Rectangle2D dataArea, DrawInfo info,                XYPlot plot, ValueAxis horizontalAxis, ValueAxis verticalAxis,                XYDataset data, int series, int item,                double translatedRangeZero, CrosshairInfo crosshairInfo) {      Shape result = null;      HighLowDataset highLowData = (HighLowDataset)data;    Number x = highLowData.getXValue(series, item);      Number yHigh  = highLowData.getHighValue(series, item);      Number yLow   = highLowData.getLowValue(series, item);      Number yOpen  = highLowData.getOpenValue(series, item);      Number yClose = highLowData.getCloseValue(series, item);      double xx = horizontalAxis.translateValueToJava2D(x.doubleValue(), dataArea);      double yyHigh = verticalAxis.translateValueToJava2D(yHigh.doubleValue(), dataArea);      double yyLow = verticalAxis.translateValueToJava2D(yLow.doubleValue(), dataArea);      double yyOpen = verticalAxis.translateValueToJava2D(yOpen.doubleValue(), dataArea);      double yyClose = verticalAxis.translateValueToJava2D(yClose.doubleValue(), dataArea);      Paint p = plot.getSeriesPaint(series);      Stroke s = plot.getSeriesStroke(series);      g2.setPaint(p);      g2.setStroke(s);            if ((yyHigh<yyOpen) && (yyHigh<yyClose)) {        g2.draw(new Line2D.Double(xx, yyHigh, xx, Math.min(yyOpen, yyClose)));      }            if ((yyLow>yyOpen) && (yyLow>yyClose)) {        g2.draw(new Line2D.Double(xx, yyLow, xx, Math.max(yyOpen, yyClose)));      }            Shape body = null;      if (yyOpen<yyClose) {        body = new Rectangle2D.Double(xx-candleWidth/2, yyOpen,                        candleWidth, yyClose-yyOpen);        g2.fill(body);      }      else {        body = new Rectangle2D.Double(xx-candleWidth/2, yyClose,                        candleWidth, yyOpen-yyClose);        g2.draw(body);      }      result = body;      return result;}", "nl": "Draws the visual representation of a single data item"}
{"code": "public CandlestickRenderer(double candleWidth) {      this.candleWidth = candleWidth;}", "nl": "Creates a new renderer"}
{"code": "public void handleClick(int x, int y, DrawInfo info) {            ValueAxis hva = this.getRangeAxis();      double hvalue = hva.translateJava2DtoValue((float)x, info.getDataArea());      hva.setAnchorValue(hvalue);      hva.setCrosshairValue(hvalue);}", "nl": "Handles a ' click ' on the plot by updating the anchor values"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {    if (axis instanceof VerticalCategoryAxis) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public Number getMinimumHorizontalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMinimumRangeValue(data);    }    else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the horizontal axis for a HorizontalBarPlot"}
{"code": "public static void saveChartAsPNG(File file, JFreeChart chart, int width, int height)      throws IOException {      DataOutputStream out = new DataOutputStream(                     new BufferedOutputStream(new FileOutputStream(file)));      writeChartAsPNG(out, chart, width, height);      out.close();}", "nl": "Saves the chart as a PNG format image file"}
{"code": "public static void writeChartAsJPEG(OutputStream out, JFreeChart chart, int width, int height)      throws IOException {      BufferedImage image = chart.createBufferedImage(width, height);      JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);      JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(image);      param.setQuality(1.0f, true);      encoder.encode(image, param);}", "nl": "Writes the chart to the output stream in JPEG format"}
{"code": "public static void writeChartAsPNG(OutputStream out, JFreeChart chart, int width, int height)      throws IOException {      BufferedImage chartImage = chart.createBufferedImage(width, height);      PngEncoder encoder = new PngEncoder(chartImage, false, 0, 9);      byte[] pngData = encoder.pngEncode();      out.write(pngData);}", "nl": "Writes the chart to the output stream in PNG format"}
{"code": "public int getCount() {    return this.count;}", "nl": "Returns the number of units"}
{"code": "public static JFreeChart createVerticalBarChart3D(String title, String categoryAxisLabel,                            String valueAxisLabel, CategoryDataset data,                            boolean legend) {      CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);      ValueAxis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);      VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);                  plot.setInsets(new Insets(20, 2, 2, 2));      plot.setRenderer(new VerticalBarRenderer3D());      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates a vertical 3D - effect bar chart with default settings"}
{"code": "public int getField() {    return this.field;}", "nl": "Returns the field used for this DateUnit"}
{"code": "public static JFreeChart createTimeSeriesChart(String title, String timeAxisLabel,                             String valueAxisLabel, XYDataset data,                             boolean legend) {      ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);            NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);      valueAxis.setAutoRangeIncludesZero(false);              XYPlot plot = new XYPlot(timeAxis, valueAxis);      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates and returns a time series chart"}
{"code": "public static JFreeChart createSignalChart(String title, String timeAxisLabel,                           String valueAxisLabel, SignalsDataset data,                           boolean legend) {      ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);      NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);      XYPlot plot = new XYPlot(timeAxis, valueAxis);      plot.setXYItemRenderer(new SignalRenderer());      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates and returns a default instance of a signal chart based on the specified dataset"}
{"code": "public static JFreeChart createHighLowChart(String title, String timeAxisLabel,                          String valueAxisLabel, HighLowDataset data,                          boolean legend) {      ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);      NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);            XYPlot plot = new XYPlot(timeAxis, valueAxis);      plot.setXYItemRenderer(new HighLowRenderer());      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates and returns a default instance of a high - low - open - close chart based on the specified dataset"}
{"code": "public static JFreeChart createVerticalBarChart(String title,                            String categoryAxisLabel, String valueAxisLabel,                            CategoryDataset data, boolean legend) {      CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);      ValueAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);      Plot plot = new VerticalBarPlot(categoryAxis, valueAxis);      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates a vertical bar chart with default settings"}
{"code": "public static JFreeChart createHorizontalBarChart(String title, String categoryAxisLabel,                              String valueAxisLabel, CategoryDataset data,                              boolean legend) {      Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);      Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);      Plot plot = new HorizontalBarPlot(valueAxis, categoryAxis);      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates a horizontal bar chart with default settings"}
{"code": "public static JFreeChart createStackedVerticalBarChart(String title, String categoryAxisLabel,                               String valueAxisLabel, CategoryDataset data,                               boolean legend) {      CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);      ValueAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);      VerticalBarPlot plot = new VerticalBarPlot(categoryAxis, valueAxis);      plot.setRenderer(new StackedVerticalBarRenderer());      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates a stacked vertical bar chart with default settings"}
{"code": "public static JFreeChart createStackedHorizontalBarChart(String title, String categoryAxisLabel,                              String valueAxisLabel, CategoryDataset data,                              boolean legend) {      Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);      Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);      HorizontalBarPlot plot = new HorizontalBarPlot(valueAxis, categoryAxis);      plot.setRenderer(new StackedHorizontalBarRenderer());      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates a stacked horizontal bar chart with default settings"}
{"code": "public static CombinedChart createCombinableTimeSeriesChart(ValueAxis horizontal,                                  ValueAxis vertical, Dataset data) {      XYPlot plot = new XYPlot(horizontal, vertical);        plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));        return createCombinableChart(data, plot);}", "nl": "Creates and returns a combinable time series chart"}
{"code": "public Date calculateHighestVisibleTickValue(DateUnit unit) {    return this.previousStandardDate(maximumDate, unit.getField(), unit.getCount());}", "nl": "Calculates the value of the highest visible tick on the axis"}
{"code": "public static JFreeChart createXYChart(String title, String xAxisLabel, String yAxisLabel,                           XYDataset data, boolean legend) {      NumberAxis xAxis = new HorizontalNumberAxis(xAxisLabel);      xAxis.setAutoRangeIncludesZero(false);      NumberAxis yAxis = new VerticalNumberAxis(yAxisLabel);      XYPlot plot = new XYPlot(xAxis, yAxis);      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates an XY plot with default settings"}
{"code": "protected DateAxis(String label,               Font labelFont, Paint labelPaint, Insets labelInsets,           boolean tickLabelsVisible,               Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,           boolean tickMarksVisible, Stroke tickMarkStroke,           boolean autoRange, Date minimumDate, Date maximumDate,           boolean autoTickUnitSelection, DateUnit tickUnit,               SimpleDateFormat tickLabelFormatter,           boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,               Date crosshairDate, Stroke crosshairStroke, Paint crosshairPaint) {    super(label, labelFont, labelPaint, labelInsets,        tickLabelsVisible, tickLabelFont, tickLabelPaint, tickLabelInsets,        tickMarksVisible, tickMarkStroke, autoRange,        autoTickUnitSelection, gridLinesVisible, gridStroke, gridPaint,          0.0,          crosshairStroke, crosshairPaint);    this.minimumDate = minimumDate;      if (minimumDate!=null) {        this.minimumAxisValue = (double)minimumDate.getTime();      }    this.maximumDate = maximumDate;      if (maximumDate!=null) {        this.maximumAxisValue = (double)maximumDate.getTime();      }      this.crosshairDate = crosshairDate;    this.tickUnit = tickUnit;    this.tickLabelFormatter = tickLabelFormatter;      this.anchorValue = (double)this.anchorDate.getTime();}", "nl": "Constructs a date axis"}
{"code": "public static CombinedChart createCombinableXYChart(ValueAxis horizontal, ValueAxis vertical,                              Dataset data) {      XYPlot plot = new XYPlot(horizontal, vertical);      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));      return createCombinableChart(data, plot);}", "nl": "Creates a combinable XY plot with default settings"}
{"code": "public static JFreeChart createCandlestickChart(String title, String timeAxisLabel,                            String valueAxisLabel, HighLowDataset data,                            boolean legend) {      ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);      NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);      XYPlot plot = new XYPlot(timeAxis, valueAxis);      plot.setXYItemRenderer(new CandlestickRenderer(4.0));      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates and returns a default instance of a candlesticks chart based on the specified dataset"}
{"code": "public static CombinedChart createCombinableVerticalXYBarChart(Axis horizontal, Axis vertical,                                     Dataset data) {      VerticalXYBarPlot plot = new VerticalXYBarPlot(horizontal, vertical);      return createCombinableChart(data, plot);}", "nl": "Creates and returns a default instance of a VerticalXYBar combinable chart based on the specified dataset"}
{"code": "public void setMaximumDate(Date maximumDate) {    this.maximumDate = maximumDate;      double millis = (double)maximumDate.getTime();      this.setMaximumAxisValue(millis);}", "nl": "Sets the maximum date visible on the axis"}
{"code": "public Date getMinimumDate() {    return this.minimumDate;}", "nl": "Returns the earliest date visible on the axis"}
{"code": "public void setCrosshairDate(Date crosshairDate) {    this.crosshairDate = crosshairDate;      double millis = (double)crosshairDate.getTime();      this.setCrosshairValue(millis);}", "nl": "incoherencetype"}
{"code": "public Date calculateLowestVisibleTickValue(DateUnit unit) {    return this.nextStandardDate(minimumDate, unit.getField(), unit.getCount());}", "nl": "Calculates the value of the lowest visible tick on the axis"}
{"code": "public DateAxis(String label) {    this(label,         Axis.DEFAULT_AXIS_LABEL_FONT,         Axis.DEFAULT_AXIS_LABEL_PAINT,         Axis.DEFAULT_AXIS_LABEL_INSETS,         true,          Axis.DEFAULT_TICK_LABEL_FONT,         Axis.DEFAULT_TICK_LABEL_PAINT,         Axis.DEFAULT_TICK_LABEL_INSETS,         true,          Axis.DEFAULT_TICK_STROKE,         true,          null,          null,          true,          new DateUnit(Calendar.DATE, 1),         new SimpleDateFormat(),         true,          ValueAxis.DEFAULT_GRID_LINE_STROKE,         ValueAxis.DEFAULT_GRID_LINE_PAINT,         DEFAULT_CROSSHAIR_DATE,         ValueAxis.DEFAULT_CROSSHAIR_STROKE,         ValueAxis.DEFAULT_CROSSHAIR_PAINT);}", "nl": "Constructs a date axis , using default values where necessary"}
{"code": "public Paint getFillPaint() {    return fillPaint;}", "nl": "Returns the Paint object used to fill the bar"}
{"code": "public void setTickUnit(DateUnit unit) {    this.tickUnit = unit;    this.notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the tick unit for the axis"}
{"code": "protected Date nextStandardDate(Date date, int field, int units) {    Date previous = previousStandardDate(date, field, units);    Calendar calendar = Calendar.getInstance();    calendar.setTime(previous);    calendar.add(field, units);    return calendar.getTime();}", "nl": "Returns the first standard date"}
{"code": "public Paint getOutlinePaint() {    return outlinePaint;}", "nl": "Returns the Paint object used to draw the outline of the bar"}
{"code": "public Stroke getOutlineStroke() {    return outlineStroke;}", "nl": "Returns the Stroke object used to draw the outline of the bar"}
{"code": "protected int findAxisMagnitudeIndex() {    long axisMagnitude = this.maximumDate.getTime()-this.minimumDate.getTime();    int index = 0;    while(index<standardTickUnitMagnitudes.length-1) {      if (axisMagnitude<standardTickUnitMagnitudes[index]) break;      index++;    }    return Math.max(0, index-1);}", "nl": "Returns the index of the largest tick unit that will fit within the axis range"}
{"code": "public Rectangle2D getArea() {    return area;}", "nl": "Returns the rectangle that is the outline of the bar"}
{"code": "public SimpleDateFormat getTickLabelFormatter() {    return tickLabelFormatter;}", "nl": "Returns the formatter for the tick labels"}
{"code": "public Date getCrosshairDate() {    return this.crosshairDate;}", "nl": "Returns the crosshair date for the axis"}
{"code": "public void setAnchorDate(Date anchorDate) {    this.anchorDate = anchorDate;      double millis = (double)anchorDate.getTime();      super.setAnchorValue(millis);}", "nl": "Sets the anchor date for the axis"}
{"code": "protected CategoryAxis(String label,                 Font labelFont, Paint labelPaint, Insets labelInsets,           boolean categoryLabelsVisible,                 Font categoryLabelFont, Paint categoryLabelPaint,                 Insets categoryLabelInsets,                 boolean tickMarksVisible,                 Stroke tickMarkStroke) {    super(label,          labelFont, labelPaint, labelInsets,        categoryLabelsVisible,          categoryLabelFont, categoryLabelPaint, categoryLabelInsets,        tickMarksVisible,          tickMarkStroke);}", "nl": "Constructs a category axis"}
{"code": "public DateTitle(int dateStyle) {      this(dateStyle, Locale.getDefault(), new Font(\"Dialog\", Font.PLAIN, 12), Color.black);}", "nl": "Constructs a new DateTitle with the specified style"}
{"code": "public DateTitle() {      this(DateFormat.LONG);}", "nl": "Constructs a new DateTitle that displays the current date in the default format for the locale , positioned to the bottom right of the chart"}
{"code": "public DateTitle(int dateStyle, Locale locale, Font font, Paint paint, int position,             int horizontalAlignment, int verticalAlignment, Insets insets) {      super(DateFormat.getDateInstance(dateStyle, locale).format(new Date()),          font, paint, position, horizontalAlignment, verticalAlignment, insets);}", "nl": "Constructs a new DateTitle with the specified attributes"}
{"code": "public DateTitle(int dateStyle, Locale locale, Font font, Paint paint) {      this(dateStyle, locale, font, paint,         AbstractTitle.BOTTOM, AbstractTitle.RIGHT, AbstractTitle.MIDDLE,         new Insets(2, 2, 2, 2));}", "nl": "Constructs a new DateTitle object with the specified attributes and the following defaults : location = BOTTOM , alignment = RIGHT , insets = new Insets"}
{"code": "public void setTickLabelFont(Font font) {            if (font==null) {        throw new IllegalArgumentException(\"Axis.setTickLabelFont(...): null not permitted.\");      }          if (!this.tickLabelFont.equals(font)) {      this.tickLabelFont = font;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the font for the tick labels"}
{"code": "public Paint getLabelPaint() {    return this.labelPaint;}", "nl": "Returns the color shade used to draw the axis label"}
{"code": "public void setLabel(String label) {      String existing = this.label;      if (existing!=null) {      if (!existing.equals(label)) {        this.label = label;        notifyListeners(new AxisChangeEvent(this));      }      }      else {        if (label!=null) {        this.label = label;        notifyListeners(new AxisChangeEvent(this));}}}", "nl": "Sets the label for the axis"}
{"code": "public Font getTickLabelFont() {    return tickLabelFont;}", "nl": "Returns the font used for the tick labels"}
{"code": "public void setTickMarksVisible(boolean flag) {    if (flag!=tickMarksVisible) {      tickMarksVisible = flag;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag that indicates whether or not the tick marks are showing"}
{"code": "public void setTickLabelPaint(Paint paint) {            if (paint==null) {        throw new IllegalArgumentException(\"Axis.setTickLabelPaint(...): null not permitted.\");      }          if (!this.tickLabelPaint.equals(paint)) {      this.tickLabelPaint = paint;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the color shade used to draw tick labels"}
{"code": "public void setLabelFont(Font font) {            if (font==null) {        throw new IllegalArgumentException(\"Axis.setLabelFont(...): null not permitted.\");      }          if (!this.labelFont.equals(font)) {      this.labelFont = font;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the font for the axis label"}
{"code": "public boolean isTickLabelsVisible() {    return tickLabelsVisible;}", "nl": "Returns a flag indicating whether or not the tick labels are visible"}
{"code": "public void addChangeListener(AxisChangeListener listener) {    listeners.add(listener);}", "nl": "Registers an object for notification of changes to the axis"}
{"code": "protected void drawVerticalString(String text, Graphics2D g2, float x, float y) {    AffineTransform saved = g2.getTransform();        AffineTransform rotate = AffineTransform.getRotateInstance(-Math.PI/2, x, y);    g2.transform(rotate);    g2.drawString(text, x, y);    g2.setTransform(saved);}", "nl": "A utility method for drawing text vertically"}
{"code": "public void setTickMarkStroke(Stroke stroke) {            if (stroke==null) {        throw new IllegalArgumentException(\"Axis.setTickMarkStroke(...): null not permitted.\");      }          if (!this.tickMarkStroke.equals(stroke)) {      this.tickMarkStroke = stroke;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the pen brush used to draw tick marks"}
{"code": "public void setLabelInsets(Insets insets) {    if (!insets.equals(this.labelInsets)) {      this.labelInsets = insets;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the insets for the axis label , and notifies registered listeners that the axis has been modified"}
{"code": "public void setLabelPaint(Paint paint) {            if (paint==null) {        throw new IllegalArgumentException(\"Axis.setLabelPaint(...): null not permitted.\");      }          if (!this.labelPaint.equals(paint)) {      this.labelPaint = paint;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the color shade used to draw the axis label"}
{"code": "public void setTickLabelsVisible(boolean flag) {    if (flag!=tickLabelsVisible) {      tickLabelsVisible = flag;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag that determines whether or not the tick labels are visible"}
{"code": "public void setPlot(Plot plot) throws PlotNotCompatibleException {      if (this.isCompatiblePlot(plot) || plot == null) {      this.plot = plot;      }      else throw new PlotNotCompatibleException(\"Axis.setPlot(...): \"                           +\"plot not compatible with axis.\");}", "nl": "Sets a reference to the plot that the axis is assigned to"}
{"code": "public Plot getPlot() {    return plot;}", "nl": "Returns the plot that the axis is assigned to"}
{"code": "public Stroke getTickMarkStroke() {    return tickMarkStroke;}", "nl": "Returns the pen brush used to draw tick marks"}
{"code": "public void setTickLabelInsets(Insets insets) {            if (insets==null) {        throw new IllegalArgumentException(\"Axis.setTickLabelInsets(...): null not permitted.\");      }          if (!this.tickLabelInsets.equals(insets)) {      this.tickLabelInsets = insets;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the insets for the tick labels , and notifies registered listeners that the axis has been modified"}
{"code": "public Font getLabelFont() {    return labelFont;}", "nl": "Returns the font for the axis label"}
{"code": "public Paint getTickLabelPaint() {    return this.tickLabelPaint;}", "nl": "Returns the color shade used for the tick labels"}
{"code": "public double getItemGapsPercent() {    return itemGapsPercent;}", "nl": "Returns the percentage of the drawing space that is allocated to providing gaps between the items in a category"}
{"code": "public void setHorizontalAxis(Axis axis) {    super.setHorizontalAxis(axis);}", "nl": "Sets the horizontal axis for the plot"}
{"code": "public CategoryDataset getDataset() {    return (CategoryDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as a CategoryDataset"}
{"code": "public void setTrailGapPercent(double percent) {            if ((percent<0.0) || (percent>MAX_TRAIL_GAP_PERCENT)) {        throw new IllegalArgumentException(\"BarPlot.setTrailGapPercent(double): argument \"                          +\"outside valid range.\");      }          if (this.trailGapPercent!=percent) {        trailGapPercent = percent;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the gap after the last bar on the chart , and notifies registered listeners that the plot has been modified"}
{"code": "public double getTrailGapPercent() {    return trailGapPercent;}", "nl": "Returns the gap following the last bar on the chart , as a percentage of the available drawing space"}
{"code": "public double getIntroGapPercent() {    return introGapPercent;}", "nl": "Returns the gap before the first bar on the chart , as a percentage of the available drawing space"}
{"code": "public void setIntroGapPercent(double percent) {            if ((percent<0.0) || (percent>MAX_INTRO_GAP_PERCENT)) {        throw new IllegalArgumentException(\"BarPlot.setIntroGapPercent(double): argument \"                          +\"outside valid range.\");      }          if (this.introGapPercent!=percent) {        this.introGapPercent = percent;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the gap before the first bar on the chart , and notifies registered listeners that the plot has been modified"}
{"code": "public void setItemGapsPercent(double percent) {            if ((percent<0.0) || (percent>MAX_ITEM_GAPS_PERCENT)) {        throw new IllegalArgumentException(\"BarPlot.setItemGapsPercent(double): argument \"                          +\"outside valid range.\");      }          if (percent!=this.itemGapsPercent) {        this.itemGapsPercent = percent;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the gap between one bar and the next within the same category , and notifies registered listeners that the plot has been modified"}
{"code": "protected BarPlot(Axis horizontalAxis, Axis verticalAxis) {    this(horizontalAxis, verticalAxis,         Plot.DEFAULT_INSETS,         DEFAULT_INTRO_GAP_PERCENT,         DEFAULT_TRAIL_GAP_PERCENT,         DEFAULT_CATEGORY_GAPS_PERCENT,         DEFAULT_ITEM_GAPS_PERCENT,         null);}", "nl": "Constructs a bar plot , using default values where necessary"}
{"code": "public Number getMinimumHorizontalDataValue() {          XYDataset data = getTempXYDataset();    if( data ==null )        return null;      long minimum = Long.MAX_VALUE;      int seriesCount = data.getSeriesCount();      for (int series=0; series<seriesCount; series++) {        int itemCount = data.getItemCount(series);        for(int itemIndex = 0; itemIndex < itemCount; itemIndex++){          Number value = data.getXValue(series, itemIndex);           if (value!=null)            minimum = Math.min(minimum, value.longValue());        }      }      return new Long(minimum);}", "nl": "Returns the minimum value in the domain , since this is plotted against the horizontal axis for a HighLowPlot"}
{"code": "public XYDataset getTempXYDataset() {     return (XYDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as an HighLowDataset"}
{"code": "public ValueAxis getHorizontalValueAxis()    {      return (ValueAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a HorizontalValueAxis"}
{"code": "public Number getMaximumVerticalDataValue() {      return null;}", "nl": "Returns the maximum value in the range , since this is plotted against the vertical axis for a HighLowPlot"}
{"code": "public ValueAxis getVerticalValueAxis()    {      return (ValueAxis)verticalAxis;}", "nl": "A convenience method that returns a reference to the vertical axis cast as a VerticalNumberAxis"}
{"code": "public String getPlotType() {        return \"Period Marker Plot\";}", "nl": "Returns the plot type as a string"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {    if (axis instanceof HorizontalNumberAxis) {      return true;    }    else if (axis instanceof HorizontalDateAxis) {      return true;    }      else return false;}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public CategoryAxis getCategoryAxis() {    return (CategoryAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a CategoryAxis"}
{"code": "public double getIntroGapPercent() {      return this.introGapPercent;}", "nl": "Returns the intro gap"}
{"code": "public double getCategoryCoordinate(int category, Rectangle2D area) {          int count = getDataset().getCategoryCount();      if ((category<0) || (category>=count)) {        throw new IllegalArgumentException(\"LinePlot.getCategoryCoordinate(...): \"                           +\"category outside valid range.\");      }      if (area==null) {        throw new IllegalArgumentException(\"LinePlot.getCategoryCoordinate(...): \"                           +\"null area not permitted.\");      }            double result = area.getX() + area.getWidth()/2;      if (count>1) {        double available = area.getWidth() * (1-introGapPercent-trailGapPercent);      result = area.getX()+(introGapPercent*area.getWidth())                  +(category*1.0/(count-1.0))*available;      }      return result;}", "nl": "Returns the x - coordinate of the center of the specified category"}
{"code": "public Number getMinimumVerticalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMinimumRangeValue(data);    }    else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the vertical axis for LinePlot"}
{"code": "public void setIntroGapPercent(double percent) {            if ((percent<=0.0) || (percent>MAX_INTRO_GAP)) {        throw new IllegalArgumentException(\"LinePlot.setIntroGapPercent(double): \"                           +\"gap percent outside valid range.\");      }            if (introGapPercent!=percent) {        introGapPercent = percent;        notifyListeners(new PlotChangeEvent(this));}}", "nl": "incoherencetype"}
{"code": "public CategoryDataset getDataset() {    return (CategoryDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as a CategoryDataset"}
{"code": "public void setTrailGapPercent(double percent) {            if ((percent<=0.0) || (percent>MAX_TRAIL_GAP)) {        throw new IllegalArgumentException(\"LinePlot.setTrailGapPercent(double): \"                           +\"gap percent outside valid range.\");      }            if (trailGapPercent!=percent) {        trailGapPercent = percent;        notifyListeners(new PlotChangeEvent(this));}}", "nl": "incoherencetype"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {    if (axis instanceof VerticalNumberAxis) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public java.util.List getCategories() {    return getDataset().getCategories();}", "nl": "A convenience method that returns a list of the categories in the data source"}
{"code": "public String getPlotType() {    return \"Line Plot\";}", "nl": "Returns a short string describing the plot type ;"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, DrawInfo info) {          if (insets!=null) {      drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,                drawArea.getY()+insets.top,                drawArea.getWidth()-insets.left-insets.right,                drawArea.getHeight()-insets.top-insets.bottom);    }        HorizontalAxis hAxis = getHorizontalAxis();    VerticalAxis vAxis = getVerticalAxis();    double hAxisAreaHeight = hAxis.reserveHeight(g2, this, drawArea);    Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);        Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),                  drawArea.getY(),                  drawArea.getWidth()-vAxisArea.getWidth(),                  drawArea.getHeight()-hAxisAreaHeight);          drawOutlineAndBackground(g2, plotArea);    getCategoryAxis().draw(g2, drawArea, plotArea);    getValueAxis().draw(g2, drawArea, plotArea);            CategoryDataset data = this.getDataset();      if (data!=null) {        Shape originalClip=g2.getClip();      g2.clip(plotArea);      int seriesCount = data.getSeriesCount();        int categoryCount = data.getCategoryCount();        int categoryIndex = 0;        Object previousCategory = null;        Iterator iterator = data.getCategories().iterator();        while (iterator.hasNext()) {          Object category = iterator.next();          for (int series=0; series<seriesCount; series++) {            renderer.drawCategoryItem(g2, plotArea, this, getValueAxis(), data,                          series, category, categoryIndex, previousCategory);          }          previousCategory = category;          categoryIndex++;        }      g2.setClip(originalClip);}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public NumberTickUnit getTickUnit() {      return this.tickUnit;}", "nl": "Returns the tick unit for the axis"}
{"code": "public String valueToString(double value) {            return this.tickUnit.formatter.format(value);}", "nl": "Converts a value to a string , using the current format for the tick labels on the axis"}
{"code": "public void setAutoRangeIncludesZero(boolean flag) {    if (autoRangeIncludesZero!=flag) {      this.autoRangeIncludesZero = flag;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag that indicates whether or not the automatic axis range is forced to include zero"}
{"code": "public double getUpperMargin() {      return this.upperMargin;}", "nl": "Returns the margin by which the maximum axis value exceeds the maximum data value"}
{"code": "public void setStandardTickUnits(TickUnits units) {      this.standardTickUnits = units;      notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the standard tick units for the axis"}
{"code": "public void setUpperMargin(double margin) {      this.upperMargin = margin;      notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the upper margin"}
{"code": "public boolean autoRangeIncludesZero() {    return this.autoRangeIncludesZero;}", "nl": "Returns the flag that indicates whether or not the automatic axis range is forced to include zero"}
{"code": "public void setTickUnit(NumberTickUnit unit) {      this.autoTickUnitSelection = false;      this.tickUnit = unit;}", "nl": "Sets the tick unit for the axis"}
{"code": "protected NumberAxis(String label) {    this(label,         Axis.DEFAULT_AXIS_LABEL_FONT,         Axis.DEFAULT_AXIS_LABEL_PAINT,         Axis.DEFAULT_AXIS_LABEL_INSETS,         true,          Axis.DEFAULT_TICK_LABEL_FONT,         Axis.DEFAULT_TICK_LABEL_PAINT,         Axis.DEFAULT_TICK_LABEL_INSETS,         true,          Axis.DEFAULT_TICK_STROKE,         true,          true,          NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,         ValueAxis.DEFAULT_MINIMUM_AXIS_VALUE,         ValueAxis.DEFAULT_MAXIMUM_AXIS_VALUE,         false,          true,          NumberAxis.DEFAULT_TICK_UNIT,         true,          ValueAxis.DEFAULT_GRID_LINE_STROKE,         ValueAxis.DEFAULT_GRID_LINE_PAINT,         0.0,           ValueAxis.DEFAULT_CROSSHAIR_STROKE,         ValueAxis.DEFAULT_CROSSHAIR_PAINT);}", "nl": "Constructs a number axis , using default values where necessary"}
{"code": "protected NumberAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,           boolean tickLabelsVisible, Font tickLabelFont, Paint tickLabelPaint,               Insets tickLabelInsets,           boolean tickMarksVisible, Stroke tickMarkStroke,           boolean autoRange, boolean autoRangeIncludesZero,               Number autoRangeMinimumSize,           double minimumAxisValue, double maximumAxisValue,               boolean inverted,           boolean autoTickUnitSelection, NumberTickUnit tickUnit,               boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,               double crosshairValue, Stroke crosshairStroke, Paint crosshairPaint) {    super(label,          labelFont, labelPaint, labelInsets,        tickLabelsVisible,          tickLabelFont, tickLabelPaint, tickLabelInsets,        tickMarksVisible, tickMarkStroke,          autoRange, autoTickUnitSelection,          gridLinesVisible, gridStroke, gridPaint,          crosshairValue,          crosshairStroke, crosshairPaint);            if (minimumAxisValue>=maximumAxisValue) {        throw new IllegalArgumentException(\"NumberAxis(...): minimum axis value must be less \"                           +\"than maximum axis value.\");      }      if (!autoRange) {                                                       }      if (autoRangeMinimumSize==null) {        throw new IllegalArgumentException(\"NumberAxis(...): autoRangeMinimum cannot be null.\");      }          this.autoRangeIncludesZero = autoRangeIncludesZero;    this.autoRangeMinimumSize = autoRangeMinimumSize;    this.minimumAxisValue = minimumAxisValue;    this.maximumAxisValue = maximumAxisValue;      this.anchorValue = 0.0;      this.inverted = inverted;    this.tickUnit = tickUnit;      this.upperMargin = DEFAULT_UPPER_MARGIN;      this.lowerMargin = DEFAULT_LOWER_MARGIN;      this.standardTickUnits = createStandardTickUnits();}", "nl": "Constructs a number axis"}
{"code": "public Number getAutoRangeMinimumSize() {    return this.autoRangeMinimumSize;}", "nl": "Returns the minimum size of the automatic axis range"}
{"code": "public double calculateHighestVisibleTickValue() {        double unit = getTickUnit().getValue().doubleValue();    double index = Math.floor(maximumAxisValue/unit);    return index*unit;}", "nl": "Calculates the value of the highest visible tick on the axis"}
{"code": "public NumberTickUnit(Number value, NumberFormat formatter) {      super(value);      this.formatter = formatter;}", "nl": "Creates a new number tick unit"}
{"code": "public Line(double x1, double y1, double x2, double y2) {    this(x1, y1, x2, y2, new BasicStroke(), Color.blue);}", "nl": "Standard constructor , with default values for the colors"}
{"code": "public Line(double x1, double y1, double x2, double y2, Stroke stroke, Paint paint) {    this.line = new Line2D.Double(x1, y1, x2, y2);    this.stroke = stroke;    this.paint = paint;}", "nl": "Standard constructor"}
{"code": "public Stroke getStroke() {    return stroke;}", "nl": "Returns the Stroke object used to draw the line"}
{"code": "public Line2D getLine() {    return line;}", "nl": "Returns the line"}
{"code": "public PiePlot() {      this(DEFAULT_INTERIOR_GAP,         true,          DEFAULT_RADIUS,         NAME_LABELS,         DEFAULT_SECTION_LABEL_FONT,         DEFAULT_SECTION_LABEL_PAINT,         DEFAULT_SECTION_LABEL_GAP,         \"0.0\",         new Insets(2, 2, 2, 2),         null);}", "nl": "Constructs a new pie plot"}
{"code": "public void setRadiusPercent(double percent) {            if ((percent<=0.0) || (percent>MAX_RADIUS)) {        throw new IllegalArgumentException(\"PiePlot.setRadiusPercent(double): \"                           +\"percentage outside valid range.\");      }            if (this.radiusPercent!=percent) {        this.radiusPercent = percent;        this.notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the radius percentage"}
{"code": "public Font getSectionLabelFont() {    return this.sectionLabelFont;}", "nl": "Returns the section label font"}
{"code": "public void setInteriorGapPercent(double percent) {            if ((percent<0.0) || (percent>MAX_INTERIOR_GAP)) {        throw new IllegalArgumentException(\"PiePlot.setInteriorGapPercent(double): \"                           +\"percentage outside valid range.\");      }            if (this.interiorGapPercent!=percent) {        this.interiorGapPercent = percent;        notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the interior gap percent"}
{"code": "protected void drawLabel(Graphics2D g2, Rectangle2D pieArea, Rectangle2D explodedPieArea,                 PieDataset data, int section, double startAngle, double extent) {            FontRenderContext frc = g2.getFontRenderContext();      String[] legendItemLabels = chart.getLegendItemLabels();      String label = \"\";      if (this.sectionLabelType==NAME_LABELS) {        label = legendItemLabels[section];      }      else if (this.sectionLabelType==PERCENT_LABELS) {        label = percentFormatter.format(extent/3.60)+\"%\";      }      else if (this.sectionLabelType==NAME_AND_PERCENT_LABELS) {        label = legendItemLabels[section]+\" (\"+percentFormatter.format(extent/3.60)+\"%)\";      }      Rectangle2D labelBounds = this.sectionLabelFont.getStringBounds(label, frc);      LineMetrics lm = this.sectionLabelFont.getLineMetrics(label, frc);      double ascent = lm.getAscent();      Point2D labelLocation = this.calculateLabelLocation(labelBounds, ascent,                                pieArea, explodedPieArea,                                startAngle, extent,                                this.getExplodePercent(section));      g2.setPaint(this.sectionLabelPaint);      g2.setFont(this.sectionLabelFont);      g2.drawString(label, (float)labelLocation.getX(), (float)labelLocation.getY());}", "nl": "Draws the label for one pie section"}
{"code": "public double getRadiusPercent() {      return this.radiusPercent;}", "nl": "Returns the radius percentage"}
{"code": "public void setPercentFormatString(String format) {      this.percentFormatter = new DecimalFormat(format);}", "nl": "Sets the format string for the percent labels"}
{"code": "public double getExplodePercent(int section) {            if (section<0) {        throw new IllegalArgumentException(\"PiePlot.getExplodePercent(int): \"                           +\"section outside valid range.\");      }            double result = 0.0;      if (this.explodePercentages!=null) {        if (section<this.explodePercentages.length) {          result = explodePercentages[section];        }      }      return result;}", "nl": "Returns the amount that a section should be ' exploded '"}
{"code": "public void setToolTipGenerator(PieToolTipGenerator generator) {      this.toolTipGenerator = generator;}", "nl": "Sets the tooltip generator"}
{"code": "public PieToolTipGenerator getToolTipGenerator() {      return this.toolTipGenerator;}", "nl": "Returns the tooltip generator"}
{"code": "public boolean isCircular() {    return circular;}", "nl": "Returns a flag indicating whether the pie chart is circular , or stretched into an elliptical shape"}
{"code": "public void setCircular(boolean flag) {                  if (circular!=flag) {      circular = flag;        this.notifyListeners(new PlotChangeEvent(this));}}", "nl": "A flag indicating whether the pie chart is circular , or stretched into an elliptical shape"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {    if (axis==null) return true;    else return false;}", "nl": "Returns true if the axis is compatible with the pie plot , and false otherwise"}
{"code": "public void setExplodePercent(int section, double percent) {            if ((section<0) || (section>=this.getDataset().getCategories().size())) {        throw new IllegalArgumentException(\"PiePlot.setExplodePercent(int, double): \"                           +\"section outside valid range.\");      }            if (this.explodePercentages!=null) {        if (section<this.explodePercentages.length) {          explodePercentages[section] = percent;        }        else {          double[] newExplodePercentages = new double[section];          for (int i=0; i<this.explodePercentages.length; i++) {            newExplodePercentages[i] = this.explodePercentages[i];          }          this.explodePercentages = newExplodePercentages;          this.explodePercentages[section] = percent;        }      }      else {        explodePercentages = new double[this.getDataset().getCategories().size()];        explodePercentages[section] = percent;}}", "nl": "Sets the amount that a pie section should be exploded"}
{"code": "public PiePlot(double interiorGapPercent, boolean circular, double radiusPercent,             int sectionLabelType,             Font sectionLabelFont, Paint sectionLabelPaint, double sectionLabelGapPercent,             String percentFormatString, Insets insets,             PieToolTipGenerator tooltipGenerator) {    super(null, null);      this.interiorGapPercent = interiorGapPercent;      this.circular = circular;      this.radiusPercent = radiusPercent;      this.sectionLabelType = sectionLabelType;      this.sectionLabelFont = sectionLabelFont;      this.sectionLabelPaint = sectionLabelPaint;      this.sectionLabelGapPercent = sectionLabelGapPercent;      this.percentFormatter = new DecimalFormat(percentFormatString);      this.explodePercentages = null;      this.toolTipGenerator = tooltipGenerator;      setInsets(insets);}", "nl": "Constructs a pie plot"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {    if (axis==null) return true;    else return false;}", "nl": "Returns true if the axis is compatible with the pie plot , and false otherwise"}
{"code": "public void setSectionLabelPaint(Paint paint) {            if (paint==null) {        throw new IllegalArgumentException(\"PiePlot.setSectionLabelPaint(...): \"                           +\"null paint not allowed.\");      }            if (!this.sectionLabelPaint.equals(paint)) {      this.sectionLabelPaint = paint;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the section label paint"}
{"code": "public void setSectionLabelType(int type) {            if ((type!=NO_LABELS) && (type!=NAME_LABELS) && (type!=PERCENT_LABELS)        && (type!=NAME_AND_PERCENT_LABELS)) {        throw new IllegalArgumentException(\"PiePlot.setSectionLabelType(int): \"                           +\"unrecognised type.\");      }            if (sectionLabelType!=type) {        this.sectionLabelType = type;        notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the section label type"}
{"code": "public void setSectionLabelGapPercent(double percent) {            if ((percent<0.0) || (percent>MAX_SECTION_LABEL_GAP)) {        throw new IllegalArgumentException(\"PiePlot.setSectionLabelGapPercent(double): \"                           +\"percentage outside valid range.\");      }            if (this.sectionLabelGapPercent!=percent) {        this.sectionLabelGapPercent = percent;        notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the section label gap percent"}
{"code": "public String getPlotType() {    return \"Pie Plot\";}", "nl": "Returns a short string describing the type of plot"}
{"code": "public double getInteriorGapPercent() {      return this.interiorGapPercent;}", "nl": "Returns the interior gap , measures as a percentage of the available drawing space"}
{"code": "public void setChart(JFreeChart chart) {          if (this.chart!=null) {        chart.removeChangeListener(this);      }    this.chart = chart;        if (verticalAxis!=null) verticalAxis.configure();    if (horizontalAxis!=null) horizontalAxis.configure();}", "nl": "Sets a reference back to the chart that this plot belongs to"}
{"code": "public Number getMaximumHorizontalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMaximumDomainValue(data);    }    else return null;}", "nl": "Returns the maximum value in either the domain or the range , whichever is displayed against the horizontal axis for the particular type of plot implementing this interface"}
{"code": "public void handleClick(int x, int y, DrawInfo info) {                  if (horizontalAxis instanceof ValueAxis) {        ValueAxis hva = (ValueAxis)horizontalAxis;        double xx = hva.translateJava2DtoValue(x, info.getDataArea());      }                  if (verticalAxis instanceof ValueAxis) {        ValueAxis vva = (ValueAxis)verticalAxis;        double yy = vva.translateJava2DtoValue(y, info.getDataArea());}}", "nl": "incoherencetype"}
{"code": "public VerticalXYBarPlot(Axis horizontalAxis, Axis verticalAxis,                 Insets insets, Paint background,                 Stroke outlineStroke, Paint outlinePaint) {      super(horizontalAxis, verticalAxis, insets, background, outlineStroke, outlinePaint);}", "nl": "Constructs a new vertical XY bar plot"}
{"code": "public void drawOutlineAndBackground(Graphics2D g2, Rectangle2D area) {    if (backgroundPaint!=null) {      g2.setPaint(backgroundPaint);      g2.fill(area);    }    if ((outlineStroke!=null) && (outlinePaint!=null)) {      g2.setStroke(outlineStroke);      g2.setPaint(outlinePaint);      g2.draw(area);}}", "nl": "Draw the plot outline and background"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {      if (axis instanceof VerticalNumberAxis) return true;      else return false;}", "nl": "Returns true if the specified axis is compatible with the plot with regard to operating as the vertical axis"}
{"code": "public Number getMinimumVerticalDataValue()  {      Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMinimumRangeValue(data);    }    else return null;}", "nl": "Returns the minimum Y value from the datasource"}
{"code": "public Paint getSeriesPaint(int index) {    return seriesPaint[index % seriesPaint.length];}", "nl": "Returns the Paint used to color any shapes for the specified series"}
{"code": "public ValueAxis getDomainAxis() {      return (ValueAxis)horizontalAxis;}", "nl": "A convenience method that returns the horizontal axis cast as a ValueAxis"}
{"code": "public void setSeriesOutlinePaint(Paint[] paint) {    this.seriesOutlinePaint = paint;    notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the paint used to outline any shapes representing series , and notifies registered listeners that the chart has been modified"}
{"code": "public void setOutlinePaint(Paint paint) {      if (!this.outlinePaint.equals(paint)) {        this.outlinePaint = paint;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the color of the outline of the plot area , and notifies registered listeners that the Plot has been modified"}
{"code": "public void setSeriesOutlineStroke(Stroke[] stroke) {    this.seriesOutlineStroke = stroke;    notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the stroke used to draw any shapes representing series , and notifies registered listeners that the chart has been modified"}
{"code": "protected void drawBar(Graphics2D g2, Rectangle2D plotArea, IntervalXYDataset data,                 int series, int item, ValueAxis horizontalAxis, ValueAxis verticalAxis,                 double translatedRangeZero) {      Paint seriesPaint = this.getSeriesPaint(series);      Paint seriesOutlinePaint = this.getSeriesOutlinePaint(series);      Number valueNumber = data.getYValue(series, item);      double translatedValue = verticalAxis.translateValueToJava2D(valueNumber.doubleValue(), plotArea);      Number startXNumber = data.getStartXValue(series, item);      double translatedStartX = horizontalAxis.translateValueToJava2D(startXNumber.doubleValue(), plotArea);      Number endXNumber = data.getEndXValue(series, item);      double translatedEndX = horizontalAxis.translateValueToJava2D(endXNumber.doubleValue(), plotArea);      double translatedWidth = Math.max(1, translatedEndX-translatedStartX);      double translatedHeight = Math.abs(translatedValue-translatedRangeZero);      Rectangle2D bar = new Rectangle2D.Double(translatedStartX,                           Math.min(translatedRangeZero, translatedValue),                           translatedWidth, translatedHeight);      g2.setPaint(seriesPaint);      g2.fill(bar);      if ((translatedEndX-translatedStartX)>3) {        g2.setStroke(this.getSeriesOutlineStroke(series));        g2.setPaint(seriesOutlinePaint);        g2.draw(bar);}}", "nl": "Draws one bar"}
{"code": "public void addChangeListener(PlotChangeListener listener) {    listeners.add(listener);}", "nl": "Registers an object for notification of changes to the plot"}
{"code": "public VerticalNumberAxis getRangeAxis() {      return (VerticalNumberAxis)verticalAxis;}", "nl": "A convenience method that returns the vertical axis cast as a VerticalNumberAxis"}
{"code": "public Number getMaximumVerticalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMaximumRangeValue(data);    }    else return null;}", "nl": "Returns the maximum Y value from the datasource"}
{"code": "protected Plot(Axis horizontalAxis, Axis verticalAxis,             Insets insets,             Paint background, Stroke outlineStroke, Paint outlinePaint) {    this.chart = null;    this.horizontalAxis=horizontalAxis;      if (horizontalAxis!=null) {      horizontalAxis.setPlot(this);      horizontalAxis.addChangeListener(this);      }    this.verticalAxis=verticalAxis;      if (verticalAxis!=null) {      verticalAxis.setPlot(this);      verticalAxis.addChangeListener(this);      }    this.insets = insets;    this.backgroundPaint = background;      this.outlineStroke = outlineStroke;    this.outlinePaint = outlinePaint;        this.seriesPaint = new Paint[] {Color.red, Color.blue, Color.green, Color.yellow,                      Color.cyan, Color.magenta, Color.orange, Color.pink,                      Color.lightGray};    this.seriesStroke = new Stroke[] { new BasicStroke(1) };    this.seriesOutlinePaint = new Paint[] { Color.gray };    this.seriesOutlineStroke = new Stroke[] { new BasicStroke(0.5f) };    this.listeners = new java.util.ArrayList();}", "nl": "Constructs a new plot"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {      if (axis instanceof HorizontalNumberAxis) return true;      else if (axis instanceof HorizontalDateAxis) return true;      else return false;}", "nl": "Returns true if the specified axis is compatible with the plot with regard to operating as the horizontal axis"}
{"code": "public void setOutlineStroke(Stroke stroke) {      if (!this.outlineStroke.equals(stroke)) {      this.outlineStroke = stroke;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the pen brush used to outline the plot area , and notifies registered listeners that the plot has been modified"}
{"code": "public Number getMinimumHorizontalDataValue() {      Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMinimumDomainValue(data);    }    else return null;}", "nl": "Returns the minimum value in either the domain or the range , whichever is displayed against the horizontal axis for the particular type of plot implementing this interface"}
{"code": "protected Plot(Axis horizontalAxis, Axis verticalAxis) {      this(horizontalAxis, verticalAxis,         DEFAULT_INSETS,         DEFAULT_BACKGROUND_COLOR,         DEFAULT_OUTLINE_STROKE,         DEFAULT_OUTLINE_COLOR);}", "nl": "Constructs a new plot with the specified axes"}
{"code": "public Stroke getOutlineStroke() {    return this.outlineStroke;}", "nl": "Returns the pen brush used to outline the plot area"}
{"code": "public void setInsets(Insets insets) {      if (!this.insets.equals(insets)) {      this.insets = insets;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the insets for the plot and notifies registered listeners that the plot has been modified"}
{"code": "public Axis getAxis(int select) {    switch (select) {        case HORIZONTAL_AXIS : return horizontalAxis;      case VERTICAL_AXIS : return verticalAxis;      default: return null;}}", "nl": "Returns the specified axis"}
{"code": "public void setSeriesPaint(Paint[] paint) {    this.seriesPaint = paint;    notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the paint used to color any shapes representing series , and notifies registered listeners that the plot has been modified"}
{"code": "public Shape getShape(int series, int item, double x, double y, double scale) {             return new Ellipse2D.Double(x-0.5*scale, y-0.5*scale, scale, scale);}", "nl": "Returns a Shape that can be used in plotting data"}
{"code": "public void removeChangeListener(PlotChangeListener listener) {    listeners.remove(listener);}", "nl": "Unregisters an object for notification of changes to the plot"}
{"code": "public void chartChanged(ChartChangeEvent event) {    if (event.getType()==ChartChangeEvent.NEW_DATASET) {      if (verticalAxis!=null) {          verticalAxis.configure();        }        if (horizontalAxis!=null) {        horizontalAxis.configure();        }    }    if (event.getType()==ChartChangeEvent.UPDATED_DATASET) {      if (verticalAxis!=null) {          verticalAxis.configure();        }        if (horizontalAxis!=null) {        horizontalAxis.configure();}}}", "nl": "Receives notification of a change to a chart"}
{"code": "public Shape getShape(int series, Object category, double x, double y, double scale) {             return new Ellipse2D.Double(x-0.5*scale, y-0.5*scale, scale, scale);}", "nl": "Returns a Shape that can be used in plotting data"}
{"code": "public HorizontalAxis getHorizontalAxis() {    return (HorizontalAxis)horizontalAxis;}", "nl": "Returns a reference to the horizontal axis"}
{"code": "public Paint getOutlinePaint() {    return this.outlinePaint;}", "nl": "Returns the color used to draw the outline of the plot area"}
{"code": "public void notifyListeners(PlotChangeEvent event) {    java.util.Iterator iterator = listeners.iterator();    while (iterator.hasNext()) {      PlotChangeListener listener = (PlotChangeListener)iterator.next();      listener.plotChanged(event);}}", "nl": "Notifies all registered listeners that the plot has been modified"}
{"code": "public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {      if (isCompatibleHorizontalAxis(axis)) {        if (axis!=null) {          try {            axis.setPlot(this);          }          catch (PlotNotCompatibleException e) {            throw new AxisNotCompatibleException(\"Plot.setHorizontalAxis(...): \"                              +\"plot not compatible with axis.\");          }          axis.addChangeListener(this);        }                if (this.horizontalAxis!=null) {        this.horizontalAxis.removeChangeListener(this);        }        this.horizontalAxis = axis;      }      else throw new AxisNotCompatibleException(\"Plot.setHorizontalAxis(...): \"                           +\"axis not compatible with plot.\");}", "nl": "Sets the horizontal axis for the plot"}
{"code": "private void drawHorizontalLines(Graphics2D g2, Rectangle2D dataArea) {            if (horizontalLines != null) {        for (int i=0; i<horizontalLines.size(); i++) {          g2.setPaint((Paint)horizontalColors.get(i));          g2.setStroke(new BasicStroke(1));          Number y = (Number)horizontalLines.get(i);          int yint = (int)getRangeAxis().translateValueToJava2D(y.doubleValue(), dataArea);          g2.drawLine(0, yint, (int)(dataArea.getWidth()), yint);}}}", "nl": "Support method for the draw"}
{"code": "private void drawVerticalLines(Graphics2D g2, Rectangle2D dataArea) {            if (verticalLines != null) {        for (int i=0; i<verticalLines.size(); i++) {          g2.setPaint((Paint)verticalColors.get(i));          g2.setStroke(new BasicStroke(1));          Number x = (Number)verticalLines.get(i);          int xint = (int)getDomainAxis().translateValueToJava2D(x.doubleValue(), dataArea);          g2.drawLine(xint, 0, xint, (int)(dataArea.getHeight()));}}}", "nl": "Support method for the draw"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {    if (axis instanceof VerticalNumberAxis) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public ValueAxis getRangeAxis() {    return (ValueAxis)verticalAxis;}", "nl": "A convenience method that returns a reference to the vertical axis cast as a ValueAxis"}
{"code": "public Number getMinimumHorizontalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMinimumDomainValue(data);    }    else return null;}", "nl": "Returns the minimum value in the domain , since this is plotted against the horizontal axis for an XYPlot"}
{"code": "public XYItemRenderer getItemRenderer() {      return this.renderer;}", "nl": "Returns a reference to the current item renderer"}
{"code": "public void addHorizontalLine(Number location, Paint color) {      if (horizontalLines == null) {        horizontalLines = new ArrayList();        horizontalColors = new ArrayList();      }      horizontalColors.add(color);      horizontalLines.add(location);}", "nl": "incoherencetype"}
{"code": "private void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value,                    Stroke stroke, Paint paint) {      double xx = this.getDomainAxis().translateValueToJava2D(value, dataArea);      Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY());      g2.setStroke(stroke);      g2.setPaint(paint);      g2.draw(line);}", "nl": "Utility method for drawing a crosshair on the chart"}
{"code": "public void handleClick(int x, int y, DrawInfo info) {            ValueAxis hva = this.getDomainAxis();      double hvalue = hva.translateJava2DtoValue((float)x, info.getDataArea());      hva.setAnchorValue(hvalue);      hva.setCrosshairValue(hvalue);            ValueAxis vva = this.getRangeAxis();      double vvalue = vva.translateJava2DtoValue((float)y, info.getDataArea());      vva.setAnchorValue(vvalue);      vva.setCrosshairValue(vvalue);}", "nl": "Handles a ' click ' on the plot by updating the anchor values"}
{"code": "private void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value,                    Stroke stroke, Paint paint) {      double yy = this.getRangeAxis().translateValueToJava2D(value, dataArea);      Line2D line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy);      g2.setStroke(stroke);      g2.setPaint(paint);      g2.draw(line);}", "nl": "Utility method for drawing a crosshair on the chart"}
{"code": "public XYPlot(ValueAxis horizontalAxis, ValueAxis verticalAxis,            Insets insets, Paint background,            Stroke outlineStroke, Paint outlinePaint) {      super(horizontalAxis, verticalAxis, insets, background, outlineStroke, outlinePaint);      this.renderer = new StandardXYItemRenderer();      this.toolTipGenerator = null;}", "nl": "Constructs a new XY plot"}
{"code": "public Number getMaximumHorizontalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMaximumDomainValue(data);    }    else return null;}", "nl": "Returns the maximum value in the domain , since this is plotted against the horizontal axis for an XYPlot"}
{"code": "public String getPlotType() {    return \"XY Plot\";}", "nl": "Returns the plot type as a string"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {    if (axis instanceof HorizontalNumberAxis) {      return true;    }    else if (axis instanceof HorizontalDateAxis) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public XYDataset getDataset() {    return (XYDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as an XYDataset"}
{"code": "public Number getMinimumVerticalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMinimumRangeValue(data);    }    else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the vertical axis for an XYPlot"}
{"code": "public VerticalNumberAxis3D(String label, Font labelFont,            double minimumAxisValue, double maximumAxisValue) {    this(label, labelFont,         Axis.DEFAULT_AXIS_LABEL_PAINT,         Axis.DEFAULT_AXIS_LABEL_INSETS,         true,         true,           Axis.DEFAULT_TICK_LABEL_FONT,         Axis.DEFAULT_TICK_LABEL_PAINT,         Axis.DEFAULT_TICK_LABEL_INSETS,       true,           Axis.DEFAULT_TICK_STROKE,         true,           true,           NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,       minimumAxisValue, maximumAxisValue,         false,        true,         NumberAxis.DEFAULT_TICK_UNIT,         false,           ValueAxis.DEFAULT_GRID_LINE_STROKE,         ValueAxis.DEFAULT_GRID_LINE_PAINT,         0.0,         ValueAxis.DEFAULT_CROSSHAIR_STROKE,         ValueAxis.DEFAULT_CROSSHAIR_PAINT,         DEFAULT_EFFECT_3D);}", "nl": "Constructs a VerticalNumberAxis3D , using default attributes where necessary"}
{"code": "public VerticalNumberAxis3D(String label, Font labelFont, Paint labelPaint, Insets labelInsets,            boolean verticalLabel,            boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint,                  Insets tickLabelInsets,            boolean showTickMarks, Stroke tickMarkStroke,            boolean autoRange, boolean autoRangeIncludesZero,                  Number autoRangeMinimum,            double minimumAxisValue, double maximumAxisValue,                  boolean inverted,            boolean autoTickUnit, NumberTickUnit tickUnit,            boolean showGridLines, Stroke gridStroke, Paint gridPaint,                  double crosshairValue, Stroke crosshairStroke, Paint crosshairPaint,                  double effect3d) {    super(label, labelFont, labelPaint, labelInsets, verticalLabel, showTickLabels,          tickLabelFont, tickLabelPaint,        tickLabelInsets, showTickMarks, tickMarkStroke,        autoRange, autoRangeIncludesZero, autoRangeMinimum,        minimumAxisValue, maximumAxisValue,          inverted,          autoTickUnit, tickUnit,          showGridLines, gridStroke, gridPaint,          crosshairValue, crosshairStroke, crosshairPaint);    this.effect3d = effect3d;}", "nl": "Constructs a new VerticalNumberAxis3D"}
{"code": "public VerticalNumberAxis3D() {    this(null);}", "nl": "Constructs a VerticalNumberAxis3D , with no label and default attributes"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {        if (this.label!=null) {      g2.setFont(labelFont);      g2.setPaint(labelPaint);      Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());      if (labelDrawnVertical) {      double xx = drawArea.getX()+labelInsets.left+labelBounds.getHeight();      double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);      drawVerticalString(label, g2, (float)xx, (float)yy);      }      else {      double xx = drawArea.getX()+labelInsets.left;      double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;      g2.drawString(label, (float)xx, (float)yy);      }    }        this.refreshTicks(g2, drawArea, plotArea);    double xx = plotArea.getX();    g2.setFont(tickLabelFont);    Iterator iterator = ticks.iterator();    while (iterator.hasNext()) {      Tick tick = (Tick)iterator.next();      float yy = (float)this.translateValueToJava2D(tick.getNumericalValue(), plotArea);      if (tickLabelsVisible) {      g2.setPaint(this.tickLabelPaint);      g2.drawString(tick.getText(), tick.getX(), tick.getY());      }      if (tickMarksVisible) {      g2.setStroke(this.getTickMarkStroke());      Line2D mark = new Line2D.Double(plotArea.getX()-2, yy,              plotArea.getX(), yy);      g2.draw(mark);      }      if (gridLinesVisible) {      g2.setStroke(gridStroke);      g2.setPaint(gridPaint);      Line2D gridline = new Line2D.Double(xx+effect3d, yy-effect3d,                plotArea.getMaxX(), yy-effect3d);      g2.draw(gridline);      Line2D grid3Dline = new Line2D.Double(xx, yy,                xx+effect3d, yy-effect3d);      g2.draw(grid3Dline);}}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public Object getMin() {      return min;}", "nl": "Returns the min of the range"}
{"code": "public Object getMax() {      return max;}", "nl": "Returns the max of the range"}
{"code": "protected boolean after(Object o1, Object o2) {      return (!o1.equals(o2) && !before(o1, o2));}", "nl": "Returns true if o1 is after o2"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,               double reservedHeight) {        double labelWidth = 0.0;    if (label!=null) {      Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());      labelWidth = labelInsets.left+labelInsets.right;      if (this.labelDrawnVertical) {      labelWidth = labelWidth + labelBounds.getHeight();        }      else {      labelWidth = labelWidth + labelBounds.getWidth();      }    }        double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;    if (tickLabelsVisible) {      Rectangle2D approximatePlotArea = new Rectangle2D.Double(drawArea.getX(), drawArea.getY(),                     drawArea.getWidth(),                     drawArea.getHeight()-reservedHeight);      this.refreshTicks(g2, drawArea, approximatePlotArea);      tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, approximatePlotArea);    }    return new Rectangle2D.Double(drawArea.getX(), drawArea.getY(), labelWidth+tickLabelWidth,              drawArea.getHeight()-reservedHeight);}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public boolean isLabelDrawnVertical() {    return this.labelDrawnVertical;}", "nl": "Returns a flag that indicates whether or not the axis label is drawn with a vertical orientation"}
{"code": "public VerticalNumberAxis(String label,                  Font labelFont, Paint labelPaint, Insets labelInsets,            boolean labelDrawnVertical,            boolean tickLabelsVisible, Font tickLabelFont, Paint tickLabelPaint,                  Insets tickLabelInsets,            boolean tickMarksVisible, Stroke tickMarkStroke,            boolean autoRange, boolean autoRangeIncludesZero,                  Number autoRangeMinimum,            double minimumAxisValue, double maximumAxisValue,                  boolean inverted,            boolean autoTickUnitSelection,                  NumberTickUnit tickUnit,             boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,                  double crosshairValue, Stroke crosshairStroke, Paint crosshairPaint) {    super(label,          labelFont, labelPaint, labelInsets,          tickLabelsVisible,          tickLabelFont, tickLabelPaint, tickLabelInsets,          tickMarksVisible,          tickMarkStroke,        autoRange, autoRangeIncludesZero, autoRangeMinimum,        minimumAxisValue, maximumAxisValue,          inverted,          autoTickUnitSelection, tickUnit,          gridLinesVisible, gridStroke, gridPaint,          crosshairValue, crosshairStroke, crosshairPaint);    this.labelDrawnVertical = labelDrawnVertical;}", "nl": "Constructs a vertical number axis"}
{"code": "public VerticalNumberAxis() {      this(null);}", "nl": "Constructs a vertical number axis , using default values where necessary"}
{"code": "public VerticalNumberAxis(String label, Font labelFont,            double minimumAxisValue, double maximumAxisValue) {    this(label,         labelFont,         Axis.DEFAULT_AXIS_LABEL_PAINT,         Axis.DEFAULT_AXIS_LABEL_INSETS,         true,          true,          Axis.DEFAULT_TICK_LABEL_FONT,         Axis.DEFAULT_TICK_LABEL_PAINT,         Axis.DEFAULT_TICK_LABEL_INSETS,       true,          Axis.DEFAULT_TICK_STROKE,         true,          true,          NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,       minimumAxisValue,         maximumAxisValue,         false,        true,          NumberAxis.DEFAULT_TICK_UNIT,       true,          ValueAxis.DEFAULT_GRID_LINE_STROKE,         ValueAxis.DEFAULT_GRID_LINE_PAINT,         0.0,         ValueAxis.DEFAULT_CROSSHAIR_STROKE,         ValueAxis.DEFAULT_CROSSHAIR_PAINT);}", "nl": "Constructs a vertical number axis"}
{"code": "public void setLabelDrawnVertical(boolean flag) {      if (this.labelDrawnVertical!=flag) {      this.labelDrawnVertical = flag;      this.notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag that controls whether or not the axis label is drawn with a vertical orientation"}
{"code": "private void selectAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {            FontRenderContext frc = g2.getFontRenderContext();      double tickLabelHeight = tickLabelFont.getLineMetrics(\"123\", frc).getHeight()                   +this.tickLabelInsets.top+this.tickLabelInsets.bottom;          double zero = this.translateValueToJava2D(0.0, plotArea);            NumberTickUnit candidate1               = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(this.tickUnit);      double y = this.translateValueToJava2D(candidate1.getValue().doubleValue(), plotArea);      double unitHeight = Math.abs(y-zero);            double bestguess = (tickLabelHeight/unitHeight) * candidate1.value.doubleValue();      NumberTickUnit guess = new NumberTickUnit(new Double(bestguess), null);      NumberTickUnit candidate2                 = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(guess);      this.tickUnit = candidate2;}", "nl": "Selects an appropriate tick value for the axis"}
{"code": "public void configure() {    if (isAutoRange()) {      autoAdjustRange();}}", "nl": "Configures the axis to work with the specified plot"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {        if (this.label!=null) {      g2.setFont(labelFont);      g2.setPaint(labelPaint);      Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());      if (labelDrawnVertical) {      double xx = drawArea.getX()+labelInsets.left+labelBounds.getHeight();      double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);      drawVerticalString(label, g2, (float)xx, (float)yy);      }      else {      double xx = drawArea.getX()+labelInsets.left;      double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;      g2.drawString(label, (float)xx, (float)yy);      }    }        this.refreshTicks(g2, drawArea, plotArea);    double xx = plotArea.getX();    g2.setFont(tickLabelFont);    Iterator iterator = ticks.iterator();    while (iterator.hasNext()) {      Tick tick = (Tick)iterator.next();      float yy = (float)this.translateValueToJava2D(tick.getNumericalValue(), plotArea);      if (tickLabelsVisible) {      g2.setPaint(this.tickLabelPaint);      g2.drawString(tick.getText(), tick.getX(), tick.getY());      }      if (tickMarksVisible) {      g2.setStroke(this.getTickMarkStroke());      Line2D mark = new Line2D.Double(plotArea.getX()-2, yy,              plotArea.getX()+2, yy);      g2.draw(mark);      }      if (gridLinesVisible) {      g2.setStroke(gridStroke);      g2.setPaint(gridPaint);      Line2D gridline = new Line2D.Double(xx, yy,                plotArea.getMaxX(), yy);      g2.draw(gridline);}}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public void autoAdjustRange() {    if (plot!=null) {      if (plot instanceof VerticalValuePlot) {      VerticalValuePlot vvp = (VerticalValuePlot)plot;          Number u = vvp.getMaximumVerticalDataValue();          double upper = this.DEFAULT_MAXIMUM_AXIS_VALUE;          if (u!=null) {        upper = u.doubleValue();          }          Number l = vvp.getMinimumVerticalDataValue();          double lower = this.DEFAULT_MINIMUM_AXIS_VALUE;          if (l!=null) {        lower = l.doubleValue();          }      double range = upper-lower;                double minRange = this.autoRangeMinimumSize.doubleValue();      if (range<minRange) {        upper = (upper+lower+minRange)/2;        lower = (upper+lower-minRange)/2;      }      if (this.autoRangeIncludesZero()) {        if (upper!=0.0) upper = Math.max(0.0, upper+upperMargin*range);        if (lower!=0.0) lower = Math.min(0.0, lower-lowerMargin*range);      }      else {        if (upper!=0.0) upper = upper+upperMargin*range;        if (lower!=0.0) lower = lower-lowerMargin*range;      }      this.minimumAxisValue=lower;      this.maximumAxisValue=upper;}}}", "nl": "Rescales the axis to ensure that all data is visible"}
{"code": "public Number getMinimumVerticalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMinimumRangeValue(data);    }    else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the vertical axis for BarPlot"}
{"code": "public CategoryAxis getCategoryAxis() {    return (CategoryAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a CategoryAxis"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {    if (axis instanceof CategoryAxis) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public double getCategoryCoordinate(int category, Rectangle2D area) {            double result = area.getX() + (area.getWidth()*introGapPercent);          int categoryCount = getDataset().getCategoryCount();      if (categoryCount>1) {      double categorySpan = area.getWidth()                    * (1-introGapPercent-trailGapPercent-categoryGapsPercent);        double categoryGapSpan = area.getWidth()*categoryGapsPercent;        result = result             + (category+0.5)*(categorySpan/categoryCount)             + (category)*(categoryGapSpan/(categoryCount-1));      }      else {        result = result             + (category+0.5)*area.getWidth()*(1-introGapPercent-trailGapPercent);      }      return result;}", "nl": "Returns the x - coordinate of the center of the specified category"}
{"code": "public VerticalBarPlot(CategoryAxis horizontalAxis, ValueAxis verticalAxis,                 Insets insets,           double introGapPercent, double trailGapPercent,                 double categoryGapPercent, double itemGapPercent,                 CategoryToolTipGenerator toolTipGenerator) {    super(horizontalAxis, verticalAxis,          insets,        introGapPercent, trailGapPercent, categoryGapPercent, itemGapPercent,          toolTipGenerator);      this.renderer = new VerticalBarRenderer();}", "nl": "Constructs a new vertical bar plot"}
{"code": "public void draw(Graphics2D g2, Rectangle2D plotArea, DrawInfo info) {            ToolTipsCollection tooltips = null;      if (info!=null) {        info.setPlotArea(plotArea);        tooltips = info.getToolTipsCollection();      }          if (insets!=null) {      plotArea.setRect(plotArea.getX()+insets.left,                 plotArea.getY()+insets.top,                 plotArea.getWidth()-insets.left-insets.right,           plotArea.getHeight()-insets.top-insets.bottom);    }      if ((plotArea.getWidth()>=MINIMUM_WIDTH_TO_DRAW)       && (plotArea.getHeight()>=MINIMUM_HEIGHT_TO_DRAW)) {                HorizontalAxis hAxis = getHorizontalAxis();        VerticalAxis vAxis = getVerticalAxis();        double hAxisAreaHeight = hAxis.reserveHeight(g2, this, plotArea);        Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, plotArea, hAxisAreaHeight);                Rectangle2D dataArea = new Rectangle2D.Double(plotArea.getX()+vAxisArea.getWidth(),                                plotArea.getY(),                                plotArea.getWidth()-vAxisArea.getWidth(),                                plotArea.getHeight()-hAxisAreaHeight);        if (info!=null) {          info.setDataArea(dataArea);        }        Shape backgroundPlotArea = calculateBackgroundPlotArea(dataArea);                drawOutlineAndBackground(g2, backgroundPlotArea);        getCategoryAxis().draw(g2, plotArea, dataArea);        getRangeAxis().draw(g2, plotArea, dataArea);        drawBars(g2, backgroundPlotArea, dataArea, info);                ValueAxis vva = this.getRangeAxis();        if (vva.isCrosshairVisible()) {          this.drawHorizontalLine(g2, dataArea, vva.getCrosshairValue(),                      vva.getCrosshairStroke(),                      vva.getCrosshairPaint());}}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public void setRenderer(VerticalBarRenderer renderer) {      this.renderer = renderer;      this.notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the renderer for the bar plot"}
{"code": "protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {      return plotArea;}", "nl": "Returns chart ' s background area"}
{"code": "public Number getMaximumVerticalDataValue() {    Dataset data = this.getChart().getDataset();    if (data!=null) {      return Datasets.getMaximumRangeValue(data);    }    else return null;}", "nl": "Returns the maximum value in either the domain or the range , whichever is displayed against the vertical axis for the particular type of plot implementing this interface"}
{"code": "public java.util.List getCategories() {    return getDataset().getCategories();}", "nl": "A convenience method that returns a list of the categories in the dataset"}
{"code": "public CategoryDataset getDataset() {    return (CategoryDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as a CategoryDataset"}
{"code": "public void drawOutlineAndBackground(Graphics2D g2, Shape area) {    if (backgroundPaint!=null) {      g2.setPaint(backgroundPaint);      g2.fill(area);    }    if ((outlineStroke!=null) && (outlinePaint!=null)) {      g2.setStroke(outlineStroke);      g2.setPaint(outlinePaint);      g2.draw(area);}}", "nl": "Draws the plot outline and background"}
{"code": "public void setAutoTickUnitSelection(boolean flag) {      if (this.autoTickUnitSelection!=flag) {        this.autoTickUnitSelection = flag;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets a flag indicating whether or not the tick unit is automatically selected from a range of standard tick units"}
{"code": "public void setCrosshairVisible(boolean flag) {      if (this.crosshairVisible!=flag) {        this.crosshairVisible=flag;        notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag indicating whether or not a crosshair is visible for this axis"}
{"code": "public boolean isGridLinesVisible() {    return gridLinesVisible;}", "nl": "Returns true if the grid lines are showing , and false otherwise"}
{"code": "public Paint getGridPaint() {    return gridPaint;}", "nl": "Returns the grid line color"}
{"code": "public void setGridLinesVisible(boolean flag) {      if (gridLinesVisible!=flag) {        gridLinesVisible = flag;      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the visibility of the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "public void setCrosshairValue(double value) {      this.crosshairValue = value;      notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the crosshair value for the axis"}
{"code": "public void setCrosshairStroke(Stroke stroke) {    crosshairStroke = stroke;    notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the Stroke used to draw the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "public Paint getCrosshairPaint() {    return crosshairPaint;}", "nl": "Returns the grid line color"}
{"code": "public Stroke getCrosshairStroke() {    return crosshairStroke;}", "nl": "Returns the Stroke used to draw the crosshair"}
{"code": "public ValueAxis(String label) {    this(label,         Axis.DEFAULT_AXIS_LABEL_FONT,         Axis.DEFAULT_AXIS_LABEL_PAINT,         Axis.DEFAULT_AXIS_LABEL_INSETS,         true,          Axis.DEFAULT_TICK_LABEL_FONT,         Axis.DEFAULT_TICK_LABEL_PAINT,         Axis.DEFAULT_TICK_LABEL_INSETS,         true,          Axis.DEFAULT_TICK_STROKE,         true,          true,          true,          ValueAxis.DEFAULT_GRID_LINE_STROKE,         ValueAxis.DEFAULT_GRID_LINE_PAINT,         0.0,           ValueAxis.DEFAULT_CROSSHAIR_STROKE,         ValueAxis.DEFAULT_CROSSHAIR_PAINT);}", "nl": "Constructs a value axis , using default values where necessary"}
{"code": "public double getCrosshairValue() {      return this.crosshairValue;}", "nl": "Returns the crosshair value"}
{"code": "public double getMaximumAxisValue() {    return maximumAxisValue;}", "nl": "Returns the maximum value for the axis"}
{"code": "public void setAxisRange(double lower, double upper) {      this.autoRange = false;      this.minimumAxisValue = lower;      this.maximumAxisValue = upper;      notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the axis range"}
{"code": "public void setGridStroke(Stroke stroke) {            if (stroke==null) {        throw new IllegalArgumentException(\"ValueAxis.setGridStroke(...): null not permitted\");      }            gridStroke = stroke;    notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the Stroke used to draw the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "public Stroke getGridStroke() {    return gridStroke;}", "nl": "Returns the Stroke used to draw the grid lines"}
{"code": "public void setMinimumAxisValue(double value) {    if (this.minimumAxisValue!=value) {      this.minimumAxisValue = value;        this.autoRange = false;        notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the minimum value for the axis"}
{"code": "public void setAutoRange(boolean auto) {    if (this.autoRange!=auto) {      this.autoRange=auto;      if (autoRange) autoAdjustRange();      notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets a flag that determines whether or not the axis range is automatically adjusted to fit the data , and notifies registered listeners that the axis has been modified"}
{"code": "public void setCrosshairLockedOnData(boolean flag) {      if (this.crosshairLockedOnData!=flag) {        this.crosshairLockedOnData=flag;        notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag indicating whether or not the crosshair should lock - on to actual data values"}
{"code": "public void setCrosshairPaint(Paint paint) {    crosshairPaint = paint;    notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the Paint used to color the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "protected ValueAxis(String label,              Font labelFont, Paint labelPaint, Insets labelInsets,          boolean tickLabelsVisible,              Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,          boolean tickMarksVisible, Stroke tickMarkStroke,          boolean autoRange, boolean autoTickUnitSelection,          boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,              double crosshairValue,              Stroke crosshairStroke, Paint crosshairPaint) {    super(label,          labelFont, labelPaint, labelInsets,        tickLabelsVisible,          tickLabelFont, tickLabelPaint, tickLabelInsets,        tickMarksVisible, tickMarkStroke);    this.autoRange = autoRange;    this.autoTickUnitSelection = autoTickUnitSelection;    this.gridLinesVisible = gridLinesVisible;    this.gridStroke = gridStroke;    this.gridPaint = gridPaint;      this.crosshairValue = crosshairValue;      this.crosshairStroke = crosshairStroke;      this.crosshairPaint = crosshairPaint;}", "nl": "Constructs a value axis"}
{"code": "public TickUnit getNearestTickUnit(TickUnit unit) {      int index = Collections.binarySearch(units, unit);      if (index>=0) {        return (TickUnit)units.get(index);      }      else {        index = -(index + 1);        return (TickUnit)units.get(Math.min(index, units.size()));}}", "nl": "Returns the tick unit in the collection that is closest in size to the specified unit"}
{"code": "public TickUnits() {      this.units = new ArrayList();}", "nl": "Constructs a new collection of tick units"}
{"code": "public void add(TickUnit unit) {      units.add(unit);      Collections.sort(units);}", "nl": "Adds a tick unit to the collection"}
{"code": "public Shape drawBar(Graphics2D g2, Rectangle2D dataArea, BarPlot plot, ValueAxis valueAxis,               CategoryDataset data, int series, Object category, int categoryIndex,               double translatedZero, double itemWidth,               double categorySpan, double categoryGapSpan,               double itemSpan, double itemGapSpan) {      Shape result = null;            Number value = data.getValue(series, category);      if (value!=null) {                double rectX = dataArea.getX()+dataArea.getWidth()*plot.getIntroGapPercent();        int categories = data.getCategoryCount();        int seriesCount = data.getSeriesCount();        if (categories>1) {          rectX = rectX                            + categoryIndex*(categorySpan/categories)                            + (categoryIndex*(categoryGapSpan/(categories-1))                            + (series*itemSpan/(categories*seriesCount)));          if (seriesCount>1) {            rectX = rectX                + (series*itemGapSpan/(categories*(seriesCount-1)));          }        }        else {          rectX = rectX                            + (series*itemSpan/(categories*seriesCount));          if (seriesCount>1) {            rectX = rectX                + (series*itemGapSpan/(categories*(seriesCount-1)));          }        }                double translatedValue = valueAxis.translateValueToJava2D(value.doubleValue(), dataArea);        double rectY = Math.min(translatedZero, translatedValue);                double rectWidth = itemWidth;                double rectHeight = Math.abs(translatedValue-translatedZero);        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);        Paint seriesPaint = plot.getSeriesPaint(series);        g2.setPaint(seriesPaint);        g2.fill(bar);        result = bar;        GeneralPath bar3dRight = null;        GeneralPath bar3dTop = null;        double effect3d = 0.00;        VerticalAxis vAxis = plot.getVerticalAxis();        if (rectHeight != 0 && vAxis instanceof VerticalNumberAxis3D) {          effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();          bar3dRight = new GeneralPath();          bar3dRight.moveTo((float)(rectX+rectWidth), (float)rectY);          bar3dRight.lineTo((float)(rectX+rectWidth), (float)(rectY+rectHeight));          bar3dRight.lineTo((float)(rectX+rectWidth+effect3d),                    (float)(rectY+rectHeight-effect3d));          bar3dRight.lineTo((float)(rectX+rectWidth+effect3d), (float)(rectY-effect3d));          if (seriesPaint instanceof Color) {            g2.setPaint( ((Color) seriesPaint).darker());          }          g2.fill(bar3dRight);          bar3dTop = new GeneralPath();          bar3dTop.moveTo( (float) rectX, (float) rectY);          bar3dTop.lineTo((float) (rectX+effect3d), (float) (rectY-effect3d));          bar3dTop.lineTo((float) (rectX+rectWidth+effect3d), (float) (rectY-effect3d));          bar3dTop.lineTo((float) (rectX+rectWidth), (float) (rectY) );          if (seriesPaint instanceof Color) {            g2.setPaint( ((Color) seriesPaint));           }          g2.fill(bar3dTop);        }        if (itemWidth>3) {          g2.setStroke(plot.getSeriesOutlineStroke(series));                    g2.setPaint(plot.getSeriesOutlinePaint(series));          g2.draw(bar);          if (bar3dRight != null) {            g2.draw(bar3dRight);          }          if (bar3dTop != null) {            g2.draw(bar3dTop);          }        }      }      return result;}", "nl": "Renders an individual bar"}
{"code": "public boolean hasItemGaps() {      return true;}", "nl": "Returns true , since there are gaps between bars in this representation"}
{"code": "public int barWidthsPerCategory(CategoryDataset data) {      return data.getSeriesCount();}", "nl": "This will be a method in the renderer that tells whether there is one bar width per category or onebarwidth per series per category"}
{"code": "public Shape drawBar(Graphics2D g2, Rectangle2D dataArea, BarPlot plot, ValueAxis valueAxis,               CategoryDataset data, int series, Object category, int categoryIndex,               double translatedZero, double itemWidth,               double categorySpan, double categoryGapSpan,               double itemSpan, double itemGapSpan) {      Shape result = null;            Number value = data.getValue(series, category);      if (value!=null) {                double rectX = dataArea.getX()+dataArea.getWidth()*plot.getIntroGapPercent();        int categories = data.getCategoryCount();        int seriesCount = data.getSeriesCount();        if (categories>1) {          rectX = rectX                            + categoryIndex*(categorySpan/categories)                            + (categoryIndex*(categoryGapSpan/(categories-1))                            + (series*itemSpan/(categories*seriesCount)));          if (seriesCount>1) {            rectX = rectX                + (series*itemGapSpan/(categories*(seriesCount-1)));          }        }        else {          rectX = rectX                            + (series*itemSpan/(categories*seriesCount));          if (seriesCount>1) {            rectX = rectX                + (series*itemGapSpan/(categories*(seriesCount-1)));          }        }                double translatedValue = valueAxis.translateValueToJava2D(value.doubleValue(), dataArea);        double rectY = Math.min(translatedZero, translatedValue);                double rectWidth = itemWidth;                double rectHeight = Math.abs(translatedValue-translatedZero);        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);        Paint seriesPaint = plot.getSeriesPaint(series);        g2.setPaint(seriesPaint);        g2.fill(bar);        if (itemWidth>3) {          g2.setStroke(plot.getSeriesStroke(series));          g2.setPaint(plot.getSeriesOutlinePaint(series));          g2.draw(bar);        }        result = bar;      }      return result;}", "nl": "Handles the rendering of a single bar"}
{"code": "protected boolean isCompatiblePlot(Plot plot) {      if (plot instanceof CategoryPlot) return true;      else return false;}", "nl": "Returns true if the specified plot is compatible with the axis , and false otherwise"}
{"code": "public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {    this.ticks.clear();    CategoryPlot categoryPlot = (CategoryPlot)plot;      Dataset data = categoryPlot.getDataset();      if (data!=null) {        Font font = this.getTickLabelFont();      g2.setFont(font);      FontRenderContext frc = g2.getFontRenderContext();      int categoryIndex = 0;      Iterator iterator = categoryPlot.getDataset().getCategories().iterator();        while (iterator.hasNext()) {        Object category = iterator.next();        String label = category.toString();        Rectangle2D labelBounds = font.getStringBounds(label, frc);        LineMetrics metrics = font.getLineMetrics(label, frc);        float xx = (float)(plotArea.getX()-tickLabelInsets.right-labelBounds.getWidth());        float yy = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)                    -metrics.getStrikethroughOffset()+0.5f);        Tick tick = new Tick(category, label, xx, yy);        ticks.add(tick);        categoryIndex = categoryIndex+1;}}}", "nl": "Creates a temporary list of ticks that can be used when drawing the axis"}
{"code": "public VerticalCategoryAxis(String label,                  Font labelFont, Paint labelPaint, Insets labelInsets,          boolean verticalLabel,          boolean categoryLabelsVisible,                  Font categoryLabelFont, Paint categoryLabelPaint,                  Insets categoryLabelInsets,          boolean tickMarksVisible, Stroke tickMarkStroke) {    super(label, labelFont, labelPaint, labelInsets,        categoryLabelsVisible, categoryLabelFont, categoryLabelPaint, categoryLabelInsets,        tickMarksVisible, tickMarkStroke);    this.verticalLabel = verticalLabel;}", "nl": "Full constructor : returns a new VerticalCategoryAxis with attributes as specified by the caller"}
{"code": "public VerticalCategoryAxis(String label) {      this(label,         Axis.DEFAULT_AXIS_LABEL_FONT,         Axis.DEFAULT_AXIS_LABEL_PAINT,         Axis.DEFAULT_TICK_LABEL_INSETS,         true,          true,          Axis.DEFAULT_TICK_LABEL_FONT,         Axis.DEFAULT_TICK_LABEL_PAINT,         Axis.DEFAULT_TICK_LABEL_INSETS,         false,          Axis.DEFAULT_TICK_STROKE);}", "nl": "Constructs a VerticalCategoryAxis , using default attributes where necessary"}
{"code": "public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {          double labelWidth = 0.0;      if (label!=null) {      Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());      labelWidth = this.labelInsets.left+labelInsets.right;      if (this.verticalLabel) {                  labelWidth = labelWidth + labelBounds.getHeight();      }      else {        labelWidth = labelWidth + labelBounds.getWidth();      }      }        double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;    if (tickLabelsVisible) {      this.refreshTicks(g2, drawArea, drawArea);      tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);    }    return labelWidth+tickLabelWidth;}", "nl": "Estimates the height required for the axis , given a specific drawing area , without any information about the width of the vertical axis"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,               double reservedHeight) {            double labelWidth = 0.0;      if (label!=null) {      Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());      labelWidth = this.labelInsets.left+labelInsets.right;      if (this.verticalLabel) {                  labelWidth = labelWidth + labelBounds.getHeight();      }      else {        labelWidth = labelWidth + labelBounds.getWidth();      }      }        double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;    if (tickLabelsVisible) {      this.refreshTicks(g2, drawArea, drawArea);      tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);    }    return new Rectangle2D.Double(drawArea.getX(), drawArea.getY(), labelWidth+tickLabelWidth,              drawArea.getHeight()-reservedHeight);}", "nl": "Returns the area required to draw the axis in the specified draw area"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {    if (axis instanceof VerticalNumberAxis3D) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "protected void drawBars(Graphics2D g2, Shape backgroundPlotArea, Rectangle2D plotArea,                DrawInfo info) {      VerticalAxis vAxis = getVerticalAxis();    double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();          if ((outlineStroke!=null) && (outlinePaint!=null)) {      g2.setStroke(outlineStroke);      g2.setPaint(outlinePaint);      g2.draw(new Line2D.Double(plotArea.getX()+effect3d, plotArea.getY()-effect3d,                plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));      g2.draw(new Line2D.Double(plotArea.getX(), plotArea.getY()+plotArea.getHeight(),                plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));      g2.draw(new Line2D.Double(plotArea.getX()+effect3d,                      plotArea.getY()+plotArea.getHeight()-effect3d,                      plotArea.getX()+plotArea.getWidth(),                      plotArea.getY()+plotArea.getHeight()-effect3d));    }    super.drawBars(g2, backgroundPlotArea, plotArea, info);}", "nl": "Draws the bars"}
{"code": "public String getTitle() {    return this.title;}", "nl": "Returns the title text"}
{"code": "public void addChangeListener(TitleChangeListener listener) {    listeners.add(listener);}", "nl": "Registers an object for notification of changes to the title"}
{"code": "protected Title(String title) {    this.title = title;    this.listeners = new java.util.ArrayList();}", "nl": "Standard constructor - builds a Title object"}
{"code": "public void removeChangeListener(TitleChangeListener listener) {    listeners.remove(listener);}", "nl": "Unregisters an object for notification of changes to the chart title"}
{"code": "public void setTitle(String text) {    this.title = text;}", "nl": "Sets the title to the specified text and notifies registered listeners that the title has been modified"}
{"code": "public static Title createInstance(String title, Font font) {    return new StandardTitle(title, font);}", "nl": "Static factory method that returns a concrete subclass of Title"}
{"code": "public ChartChangeEvent(Object source) {      this(source, null, GENERAL);}", "nl": "Standard constructor : returns a new ChartChangeEvent object , type GENERAL"}
{"code": "public int getType() {      return this.type;}", "nl": "Returns the event type"}
{"code": "public JFreeChart getChart() {      return chart;}", "nl": "Returns a reference to the chart that generated the change event"}
{"code": "public AxisChangeEvent(Axis axis) {      super(axis);      this.axis = axis;}", "nl": "Default constructor : returns a new AxisChangeEvent"}
{"code": "public void setRange(AxisRange range) {      setAutoRange(false);      setMinimumDate((Date)range.getMin());      setMaximumDate((Date)range.getMax());      if (visible) {        HorizontalDateAxis axis = (HorizontalDateAxis)getParentAxis();        axis.setAutoRange(false);        axis.setMinimumDate((Date)range.getMin());        axis.setMaximumDate((Date)range.getMax());}}", "nl": "Sets our AxisRange"}
{"code": "public void setVisible(boolean flag) {      visible = flag;}", "nl": "Sets the visible flag on or off for this combined axis"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {      if (visible) {        axis.draw(g2, drawArea, plotArea);      }      else if (gridLinesVisible) {        refreshTicks(g2, drawArea, plotArea);        g2.setStroke(gridStroke);        g2.setPaint(gridPaint);        Iterator iterator = ticks.iterator();        while (iterator.hasNext()) {          Tick tick = (Tick)iterator.next();          float xx = (float)translateValueToJava2D(tick.getNumericalValue(), plotArea);          Line2D gridline = new Line2D.Float(xx, (float)plotArea.getMaxY(),                             xx, (float)plotArea.getMinY());          g2.draw(gridline);}}}", "nl": "If axis is not visible , just draws grid lines if needed , but no horizonatal date axis labels"}
{"code": "public Axis getParentAxis() {      return axis;}", "nl": "Returns our parent axis"}
{"code": "public AxisRange getRange() {      DateAxisRange range;      if (visible) {        axis.autoAdjustRange();        range = new DateAxisRange(axis.getMinimumDate(), axis.getMaximumDate());      }      else {        autoAdjustRange();        range = new DateAxisRange(getMinimumDate(), getMaximumDate());      }      return (range);}", "nl": "Returns the AxisRange of our Axis"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,                       double reservedWidth) {      if (visible) {        return axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);      }      else {        return new Rectangle2D.Double();}}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {      Iterator iter = axes.iterator();      while (iter.hasNext()) {        HorizontalAxis axis = (HorizontalAxis)iter.next();        double height = axis.reserveHeight(g2, plot, drawArea);        if (height != 0) {          return height;        }      }      return 0;}", "nl": "Returns the height required to draw the axis in the specified draw area"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,                       double reservedWidth) {      Rectangle2D empty = new Rectangle2D.Double();      Iterator iter = axes.iterator();      while (iter.hasNext()) {        HorizontalAxis axis = (HorizontalAxis)iter.next();        Rectangle2D area = axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);        if (!area.equals(empty)) {          return area;        }      }      return empty;}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public OverlaidHorizontalNumberAxis(CombinedPlot plot) {      super((HorizontalNumberAxis)plot.getHorizontalAxis(), false);      this.plot = plot;      this.axes = plot.getHorizontalAxes();            boolean oneVisible = false;      Iterator iter = axes.iterator();      while (iter.hasNext()) {        Object axis = iter.next();        if ((axis instanceof CombinedHorizontalNumberAxis)) {          CombinedHorizontalNumberAxis combAxis = (CombinedHorizontalNumberAxis)axis;          oneVisible |= combAxis.isVisible();          if (iter.hasNext() || oneVisible) {            combAxis.setGridLinesVisible(false);                      }        } else {          throw new IllegalArgumentException(\"Can not combine \" + axis.getClass()                       + \" into \" + this.getClass() );}}}", "nl": "Constructor"}
{"code": "public AxisRange getRange() {      return plot.getRange(axes);}", "nl": "Returns the AxisRange of our Axis"}
{"code": "public void setReserveDimension(double dimension) {      this.reserveWidth = dimension;}", "nl": "The CombinedPlot will calculate the maximim of all reserveWidth or reserveHeight depending on the type of CombinedPlot and inform all CombinedXXXXXAxis to store this value"}
{"code": "public CombinedVerticalNumberAxis(VerticalNumberAxis axis, boolean visible) {      super(axis.getLabel(),          axis.getLabelFont(),          axis.getLabelPaint(),          axis.getLabelInsets(),          axis.isLabelDrawnVertical(),          axis.isTickLabelsVisible(),          axis.getTickLabelFont(),          axis.getTickLabelPaint(),          axis.getTickLabelInsets(),          axis.isTickMarksVisible(),          axis.getTickMarkStroke(),          axis.isAutoRange(),          axis.autoRangeIncludesZero(),          axis.getAutoRangeMinimumSize(),          axis.getMinimumAxisValue(),          axis.getMaximumAxisValue(),          axis.isInverted(),          axis.isAutoTickUnitSelection(),          axis.getTickUnit(),          axis.isGridLinesVisible(),          axis.getGridStroke(),          axis.getGridPaint(),          axis.getCrosshairValue(),          axis.getCrosshairStroke(),          axis.getCrosshairPaint());      this.axis = axis;      this.visible = visible;}", "nl": "Constructs a combined vertical number axis"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,                       double reservedHeight) {      return new Rectangle2D.Double(drawArea.getX(),                      drawArea.getY(),                      reserveWidth(g2, plot, drawArea),                      drawArea.getHeight()-reservedHeight);}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public Axis getParentAxis() {      return axis;}", "nl": "Returns our parent axis"}
{"code": "public CombinedVerticalNumberAxis(VerticalNumberAxis axis) {      this(axis, true);}", "nl": "Constructs a visible combined vertical number axis"}
{"code": "public void setRange(AxisRange range) {      setAutoRange(false);      Number min = (Number)range.getMin();      Number max = (Number)range.getMax();      setMinimumAxisValue(min.doubleValue());      setMaximumAxisValue(max.doubleValue());      if (visible) {        VerticalNumberAxis axis = (VerticalNumberAxis)getParentAxis();        axis.setAutoRange(false);        axis.setMinimumAxisValue(min.doubleValue());        axis.setMaximumAxisValue(max.doubleValue());}}", "nl": "Sets our AxisRange"}
{"code": "public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {      if (!visible) {        return 0;      } else if (reserveWidth > 0) {        return reserveWidth;      } else {        return axis.reserveWidth(g2, plot, drawArea);}}", "nl": "Returns the width required to draw the biggest axis of all the combined vertical axis in the specified draw area"}
{"code": "public Number getObject() {      return object;}", "nl": "Returns the object - caller has to use doubleValue method"}
{"code": "protected Rectangle2D adjustForInsets(Rectangle2D drawArea, Insets insets) {      if (insets != null) {        return new Rectangle2D.Double(drawArea.getX()+insets.left,                        drawArea.getY()+insets.top,                        drawArea.getWidth()-insets.left-insets.right,                        drawArea.getHeight()-insets.top-insets.bottom);      } else {        return drawArea;}}", "nl": "Utility method to adjust a Rectangle2D for Insets"}
{"code": "public Number getXValue(int series, int item) {      return new Double(-10.0+translate+(item*0.2));}", "nl": "Returns the x - value for the specified series and item"}
{"code": "public Rectangle2D getPlotArea() {      return plotArea;}", "nl": "Returns the last plotArea calculated"}
{"code": "public String getSeriesName(int series) {      if (series==0) {        return \"y = cosine(x)\";      }      else if (series==1) {        return \"y = 2*sine(x)\";      }      else return \"Error\";}", "nl": "Returns the name of the series"}
{"code": "public CombinedPlot(Axis axis, int type) {      super((type == VERTICAL ? axis : null), (type == HORIZONTAL ? axis : null));      if (type != HORIZONTAL && type != VERTICAL) {        throw new IllegalArgumentException(\"Invalid type (\" + type + \")\");      }      this.type = type;      setInsets(new Insets(0, 0, 0, 0));}", "nl": "Creates a HORIZONTAL or VERTICAL CombinedPlot"}
{"code": "public Number getYValue(int series, int item) {      if (series==0) {        return new Double(Math.cos(-10.0+translate+(item/10.0)));      }      else return new Double(2*(Math.sin(-10.0+translate+(item/10.0))));}", "nl": "Returns the y - value for the specified series and item"}
{"code": "public SampleXYDataset() {      this.translate = 0.0;}", "nl": "Default constructor"}
{"code": "public void add(CombinedChart chart, int weight)      throws AxisNotCompatibleException, IllegalArgumentException {            Plot p = chart.getPlot();      if (getHorizontalAxis() != p.getHorizontalAxis() && type != HORIZONTAL) {        throw new AxisNotCompatibleException(\"Can't combine with different horizontal axis\");      } else if (getVerticalAxis() != p.getVerticalAxis() && type != VERTICAL) {        throw new AxisNotCompatibleException(\"Can't combine with different vertical axis\");      } else if (!isCompatibleHorizontalAxis((Axis)p.getHorizontalAxis())) {        throw new AxisNotCompatibleException(\"Incompatible horizontal axis\");      } else if (!isCompatibleVerticalAxis((Axis)p.getVerticalAxis())) {        throw new AxisNotCompatibleException(\"Incompatible vertical axis\");      }            if (weight <= 0 && type != OVERLAID) {        throw new IllegalArgumentException(\"weight must be positive\");      } else if (weight != 1 && type == OVERLAID) {        throw new IllegalArgumentException(\"weight must 1\");      }            if (charts.size() > 0 && type == OVERLAID) {        p.setBackgroundPaint(null);        p.setOutlineStroke(null);        p.setOutlinePaint(null);      }            ChartInfo chartInfo = new ChartInfo(chart, weight);      charts.add(chartInfo);            weights += weight;}", "nl": "Adds a CombinedChart to the CombinedPlot"}
{"code": "public void adjustPlots() {            adjustPlotsAxis();            adjustPlotsMinMax();            adjustSeriesPaintAndStroke();}", "nl": "Adjusts the charts to combine changing their axis and rescaling them to take into account combined plots"}
{"code": "public void setRange(AxisRange range, java.util.List axes) {      Iterator iter = axes.iterator();      while (iter.hasNext()) {        CombinableAxis axis = (CombinableAxis)iter.next();        axis.setRange(range);}}", "nl": "Sets the AxisRange for all the axes in the List"}
{"code": "public Number getMaximumHorizontalDataValue() {      if (charts.size() == 0) {        return null;      }      Number max = new Double(Double.MIN_VALUE);      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        HorizontalValuePlot plot = (HorizontalValuePlot)chartInfo.plot;        Number x = plot.getMaximumHorizontalDataValue();        if (x.doubleValue() > max.doubleValue()) {          max = x;        }      }      return max;}", "nl": "Returns the maximum value in the domain of all the charts , since this is plotted against the horizontal axis for a combined plot"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {      return (axis instanceof VerticalNumberAxis);}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {      return ((axis instanceof HorizontalNumberAxis) ||          (axis instanceof HorizontalDateAxis));}", "nl": "Checks the compatibility of a horizontal axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "protected void adjustPlotsMinMax(boolean adjustHorizontal, boolean adjustVertical) {      java.util.List axes;      AxisRange range;      if (adjustHorizontal && !axisRangeSet[HORIZONTAL]) {        axes = getHorizontalAxes(true);        range = getRange(axes);        setRange(range, axes);        setAxisRangeSet(HORIZONTAL, true);      }      if (adjustVertical && !axisRangeSet[VERTICAL]) {        axes = getVerticalAxes(true);        range = getRange(axes);        setRange(range, axes);        setAxisRangeSet(VERTICAL, true);}}", "nl": "Adjusts our axes ranges"}
{"code": "public java.util.List getHorizontalAxes(boolean recursive) {      ArrayList axes = new ArrayList();      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        axes.add(chartInfo.plot.getHorizontalAxis());        if (recursive && chartInfo.plot instanceof CombinedPlot) {          CombinedPlot subPlot = (CombinedPlot)chartInfo.plot;          java.util.List moreAxes = subPlot.getHorizontalAxes(true);          axes.addAll(moreAxes);        }      }      return axes;}", "nl": "Returns a List of all our Horizontal Axes"}
{"code": "private void readjustPlotsMinMax(boolean doHorizontalAxis, boolean doVerticalAxis) {      if (inReadjustPlotsMinMax) return;      doHorizontalAxis &= axisRangeSet[HORIZONTAL];      doVerticalAxis &= axisRangeSet[VERTICAL];            if (doHorizontalAxis || doVerticalAxis) {        if (doHorizontalAxis) {          setAxisRangeSet(HORIZONTAL, false);        }        if (doVerticalAxis) {          setAxisRangeSet(VERTICAL, false);        }        adjustPlotsMinMax(doHorizontalAxis, doVerticalAxis);      }            inReadjustPlotsMinMax = true;        Iterator iter = charts.iterator();      while(iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        Plot plot = chartInfo.plot;        if (plot instanceof CombinedPlot) {          ((CombinedPlot)plot).readjustPlotsMinMax(!doHorizontalAxis, !doVerticalAxis);        }      }      inReadjustPlotsMinMax = false;}", "nl": "Readjust the plot axes min and max as needed"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, DrawInfo info) {      int n = charts.size();      int verticalGap = 0;      int horizontalGap = 0;            adjustPlots();                              drawArea = adjustForInsets(drawArea, insets);      if (insets != null && type != OVERLAID) {        verticalGap = Math.max(insets.top, insets.bottom);        horizontalGap = Math.max(insets.right, insets.left);      }            double hAxisAreaHeight = 0;      double vAxisAreaWidth = 0;      if (type != HORIZONTAL) {                hAxisAreaHeight = getHorizontalAxis().reserveHeight(g2, this, drawArea);      }      if (type != VERTICAL) {                vAxisAreaWidth = getVerticalAxis().reserveWidth(g2, this, drawArea);      }            Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX(),                              drawArea.getY(),                              drawArea.getWidth()-vAxisAreaWidth,                              drawArea.getHeight()-hAxisAreaHeight);            Rectangle2D[] subPlotArea = new Rectangle2D[n];      double x = plotArea.getX();      double y = plotArea.getY();      double usableWidth = plotArea.getWidth()-horizontalGap*(charts.size()-1);      double usableHeight = plotArea.getHeight()-verticalGap*(charts.size()-1);      double maxAxisWidth = Double.MIN_VALUE;      double maxAxisHeight = Double.MIN_VALUE;      for (int i=0; i<n; i++) {        ChartInfo chartInfo = (ChartInfo)charts.get(i);        Plot plot = chartInfo.plot;                double subPlotAreaHeight = usableHeight;        if (type == VERTICAL) {          subPlotAreaHeight *= (double)chartInfo.weight/weights;        }        if (i == n-1) {                    subPlotAreaHeight += hAxisAreaHeight;        }                double subPlotAreaWidth = usableWidth;        if (type == HORIZONTAL) {          subPlotAreaWidth *= (double)chartInfo.weight/weights;        }        if (i == 0) {                    subPlotAreaWidth += vAxisAreaWidth;        }                subPlotArea[i] = new Rectangle2D.Double(x, y, subPlotAreaWidth, subPlotAreaHeight);                if (type != OVERLAID) {          Rectangle2D tempArea = adjustForInsets(subPlotArea[i], plot.getInsets());          if (type == VERTICAL) {            maxAxisWidth = Math.max(maxAxisWidth,                         plot.getVerticalAxis().reserveWidth(g2, plot, tempArea));          } else if (type == HORIZONTAL) {            maxAxisHeight = Math.max(maxAxisHeight,                      plot.getHorizontalAxis().reserveHeight(g2, plot, tempArea));          }        }                if (type == VERTICAL) {          y += subPlotAreaHeight + verticalGap;        } else if (type == HORIZONTAL) {          x += subPlotAreaWidth + horizontalGap;        } if (type == OVERLAID && i == 0) {          x += vAxisAreaWidth;        }      }            if (type == VERTICAL) {        setVerticalAxisWidth(maxAxisWidth);      } else if (type == HORIZONTAL) {        setHorizontalAxisHeight(maxAxisHeight);      }            for (int i=0; i<n; i++) {        ChartInfo chartInfo = (ChartInfo)charts.get(i);        chartInfo.chart.draw(g2, subPlotArea[i], null);}}", "nl": "Draws the CombinedPlot on a Java 2D graphics device"}
{"code": "public java.util.List getVerticalAxes() {      return getVerticalAxes(false);}", "nl": "Returns a List of all our Vertical Axes"}
{"code": "public AxisRange getRange(java.util.List axes) {      AxisRange range = null;      Iterator iter = axes.iterator();      while (iter.hasNext()) {        CombinableAxis axis = (CombinableAxis)iter.next();        if (range == null) {          range = axis.getRange();        } else {          range.combine(axis.getRange());        }      }      return range;}", "nl": "Returns the AxisRange of the axes list"}
{"code": "protected boolean horizontalAxisVisible(boolean firstPlot, boolean lastPlot, Plot subPlot) {      if (type == HORIZONTAL) {        return true;      } else if (lastPlot) {        return true;      } else {        return false;}}", "nl": "Returns true if a horizontal axis is visible"}
{"code": "public Number getMinimumVerticalDataValue() {      if (charts.size() == 0) {        return null;      }      Number min = new Double(Double.MAX_VALUE);      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        VerticalValuePlot plot = (VerticalValuePlot)chartInfo.plot;        Number x = plot.getMinimumVerticalDataValue();        if (x.doubleValue() < min.doubleValue()) {          min = x;        }      }      return min;}", "nl": "Returns the minimum value displayed against the vertical axis"}
{"code": "public java.util.List getVerticalAxes(boolean recursive) {      ArrayList axes = new ArrayList();      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        axes.add(chartInfo.plot.getVerticalAxis());        if (recursive && chartInfo.plot instanceof CombinedPlot) {          CombinedPlot subPlot = (CombinedPlot)chartInfo.plot;          java.util.List moreAxes = subPlot.getVerticalAxes(true);          axes.addAll(moreAxes);        }      }      return axes;}", "nl": "Returns a List of all our Vertical Axes"}
{"code": "public java.util.List getHorizontalAxes() {      return getHorizontalAxes(false);}", "nl": "Returns a List of all our Horizontal Axes"}
{"code": "public String getSeriesName(int series) {      if (series==0) {        return \"IBM\";      }      else return \"Error\";}", "nl": "Returns the name of the series"}
{"code": "protected void adjustPlotsAxis(boolean hVisible, boolean vVisible) {      Iterator iter = charts.iterator();      boolean hAxisVisible, vAxisVisible;      boolean first = true;      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        Plot plot = chartInfo.plot;        if (plot instanceof CombinedPlot) {                    hAxisVisible = (hVisible && horizontalAxisVisible(first, !iter.hasNext(), plot));          vAxisVisible = (vVisible && verticalAxisVisible(first, !iter.hasNext(), plot));          ((CombinedPlot)plot).adjustPlotsAxis(hAxisVisible, vAxisVisible);        }                hAxisVisible = (hVisible && horizontalAxisVisible(first, !iter.hasNext(), plot));        Axis h = createCombinedAxis(plot, (Axis)plot.getHorizontalAxis(), hAxisVisible);                vAxisVisible = (vVisible && verticalAxisVisible(first, !iter.hasNext(), plot));        Axis v = createCombinedAxis(plot, (Axis)plot.getVerticalAxis(), vAxisVisible);                plot.setHorizontalAxis(h);        plot.setVerticalAxis(v);        first = false;      }      isAdjusted = true;}", "nl": "Adjusts the internal charts to allow automatic rendering of their conponents"}
{"code": "public String getPlotType() {      switch (type) {        case OVERLAID:   return \"Overlaid Plot\";        case HORIZONTAL: return \"Horizontal Combined Plot\";        case VERTICAL:   return \"Vertical Combined Plot\";        default:     return \"Unknown Combined Plot\";}}", "nl": "Returns the plot type as a string"}
{"code": "private void adjustSeriesPaintAndStroke() {      if (chart != null) {        SeriesDataset masterData = (SeriesDataset)chart.getDataset();        adjustSeriesPaintAndStroke(this, masterData);}}", "nl": "Adjusts the Stroke and Paint objects associated with each Plot ' s Series that use the CombinedDataset so that each series is always drawn using the same rendering objects , no matter on what plot it appears"}
{"code": "public void chartChanged(ChartChangeEvent event) {      readjustPlotsMinMax(axisRangeSet[HORIZONTAL], axisRangeSet[VERTICAL]);}", "nl": "Receives notification of a change to a chart"}
{"code": "public NumberAxisRange(Number min, Number max) {      super(min, max);}", "nl": "Creates an NumberAxisRange object"}
{"code": "public DateAxisRange(Date min, Date max) {      super(min, max);}", "nl": "Creates an DateAxisRange object"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,                       double reservedWidth) {      if (visible) {        return axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);      }      else {        return new Rectangle2D.Double();}}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public boolean isVisible() {      return visible;}", "nl": "Is this axis visible ? Is is drawn ?"}
{"code": "private void initialiseData() {      dates = new Date[47];      highs = new Double[47];      lows = new Double[47];      opens = new Double[47];      closes = new Double[47];      dates[0]  = createDate(2001, Calendar.JANUARY,4);      highs[0]  = new Double(47.0);      lows[0]   = new Double(33.0);      opens[0]  = new Double(35.0);      closes[0] = new Double(33.0);      dates[1]  = createDate(2001, Calendar.JANUARY,5);      highs[1]  = new Double(47.0);      lows[1]   = new Double(32.0);      opens[1]  = new Double(41.0);      closes[1] = new Double(37.0);      dates[2]  = createDate(2001, Calendar.JANUARY,6);      highs[2]  = new Double(49.0);      lows[2]   = new Double(43.0);      opens[2]  = new Double(46.0);      closes[2] = new Double(48.0);      dates[3]  = createDate(2001, Calendar.JANUARY,7);      highs[3]  = new Double(51.0);      lows[3]   = new Double(39.0);      opens[3]  = new Double(40.0);      closes[3] = new Double(47.0);      dates[4]  = createDate(2001, Calendar.JANUARY,8);      highs[4]  = new Double(60.0);      lows[4]   = new Double(40.0);      opens[4]  = new Double(46.0);      closes[4] = new Double(53.0);      dates[5]  = createDate(2001, Calendar.JANUARY,9);      highs[5]  = new Double(62.0);      lows[5]   = new Double(55.0);      opens[5]  = new Double(57.0);      closes[5] = new Double(61.0);      dates[6]  = createDate(2001, Calendar.JANUARY,10);      highs[6]  = new Double(65.0);      lows[6]   = new Double(56.0);      opens[6]  = new Double(62.0);      closes[6] = new Double(59.0);      dates[7]  = createDate(2001, Calendar.JANUARY,11);      highs[7]  = new Double(55.0);      lows[7]   = new Double(43.0);      opens[7]  = new Double(45.0);      closes[7] = new Double(47.0);      dates[8]  = createDate(2001, Calendar.JANUARY,12);      highs[8]  = new Double(54.0);      lows[8]   = new Double(33.0);      opens[8]  = new Double(40.0);      closes[8] = new Double(51.0);      dates[9]  = createDate(2001, Calendar.JANUARY,13);      highs[9]  = new Double(47.0);      lows[9]   = new Double(33.0);      opens[9]  = new Double(35.0);      closes[9] = new Double(33.0);      dates[10]  = createDate(2001, Calendar.JANUARY,14);      highs[10]  = new Double(54.0);      lows[10]   = new Double(38.0);      opens[10]  = new Double(43.0);      closes[10] = new Double(52.0);      dates[11]  = createDate(2001, Calendar.JANUARY,15);      highs[11]  = new Double(48.0);      lows[11]   = new Double(41.0);      opens[11]  = new Double(44.0);      closes[11] = new Double(41.0);      dates[12]  = createDate(2001, Calendar.JANUARY,17);      highs[12]  = new Double(60.0);      lows[12]   = new Double(30.0);      opens[12]  = new Double(34.0);      closes[12] = new Double(44.0);      dates[13]  = createDate(2001, Calendar.JANUARY,18);      highs[13]  = new Double(58.0);      lows[13]   = new Double(44.0);      opens[13]  = new Double(54.0);      closes[13] = new Double(56.0);      dates[14]  = createDate(2001, Calendar.JANUARY,19);      highs[14]  = new Double(54.0);      lows[14]   = new Double(32.0);      opens[14]  = new Double(42.0);      closes[14] = new Double(53.0);      dates[15]  = createDate(2001, Calendar.JANUARY,20);      highs[15]  = new Double(53.0);      lows[15]   = new Double(39.0);      opens[15]  = new Double(50.0);      closes[15] = new Double(49.0);      dates[16]  = createDate(2001, Calendar.JANUARY,21);      highs[16]  = new Double(47.0);      lows[16]   = new Double(33.0);      opens[16]  = new Double(41.0);      closes[16] = new Double(40.0);      dates[17]  = createDate(2001, Calendar.JANUARY,22);      highs[17]  = new Double(55.0);      lows[17]   = new Double(37.0);      opens[17]  = new Double(43.0);      closes[17] = new Double(45.0);      dates[18]  = createDate(2001, Calendar.JANUARY,23);      highs[18]  = new Double(54.0);      lows[18]   = new Double(42.0);      opens[18]  = new Double(50.0);      closes[18] = new Double(42.0);      dates[19]  = createDate(2001, Calendar.JANUARY,24);      highs[19]  = new Double(48.0);      lows[19]   = new Double(37.0);      opens[19]  = new Double(37.0);      closes[19] = new Double(47.0);      dates[20]  = createDate(2001, Calendar.JANUARY,25);      highs[20]  = new Double(58.0);      lows[20]   = new Double(33.0);      opens[20]  = new Double(39.0);      closes[20] = new Double(41.0);      dates[21]  = createDate(2001, Calendar.JANUARY,26);      highs[21]  = new Double(47.0);      lows[21]   = new Double(31.0);      opens[21]  = new Double(36.0);      closes[21] = new Double(41.0);      dates[22]  = createDate(2001, Calendar.JANUARY,27);      highs[22]  = new Double(58.0);      lows[22]   = new Double(44.0);      opens[22]  = new Double(49.0);      closes[22] = new Double(44.0);      dates[23]  = createDate(2001, Calendar.JANUARY,28);      highs[23]  = new Double(46.0);      lows[23]   = new Double(41.0);      opens[23]  = new Double(43.0);      closes[23] = new Double(44.0);      dates[24]  = createDate(2001, Calendar.JANUARY,29);      highs[24]  = new Double(56.0);      lows[24]   = new Double(39.0);      opens[24]  = new Double(39.0);      closes[24] = new Double(51.0);      dates[25]  = createDate(2001, Calendar.JANUARY,30);      highs[25]  = new Double(56.0);      lows[25]   = new Double(39.0);      opens[25]  = new Double(47.0);      closes[25] = new Double(49.0);      dates[26]  = createDate(2001, Calendar.JANUARY,31);      highs[26]  = new Double(53.0);      lows[26]   = new Double(39.0);      opens[26]  = new Double(52.0);      closes[26] = new Double(47.0);      dates[27]  = createDate(2001, Calendar.FEBRUARY,1);      highs[27]  = new Double(51.0);      lows[27]   = new Double(30.0);      opens[27]  = new Double(45.0);      closes[27] = new Double(47.0);      dates[28]  = createDate(2001, Calendar.FEBRUARY,2);      highs[28]  = new Double(47.0);      lows[28]   = new Double(30.0);      opens[28]  = new Double(34.0);      closes[28] = new Double(46.0);      dates[29]  = createDate(2001, Calendar.FEBRUARY,3);      highs[29]  = new Double(57.0);      lows[29]   = new Double(37.0);      opens[29]  = new Double(44.0);      closes[29] = new Double(56.0);      dates[30]  = createDate(2001, Calendar.FEBRUARY,4);      highs[30]  = new Double(49.0);      lows[30]   = new Double(40.0);      opens[30]  = new Double(47.0);      closes[30] = new Double(44.0);      dates[31]  = createDate(2001, Calendar.FEBRUARY,5);      highs[31]  = new Double(46.0);      lows[31]   = new Double(38.0);      opens[31]  = new Double(43.0);      closes[31] = new Double(40.0);      dates[32]  = createDate(2001, Calendar.FEBRUARY,6);      highs[32]  = new Double(55.0);      lows[32]   = new Double(38.0);      opens[32]  = new Double(39.0);      closes[32] = new Double(53.0);      dates[33]  = createDate(2001, Calendar.FEBRUARY,7);      highs[33]  = new Double(50.0);      lows[33]   = new Double(33.0);      opens[33]  = new Double(37.0);      closes[33] = new Double(37.0);      dates[34]  = createDate(2001, Calendar.FEBRUARY,8);      highs[34]  = new Double(59.0);      lows[34]   = new Double(34.0);      opens[34]  = new Double(57.0);      closes[34] = new Double(43.0);      dates[35]  = createDate(2001, Calendar.FEBRUARY,9);      highs[35]  = new Double(48.0);      lows[35]   = new Double(39.0);      opens[35]  = new Double(46.0);      closes[35] = new Double(47.0);      dates[36]  = createDate(2001, Calendar.FEBRUARY,10);      highs[36]  = new Double(55.0);      lows[36]   = new Double(30.0);      opens[36]  = new Double(37.0);      closes[36] = new Double(30.0);      dates[37]  = createDate(2001, Calendar.FEBRUARY,11);      highs[37]  = new Double(60.0);      lows[37]   = new Double(32.0);      opens[37]  = new Double(56.0);      closes[37] = new Double(36.0);      dates[38]  = createDate(2001, Calendar.FEBRUARY,12);      highs[38]  = new Double(56.0);      lows[38]   = new Double(42.0);      opens[38]  = new Double(53.0);      closes[38] = new Double(54.0);      dates[39]  = createDate(2001, Calendar.FEBRUARY,13);      highs[39]  = new Double(49.0);      lows[39]   = new Double(42.0);      opens[39]  = new Double(45.0);      closes[39] = new Double(42.0);      dates[40]  = createDate(2001, Calendar.FEBRUARY,14);      highs[40]  = new Double(55.0);      lows[40]   = new Double(42.0);      opens[40]  = new Double(47.0);      closes[40] = new Double(54.0);       dates[41]  = createDate(2001, Calendar.FEBRUARY,15);      highs[41]  = new Double(49.0);      lows[41]   = new Double(35.0);      opens[41]  = new Double(38.0);      closes[41] = new Double(35.0);      dates[42]  = createDate(2001, Calendar.FEBRUARY,16);      highs[42]  = new Double(47.0);      lows[42]   = new Double(38.0);      opens[42]  = new Double(43.0);      closes[42] = new Double(42.0);      dates[43]  = createDate(2001, Calendar.FEBRUARY,17);      highs[43]  = new Double(53.0);      lows[43]   = new Double(42.0);      opens[43]  = new Double(47.0);      closes[43] = new Double(48.0);      dates[44]  = createDate(2001, Calendar.FEBRUARY,18);      highs[44]  = new Double(47.0);      lows[44]   = new Double(44.0);      opens[44]  = new Double(46.0);      closes[44] = new Double(44.0);      dates[45]  = createDate(2001, Calendar.FEBRUARY,19);      highs[45]  = new Double(46.0);      lows[45]   = new Double(40.0);      opens[45]  = new Double(43.0);      closes[45] = new Double(44.0);      dates[46]  = createDate(2001, Calendar.FEBRUARY,20);      highs[46]  = new Double(48.0);      lows[46]   = new Double(41.0);      opens[46]  = new Double(46.0);      closes[46] = new Double(41.0);}", "nl": "Sets up the data for the sample data source"}
{"code": "public void setRange(AxisRange range) {      setAutoRange(false);      Number min = (Number)range.getMin();      Number max = (Number)range.getMax();      setMinimumAxisValue(min.doubleValue());      setMaximumAxisValue(max.doubleValue());      if (visible) {        HorizontalNumberAxis axis = (HorizontalNumberAxis)getParentAxis();        axis.setAutoRange(false);        axis.setMinimumAxisValue(min.doubleValue());        axis.setMaximumAxisValue(max.doubleValue());}}", "nl": "Sets our AxisRange"}
{"code": "public Number getLowValue(int series, int item) {      if (series==0) {        return lows[item];      }      else return null;}", "nl": "Returns the low - value for the specified series and item"}
{"code": "public Number getOpenValue(int series, int item) {      if (series==0) {        return opens[item];      }      else return null;}", "nl": "Returns the open - value for the specified series and item"}
{"code": "public Number getHighValue(int series, int item) {      if (series==0) {        return highs[item];      }      else return null;}", "nl": "Returns the high - value for the specified series and item"}
{"code": "public CombinedHorizontalNumberAxis(HorizontalNumberAxis axis, boolean visible) {      super(axis.getLabel(),          axis.getLabelFont(),          axis.getLabelPaint(),          axis.getLabelInsets(),          axis.isTickLabelsVisible(),          axis.getTickLabelFont(),          axis.getTickLabelPaint(),          axis.getTickLabelInsets(),          axis.getVerticalTickLabels(),          axis.isTickMarksVisible(),          axis.getTickMarkStroke(),          axis.isAutoRange(),          axis.autoRangeIncludesZero(),          axis.getAutoRangeMinimumSize(),          axis.getMinimumAxisValue(),          axis.getMaximumAxisValue(),          axis.isInverted(),          axis.isAutoTickUnitSelection(),          axis.getTickUnit(),          axis.isGridLinesVisible(),          axis.getGridStroke(),          axis.getGridPaint(),          axis.getCrosshairValue(),          axis.getCrosshairStroke(),          axis.getCrosshairPaint());      this.axis = axis;      this.visible = visible;}", "nl": "incoherencetype"}
{"code": "public Number getYValue(int series, int item) {      if (series==0) {        return closes[item];      }      else return null;}", "nl": "Returns the y - value for the specified series and item"}
{"code": "public Axis getParentAxis() {      return axis;}", "nl": "Returns our parent axis"}
{"code": "public int getItemCount(int series) {      return 47;}", "nl": "Returns the number of items in the specified series"}
{"code": "public Number getCloseValue(int series, int item) {      if (series==0) {        return closes[item];      }      else return null;}", "nl": "Returns the close - value for the specified series and item"}
{"code": "public Number getXValue(int series, int item) {      return new Long(dates[item].getTime());}", "nl": "Returns the x - value for the specified series and item"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,                       double reservedWidth) {      Rectangle2D empty = new Rectangle2D.Double();      Iterator iter = axes.iterator();      while (iter.hasNext()) {        VerticalAxis axis = (VerticalAxis)iter.next();        Rectangle2D area = axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);        if (!area.equals(empty)) {          return area;        }      }      return empty;}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {      Iterator iter = axes.iterator();      while (iter.hasNext()) {        VerticalAxis axis = (VerticalAxis)iter.next();        double width = axis.reserveWidth(g2, plot, drawArea);        if (width != 0) {          return width;        }      }      return 0;}", "nl": "Returns the width required to draw the axis in the specified draw area"}
{"code": "public OverlaidVerticalNumberAxis(CombinedPlot plot) {      super((VerticalNumberAxis)plot.getVerticalAxis(), false);      this.plot = plot;      this.axes = plot.getVerticalAxes();            boolean oneVisible = false;      Iterator iter = axes.iterator();      while (iter.hasNext()) {        Object axis = iter.next();        if ((axis instanceof CombinedVerticalNumberAxis)) {          CombinedVerticalNumberAxis combAxis = (CombinedVerticalNumberAxis)axis;          oneVisible |= combAxis.isVisible();          if (iter.hasNext() || oneVisible) {            combAxis.setGridLinesVisible(false);          }        } else {          throw new IllegalArgumentException(\"Can not combine \" + axis.getClass()                       + \" into \" + this.getClass() );}}}", "nl": "Constructor"}
{"code": "public AxisRange getRange() {      return plot.getRange(axes);}", "nl": "Returns the AxisRange of our Axis"}
{"code": "public OverlaidHorizontalDateAxis(CombinedPlot plot) {      super((HorizontalDateAxis)plot.getHorizontalAxis(), false);      this.plot = plot;      this.axes = plot.getHorizontalAxes();            boolean oneVisible = false;      Iterator iter = axes.iterator();      while (iter.hasNext()) {        Object axis = iter.next();        if ((axis instanceof CombinedHorizontalDateAxis)) {          CombinedHorizontalDateAxis combAxis = (CombinedHorizontalDateAxis)axis;          oneVisible |= combAxis.isVisible();          if (iter.hasNext() || oneVisible) {            combAxis.setGridLinesVisible(false);          }        } else {        throw new IllegalArgumentException(\"Can not combine \" + axis.getClass()                           + \" into \" + this.getClass() );}}}", "nl": "Constructor"}
{"code": "public HighLowDataset createHighLowDataset() {      Object[][][] data = new Object[][][] { {        { createDate(1999, Calendar.JANUARY,4), new Double(47) },        { createDate(1999, Calendar.JANUARY,4), new Double(33) },        { createDate(1999, Calendar.JANUARY,4), new Double(35) },        { createDate(1999, Calendar.JANUARY,4), new Double(33) },        { createDate(1999, Calendar.JANUARY,5), new Double(47) },        { createDate(1999, Calendar.JANUARY,5), new Double(32) },        { createDate(1999, Calendar.JANUARY,5), new Double(41) },        { createDate(1999, Calendar.JANUARY,5), new Double(37) },        { createDate(1999, Calendar.JANUARY,6), new Double(49) },        { createDate(1999, Calendar.JANUARY,6), new Double(43) },        { createDate(1999, Calendar.JANUARY,6), new Double(46) },        { createDate(1999, Calendar.JANUARY,6), new Double(48) },        { createDate(1999, Calendar.JANUARY,7), new Double(51) },        { createDate(1999, Calendar.JANUARY,7), new Double(39) },        { createDate(1999, Calendar.JANUARY,7), new Double(40) },        { createDate(1999, Calendar.JANUARY,7), new Double(47) },        { createDate(1999, Calendar.JANUARY,8), new Double(60) },        { createDate(1999, Calendar.JANUARY,8), new Double(40) },        { createDate(1999, Calendar.JANUARY,8), new Double(46) },        { createDate(1999, Calendar.JANUARY,8), new Double(53) },        { createDate(1999, Calendar.JANUARY,9), new Double(62) },        { createDate(1999, Calendar.JANUARY,9), new Double(55) },        { createDate(1999, Calendar.JANUARY,9), new Double(57) },        { createDate(1999, Calendar.JANUARY,9), new Double(61) },        { createDate(1999, Calendar.JANUARY,10), new Double(65) },        { createDate(1999, Calendar.JANUARY,10), new Double(56) },        { createDate(1999, Calendar.JANUARY,10), new Double(62) },        { createDate(1999, Calendar.JANUARY,10), new Double(59) },        { createDate(1999, Calendar.JANUARY,11), new Double(55) },        { createDate(1999, Calendar.JANUARY,11), new Double(43) },        { createDate(1999, Calendar.JANUARY,11), new Double(45) },        { createDate(1999, Calendar.JANUARY,11), new Double(47) },        { createDate(1999, Calendar.JANUARY,12), new Double(54) },        { createDate(1999, Calendar.JANUARY,12), new Double(33) },        { createDate(1999, Calendar.JANUARY,12), new Double(40) },        { createDate(1999, Calendar.JANUARY,12), new Double(51) },        { createDate(1999, Calendar.JANUARY,13), new Double(58) },        { createDate(1999, Calendar.JANUARY,13), new Double(42) },        { createDate(1999, Calendar.JANUARY,13), new Double(44) },        { createDate(1999, Calendar.JANUARY,13), new Double(57) },        { createDate(1999, Calendar.JANUARY,14), new Double(54) },        { createDate(1999, Calendar.JANUARY,14), new Double(38) },        { createDate(1999, Calendar.JANUARY,14), new Double(43) },        { createDate(1999, Calendar.JANUARY,14), new Double(52) },        { createDate(1999, Calendar.JANUARY,15), new Double(48) },        { createDate(1999, Calendar.JANUARY,15), new Double(41) },        { createDate(1999, Calendar.JANUARY,15), new Double(44) },        { createDate(1999, Calendar.JANUARY,15), new Double(41) },        { createDate(1999, Calendar.JANUARY,17), new Double(60) },        { createDate(1999, Calendar.JANUARY,17), new Double(30) },        { createDate(1999, Calendar.JANUARY,17), new Double(34) },        { createDate(1999, Calendar.JANUARY,17), new Double(44) },        { createDate(1999, Calendar.JANUARY,18), new Double(58) },        { createDate(1999, Calendar.JANUARY,18), new Double(44) },        { createDate(1999, Calendar.JANUARY,18), new Double(54) },        { createDate(1999, Calendar.JANUARY,18), new Double(56) },        { createDate(1999, Calendar.JANUARY,19), new Double(54) },        { createDate(1999, Calendar.JANUARY,19), new Double(32) },        { createDate(1999, Calendar.JANUARY,19), new Double(42) },        { createDate(1999, Calendar.JANUARY,19), new Double(53) },        { createDate(1999, Calendar.JANUARY,20), new Double(53) },        { createDate(1999, Calendar.JANUARY,20), new Double(39) },        { createDate(1999, Calendar.JANUARY,20), new Double(50) },        { createDate(1999, Calendar.JANUARY,20), new Double(49) },        { createDate(1999, Calendar.JANUARY,21), new Double(47) },        { createDate(1999, Calendar.JANUARY,21), new Double(38) },        { createDate(1999, Calendar.JANUARY,21), new Double(41) },        { createDate(1999, Calendar.JANUARY,21), new Double(40) },        { createDate(1999, Calendar.JANUARY,22), new Double(55) },        { createDate(1999, Calendar.JANUARY,22), new Double(37) },        { createDate(1999, Calendar.JANUARY,22), new Double(43) },        { createDate(1999, Calendar.JANUARY,22), new Double(45) },        { createDate(1999, Calendar.JANUARY,23), new Double(54) },        { createDate(1999, Calendar.JANUARY,23), new Double(42) },        { createDate(1999, Calendar.JANUARY,23), new Double(50) },        { createDate(1999, Calendar.JANUARY,23), new Double(42) },        { createDate(1999, Calendar.JANUARY,24), new Double(48) },        { createDate(1999, Calendar.JANUARY,24), new Double(37) },        { createDate(1999, Calendar.JANUARY,24), new Double(37) },        { createDate(1999, Calendar.JANUARY,24), new Double(47) },        { createDate(1999, Calendar.JANUARY,25), new Double(58) },        { createDate(1999, Calendar.JANUARY,25), new Double(33) },        { createDate(1999, Calendar.JANUARY,25), new Double(39) },        { createDate(1999, Calendar.JANUARY,25), new Double(41) },        { createDate(1999, Calendar.JANUARY,26), new Double(47) },        { createDate(1999, Calendar.JANUARY,26), new Double(31) },        { createDate(1999, Calendar.JANUARY,26), new Double(36) },        { createDate(1999, Calendar.JANUARY,26), new Double(41) },        { createDate(1999, Calendar.JANUARY,27), new Double(58) },        { createDate(1999, Calendar.JANUARY,27), new Double(44) },        { createDate(1999, Calendar.JANUARY,27), new Double(49) },        { createDate(1999, Calendar.JANUARY,27), new Double(44) },        { createDate(1999, Calendar.JANUARY,28), new Double(46) },        { createDate(1999, Calendar.JANUARY,28), new Double(41) },        { createDate(1999, Calendar.JANUARY,28), new Double(43) },        { createDate(1999, Calendar.JANUARY,28), new Double(44) },        { createDate(1999, Calendar.JANUARY,29), new Double(56) },        { createDate(1999, Calendar.JANUARY,29), new Double(39) },        { createDate(1999, Calendar.JANUARY,29), new Double(39) },        { createDate(1999, Calendar.JANUARY,29), new Double(51) },        { createDate(1999, Calendar.JANUARY,30), new Double(56) },        { createDate(1999, Calendar.JANUARY,30), new Double(39) },        { createDate(1999, Calendar.JANUARY,30), new Double(47) },        { createDate(1999, Calendar.JANUARY,30), new Double(49) },        { createDate(1999, Calendar.JANUARY,31), new Double(53) },        { createDate(1999, Calendar.JANUARY,31), new Double(39) },        { createDate(1999, Calendar.JANUARY,31), new Double(52) },        { createDate(1999, Calendar.JANUARY,31), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,1), new Double(51) },        { createDate(1999, Calendar.FEBRUARY,1), new Double(30) },        { createDate(1999, Calendar.FEBRUARY,1), new Double(45) },        { createDate(1999, Calendar.FEBRUARY,1), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,2), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,2), new Double(30) },        { createDate(1999, Calendar.FEBRUARY,2), new Double(34) },        { createDate(1999, Calendar.FEBRUARY,2), new Double(46) },        { createDate(1999, Calendar.FEBRUARY,3), new Double(57) },        { createDate(1999, Calendar.FEBRUARY,3), new Double(37) },        { createDate(1999, Calendar.FEBRUARY,3), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,3), new Double(56) },        { createDate(1999, Calendar.FEBRUARY,4), new Double(49) },        { createDate(1999, Calendar.FEBRUARY,4), new Double(40) },        { createDate(1999, Calendar.FEBRUARY,4), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,4), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,5), new Double(46) },        { createDate(1999, Calendar.FEBRUARY,5), new Double(38) },        { createDate(1999, Calendar.FEBRUARY,5), new Double(43) },        { createDate(1999, Calendar.FEBRUARY,5), new Double(40) },        { createDate(1999, Calendar.FEBRUARY,6), new Double(55) },        { createDate(1999, Calendar.FEBRUARY,6), new Double(38) },        { createDate(1999, Calendar.FEBRUARY,6), new Double(39) },        { createDate(1999, Calendar.FEBRUARY,6), new Double(53) },        { createDate(1999, Calendar.FEBRUARY,7), new Double(50) },        { createDate(1999, Calendar.FEBRUARY,7), new Double(33) },        { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },        { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },        { createDate(1999, Calendar.FEBRUARY,8), new Double(59) },        { createDate(1999, Calendar.FEBRUARY,8), new Double(34) },        { createDate(1999, Calendar.FEBRUARY,8), new Double(57) },        { createDate(1999, Calendar.FEBRUARY,8), new Double(43) },        { createDate(1999, Calendar.FEBRUARY,9), new Double(48) },        { createDate(1999, Calendar.FEBRUARY,9), new Double(39) },        { createDate(1999, Calendar.FEBRUARY,9), new Double(46) },        { createDate(1999, Calendar.FEBRUARY,9), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,10), new Double(55) },        { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },        { createDate(1999, Calendar.FEBRUARY,10), new Double(37) },        { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },        { createDate(1999, Calendar.FEBRUARY,11), new Double(60) },        { createDate(1999, Calendar.FEBRUARY,11), new Double(32) },        { createDate(1999, Calendar.FEBRUARY,11), new Double(56) },        { createDate(1999, Calendar.FEBRUARY,11), new Double(36) },        { createDate(1999, Calendar.FEBRUARY,12), new Double(56) },        { createDate(1999, Calendar.FEBRUARY,12), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,12), new Double(53) },        { createDate(1999, Calendar.FEBRUARY,12), new Double(54) },        { createDate(1999, Calendar.FEBRUARY,13), new Double(49) },        { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,13), new Double(45) },        { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,14), new Double(55) },        { createDate(1999, Calendar.FEBRUARY,14), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,14), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,14), new Double(54) },        { createDate(1999, Calendar.FEBRUARY,15), new Double(49) },        { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },        { createDate(1999, Calendar.FEBRUARY,15), new Double(38) },        { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },        { createDate(1999, Calendar.FEBRUARY,16), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,16), new Double(38) },        { createDate(1999, Calendar.FEBRUARY,16), new Double(43) },        { createDate(1999, Calendar.FEBRUARY,16), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,17), new Double(53) },        { createDate(1999, Calendar.FEBRUARY,17), new Double(42) },        { createDate(1999, Calendar.FEBRUARY,17), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,17), new Double(48) },        { createDate(1999, Calendar.FEBRUARY,18), new Double(47) },        { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,18), new Double(46) },        { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,19), new Double(46) },        { createDate(1999, Calendar.FEBRUARY,19), new Double(40) },        { createDate(1999, Calendar.FEBRUARY,19), new Double(43) },        { createDate(1999, Calendar.FEBRUARY,19), new Double(44) },        { createDate(1999, Calendar.FEBRUARY,20), new Double(48) },        { createDate(1999, Calendar.FEBRUARY,20), new Double(41) },        { createDate(1999, Calendar.FEBRUARY,20), new Double(46) },        { createDate(1999, Calendar.FEBRUARY,20), new Double(41) } }      };      return null;}", "nl": "Creates and returns a sample high - low dataset for the demo"}
{"code": "protected Color getColor(int color) {      switch (color % 11) {        case 0: return Color.white;        case 1: return Color.black;        case 2: return Color.blue;        case 3: return Color.green;        case 4: return Color.red;        case 5: return Color.yellow;        case 6: return Color.gray;        case 7 : return Color.orange;        case 8: return Color.cyan;        case 9: return Color.magenta;        case 10: return Color.pink;        default: return Color.white;}}", "nl": "Utility method to return a color"}
{"code": "public CategoryDataset createCategoryDataset() {      Number[][] data = new Integer[][] {        { new Integer(10), new Integer(4), new Integer(15), new Integer(14) },        { new Integer(5), new Integer(7), new Integer(14), new Integer(3) },        { new Integer(6), new Integer(17), new Integer(12), new Integer(7) },        { new Integer(7), new Integer(15), new Integer(11), new Integer(0) },        { new Integer(8), new Integer(6), new Integer(10), new Integer(9) },        { new Integer(9), new Integer(8), new Integer(8), new Integer(6) },        { new Integer(10), new Integer(9), new Integer(7), new Integer(7) },        { new Integer(11), new Integer(13), new Integer(9), new Integer(9) },        { new Integer(3), new Integer(7), new Integer(11), new Integer(10) }      };      return new DefaultCategoryDataset(data);}", "nl": "Creates and returns a category dataset for the demo charts"}
{"code": "private Date createDateTime(int year, int month, int day, int hour, int minute) {      GregorianCalendar calendar = new GregorianCalendar(year, month, day, hour, minute);      return calendar.getTime();}", "nl": "Returns a java . util . Date for the specified year , month , day , hour and minute"}
{"code": "public void doGet(HttpServletRequest request,             HttpServletResponse response) throws ServletException, IOException {      response.setContentType(\"image/jpeg\");      int type = 1;      try {        type = Integer.parseInt( request.getParameter( \"type\" ) );      }      catch (Exception e) {      }      int  initGradColor= 0;      int  finalGradColor= 0;      try {        initGradColor = Integer.parseInt( request.getParameter( \"initGradColor\" ) );        finalGradColor = Integer.parseInt( request.getParameter( \"finalGradColor\" ) );      }      catch (Exception e) {      }      JFreeChart chart = createChart( type, initGradColor, finalGradColor );      int width = 400;      int height = 300;      try {        width = Integer.parseInt( request.getParameter( \"width\" ) );        height = Integer.parseInt( request.getParameter( \"height\" ) );      }      catch (Exception e) {      }            OutputStream out = response.getOutputStream();           ChartUtilities.writeChartAsJPEG(out, chart, width, height);      out.close();}", "nl": "Basic servlet method , answers requests fromt the browser"}
{"code": "public XYDataset createTestXYDataset() {      Object[][][] data = new Object[][][] { {        { createDateTime(2000, Calendar.OCTOBER, 18, 9, 5), new Double(10921.0) },        { createDateTime(2000, Calendar.OCTOBER, 18, 10, 6), new Double(10886.7) },        { createDateTime(2000, Calendar.OCTOBER, 18, 11, 6), new Double(10846.6) },        { createDateTime(2000, Calendar.OCTOBER, 18, 12, 6), new Double(10843.7) },        { createDateTime(2000, Calendar.OCTOBER, 18, 13, 6), new Double(10841.2) },        { createDateTime(2000, Calendar.OCTOBER, 18, 14, 6), new Double(10830.7) },        { createDateTime(2000, Calendar.OCTOBER, 18, 15, 6), new Double(10795.8) },        { createDateTime(2000, Calendar.OCTOBER, 18, 16, 7), new Double(10733.8) }      } };      return new DefaultXYDataset(data);}", "nl": "Creates and returns a XYDataset for the demo charts"}
{"code": "public void init(ServletConfig config) throws ServletException {      super.init(config);            context = config.getServletContext();}", "nl": "Override init to set up data used by invocations of this servlet"}
{"code": "public Number getXValue(int series, int item) {      return xValues[series][item];}", "nl": "Returns the x - value for the specified series and item"}
{"code": "public String getSeriesName(int series) {      return \"Sample \"+series;}", "nl": "Returns the name of the series"}
{"code": "public int getSeriesCount() {      return SERIES_COUNT;}", "nl": "Returns the number of series in the data source"}
{"code": "public ToolTip(String text, Shape area) {            if (area==null) throw new IllegalArgumentException(\"ToolTip(...): null area.\");      this.text = text;      this.area = area;}", "nl": "Constructs a new tooltip"}
{"code": "public String getText() {      return this.text;}", "nl": "Returns the tooltip text"}
{"code": "public StandardToolTipsCollection() {      tooltips = new ArrayList();}", "nl": "Constructs a new tooltip collection"}
{"code": "public void addToolTip(String text, Shape area) {      ToolTip tooltip = new ToolTip(text, area);      tooltips.add(tooltip);}", "nl": "Adds a tooltip"}
{"code": "public void actionPerformed(ActionEvent event) {      String command = event.getActionCommand();      if (command.equals(\"BackgroundPaint\")) {        attemptModifyBackgroundPaint();}}", "nl": "Handles user interactions with the panel"}
{"code": "public Paint getBackgroundPaint() {      return background.getPaint();}", "nl": "Returns the current background paint"}
{"code": "public boolean getAntiAlias() {      return antialias.isSelected();}", "nl": "Returns the current setting of the anti - alias flag"}
{"code": "public LegendPropertyEditPanel getLegendPropertyEditPanel() {      return legendPropertiesPanel;}", "nl": "Returns a reference to the legend property sub - panel"}
{"code": "public ChartPropertyEditPanel(JFreeChart chart) {      setLayout(new BorderLayout());      JPanel other = new JPanel(new BorderLayout());      other.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));      JPanel general = new JPanel(new BorderLayout());      general.setBorder(BorderFactory.createTitledBorder(                  BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(6));      interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      antialias = new JCheckBox(\"Draw anti-aliased\");      antialias.setSelected(chart.getAntiAlias());      interior.add(antialias);      interior.add(new JLabel(\"\"));      interior.add(new JLabel(\"\"));      interior.add(new JLabel(\"Background paint:\"));      background = new PaintSample(chart.getChartBackgroundPaint());      interior.add(background);      JButton button = new JButton(\"Select...\");      button.setActionCommand(\"BackgroundPaint\");      button.addActionListener(this);      interior.add(button);      interior.add(new JLabel(\"Series Paint:\"));      JTextField info = new JTextField(\"No editor implemented\");      info.setEnabled(false);      interior.add(info);      button = new JButton(\"Edit...\");      button.setEnabled(false);      interior.add(button);      interior.add(new JLabel(\"Series Stroke:\"));      info = new JTextField(\"No editor implemented\");      info.setEnabled(false);      interior.add(info);      button = new JButton(\"Edit...\");      button.setEnabled(false);      interior.add(button);      interior.add(new JLabel(\"Series Outline Paint:\"));      info = new JTextField(\"No editor implemented\");      info.setEnabled(false);      interior.add(info);      button = new JButton(\"Edit...\");      button.setEnabled(false);      interior.add(button);      interior.add(new JLabel(\"Series Outline Stroke:\"));      info = new JTextField(\"No editor implemented\");      info.setEnabled(false);      interior.add(info);      button = new JButton(\"Edit...\");      button.setEnabled(false);      interior.add(button);      general.add(interior, BorderLayout.NORTH);      other.add(general, BorderLayout.NORTH);      JPanel parts = new JPanel(new BorderLayout());            Legend legend = chart.getLegend();      Plot plot = chart.getPlot();      JTabbedPane tabs = new JTabbedPane();                              if (legend!=null) {        legendPropertiesPanel = new LegendPropertyEditPanel(legend);        legendPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));        tabs.addTab(\"Legend\", legendPropertiesPanel);      }      plotPropertiesPanel = new PlotPropertyEditPanel(plot);      plotPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));      tabs.addTab(\"Plot\", plotPropertiesPanel);      tabs.add(\"Other\", other);      parts.add(tabs, BorderLayout.NORTH);      add(parts);}", "nl": "Standard constructor - the property panel is made up of a number of sub - panels that are displayed in the tabbed pane"}
{"code": "private void attemptModifyBackgroundPaint() {      Color c;      c = JColorChooser.showDialog(this, \"Background Color\", Color.blue);      if (c!=null) {        background.setPaint(c);}}", "nl": "Allows the user the opportunity to select a new background paint"}
{"code": "public Font getLabelFont() {      return labelFont;}", "nl": "Returns the current label font"}
{"code": "public Paint getTickLabelPaint() {      return tickLabelPaintSample.getPaint();}", "nl": "Returns the current tick label paint"}
{"code": "public Paint getLabelPaint() {      return labelPaintSample.getPaint();}", "nl": "Returns the current label paint"}
{"code": "private void attemptModifyLabelPaint() {      Color c;      c = JColorChooser.showDialog(this, \"Label Color\", Color.blue);      if (c!=null) {        labelPaintSample.setPaint(c);}}", "nl": "Allows the user the opportunity to change the outline paint"}
{"code": "public void attemptTickLabelFontSelection() {      FontChooserPanel panel = new FontChooserPanel(tickLabelFont);      int result = JOptionPane.showConfirmDialog(this, panel, \"Font Selection\",        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        tickLabelFont = panel.getSelectedFont();        tickLabelFontField.setText(tickLabelFont.getFontName()+\" \"+tickLabelFont.getSize());}}", "nl": "Presents a tick label font selection dialog to the user"}
{"code": "public static AxisPropertyEditPanel getInstance(Axis axis) {      if (axis!=null) {                if (axis instanceof NumberAxis) {          return new NumberAxisPropertyEditPanel((NumberAxis)axis);        }        else return new AxisPropertyEditPanel(axis);      }      else return null;}", "nl": "A static method that returns a panel that is appropriate for the axis type"}
{"code": "public String getLabel() {      return label.getText();}", "nl": "Returns the current axis label"}
{"code": "public JTabbedPane getOtherTabs() {      return otherTabs;}", "nl": "Returns a reference to the tabbed pane"}
{"code": "public Insets getTickLabelInsets() {      return (_tickLabelInsets == null) ? new Insets(0,0,0,0) : _tickLabelInsets;}", "nl": "Returns the current tick label insets value"}
{"code": "public void setAxisProperties(Axis axis) {      axis.setLabel(this.getLabel());      axis.setLabelFont(this.getLabelFont());      axis.setLabelPaint(this.getLabelPaint());      axis.setTickMarksVisible(this.isTickMarksVisible());            axis.setTickLabelsVisible(this.isTickLabelsVisible());      axis.setTickLabelFont(this.getTickLabelFont());      axis.setTickLabelPaint(this.getTickLabelPaint());      axis.setTickLabelInsets(this.getTickLabelInsets());      axis.setLabelInsets(this.getLabelInsets());}", "nl": "Sets the properties of the specified axis to match the properties defined on this panel"}
{"code": "public boolean isTickLabelsVisible() {      return showTickLabelsCheckBox.isSelected();}", "nl": "Returns a flag that indicates whether or not the tick labels are visible"}
{"code": "public void actionPerformed(ActionEvent event) {      String command = event.getActionCommand();      if (command.equals(\"SelectLabelFont\")) {        attemptLabelFontSelection();      }      else if (command.equals(\"SelectLabelPaint\")) {        attemptModifyLabelPaint();      }      else if (command.equals(\"SelectTickLabelFont\")) {        attemptTickLabelFontSelection();      }      else if (command.equals(\"LabelInsets\"))      {        editLabelInsets();      }      else if (command.equals(\"TickLabelInsets\"))      {        editTickLabelInsets();}}", "nl": "Handles user interaction with the property panel"}
{"code": "public Font getTickLabelFont() {      return tickLabelFont;}", "nl": "Returns the font used to draw the tick labels"}
{"code": "public PlotPropertyEditPanel(Plot plot) {      _insets = plot.getInsets();      backgroundPaintSample = new PaintSample(plot.getBackgroundPaint());      outlineStrokeSample = new StrokeSample(plot.getOutlineStroke());      outlinePaintSample = new PaintSample(plot.getOutlinePaint());      setLayout(new BorderLayout());      availableStrokeSamples = new StrokeSample[3];      availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));      availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));      availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));            JPanel panel = new JPanel(new BorderLayout());      panel.setBorder(BorderFactory.createTitledBorder(                BorderFactory.createEtchedBorder(), plot.getPlotType()+\":\"));      JPanel general = new JPanel(new BorderLayout());      general.setBorder(BorderFactory.createTitledBorder(                  BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(4));      interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      interior.add(new JLabel(\"Insets:\"));      JButton button = new JButton(\"Edit...\");      button.setActionCommand(\"Insets\");      button.addActionListener(this);      insetsTextField = new InsetsTextField(_insets);      insetsTextField.setEnabled(false);      interior.add(insetsTextField);      interior.add(button);      interior.add(new JLabel(\"Outline stroke:\"));      button = new JButton(\"Select...\");      button.setActionCommand(\"OutlineStroke\");      button.addActionListener(this);      interior.add(outlineStrokeSample);      interior.add(button);      interior.add(new JLabel(\"Outline paint:\"));      button = new JButton(\"Select...\");      button.setActionCommand(\"OutlinePaint\");      button.addActionListener(this);      interior.add(outlinePaintSample);      interior.add(button);      interior.add(new JLabel(\"Background paint:\"));      button = new JButton(\"Select...\");      button.setActionCommand(\"BackgroundPaint\");      button.addActionListener(this);      interior.add(backgroundPaintSample);      interior.add(button);      general.add(interior, BorderLayout.NORTH);      JPanel appearance = new JPanel(new BorderLayout());      appearance.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));      appearance.add(general, BorderLayout.NORTH);      JTabbedPane tabs = new JTabbedPane();      tabs.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      verticalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.VERTICAL_AXIS));      if (verticalAxisPropertyPanel!=null) {        verticalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));        tabs.add(\"Vertical Axis\", verticalAxisPropertyPanel);      }      horizontalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.HORIZONTAL_AXIS));      if (horizontalAxisPropertyPanel!=null) {        horizontalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));        tabs.add(\"Horizontal Axis\", horizontalAxisPropertyPanel);      }      tabs.add(\"Appearance\", appearance);      panel.add(tabs);      add(panel);}", "nl": "Standard constructor - constructs a panel for editing the properties of the specified plot"}
{"code": "public Paint getOutlinePaint() {      return outlinePaintSample.getPaint();}", "nl": "Returns the current outline paint"}
{"code": "public Paint getBackgroundPaint() {      return backgroundPaintSample.getPaint();}", "nl": "Returns the current background paint"}
{"code": "public AxisPropertyEditPanel getVerticalAxisPropertyEditPanel() {      return verticalAxisPropertyPanel;}", "nl": "Returns a reference to the panel for editing the properties of the vertical axis"}
{"code": "private void attemptOutlineStrokeSelection() {      StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);      int result = JOptionPane.showConfirmDialog(this, panel, \"Stroke Selection\",        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        outlineStrokeSample.setStroke(panel.getSelectedStroke());}}", "nl": "Allow the user to change the outline stroke"}
{"code": "private void attemptBackgroundPaintSelection() {      Color c;      c = JColorChooser.showDialog(this, \"Background Color\", Color.blue);      if (c!=null) {        backgroundPaintSample.setPaint(c);}}", "nl": "Allow the user to change the background paint"}
{"code": "public AxisPropertyEditPanel getHorizontalAxisPropertyEditPanel() {      return horizontalAxisPropertyPanel;}", "nl": "Returns a reference to the panel for editing the properties of the horizontal axis"}
{"code": "private void editInsets() {      InsetsChooserPanel panel = new InsetsChooserPanel(_insets);      int result =        JOptionPane.showConfirmDialog(this, panel, \"Edit Insets\",                        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        _insets = panel.getInsets();        insetsTextField.setInsets(_insets);}}", "nl": "Allow the user to edit the individual insets ' values"}
{"code": "public void updatePlotProperties(Plot plot) {            plot.setOutlinePaint(this.getOutlinePaint());      plot.setOutlineStroke(this.getOutlineStroke());      plot.setBackgroundPaint(this.getBackgroundPaint());      plot.setInsets(this.getPlotInsets());            if (this.horizontalAxisPropertyPanel!=null) {        this.horizontalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.HORIZONTAL_AXIS));      }      if (this.verticalAxisPropertyPanel!=null) {        this.verticalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.VERTICAL_AXIS));}}", "nl": "Updates the plot properties to match the properties defined on the panel"}
{"code": "public NumberAxisPropertyEditPanel(NumberAxis axis) {      super(axis);      autoRange = axis.isAutoRange();      minimumValue = axis.getMinimumAxisValue();      maximumValue = axis.getMaximumAxisValue();      gridPaintSample = new PaintSample(axis.getGridPaint());      gridStrokeSample = new StrokeSample(axis.getGridStroke());      availableStrokeSamples = new StrokeSample[3];      availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));      availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));      availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));      JTabbedPane other = getOtherTabs();      JPanel range = new JPanel(new LCBLayout(3));      range.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));      range.add(new JPanel());      autoRangeCheckBox = new JCheckBox(\"Auto-adjust range:\", autoRange);      autoRangeCheckBox.setActionCommand(\"AutoRangeOnOff\");      autoRangeCheckBox.addActionListener(this);      range.add(autoRangeCheckBox);      range.add(new JPanel());      range.add(new JLabel(\"Minimum range value:\"));      minimumRangeValue = new JTextField(Double.toString(minimumValue));      minimumRangeValue.setEnabled(!autoRange);      minimumRangeValue.setActionCommand(\"MinimumRange\");      minimumRangeValue.addActionListener(this);      minimumRangeValue.addFocusListener(this);      range.add(minimumRangeValue);      range.add(new JPanel());      range.add(new JLabel(\"Maximum range value:\"));      maximumRangeValue = new JTextField(Double.toString(maximumValue));      maximumRangeValue.setEnabled(!autoRange);      maximumRangeValue.setActionCommand(\"MaximumRange\");      maximumRangeValue.addActionListener(this);      maximumRangeValue.addFocusListener(this);      range.add(maximumRangeValue);      range.add(new JPanel());      other.add(\"Range\", range);      JPanel grid = new JPanel(new LCBLayout(3));      grid.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));      grid.add(new JPanel());      showGridLinesCheckBox = new JCheckBox(\"Show grid lines\", axis.isGridLinesVisible());      grid.add(showGridLinesCheckBox);      grid.add(new JPanel());      grid.add(new JLabel(\"Grid stroke:\"));      JButton button = new JButton(\"Set stroke...\");      button.setActionCommand(\"GridStroke\");      button.addActionListener(this);      grid.add(gridStrokeSample);      grid.add(button);      grid.add(new JLabel(\"Grid paint:\"));      button = new JButton(\"Set paint...\");      button.setActionCommand(\"GridPaint\");      button.addActionListener(this);      grid.add(gridPaintSample);      grid.add(button);      other.add(\"Grid\", grid);}", "nl": "Standard constructor : builds a property panel for the specified axis"}
{"code": "public double getMinimumValue() {      return minimumValue;}", "nl": "Returns the current setting of the minimum value in the axis range"}
{"code": "private void attemptGridPaintSelection() {      Color c;      c = JColorChooser.showDialog(this, \"Grid Color\", Color.blue);      if (c!=null) {        gridPaintSample.setPaint(c);}}", "nl": "Handle a grid paint selection"}
{"code": "public boolean isAutoRange() {      return autoRange;}", "nl": "Returns the current setting of the auto - range property"}
{"code": "public void actionPerformed(ActionEvent event) {      String command = event.getActionCommand();      if (command.equals(\"OutlineStroke\")) {        attemptModifyOutlineStroke();      }      else if (command.equals(\"OutlinePaint\")) {        attemptModifyOutlinePaint();      }      else if (command.equals(\"BackgroundPaint\")) {        attemptModifyBackgroundPaint();      }      else if (command.equals(\"SeriesFont\")) {        attemptModifySeriesFont();      }      else if (command.equals(\"SeriesPaint\")) {        attemptModifySeriesPaint();}}", "nl": "Handles user interactions with the panel"}
{"code": "private void attemptModifySeriesPaint() {      Color c;      c = JColorChooser.showDialog(this, \"Series Label Color\", Color.blue);      if (c!=null) {        seriesPaint.setPaint(c);}}", "nl": "Allows the user the opportunity to change the series label paint"}
{"code": "public void attemptModifySeriesFont() {      FontChooserPanel panel = new FontChooserPanel(seriesFont);      int result = JOptionPane.showConfirmDialog(this, panel, \"Font Selection\",        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        seriesFont = panel.getSelectedFont();}}", "nl": "Allows the user the opportunity to change the series label font"}
{"code": "public LegendPropertyEditPanel(Legend legend) {      StandardLegend l = (StandardLegend)legend;      outlineStroke = new StrokeSample(l.getOutlineStroke());      outlinePaint = new PaintSample(l.getOutlinePaint());      backgroundPaint = new PaintSample(l.getBackgroundPaint());      seriesFont = l.getSeriesFont();      seriesPaint = new PaintSample(l.getSeriesPaint());      availableStrokeSamples = new StrokeSample[4];      availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));      availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));      availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));      availableStrokeSamples[3] = new StrokeSample(new BasicStroke(4.0f));      setLayout(new BorderLayout());      JPanel general = new JPanel(new BorderLayout());      general.setBorder(BorderFactory.createTitledBorder(                  BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(5));      interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      JLabel titleLabel = new JLabel(\"Text:\");      interior.add(new JLabel(\"Outline:\"));      interior.add(outlineStroke);      JButton button = new JButton(\"Select...\");      button.setActionCommand(\"OutlineStroke\");      button.addActionListener(this);      interior.add(button);      interior.add(new JLabel(\"Outline Paint:\"));      button = new JButton(\"Select...\");      button.setActionCommand(\"OutlinePaint\");      button.addActionListener(this);      interior.add(outlinePaint);      interior.add(button);      interior.add(new JLabel(\"Background:\"));      button = new JButton(\"Select...\");      button.setActionCommand(\"BackgroundPaint\");      button.addActionListener(this);      interior.add(backgroundPaint);      interior.add(button);      interior.add(new JLabel(\"Series label font:\"));      button = new JButton(\"Select...\");      button.setActionCommand(\"SeriesFont\");      button.addActionListener(this);      interior.add(new FontDisplayField(seriesFont));      interior.add(button);      interior.add(new JLabel(\"Series label paint:\")) ;      button = new JButton(\"Select...\");      button.setActionCommand(\"SeriesPaint\");      button.addActionListener(this);      interior.add(seriesPaint) ;      interior.add(button) ;      general.add(interior);      add(general, BorderLayout.NORTH);}", "nl": "Standard constructor : builds a panel based on the specified legend"}
{"code": "private void attemptModifyOutlinePaint() {      Color c;      c = JColorChooser.showDialog(this, \"Outline Color\", Color.blue);      if (c!=null) {        outlinePaint.setPaint(c);}}", "nl": "Allows the user the opportunity to change the outline paint"}
{"code": "public Paint getBackgroundPaint() {      return backgroundPaint.getPaint();}", "nl": "Returns the current background paint"}
{"code": "public Stroke getOutlineStroke() {      return outlineStroke.getStroke();}", "nl": "Returns the current outline stroke"}
{"code": "public Font getSeriesFont() {      return seriesFont;}", "nl": "Returns the current series label font"}
{"code": "public void setLegendProperties(Legend legend) {      if (legend instanceof StandardLegend) {          StandardLegend standard = (StandardLegend)legend;        standard.setOutlineStroke(this.getOutlineStroke());        standard.setOutlinePaint(this.getOutlinePaint());        standard.setBackgroundPaint(this.getBackgroundPaint());        standard.setSeriesFont(this.getSeriesFont());        standard.setSeriesPaint(this.getSeriesPaint());}}", "nl": "Sets the properties of the specified legend to match the properties defined on this panel"}
{"code": "private void attemptModifyOutlineStroke() {      StrokeChooserPanel panel = new StrokeChooserPanel(outlineStroke, availableStrokeSamples);      int result = JOptionPane.showConfirmDialog(this, panel, \"Pen/Stroke Selection\",        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        outlineStroke.setStroke(panel.getSelectedStroke());}}", "nl": "Allows the user the opportunity to change the outline stroke"}
{"code": "public TitlePropertyEditPanel(StandardTitle title) {            titleFont = title.getTitleFont();      titlePaint = new PaintSample(title.getTitlePaint());      setLayout(new BorderLayout());      JPanel general = new JPanel(new BorderLayout());      general.setBorder(BorderFactory.createTitledBorder(                BorderFactory.createEtchedBorder(), \"General:\"));      JPanel interior = new JPanel(new LCBLayout(3));      interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));      JLabel titleLabel = new JLabel(\"Text:\");      titleField = new JTextField(title.getTitle());      interior.add(titleLabel);      interior.add(titleField);      interior.add(new JPanel());      interior.add(new JLabel(\"Font:\"));      fontfield = new FontDisplayField(titleFont);      JButton b = new JButton(\"Select...\");      b.setActionCommand(\"SelectFont\");      b.addActionListener(this);      interior.add(fontfield);      interior.add(b);      interior.add(new JLabel(\"Color:\"));      titlePaint = new PaintSample(title.getTitlePaint());      b = new JButton(\"Select...\");      b.setActionCommand(\"SelectPaint\");      b.addActionListener(this);      interior.add(titlePaint);      interior.add(b);      general.add(interior);      add(general, BorderLayout.NORTH);}", "nl": "Standard constructor : builds a panel for displaying editing the properties of the specified title"}
{"code": "public String getTitle() {      return titleField.getText();}", "nl": "Returns the title entered in the panel"}
{"code": "public Font getTitleFont() {      return titleFont;}", "nl": "Returns the font selected in the panel"}
{"code": "public Paint getTitlePaint() {      return titlePaint.getPaint();}", "nl": "Returns the paint selected in the panel"}
{"code": "public void actionPerformed(ActionEvent event) {      String command = event.getActionCommand();      if (command.equals(\"SelectFont\")) {        attemptFontSelection();      }      else if (command.equals(\"SelectPaint\")) {        attemptPaintSelection();}}", "nl": "Handles button clicks by passing control to an appropriate handler method"}

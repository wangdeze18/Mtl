{"code": "public static void makeCoffee() {     Recipe [] recipes = coffeeMaker.getRecipes();     for(int i = 0; i < recipes.length; i++) {       if (recipes[i] != null) {         System.out.println((i+1) + \". \" + recipes[i].getName());       }     }          int recipeToPurchase = recipeListSelection(\"Please select the number of the recipe to purchase.\");          String amountPaid = inputOutput(\"Please enter the amount you wish to pay\");     int amtPaid = 0;     try {       amtPaid = Integer.parseInt(amountPaid);     } catch (NumberFormatException e) {       System.out.println(\"Please enter a positive integer\");       mainMenu();     }          int change = coffeeMaker.makeCoffee(recipeToPurchase, amtPaid);          if (change == amtPaid) {       System.out.println(\"Insufficient funds to purchase.\");     } else {       System.out.println(\"Thank you for purchasing \" + coffeeMaker.getRecipes()[recipeToPurchase].getName());     }     System.out.println(\"Your change is: \" + change + \"\\n\");     mainMenu();}", "nl": "Make coffee user interface the processes input"}
{"code": "public static void deleteRecipe() {     Recipe [] recipes = coffeeMaker.getRecipes();     for(int i = 0; i < recipes.length; i++) {       if (recipes[i] != null) {         System.out.println((i+1) + \". \" + recipes[i].getName());       }     }     int recipeToDelete = recipeListSelection(\"Please select the number of the recipe to delete.\");          if(recipeToDelete < 0) {       mainMenu();     }          String recipeDeleted = coffeeMaker.deleteRecipe(recipeToDelete);          if (recipeDeleted != null) {       System.out.println(recipeDeleted + \" successfully deleted.\\n\");     } else {       System.out.println(\"Selected recipe doesn't exist and could not be deleted.\\n\");     }     mainMenu();}", "nl": "Delete recipe user interface that processes input"}
{"code": "public synchronized String deleteRecipe(int recipeToDelete) {     if (recipeArray[recipeToDelete] != null) {       String recipeName = recipeArray[recipeToDelete].getName();       recipeArray[recipeToDelete] = null;       return recipeName;     } else {       return null;}}", "nl": "Returns the name of the recipe deleted at the position specified and null if the recipe does not exist"}
{"code": "public RecipeBook() {     recipeArray = new Recipe[NUM_RECIPES];}", "nl": "Default constructor for a RecipeBook"}
{"code": "public int getPrice() {     return price;}", "nl": "@ return Returns the price"}
{"code": "public void setPrice(String price) throws RecipeException{     int amtPrice = 0;     try {       amtPrice = Integer.parseInt(price);     } catch (NumberFormatException e) {       throw new RecipeException(\"Price must be a positive integer\");     }     if (amtPrice >= 0) {       this.price = amtPrice;     } else {       throw new RecipeException(\"Price must be a positive integer\");}}", "nl": "set"}
{"code": "public Recipe() {     this.name = \"\";     this.price = 0;     this.amtCoffee = 0;     this.amtMilk = 0;     this.amtSugar = 0;     this.amtChocolate = 0;}", "nl": "Creates a default recipe for the coffee maker"}
{"code": "public void setAmtSugar(String sugar) throws RecipeException {     int amtSugar = 0;     try {       amtSugar = Integer.parseInt(sugar);     } catch (NumberFormatException e) {       throw new RecipeException(\"Units of sugar must be a positive integer\");     }     if (amtSugar >= 0) {       this.amtSugar = amtSugar;     } else {       throw new RecipeException(\"Units of sugar must be a positive integer\");}}", "nl": "incoherencetype"}
{"code": "public synchronized void setChocolate(int chocolate) {     if(chocolate >= 0) {       Inventory.chocolate = chocolate;}}", "nl": "Sets the number of chocolate units in the inventory to the specified amount"}
{"code": "public int getCoffee() {     return coffee;}", "nl": "Returns the current number of coffee units in the inventory"}
{"code": "protected void finalize()     throws Throwable    {     this.reader = null;     this.resolver = null;     this.buffer = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "protected void finalize()     throws Throwable    {     this.reader = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "protected void processIgnoreSection(IXMLReader     reader,                      IXMLEntityResolver entityResolver)     throws Exception    {     if (! XMLUtil.checkLiteral(reader, \"NORE\")) {      XMLUtil.skipTag(reader);      return;     }     XMLUtil.skipWhitespace(reader, null);     String str = XMLUtil.read(reader, '%');     char ch = str.charAt(0);     if (ch != '[') {      XMLUtil.skipTag(reader);      return;     }     Reader subreader = new CDATAReader(reader);     subreader.close();}", "nl": "Processes an ignore section"}
{"code": "protected void processConditionalSection(IXMLReader     reader,                       IXMLEntityResolver entityResolver)     throws Exception    {     XMLUtil.skipWhitespace(reader, null);     String str = XMLUtil.read(reader, '%');     char ch = str.charAt(0);     if (ch != 'I') {      XMLUtil.skipTag(reader);      return;     }     str = XMLUtil.read(reader, '%');     ch = str.charAt(0);     switch (ch) {      case 'G':       this.processIgnoreSection(reader, entityResolver);       return;      case 'N':       break;      default:       XMLUtil.skipTag(reader);       return;     }     if (! XMLUtil.checkLiteral(reader, \"CLUDE\")) {      XMLUtil.skipTag(reader);      return;     }     XMLUtil.skipWhitespace(reader, null);     str = XMLUtil.read(reader, '%');     ch = str.charAt(0);     if (ch != '[') {      XMLUtil.skipTag(reader);      return;     }     Reader subreader = new CDATAReader(reader);     StringBuffer buf = new StringBuffer(1024);     for (;;) {      int ch2 = subreader.read();      if (ch2 < 0) {       break;      }      buf.append((char) ch2);     }     subreader.close();     reader.startNewStream(new StringReader(buf.toString()));}", "nl": "Processes a conditional section"}
{"code": "public XMLValidationException(int  errorType,                  String systemID,                  int  lineNr,                  String elementName,                  String attributeName,                  String attributeValue,                  String msg)    {     super(systemID, lineNr, null,       msg + ((elementName == null) ? \"\" : (\", element=\" + elementName))       + ((attributeName == null) ? \"\"                      : (\", attribute=\" + attributeName))       + ((attributeValue == null) ? \"\"                      : (\", value='\" + attributeValue + \"'\")),       false);     this.elementName = elementName;     this.attributeName = attributeName;     this.attributeValue = attributeValue;}", "nl": "Creates a new exception"}
{"code": "protected void finalize()     throws Throwable    {     this.elementName = null;     this.attributeName = null;     this.attributeValue = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "static boolean checkLiteral(IXMLReader     reader,                  String       literal)     throws IOException,        XMLParseException    {     for (int i = 0; i < literal.length(); i++) {      if (reader.read() != literal.charAt(i)) {       return false;      }     }     return true;}", "nl": "Returns true if the data starts with literal"}
{"code": "@Override   public boolean isEnabled() {     return app != null && app.isEnabled() && enabled;}", "nl": "Returns true if the action is enabled"}
{"code": "static void errorInvalidEntity(String systemID,                   int  lineNr,                   String   entity)     throws XMLParseException    {     throw new XMLParseException(systemID, lineNr,                   \"Invalid entity: `&\" + entity + \";'\");}", "nl": "Throws an XMLParseException to indicate that an entity could not be resolved"}
{"code": "static void errorUnexpectedElement(String systemID,                     int  lineNr,                     String parentElementName,                     String unexpectedElementName)     throws XMLValidationException    {     throw new XMLValidationException(                 XMLValidationException.UNEXPECTED_ELEMENT,                 systemID, lineNr,                 unexpectedElementName,                  null,                  null,                 \"Unexpected \" + unexpectedElementName + \" in a \"                 + parentElementName);}", "nl": "Throws an XMLValidationException to indicate that an element is unexpected"}
{"code": "static void skipWhitespace(IXMLReader   reader,                 StringBuffer buffer)     throws IOException    {     char ch;     if (buffer == null) {      do {       ch = reader.read();      } while ((ch == ' ') || (ch == '\\t') || (ch == '\\n'));     } else {      for (;;) {       ch = reader.read();       if ((ch != ' ') && (ch != '\\t') && (ch != '\\n')) {          break;       }       if (ch == '\\n') {          buffer.append('\\n');       } else {          buffer.append(' ');       }      }     }     reader.unread(ch);}", "nl": "Skips whitespace from the reader"}
{"code": "static void skipTag(IXMLReader reader)     throws IOException,        XMLParseException    {     int level = 1;     while (level > 0) {      char ch = reader.read();      switch (ch) {       case '<':          ++level;          break;       case '>':          --level;          break;}}}", "nl": "Skips the remainder of the current XML tag"}
{"code": "protected void updateViewTitle(View v, JFrame f) {     String title;     URI uri = v.getURI();     if (uri == null) {       title = labels.getString(\"unnamedFile\");     } else {       title = URIUtil.getName(uri);     }     v.setTitle(labels.getFormatted(\"frame.title\", title, getName(), v.getMultipleOpenId()));     f.setTitle(v.getTitle());               if (uri != null && uri.getScheme() != null && uri.getScheme().equals(\"file\")) {       f.getRootPane().putClientProperty(\"Window.documentFile\", new File(uri));     } else {       f.getRootPane().putClientProperty(\"Window.documentFile\", null);}}", "nl": "Updates the title of a view and displays it in the given frame"}
{"code": "public boolean hasUnsavedChanges() {     return hasUnsavedChanges;}", "nl": "Returns true , if the view has unsaved changes"}
{"code": "protected void finalize()     throws Throwable    {     this.entities.clear();     this.entities = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "public XMLWriter(OutputStream stream)    {     this.writer = new PrintWriter(stream);}", "nl": "Creates a new XML writer"}
{"code": "protected void addAction(JMenu m, View view, String actionID) {     addAction(m, getAction(view, actionID));}", "nl": "Adds the specified action as a menu item to the supplied menu"}
{"code": "public void setActiveView(View newValue) {     View oldValue = activeView;     if (activeView != null) {       activeView.deactivate();     }     activeView = newValue;     if (activeView != null) {       activeView.activate();     }     firePropertyChange(ACTIVE_VIEW_PROPERTY, oldValue, newValue);}", "nl": "Sets the active view"}
{"code": "public String getFullName() {     return this.fullName;}", "nl": "Returns the full name"}
{"code": "public IXMLElement getParent() {     return this.parent;}", "nl": "Returns the parent element"}
{"code": "public IXMLElement createElement(String fullName,       String systemID,       int  lineNr) {     return new XMLElement(fullName, systemID, lineNr);}", "nl": "Creates an empty element"}
{"code": "protected void updateOpenRecentMenu() {       if (openRecentMenu.getItemCount() > 0) {         JMenuItem clearRecentFilesItem = (JMenuItem) openRecentMenu.getItem(             openRecentMenu.getItemCount() - 1);         openRecentMenu.remove(openRecentMenu.getItemCount() - 1);                  for (Action action : openRecentActions) {           if (action instanceof Disposable) {             ((Disposable) action).dispose();           }         }         openRecentActions.clear();         openRecentMenu.removeAll();                  if (getAction(view, LoadFileAction.ID) != null ||              getAction(view, LoadDirectoryAction.ID) != null) {           for (URI f : getRecentURIs()) {             LoadRecentFileAction action = new LoadRecentFileAction(AbstractApplication.this, view, f);             openRecentMenu.add(action);             openRecentActions.add(action);           }         } else {           for (URI f : getRecentURIs()) {             OpenRecentFileAction action = new OpenRecentFileAction(AbstractApplication.this, f);             openRecentMenu.add(action);             openRecentActions.add(action);           }         }         if (getRecentURIs().size() > 0) {           openRecentMenu.addSeparator();         }                  openRecentMenu.add(clearRecentFilesItem);}}", "nl": "Updates the File & gt ; Open Recent menu"}
{"code": "public IXMLElement createElement(String fullName,       String namespace,       String systemID,       int  lineNr) {     return new XMLElement(fullName, namespace, systemID, lineNr);}", "nl": "Creates an empty element"}
{"code": "public String getAttribute(String name,       String namespace,       String defaultValue) {     XMLAttribute attr = this.findAttribute(name, namespace);     if (attr == null) {       return defaultValue;     } else {       return attr.getValue();}}", "nl": "Returns the value of an attribute"}
{"code": "public void removeAttribute(String name) {     for (int i = 0; i < this.attributes.size(); i++) {       XMLAttribute attr = (XMLAttribute) this.attributes.get(i);       if (attr.getFullName().equals(name)) {         this.attributes.remove(i);         return;}}}", "nl": "Removes an attribute"}
{"code": "public IXMLElement createElement(String fullName,       String namespace) {     return new XMLElement(fullName, namespace);}", "nl": "Creates an empty element"}
{"code": "public String getAttribute(String name) {     return this.getAttribute(name, null);}", "nl": "2"}
{"code": "public void removeAttribute(String name,       String namespace) {     for (int i = 0; i < this.attributes.size(); i++) {       XMLAttribute attr = (XMLAttribute) this.attributes.get(i);       boolean found = attr.getName().equals(name);       if (namespace == null) {         found &= (attr.getNamespace() == null);       } else {         found &= attr.getNamespace().equals(namespace);       }              if (found) {         this.attributes.remove(i);         return;}}}", "nl": "Removes an attribute"}
{"code": "protected JMenuBar createMenuBar(View v) {     JMenuBar mb = new JMenuBar();          JMenu fileMenu = null;     JMenu editMenu = null;     JMenu helpMenu = null;     JMenu viewMenu = null;     JMenu windowMenu = null;     String fileMenuText = labels.getString(\"file.text\");     String editMenuText = labels.getString(\"edit.text\");     String viewMenuText = labels.getString(\"view.text\");     String windowMenuText = labels.getString(\"window.text\");     String helpMenuText = labels.getString(\"help.text\");     for (JMenu mm : getModel().createMenus(this, v)) {       String text = mm.getText();       if (text == null) {       } else if (text.equals(fileMenuText)) {         fileMenu = mm;         continue;       } else if (text.equals(editMenuText)) {         editMenu = mm;         continue;       } else if (text.equals(viewMenuText)) {         viewMenu = mm;         continue;       } else if (text.equals(windowMenuText)) {         windowMenu = mm;         continue;       } else if (text.equals(helpMenuText)) {         helpMenu = mm;         continue;       }       mb.add(mm);     }          if (fileMenu == null) {       fileMenu = createFileMenu(v);     }     if (editMenu == null) {       editMenu = createEditMenu(v);     }     if (viewMenu == null) {       viewMenu = createViewMenu(v);     }     if (windowMenu == null) {       windowMenu = createWindowMenu(v);     }     if (helpMenu == null) {       helpMenu = createHelpMenu(v);     }          if (fileMenu != null) {       mb.add(fileMenu, 0);     }     if (editMenu != null) {       mb.add(editMenu, Math.min(1, mb.getComponentCount()));     }     if (viewMenu != null) {       mb.add(viewMenu, Math.min(2, mb.getComponentCount()));     }     if (windowMenu != null) {       mb.add(windowMenu);     }     if (helpMenu != null) {       mb.add(helpMenu);     }     return mb;}", "nl": "Creates a menu bar"}
{"code": "public Iterator iterateAttributeNames() {     ArrayList result = new ArrayList();     Iterator enm = this.attributes.iterator();     while (enm.hasNext()) {       XMLAttribute attr = (XMLAttribute) enm.next();       result.add(attr.getFullName());     }     return result.iterator();}", "nl": "Returns an enumeration of all attribute names"}
{"code": "public void startNewStream(Reader reader)    {     this.startNewStream(reader, false);}", "nl": "Starts a new stream from a Java reader"}
{"code": "public void unread(char ch)     throws IOException    {     this.currentReader.pbReader.unread(ch);}", "nl": "Pushes the last character read back to the stream"}
{"code": "public IXMLValidator getDelegate()    {     return this.delegate;}", "nl": "Returns the delegate"}
{"code": "public void setParameterEntityResolver(IXMLEntityResolver resolver)    {     this.delegate.setParameterEntityResolver(resolver);}", "nl": "Sets the parameter entity resolver"}
{"code": "protected void finalize()     throws Throwable    {     this.prototype = null;     this.root = null;     this.stack.clear();     this.stack = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "public void addAttribute(String key,               String nsPrefix,               String nsURI,               String value,               String type)     throws Exception    {     String fullName = key;     if (nsPrefix != null) {      fullName = nsPrefix + ':' + key;     }     IXMLElement top = (IXMLElement) this.stack.peek();     if (top.hasAttribute(fullName)) {      throw new XMLParseException(top.getSystemID(),                    top.getLineNr(),                    \"Duplicate attribute: \" + key);     }     if (nsPrefix != null) {      top.setAttribute(fullName, nsURI, value);     } else {      top.setAttribute(fullName, value);}}", "nl": "This method is called when a new attribute of an XML element is encountered"}
{"code": "public IXMLEntityResolver getResolver()    {     return this.entityResolver;}", "nl": "Returns the entity resolver"}
{"code": "protected void finalize()     throws Throwable    {     this.builder = null;     this.reader = null;     this.entityResolver = null;     this.validator = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "public IXMLBuilder getBuilder()    {     return this.builder;}", "nl": "Returns the builder which creates the logical structure of the XML data"}
{"code": "public void setBuilder(IXMLBuilder builder)    {     this.builder = builder;}", "nl": "Sets the builder which creates the logical structure of the XML data"}
{"code": "String getName()    {     return this.name;}", "nl": "Returns the short name of the attribute"}
{"code": "String getNamespace()    {     return this.namespace;}", "nl": "Returns the namespace of the attribute"}
{"code": "public void printStackTrace(PrintStream stream)    {     super.printStackTrace(stream);     if (this.encapsulatedException != null) {      stream.println(\"*** Nested Exception:\");      this.encapsulatedException.printStackTrace(stream);}}", "nl": "Dumps the exception stack to an output stream"}
{"code": "public String getSystemID()    {     return this.systemID;}", "nl": "Returns the system ID of the XML data where the exception occurred"}
{"code": "protected void finalize()     throws Throwable    {     this.systemID = null;     this.encapsulatedException = null;     super.finalize();}", "nl": "Cleans up the object when it ' s destroyed"}
{"code": "public Figure getOwner() {     return owner;}", "nl": "Gets the connector ' s owner"}
{"code": "protected Point2D.Double chop(Figure target, Point2D.Double from) {     target = getConnectorTarget(target);     Rectangle2D.Double r = target.getBounds();          if (target.get(DiamondFigure.IS_QUADRATIC)) {       double side = Math.max(r.width, r.height);       r.x -= (side - r.width) / 2;       r.y -= (side - r.height) / 2;       r.width = r.height = side;     }     double growx;     double growy;          switch (target.get(STROKE_PLACEMENT)) {       case INSIDE : {         growx = growy = 0f;         break;       }       case OUTSIDE : {         double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);         double scale = getStrokeTotalWidth(target) * 2d / lineLength;         growx = scale * r.height;         growy = scale * r.width;                  break;       }       case CENTER :       default :         double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);         double scale = getStrokeTotalWidth(target) / lineLength;         growx = scale * r.height;         growy = scale * r.width;                  break;     }     Geom.grow(r, growx, growy);               Point2D.Double c1 = new Point2D.Double(r.x + r.width/2, r.y + (r.height/2));     Point2D.Double p2 = new Point2D.Double(r.x + r.width/2, r.y + r.height);     Point2D.Double p4 = new Point2D.Double(r.x + r.width/2, r.y);               if (r.contains(from)) {       if (from.y > r.y && from.y < (r.y +r.height/2)) {         return p2;       } else {         return p4;       }     }               double ang = Geom.pointToAngle(r, from);               Point2D.Double p1 = new Point2D.Double(r.x + r.width  , r.y + (r.height/2));     Point2D.Double p3 = new Point2D.Double(r.x      , r.y + (r.height/2));     Point2D.Double rp = null;                if (ang > 0 && ang < 1.57) {       rp = Geom.intersect(p1.x, p1.y, p2.x, p2.y, c1.x, c1.y, from.x, from.y);     } else if (ang > 1.575 && ang < 3.14) {       rp = Geom.intersect(p2.x, p2.y, p3.x, p3.y, c1.x, c1.y, from.x, from.y);     } else if (ang > -3.14 && ang < -1.575) {       rp = Geom.intersect(p3.x, p3.y, p4.x, p4.y, c1.x, c1.y, from.x, from.y);     } else if (ang > -1.57 && ang < 0) {       rp = Geom.intersect(p4.x, p4.y, p1.x, p1.y, c1.x, c1.y, from.x, from.y);     }               if (rp == null) {       rp = Geom.angleToPoint(r, ang);     }          return rp;}", "nl": "Return an appropriate connection point on the edge of a diamond figure"}
{"code": "public PrintApplicationFileAction(Application app) {     super(app, null);     putValue(Action.NAME, \"OSX Print File\");}", "nl": "Creates a new instance"}
{"code": "protected void uninstallViewListeners(View p) {     p.removePropertyChangeListener(viewListener);}", "nl": "Uninstalls listeners on the view object"}
{"code": "public AbstractViewAction(Application app, View view) {     this.app = app;     this.view = view;     this.enabled = true;     if (view == null) {       app.addPropertyChangeListener(applicationListener);     } else {       view.addPropertyChangeListener(viewListener);     }     updateView(null, getActiveView());}", "nl": "Creates a new instance which acts on the specified view of the application"}
{"code": "public AbstractLineDecoration(boolean isFilled, boolean isStroked, boolean isSolid) {     this.isFilled = isFilled;     this.isStroked = isStroked;     this.isSolid = isSolid;}", "nl": "Constructs an arrow tip with the given angle and radius"}
{"code": "public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {     Path2D.Double path = getTransformedDecoratorPath(f, p1, p2);     Color color;     if (isFilled) {       if (isSolid) {         color = f.get(STROKE_COLOR);       } else {         color = f.get(FILL_COLOR);       }       if (color != null) {         g.setColor(color);         g.fill(path);       }     }     if (isStroked) {       color = f.get(STROKE_COLOR);       if (color != null) {         g.setColor(color);         g.setStroke(AttributeKeys.getStroke(f));         g.draw(path);}}}", "nl": "Draws the arrow tip in the direction specified by the given two Points"}
{"code": "public HandleMulticaster(Handle handle) {     this.handles = new LinkedList<Handle>();     this.handles.add(handle);}", "nl": "Creates a new instance"}
{"code": "public Figure getFigure() {     return (Figure) getSource();}", "nl": "Gets the changed figure"}
{"code": "protected JDialog createDialog(URIChooser chooser, Component parent) throws HeadlessException {     String title = chooser.getDialogTitle();     if (chooser instanceof JFileChooser) {       ((JFileChooser) chooser).getAccessibleContext().setAccessibleDescription(title);     }     JDialog dialog;     Window window = (parent instanceof Window) ? (Window) parent : SwingUtilities.getWindowAncestor(parent);     if (window instanceof Frame) {       dialog = new JDialog((Frame) window, title, true);     } else {       dialog = new JDialog((Dialog) window, title, true);     }     dialog.setComponentOrientation(chooser.getComponent().getComponentOrientation());     Container contentPane = dialog.getContentPane();     contentPane.setLayout(new BorderLayout());     contentPane.add(chooser.getComponent(), BorderLayout.CENTER);     if (JDialog.isDefaultLookAndFeelDecorated()) {       boolean supportsWindowDecorations =           UIManager.getLookAndFeel().getSupportsWindowDecorations();       if (supportsWindowDecorations) {         dialog.getRootPane().setWindowDecorationStyle(JRootPane.FILE_CHOOSER_DIALOG);       }     }          Preferences prefs = PreferencesUtil.userNodeForPackage(getApplication().getModel().getClass());     PreferencesUtil.installFramePrefsHandler(prefs, \"openChooser\", dialog);          return dialog;}", "nl": "We implement JFileChooser . showDialog by ourselves , so that we can center dialogs properly on screen on Mac OS X"}
{"code": "public LoadFileAction(Application app, View view) {     super(app, view);     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.app.Labels\");     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "public void draw(Graphics2D g) {     drawCircle(g,         (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_FILL_COLOR),         (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_STROKE_COLOR));}", "nl": "Draws this handle"}
{"code": "protected void fireUndoableEditHappened(UndoableEdit edit) {     view.getDrawing().fireUndoableEditHappened(edit);}", "nl": "Notify all listenerList that have registered interest for notification on this event type"}
{"code": "public DrawingView getView() {     return view;}", "nl": "Gets the drawing view of the tool"}
{"code": "public ToolEvent(Tool src, DrawingView view, Rectangle invalidatedArea) {     super(src);     this.view = view;     this.invalidatedArea = invalidatedArea;}", "nl": "Creates a new instance"}
{"code": "public SaveFileAction(Application app, View view) {     this(app, view, false);}", "nl": "Creates a new instance"}
{"code": "public void printQuartz(PrintableView v) {     Frame frame = (Frame) SwingUtilities.getWindowAncestor(v.getComponent());     final Pageable pageable = v.createPageable();     final double resolution = 300d;     JobAttributes jobAttr = new JobAttributes();          PageAttributes pageAttr = new PageAttributes();     pageAttr.setMedia(PageAttributes.MediaType.A4);     pageAttr.setPrinterResolution((int) resolution);     final PrintJob pj = frame.getToolkit().getPrintJob(         frame,         \"Job Title\",         jobAttr,         pageAttr);     getActiveView().setEnabled(false);     new Worker() {       protected Object construct() throws PrinterException {                  Paper paper = new Paper();         paper.setSize(             pj.getPageDimension().width / resolution * 72d,             pj.getPageDimension().height / resolution * 72d);         paper.setImageableArea(64d, 32d, paper.getWidth() - 96d, paper.getHeight() - 64);         PageFormat pageFormat = new PageFormat();         pageFormat.setPaper(paper);                  try {           for (int i = 0,  n = pageable.getNumberOfPages(); i < n; i++) {             PageFormat pf = pageable.getPageFormat(i);             pf = pageFormat;             Graphics g = pj.getGraphics();             if (g instanceof Graphics2D) {               pageable.getPrintable(i).print(g, pf, i);             } else {               BufferedImage buf = new BufferedImage(                   (int) (pf.getImageableWidth() * resolution / 72d),                   (int) (pf.getImageableHeight() * resolution / 72d),                   BufferedImage.TYPE_INT_RGB);               Graphics2D bufG = buf.createGraphics();                bufG.setBackground(Color.WHITE);               bufG.fillRect(0, 0, buf.getWidth(), buf.getHeight());               bufG.scale(resolution / 72d, resolution / 72d);               bufG.translate(-pf.getImageableX(), -pf.getImageableY());               pageable.getPrintable(i).print(bufG, pf, i);               bufG.dispose();               g.drawImage(buf,                   (int) (pf.getImageableX() * resolution / 72d),                   (int) (pf.getImageableY() * resolution / 72d),                   null);               buf.flush();             }             g.dispose();           }         } finally {           pj.end();         }         return null;       }       protected void failed(Throwable error) {          error.printStackTrace();       }       protected void finished() {         getActiveView().setEnabled(true);       }     }.start();}", "nl": "On Mac OS X with the Quartz rendering engine , the following code achieves the best results"}
{"code": "@Override   public <T> T get(AttributeKey<T> key) {     return key.get(attributes);}", "nl": "Gets an attribute from the figure"}
{"code": "@Override   public <T> void set(AttributeKey<T> key, T newValue) {     if (forbiddenAttributes == null || !forbiddenAttributes.contains(key)) {       Object oldValue = attributes.put(key, newValue);       setAttributeOnChildren(key, newValue);       fireAttributeChanged(key, oldValue, newValue);}}", "nl": "Sets an attribute of the figure"}
{"code": "public void removeAllChildren() {     willChange();     for (Figure f : new LinkedList<Figure>(getChildren())) {       if (getDrawing() != null) {         f.removeNotify(getDrawing());       }       int index = basicRemove(f);     }     changed();}", "nl": "Removes all children"}
{"code": "public java.util.List<Figure> getChildrenFrontToBack() {     return children.size() == 0 ? new LinkedList<Figure>() : new ReversedList<Figure>(getChildren());}", "nl": "Returns an iterator to iterate in Z - order front to back over the children"}
{"code": "public void draw(Graphics2D g) {     drawRectangle(g, (pressed) ? Color.orange : Color.white, Color.black);     Rectangle r = getBounds();     g.drawLine(r.x, r.y, r.x+r.width, r.y+r.height);     g.drawLine(r.x+r.width, r.y, r.x, r.y+r.height);}", "nl": "Draws this handle"}
{"code": "public CloseHandle(Figure owner) {     this(owner, new RelativeLocator(1.0, 0.0));}", "nl": "Creates a new instance"}
{"code": "protected void connect(Connector c) {     getOwner().setEndConnector(c);}", "nl": "Sets the start of the connection"}
{"code": "public BoundsOutlineHandle(Figure owner, boolean isTransformHandle, boolean isHoverHandle) {     super(owner);     if (isTransformHandle) {       if (isHoverHandle) {         stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;         strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;         stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;         strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;       } else {         stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;         strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;         stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;         strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;       }       stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;       strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;       stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;       strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;     } else {       if (isHoverHandle) {         stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;         strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;         stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;         strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;       } else {         stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;         strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;         stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;         strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;       }       stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;       strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;       stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;       strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;}}", "nl": "Creates a bounds outline handle for resizing or transforming a component"}
{"code": "public static void setReOpenApplicationHandler(ActionListener reopenHandler) {     setHandler(new OSXAdapter(\"handleReOpenApplication\", reopenHandler));}", "nl": "Called when the application receives a Reopen Application event from the Finder or another application"}
{"code": "protected OSXAdapter(String proxySignature, Object target, Method handler) {     this.proxySignature = proxySignature;     this.targetObject = target;     this.targetMethod = handler;}", "nl": "Each OSXAdapter has the name of the EAWT method it intends to listen for , the Object that will ultimately perform the task , and the Method to be called on that Object"}
{"code": "@Override   public void undo() throws CannotRedoException {     super.undo();     try {       getSetter().invoke(source, oldValue);     } catch (Exception e) {       InternalError ie = new InternalError(\"Couldn't invoke setter for property \\\"\" + propertyName + \"\\\" in \" + source);       ie.initCause(e);       throw ie;}}", "nl": "Undoes the change"}
{"code": "public PropertyChangeEdit(Object source, String propertyName, long oldValue, long newValue) {     this(source, propertyName, Long.TYPE, oldValue, newValue);}", "nl": "Creates a new PropertyChangeEdit"}
{"code": "public void addPropertyChangeListener(PropertyChangeListener listener) {     propertySupport.addPropertyChangeListener(listener);}", "nl": "Adds a PropertyChangeListener which can optionally be wrapped into a WeakPropertyChangeListener"}
{"code": "public void removePropertyChangeListener(PropertyChangeListener listener) {                    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners()) {       if (l == listener) {         propertySupport.removePropertyChangeListener(l);         break;       }       if (l instanceof WeakPropertyChangeListener) {         WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;         PropertyChangeListener target = wl.getTarget();         if (target == listener) {           propertySupport.removePropertyChangeListener(l);           break;}}}}", "nl": "Removes a PropertyChangeListener"}
{"code": "public TextOverflowHandle(TextHolderFigure owner) {     super(owner);}", "nl": "Creates a new instance"}
{"code": "@Override public void draw(Graphics2D g) {     if (getOwner().isTextOverflow()) {     drawRectangle(g,          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_FILL_COLOR),         (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR)         );       g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));       Rectangle r = basicGetBounds();       g.drawLine(r.x+1, r.y+1, r.x+r.width-2, r.y+r.height-2);       g.drawLine(r.x+r.width-2, r.y+1, r.x+1, r.y+r.height-2);}}", "nl": "Draws this handle"}
{"code": "public SerializationInputOutputFormat() {     this(\"Drawing\", \"ser\", new DefaultDrawing());}", "nl": "Creates a new instance with format name Drawing , file extension xml and mime type image x - jhotdraw"}
{"code": "public ImageInputFormat(ImageHolderFigure prototype, String formatName, String description, String fileExtension,       String mimeType) {     this(prototype, formatName, description, new String[]{fileExtension}, new String[]{mimeType});}", "nl": "Creates a new image input format for the specified image format"}
{"code": "static public Locator northEast() {     return new RelativeDecoratorLocator(1.0, 0.0);}", "nl": "North east"}
{"code": "static public void addGroupTransformHandles(Figure f, Collection<Handle> handles) {     handles.add(new BoundsOutlineHandle(f,         GROUP_BOUNDS_STROKE_1, GROUP_BOUNDS_COLOR_1,         GROUP_BOUNDS_STROKE_2, GROUP_BOUNDS_COLOR_2,         GROUP_BOUNDS_STROKE_1_DISABLED, GROUP_BOUNDS_COLOR_1_DISABLED,         GROUP_BOUNDS_STROKE_2_DISABLED, GROUP_BOUNDS_COLOR_2_DISABLED         ));     addCornerTransformHandles(f, handles);     addEdgeTransformHandles(f, handles);     handles.add(new RotateHandle(f));}", "nl": "Adds handles for scaling , moving , rotating and shearing a Figure"}
{"code": "protected InputMap createInputMap() {     return null;}", "nl": "Override this method to create a tool - specific input map , which overrides the input map of the drawing edtior"}
{"code": "protected ActionMap createActionMap() {     return null;}", "nl": "Override this method to create a tool - specific action map , which overrides the action map of the drawing edtior"}
{"code": "protected void maybeFireBoundsInvalidated(Rectangle invalidatedArea) {     Drawing d = getDrawing();     Rectangle2D.Double canvasBounds = new Rectangle2D.Double(0, 0, 0, 0);     if (d.get(CANVAS_WIDTH) != null) {       canvasBounds.width += d.get(CANVAS_WIDTH);     }     if (d.get(CANVAS_HEIGHT) != null) {       canvasBounds.height += d.get(CANVAS_HEIGHT);     }     if (!canvasBounds.contains(invalidatedArea)) {        fireBoundsInvalidated(invalidatedArea);}}", "nl": "Notify all listenerList that have registered interest for notification on this event type"}
{"code": "public void setInputMap(InputMap newValue) {     inputMap = newValue;}", "nl": "Sets the InputMap for the Tool"}
{"code": "static public Locator east() {     return east(false);}", "nl": "Non - transforming East"}
{"code": "public BufferedImage toImage(Drawing drawing,       java.util.List<Figure> figures,       double scaleFactor, boolean clipToFigures) {               Rectangle2D.Double drawBounds = null;     for (Figure f : figures) {       if (drawBounds == null) {         drawBounds = f.getDrawingArea();       } else {         drawBounds.add(f.getDrawingArea());       }     }     if (clipToFigures) {     AffineTransform transform = new AffineTransform();       transform.translate(-drawBounds.x * scaleFactor,            -drawBounds.y * scaleFactor);     transform.scale(scaleFactor, scaleFactor);     return toImage(drawing, figures, transform,         new Dimension(         (int) (drawBounds.width * scaleFactor),         (int) (drawBounds.height * scaleFactor)         )         );     } else {     AffineTransform transform = new AffineTransform();     if (drawBounds.x < 0) {       transform.translate(-drawBounds.x * scaleFactor, 0);     }     if (drawBounds.y < 0) {       transform.translate(0, -drawBounds.y * scaleFactor);     }     transform.scale(scaleFactor, scaleFactor);      return toImage(drawing, figures, transform,         new Dimension(         (int) ((Math.max(0, drawBounds.x)+drawBounds.width) * scaleFactor),         (int) ((Math.max(0, drawBounds.y)+drawBounds.height) * scaleFactor)));}}", "nl": "Creates a BufferedImage from the specified list of figures"}
{"code": "public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures,       AffineTransform drawingTransform, Dimension imageSize) throws IOException {     BufferedImage img;     if (drawingTransform == null || imageSize == null) {       img = toImage(drawing, figures, 1d, false);     } else {       img = toImage(drawing, figures, drawingTransform, imageSize);     }     ImageIO.write(img, formatName, out);     img.flush();}", "nl": "Writes the figures to the specified output stream"}
{"code": "static public Locator southEast(boolean isTransform) {     return new RelativeLocator(1.0, 1.0, isTransform);}", "nl": "South East"}
{"code": "static public Locator northEast(boolean isTransform) {     return new RelativeLocator(1.0, 0.0, isTransform);}", "nl": "Norht East"}
{"code": "static public Locator southWest(boolean isTransform) {     return new RelativeLocator(0.0, 1.0, isTransform);}", "nl": "South West"}
{"code": "protected void creationFinished(Figure createdFigure) {     if (isToolDoneAfterCreation()) {       fireToolDone();}}", "nl": "This method allows subclasses to do perform additonal user interactions after the new figure has been created"}
{"code": "protected boolean canConnect(ConnectionFigure f, Connector startConnector) {     return f.canConnect(startConnector);}", "nl": "This method is called on the Figure , onto which the user wants to start a new connection"}
{"code": "public String getText() {     return textField.getText();}", "nl": "Gets the text contents of the overlay"}
{"code": "public void createOverlay(DrawingView view, TextHolderFigure figure) {     view.getComponent().add(textField, 0);     textField.setText(figure.getText());     textField.setColumns(figure.getTextColumns());     textField.selectAll();     textField.setVisible(true);     editedFigure = figure;     editedFigure.addFigureListener(figureHandler);     this.view = view;     updateWidget();}", "nl": "Creates the overlay for the given Container using a specific font"}
{"code": "public SlantedLiner() {     this(20);}", "nl": "Creates a new instance"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public static Point2D.Double ovalAngleToPoint(Rectangle2D.Double r, double angle) {     Point2D.Double center = Geom.center(r);     Point2D.Double p = Geom.polarToPoint2D(angle, r.width / 2, r.height / 2);     return new Point2D.Double(center.x + p.x, center.y + p.y);}", "nl": "Gets the point on an oval that corresponds to the given angle"}
{"code": "public static Point ovalAngleToPoint(Rectangle r, double angle) {     Point center = Geom.center(r);     Point p = Geom.polarToPoint(angle, r.width / 2, r.height / 2);     return new Point(center.x + p.x, center.y + p.y);}", "nl": "Gets the point on an oval that corresponds to the given angle"}
{"code": "public static Point2D.Double chop(Shape shape, Point2D.Double p) {     Rectangle2D bounds = shape.getBounds2D();     Point2D.Double ctr = new Point2D.Double(bounds.getCenterX(), bounds.getCenterY());          double cx = -1;     double cy = -1;     double len = Double.MAX_VALUE;          PathIterator i = shape.getPathIterator(new AffineTransform(), 1);     double[] coords = new double[6];     int type = i.currentSegment(coords);     double prevX = coords[0];     double prevY = coords[1];     double moveToX = prevX;     double moveToY = prevY;     i.next();     for (; !i.isDone(); i.next()) {       switch (i.currentSegment(coords)) {         case PathIterator.SEG_MOVETO:           moveToX = coords[0];           moveToY = coords[1];           break;         case PathIterator.SEG_CLOSE:           coords[0] = moveToX;           coords[1] = moveToY;           break;       }       Point2D.Double chop = Geom.intersect(           prevX, prevY,           coords[0], coords[1],           p.x, p.y,           ctr.x, ctr.y);       if (chop != null) {         double cl = Geom.length2(chop.x, chop.y, p.x, p.y);         if (cl < len) {           len = cl;           cx = chop.x;           cy = chop.y;         }       }       prevX = coords[0];       prevY = coords[1];     }                if (len == Double.MAX_VALUE) {       i = shape.getPathIterator(new AffineTransform(), 1);       for (; !i.isDone(); i.next()) {         i.currentSegment(coords);         double l = Geom.length2(ctr.x, ctr.y, coords[0], coords[1]);         if (l < len) {           len = l;           cx = coords[0];           cy = coords[1];         }       }     }     return new Point2D.Double(cx, cy);}", "nl": "Returns a point on the edge of the bezier path which crosses the line from the center of the bezier path to the specified point"}
{"code": "public static long length(int x1, int y1, int x2, int y2) {     return (long) sqrt(length2(x1, y1, x2, y2));}", "nl": "Gets the distance between to points"}
{"code": "public static double pointToAngle(Rectangle2D.Double r, Point2D.Double p) {     double px = p.x - (r.x + r.width / 2);     double py = p.y - (r.y + r.height / 2);     return atan2(py * r.width, px * r.height);}", "nl": "Gets the angle of a point relative to a rectangle"}
{"code": "public static Point2D.Double cap(Point2D.Double p1, Point2D.Double p2, double radius) {     double angle = PI / 2 - atan2(p2.x - p1.x, p2.y - p1.y);     Point2D.Double p3 = new Point2D.Double(         p2.x + radius * cos(angle),         p2.y + radius * sin(angle));     return p3;}", "nl": "Caps the line defined by p1 and p2 by the number of units specified by radius"}
{"code": "void updateBounds(double x, double y) {       if (x < bounds.x) {         bounds.width = bounds.width + (bounds.x - x);         bounds.x = x;       } else {         bounds.width = Math.max(bounds.width, x - bounds.x);              }       if (y < bounds.y) {         bounds.height = bounds.height + (bounds.y - y);         bounds.y = y;       } else {         bounds.height = Math.max(bounds.height, y - bounds.y);}}", "nl": "Resizes the bounding box to accomodate the specified coordinates"}
{"code": "void updateBounds(float x, float y) {       if (x < bounds.x) {         bounds.width = bounds.width + (bounds.x - x);         bounds.x = x;       } else {         bounds.width = Math.max(bounds.width, x - bounds.x);              }       if (y < bounds.y) {         bounds.height = bounds.height + (bounds.y - y);         bounds.y = y;       } else {         bounds.height = Math.max(bounds.height, y - bounds.y);}}", "nl": "Resizes the bounding box to accomodate the specified coordinates"}
{"code": "public int currentSegment(float[] coords) {       if (index >= poly.npoints) {         return SEG_CLOSE;       }       coords[0] = (float) poly.xpoints[index];       coords[1] = (float) poly.ypoints[index];       if (transform != null) {         transform.transform(coords, 0, coords, 0, 1);       }       return (index == 0 ? SEG_MOVETO : SEG_LINETO);}", "nl": "Returns the coordinates and type of the current path segment in the iteration"}
{"code": "public boolean isDone() {       return index > poly.npoints;}", "nl": "Tests if there are more points to read"}
{"code": "public void set(Insets2D i) {     set(i.getTop(), i.getLeft(), i.getBottom(), i.getRight());}", "nl": "Sets the insets"}
{"code": "public void addTo(Rectangle2D r) {     r.setRect(         r.getX() - getLeft(),         r.getY() - getTop(),         r.getWidth() + getLeft() + getRight(),         r.getHeight() + getTop() + getBottom());}", "nl": "Adds the current insets to the specified Rectangle2D making the rectangle larger"}
{"code": "public double getHeight() {   return height;}", "nl": "Returns the height of this dimension in double precision"}
{"code": "public Dimension2DDouble getSize() {   return new Dimension2DDouble(width, height);}", "nl": "Gets the size of this Dimension2DDouble object"}
{"code": "public void fireAreaInvalidated() {     fireAreaInvalidated(getDrawingArea());}", "nl": "Notify all listenerList that have registered interest for notification on this event type"}
{"code": "@Override   public Collection<Action> getActions(Point2D.Double p) {     return Collections.emptyList();}", "nl": "Returns a collection of actions which are presented to the user in a popup menu"}
{"code": "public void putClone(Map<AttributeKey, Object> a, T value) {     try {        put(a, value == null ? null : clazz.cast(Methods.invoke(value, \"clone\")));     } catch (NoSuchMethodException ex) {       InternalError e = new InternalError();       e.initCause(ex);       throw e;}}", "nl": "Convenience method for putting a clone of a value on a map"}
{"code": "@SuppressWarnings(\"unchecked\")   public T getClone(Figure f) {     T value = f.get(this);     try {       return value == null ? null : clazz.cast(Methods.invoke(value, \"clone\"));     } catch (NoSuchMethodException ex) {       InternalError e = new InternalError();       e.initCause(ex);       throw e;}}", "nl": "Gets a clone of the value from the Figure"}
{"code": "public boolean isNullValueAllowed() {     return isNullValueAllowed;}", "nl": "Returns true if null values are allowed"}
{"code": "public Point2D.Double getPoint(int index) {     return path.get(index).getControlPoint(0);}", "nl": "Convenience method for getting the point coordinate of the first control point of the specified node"}
{"code": "protected BezierPath getCappedPath() {     if (cappedPath == null) {       cappedPath = (BezierPath) path.clone();       if (isClosed()) {         cappedPath.setClosed(true);       } else {         if (cappedPath.size() > 1) {           if (get(START_DECORATION) != null) {             BezierPath.Node p0 = cappedPath.get(0);             BezierPath.Node p1 = cappedPath.get(1);             Point2D.Double pp;             if ((p0.getMask() & BezierPath.C2_MASK) != 0) {               pp = p0.getControlPoint(2);             } else if ((p1.getMask() & BezierPath.C1_MASK) != 0) {               pp = p1.getControlPoint(1);             } else {               pp = p1.getControlPoint(0);             }             double radius = get(START_DECORATION).getDecorationRadius(this);             double lineLength = Geom.length(p0.getControlPoint(0), pp);             cappedPath.set(0,0, Geom.cap(pp, p0.getControlPoint(0), - Math.min(radius, lineLength)));           }           if (get(END_DECORATION) != null) {             BezierPath.Node p0 = cappedPath.get(cappedPath.size() - 1);             BezierPath.Node p1 = cappedPath.get(cappedPath.size() - 2);                          Point2D.Double pp;             if ((p0.getMask() & BezierPath.C1_MASK) != 0) {               pp = p0.getControlPoint(1);             } else if ((p1.getMask() & BezierPath.C2_MASK) != 0) {               pp = p1.getControlPoint(2);             } else {               pp = p1.getControlPoint(0);             }                                       double radius = get(END_DECORATION).getDecorationRadius(this);             double lineLength = Geom.length(p0.getControlPoint(0), pp);             cappedPath.set(cappedPath.size() - 1, 0, Geom.cap(pp, p0.getControlPoint(0), -Math.min(radius, lineLength)));           }           cappedPath.invalidatePath();         }       }     }     return cappedPath;}", "nl": "Returns a path which is cappedPath at the ends , to prevent it from drawing under the end caps"}
{"code": "public int joinSegments(Point2D.Double join, float tolerance) {     return path.joinSegments(join, tolerance);}", "nl": "Joins two segments into one if the given Point2D . Double hits a node of the polyline"}
{"code": "public BezierPath getBezierPath() {     return (BezierPath) path.clone();}", "nl": "Returns a clone of the bezier path of this figure"}
{"code": "public Point2D.Double getPoint(int index, int coord) {     return path.get(index).getControlPoint(coord);}", "nl": "Gets the point coordinate of a control point"}
{"code": "private void ensureSorted() {     if (needsSorting) {       Collections.sort(children, FigureLayerComparator.INSTANCE);       needsSorting = false;}}", "nl": "Ensures that the children are sorted in z - order sequence from back to front"}
{"code": "public java.util.List<Figure> getFiguresFrontToBack() {     ensureSorted();     return new ReversedList<Figure>(getChildren());}", "nl": "Returns an iterator to iterate in Z - order front to back over the children"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public static JPopupButton createSelectionColorButton(       DrawingEditor editor, AttributeKey<Color> attributeKey,       java.util.List<ColorIcon> swatches, int columnCount,       String labelKey, ResourceBundleUtil labels,       Map<AttributeKey, Object> defaultAttributes) {     return createSelectionColorButton(editor, attributeKey,         swatches, columnCount, labelKey, labels, defaultAttributes,         new Rectangle(1, 17, 20, 4));}", "nl": "Creates a color button , with an action region and a popup menu"}
{"code": "public static JPopupButton createEditorColorButton(       DrawingEditor editor, AttributeKey<Color> attributeKey,       java.util.List<ColorIcon> swatches, int columnCount,       String labelKey, ResourceBundleUtil labels) {     return createEditorColorButton(         editor, attributeKey,         swatches, columnCount,         labelKey, labels,         null);}", "nl": "Creates a color button , with an action region and a popup menu"}
{"code": "private void updatePanel() {     if (drawing != null) {       colorButton.setBackground(drawing.get(CANVAS_FILL_COLOR));}}", "nl": "Updates the panel due to changes made on the drawing"}
{"code": "public DrawingAttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {     this(editor, key, value, null, icon);}", "nl": "Creates a new instance"}
{"code": "private void invalidateHandles() {     if (handlesAreValid) {       handlesAreValid = false;       Rectangle invalidatedArea = null;       for (Handle handle : selectionHandles) {         handle.removeHandleListener(eventHandler);         if (invalidatedArea == null) {           invalidatedArea = handle.getDrawingArea();         } else {           invalidatedArea.add(handle.getDrawingArea());         }         handle.dispose();       }       for (Handle handle : secondaryHandles) {         handle.removeHandleListener(eventHandler);         if (invalidatedArea == null) {           invalidatedArea = handle.getDrawingArea();         } else {           invalidatedArea.add(handle.getDrawingArea());         }         handle.dispose();       }       selectionHandles.clear();       secondaryHandles.clear();       setActiveHandle(null);       if (invalidatedArea != null) {         repaint(invalidatedArea);}}}", "nl": "Invalidates the handles"}
{"code": "@Override   public void selectAll() {     Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);     selectedFigures.clear();     for (Figure figure : drawing.getChildren()) {       if (figure.isSelectable()) {         selectedFigures.add(figure);       }     }     Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);     invalidateHandles();     fireSelectionChanged(oldSelection, newSelection);     repaint();}", "nl": "Selects all selectable figures"}
{"code": "@Override   public void setBounds(int x, int y, int width, int height) {     super.setBounds(x, y, width, height);     validateViewTranslation();}", "nl": "Side effect : Changes view Translation"}
{"code": "public void removeFromSelection(Figure figure) {     Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);     if (selectedFigures.remove(figure)) {       Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);       invalidateHandles();       figure.removeFigureListener(handleInvalidator);       fireSelectionChanged(oldSelection, newSelection);       repaint();}}", "nl": "Removes a figure from the selection"}
{"code": "@Override   public Figure findFigure(       Point p) {     return getDrawing().findFigure(viewToDrawing(p));}", "nl": "Finds a figure at a given coordinates"}
{"code": "@Override   public Point drawingToView(       Point2D.Double p) {     return new Point(         (int) (p.x * scaleFactor) - translation.x,         (int) (p.y * scaleFactor) - translation.y);}", "nl": "Converts drawing coordinates to view coordinates"}
{"code": "public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {     return new ChopDiamondConnector(this);}", "nl": "Returns the Figures connector for the specified location"}
{"code": "public DiamondFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public int getHgap() {     return hgap;}", "nl": "Gets the horizontal gap between components"}
{"code": "public int getVgap() {     return vgap;}", "nl": "Gets the vertical gap between components"}
{"code": "protected synchronized T getValue() {     return value;}", "nl": "Get the value produced by the worker thread , or null if it hasn ' t been constructed yet"}
{"code": "protected void failed(Throwable error) {     error.printStackTrace();}", "nl": "Called on the event dispatching thread after the construct method has thrown an error"}
{"code": "public boolean isAnimated() {     return isAnimated;}", "nl": "If this returns true , the JSheet uses a transition effect when shown and when hidden"}
{"code": "public static void showMessageSheet(Component parentComponent,       Object message, int messageType) {     showMessageSheet(parentComponent, message, messageType, null, null);}", "nl": "Brings up a sheet that displays a message using a default icon determined by the messageType parameter"}
{"code": "public static void showSaveSheet(URIChooser chooser, Component parent, SheetListener listener) {     chooser.setDialogType(JFileChooser.SAVE_DIALOG);     showSheet(chooser, parent, null, listener);}", "nl": "Displays a Save File file chooser sheet"}
{"code": "public void setAnimated(boolean newValue) {     boolean oldValue = isAnimated;     isAnimated = newValue;     firePropertyChange(\"animated\", oldValue, newValue);}", "nl": "If this is set to true , the JSheet uses a transition effect when shown and when hidden"}
{"code": "public static void showOpenSheet(URIChooser chooser, Component parent, SheetListener listener) {     chooser.setDialogType(JFileChooser.OPEN_DIALOG);     showSheet(chooser, parent, null, listener);}", "nl": "Displays an Open File file chooser sheet"}
{"code": "public static void showMessageSheet(Component parentComponent,       Object message) {     showMessageSheet(parentComponent, message,         JOptionPane.INFORMATION_MESSAGE);}", "nl": "Brings up an information - message sheet"}
{"code": "public JPopupButton() {     initComponents();     setFocusable(false);     itemFont = ITEM_FONT;}", "nl": "Creates new form JToolBarMenu"}
{"code": "public void setPopupAnchor(int newValue) {     popupAnchor = newValue;}", "nl": "Sets the popup anchor"}
{"code": "public FontChooserUI getUI() {     return (FontChooserUI) ui;}", "nl": "Returns the look and feel object that renders this component"}
{"code": "public static synchronized Font[] getAllFonts() {     loadAllFonts();     try {       return future.get().clone();     } catch (InterruptedException ex) {       return new Font[0];     } catch (ExecutionException ex) {       return new Font[0];}}", "nl": "Gets all fonts from the graphics environment"}
{"code": "public ImageFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public void setImage(byte[] imageData, BufferedImage bufferedImage) {     willChange();     this.imageData = imageData;     this.bufferedImage = bufferedImage;     changed();}", "nl": "Sets the image"}
{"code": "public boolean figureContains(Point2D.Double p) {     Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();     double grow = AttributeKeys.getPerpendicularHitGrowth(this) + 1d;     Geom.grow(r, grow, grow);     return r.contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public GraphicalCompositeFigure() {     this(null);}", "nl": "Default constructor which uses nothing as presentation figure"}
{"code": "public Rectangle2D.Double getDrawingArea() {     Rectangle2D.Double r = super.getDrawingArea();     if (getPresentationFigure() != null) {       r.add(getPresentationFigure().getDrawingArea());     }     return r;}", "nl": "Return the draw area"}
{"code": "@SuppressWarnings(\"unchecked\")   protected void applyAttributesTo(Figure that) {     for (Map.Entry<AttributeKey, Object> entry : attributes.entrySet()) {       that.set(entry.getKey(), entry.getValue());}}", "nl": "Applies all attributes of this figure to that figure"}
{"code": "public Collection<Handle> createHandles(int detailLevel) {     LinkedList<Handle> handles = new LinkedList<Handle>();     if (detailLevel == 0) {     MoveHandle.addMoveHandles(this, handles);     }     return handles;}", "nl": "Return default handles from the presentation figure"}
{"code": "protected Point2D.Double constrainPoint(Point2D.Double p, TranslationDirection dir) {     Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());     switch (dir) {       case NORTH:       case NORTH_WEST:       case NORTH_EAST:         if (p0.y < p.y) {           p.y = p0.y;         } else if (p0.y > p.y) {           p.y = p0.y - height;         }         break;       case SOUTH:       case SOUTH_WEST:       case SOUTH_EAST:         if (p0.y < p.y) {           p.y = p0.y + height;         } else if (p0.y > p.y) {           p.y = p0.y;         }         break;     }     switch (dir) {       case WEST:       case NORTH_WEST:       case SOUTH_WEST:         if (p0.x < p.x) {           p.x = p0.x;         } else if (p0.x > p.x) {           p.x = p0.x - width;         }         break;       case EAST:       case NORTH_EAST:       case SOUTH_EAST:         if (p0.x < p.x) {           p.x = p0.x + width;         } else if (p0.x > p.x) {           p.x = p0.x;         }         break;     }     return p;}", "nl": "Constrains the placement of a point towards a direction"}
{"code": "protected Rectangle2D.Double constrainRectangle(Rectangle2D.Double r, TranslationDirection dir) {     Point2D.Double p0 = new Point2D.Double(r.x, r.y);     switch (dir) {       case NORTH:       case NORTH_WEST:       case WEST:         constrainPoint(p0, dir);         break;       case EAST:       case NORTH_EAST:         p0.x += r.width;         constrainPoint(p0, dir);         p0.x -= r.width;         break;       case SOUTH:       case SOUTH_WEST:         p0.y += r.height;         constrainPoint(p0, dir);         p0.y -= r.height;         break;       case SOUTH_EAST:         p0.y += r.height;         p0.x += r.width;         constrainPoint(p0, dir);         p0.y -= r.height;         p0.x -= r.width;         break;     }     r.x = p0.x;     r.y = p0.y;     return r;}", "nl": "Constrains the placement of a rectangle towards a direction"}
{"code": "public void draw(Graphics2D g) {     super.draw(g);     for (Figure child : children) {       if (child.isVisible()) {         child.draw(g);}}}", "nl": "Draw the figure"}
{"code": "public boolean contains(Point2D.Double p) {     Ellipse2D.Double r = (Ellipse2D.Double) ellipse.clone();     double grow = AttributeKeys.getPerpendicularHitGrowth(this);     r.x -= grow;     r.y -= grow;     r.width += grow * 2;     r.height += grow * 2;     return r.contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public ImageTool(ImageHolderFigure prototype) {     super(prototype);}", "nl": "Creates a new instance"}
{"code": "public ImageTool(ImageHolderFigure prototype, Map<AttributeKey, Object> attributes) {     super(prototype, attributes);}", "nl": "Creates a new instance"}
{"code": "public void setView(DrawingView newValue) {     this.view = newValue;     updateActiveView();}", "nl": "Attaches the FigureAttributeEditorHandler to the specified DrawingView"}
{"code": "public void setDrawingEditor(DrawingEditor newValue) {     DrawingEditor oldValue = drawingEditor;     if (drawingEditor != null) {       drawingEditor.removePropertyChangeListener(eventHandler);     }     this.drawingEditor = newValue;     if (drawingEditor != null) {       drawingEditor.addPropertyChangeListener(new WeakPropertyChangeListener(eventHandler));     }     updateActiveView();}", "nl": "Attaches the FigureAttributeEditorHandler to the specified DrawingEditor"}
{"code": "public NetPanel() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     initComponents();     undoManager = new UndoRedoManager();     editor = new DefaultDrawingEditor();     editor.add(view);          addCreationButtonsTo(creationToolbar, editor);     ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);          JPopupButton pb = new JPopupButton();     pb.setItemFont(UIManager.getFont(\"MenuItem.font\"));     labels.configureToolBarButton(pb, \"actions\");     pb.add(new DuplicateAction());     pb.addSeparator();     pb.add(new GroupAction(editor));     pb.add(new UngroupAction(editor));     pb.addSeparator();     pb.add(new BringToFrontAction(editor));     pb.add(new SendToBackAction(editor));     pb.addSeparator();     pb.add(new CutAction());     pb.add(new CopyAction());     pb.add(new PasteAction());     pb.add(new SelectAllAction());     pb.add(new SelectSameAction(editor));     pb.addSeparator();     pb.add(undoManager.getUndoAction());     pb.add(undoManager.getRedoAction());                            JMenu m = new JMenu(labels.getString(\"view.zoomFactor.text\"));     JRadioButtonMenuItem rbmi;     ButtonGroup group = new ButtonGroup();     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));     rbmi.setSelected(true);     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));     group.add(rbmi);     m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));     group.add(rbmi);     pb.add(m);     pb.setFocusable(false);     creationToolbar.addSeparator();     creationToolbar.add(pb);               DefaultDrawing drawing = new DefaultDrawing();     view.setDrawing(drawing);     drawing.addUndoableEditListener(undoManager);}", "nl": "Creates new instance"}
{"code": "private void initComponents() {     java.awt.GridBagConstraints gridBagConstraints;     toolButtonGroup = new javax.swing.ButtonGroup();     scrollPane = new javax.swing.JScrollPane();     view = new org.jhotdraw.draw.DefaultDrawingView();     jPanel1 = new javax.swing.JPanel();     creationToolbar = new javax.swing.JToolBar();     attributesToolbar = new javax.swing.JToolBar();     setLayout(new java.awt.BorderLayout());     scrollPane.setViewportView(view);     add(scrollPane, java.awt.BorderLayout.CENTER);     jPanel1.setLayout(new java.awt.GridBagLayout());     creationToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 0;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(creationToolbar, gridBagConstraints);     attributesToolbar.setFloatable(false);     gridBagConstraints = new java.awt.GridBagConstraints();     gridBagConstraints.gridx = 0;     gridBagConstraints.gridy = 1;     gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;     gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;     jPanel1.add(attributesToolbar, gridBagConstraints);     add(jPanel1, java.awt.BorderLayout.SOUTH);}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "public URIChooser getChooser() {     return (URIChooser) pane;}", "nl": "Returns the URIChooser pane on the sheet"}
{"code": "public int getOption() {     return option;}", "nl": "Returns the option that the JFileChooser or JOptionPane returned"}
{"code": "@SuppressWarnings(\"unchecked\")   public void setFonts(Font[] fonts) {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.gui.Labels\");          ArrayList<FontFamilyNode> families = new ArrayList<FontFamilyNode>();     HashMap<String, FontFamilyNode> familyMap = new HashMap<String, FontFamilyNode>();     for (Font f : fonts) {       String familyName = f.getFamily();       FontFamilyNode family;       if (familyMap.containsKey(familyName)) {         family = familyMap.get(familyName);       } else {         family = new FontFamilyNode(familyName);         familyMap.put(familyName, family);       }       family.add(new FontFaceNode(f));     }     families.addAll(familyMap.values());     Collections.sort(families);          root.removeAllChildren();     root.add(new FontCollectionNode(labels.getString(\"FontCollection.allFonts\"), (ArrayList<FontFamilyNode>) families.clone()));          root.add(         new FontCollectionNode(labels.getString(\"FontCollection.web\"), collectFamiliesNamed(families,         \"Arial\",         \"Arial Black\",         \"Comic Sans MS\",         \"Georgia\",         \"Impact\",         \"Times New Roman\",         \"Trebuchet MS\",         \"Verdana\",         \"Webdings\")));               root.add(         new FontCollectionNode(labels.getString(\"FontCollection.system\"), collectFamiliesNamed(families,         \"Dialog\",         \"DialogInput\",         \"Monospaced\",         \"SansSerif\",         \"Serif\")));          root.add(         new FontCollectionNode(labels.getString(\"FontCollection.serif\"), collectFamiliesNamed(families,                  \"Adobe Caslon Pro\",         \"Adobe Garamond Pro\",         \"American Typewriter\",         \"Arno Pro\",         \"Baskerville\",         \"Baskerville Old Face\",         \"Bell MT\",         \"Big Caslon\",         \"Bodoni SvtyTwo ITC TT\",         \"Bodoni SvtyTwo OS ITC TT\",         \"Bodoni SvtyTwo SC ITC TT\",         \"Book Antiqua\",         \"Bookman Old Style\",         \"Calisto MT\",         \"Chaparral Pro\",         \"Century\",         \"Century Schoolbook\",         \"Cochin\",         \"Footlight MT Light\",         \"Garamond\",         \"Garamond Premier Pro\",         \"Georgia\",         \"Goudy Old Style\",         \"Hoefler Text\",         \"Lucida Bright\",         \"Lucida Fax\",         \"Minion Pro\",         \"Palatino\",         \"Times\",         \"Times New Roman\",                  \"Palatino Linotype\",         \"Bitstream Vera Serif Bold\",         \"Bodoni MT\",         \"Bodoni MT Black\",         \"Bodoni MT Condensed\",         \"Californian FB\",         \"Cambria\",         \"Cambria Math\",         \"Centaur\",         \"Constantia\",         \"High Tower Text\",         \"Perpetua\",         \"Poor Richard\",         \"Rockwell Condensed\",         \"Slimbach-Black\",         \"Slimbach-BlackItalic\",         \"Slimbach-Bold\",         \"Slimbach-BoldItalic\",         \"Slimbach-Book\",         \"Slimbach-BookItalic\",         \"Slimbach-Medium\",         \"Slimbach-MediumItalic\",         \"Sylfaen\",                  \"Andalus\",         \"Angsana New\",         \"AngsanaUPC\",         \"Arabic Typesetting\",         \"Cambria\",         \"Cambria Math\",         \"Constantia\",         \"DaunPenh\",         \"David\",         \"DilleniaUPC\",         \"EucrosiaUPC\",         \"Frank Ruehl\",         \"IrisUPC\",         \"Iskoola Pota\",         \"JasmineUPC\",         \"KodchiangUPC\",         \"Narkisim\")));          root.add(         new FontCollectionNode(labels.getString(\"FontCollection.sansSerif\"), collectFamiliesNamed(families,                  \"Abadi MT Condensed Extra Bold\",         \"Abadi MT Condensed Light\",         \"Al Bayan\",         \"AppleGothic\",         \"Arial\",         \"Arial Black\",         \"Arial Narrow\",         \"Arial Rounded MT Bold\",         \"Arial Unicode MS\",         \"Bell Gothic Std\",         \"Blair MdITC TT\",         \"Century Gothic\",         \"Frutiger\",         \"Futura\",         \"Geneva\",         \"Gill Sans\",         \"Gulim\",         \"Helvetica\",         \"Helvetica Neue\",         \"Lucida Grande\",         \"Lucida Sans\",         \"Microsoft Sans Serif\",         \"Myriad Pro\",         \"News Gothic\",         \"Tahoma\",         \"Trebuchet MS\",         \"Verdana\",                  \"Franklin Gothic Medium\",         \"Lucida Sans Unicode\",         \"Agency FB\",         \"Berlin Sans FB\",         \"Berlin Sans FB Demi Bold\",         \"Bitstream Vera Sans Bold\",         \"Calibri\",         \"Candara\",         \"Corbel\",         \"Estrangelo Edessa\",         \"Eras Bold ITC\",         \"Eras Demi ITC\",         \"Eras Light ITC\",         \"Eras Medium ITC\",         \"Franklin Gothic Book\",         \"Franklin Gothic Demi\",         \"Franklin Gothic Demi Cond\",         \"Franklin Gothic Heavy\",         \"Franklin Gothic Medium Cond\",         \"Gill Sans MT\",         \"Gill Sans MT Condensed\",         \"Gill Sans MT Ext Condensed Bold\",         \"Maiandra GD\",         \"MS Reference Sans...\",         \"Tw Cen MT\",         \"Tw Cen MT Condensed\",         \"Tw Cen MT Condensed Extra Bold\",                  \"Aharoni\",         \"Browallia New\",         \"BrowalliaUPC\",         \"Calibri\",         \"Candara\",         \"Corbel\",         \"Cordia New\",         \"CordiaUPC\",         \"DokChampa\",         \"Dotum\",         \"Estrangelo Edessa\",         \"Euphemia\",         \"Freesia UPC\",         \"Gautami\",         \"Gisha\",         \"Kalinga\",         \"Kartika\",         \"Levenim MT\",         \"LilyUPC\",         \"Malgun Gothic\",         \"Meiryo\",         \"Miriam\",         \"Segoe UI\")));          root.add(         new FontCollectionNode(labels.getString(\"FontCollection.script\"), collectFamiliesNamed(families,                  \"Apple Chancery\",         \"Bickham Script Pro\",         \"Blackmoor LET\",         \"Bradley Hand ITC TT\",         \"Brush Script MT\",         \"Brush Script Std\",         \"Chalkboard\",         \"Charlemagne Std\",         \"Comic Sans MS\",         \"Curlz MT\",         \"Edwardian Script ITC\",         \"Footlight MT Light\",         \"Giddyup Std\",         \"Handwriting - Dakota\",         \"Harrington\",         \"Herculanum\",         \"Kokonor\",         \"Lithos Pro\",         \"Lucida Blackletter\",         \"Lucida Calligraphy\",         \"Lucida Handwriting\",         \"Marker Felt\",         \"Matura MT Script Capitals\",         \"Mistral\",         \"Monotype Corsiva\",         \"Party LET\",         \"Papyrus\",         \"Santa Fe LET\",         \"Savoye LET\",         \"SchoolHouse Cursive B\",         \"SchoolHouse Printed A\",         \"Skia\",         \"Snell Roundhand\",         \"Tekton Pro\",         \"Trajan Pro\",         \"Zapfino\",                  \"Blackadder ITC\",         \"Bradley Hand ITC\",         \"Chiller\",         \"Freestyle Script\",         \"French Script MT\",         \"Gigi\",         \"Harlow Solid Italic\",         \"Informal Roman\",         \"Juice ITC\",         \"Kristen ITC\",         \"Kunstler Script\",         \"Magneto Bold\",         \"Maiandra GD\",         \"Old English Text\",         \"Palace Script MT\",         \"Parchment\",         \"Pristina\",         \"Rage Italic\",         \"Ravie\",         \"Script MT Bold\",         \"Tempus Sans ITC\",         \"Viner Hand ITC\",         \"Vivaldi Italic\",         \"Vladimir Script\",                  \"Segoe Print\",         \"Segoe Script\")));               root.add(         new FontCollectionNode(labels.getString(\"FontCollection.monospaced\"), collectFamiliesNamed(families,                  \"Andale Mono\",         \"Courier\",         \"Courier New\",         \"Letter Gothic Std\",         \"Lucida Sans Typewriter\",         \"Monaco\",         \"OCR A Std\",         \"Orator Std\",         \"Prestige Elite Std\",                  \"Lucida Console\",         \"Bitstream Vera S...\",         \"Consolas\",         \"OCR A Extended\",         \"OCR B\",                  \"Consolas\",         \"DotumChe\",         \"Miriam Fixed\",         \"Rod\")));               root.add(         new FontCollectionNode(labels.getString(\"FontCollection.decorative\"), collectFamiliesNamed(families,                  \"Academy Engraved LET\",         \"Arial Black\",         \"Bank Gothic\",         \"Bauhaus 93\",         \"Bernard MT Condensed\",         \"Birch Std\",         \"Blackoak Std\",         \"BlairMdITC TT\",         \"Bordeaux Roman Bold LET\",         \"Braggadocio\",         \"Britannic Bold\",         \"Capitals\",         \"Colonna MT\",         \"Cooper Black\",         \"Cooper Std\",         \"Copperplate\",         \"Copperplate Gothic Bold\",         \"Copperplate Gothic Light\",         \"Cracked\",         \"Desdemona\",         \"Didot\",         \"Eccentric Std\",         \"Engravers MT\",         \"Eurostile\",         \"Gill Sans Ultra Bold\",         \"Gloucester MT Extra Condensed\",         \"Haettenschweiler\",         \"Hobo Std\",         \"Impact\",         \"Imprint MT Shadow\",         \"Jazz LET\",         \"Kino MT\",         \"Matura MT Script Capitals\",         \"Mesquite Std\",         \"Modern No. 20\",         \"Mona Lisa Solid ITC TT\",         \"MS Gothic\",         \"Nueva Std\",         \"Onyx\",         \"Optima\",         \"Perpetua Titling MT\",         \"Playbill\",         \"Poplar Std\",         \"PortagoITC TT\",         \"Princetown LET\",         \"Rockwell\",         \"Rockwell Extra Bold\",         \"Rosewood Std\",         \"Santa Fe LET\",         \"Stencil\",         \"Stencil Std\",         \"Stone Sans ITC TT\",         \"Stone Sans OS ITC TT\",         \"Stone Sans Sem ITC TT\",         \"Stone Sans Sem OS ITCTT\",         \"Stone Sans Sem OS ITC TT\",         \"Synchro LET\",         \"Wide Latin\",                  \"Algerian\",         \"Bodoni MT Black\",         \"Bodoni MT Poster Compressed\",         \"Broadway\",         \"Castellar\",         \"Elephant\",         \"Felix Titling\",         \"Franklin Gothic Heavy\",         \"Gill Sans MT Ext Condensed Bold\",         \"Gill Sans Ultra Bold Condensed\",         \"Goudy Stout\",         \"Jokerman\",         \"Juice ITC\",         \"Magneto\",         \"Magneto Bold\",         \"Niagara Engraved\",         \"Niagara Solid\",         \"Poor Richard\",         \"Ravie\",         \"Rockwell Condensed\",         \"Showcard Gothic\",         \"Slimbach-Black\",         \"Slimbach-BlackItalic\",         \"Snap ITC\"                  )));     root.add(         new FontCollectionNode(labels.getString(\"FontCollection.symbols\"), collectFamiliesNamed(families,                  \"Apple Symbols\",         \"Blackoack Std\",         \"Bodoni Ornaments ITC TT\",         \"EuropeanPi\",         \"Monotype Sorts\",         \"MT Extra\",         \"Symbol\",         \"Type Embellishments One LET\",         \"Webdings\",         \"Wingdings\",         \"Wingdings 2\",         \"Wingdings 3\",         \"Zapf Dingbats\",                  \"Bookshelf Symbol\"                  )));               FontCollectionNode others = new FontCollectionNode(labels.getString(\"FontCollection.other\"));     HashSet<FontFamilyNode> otherFamilySet = new HashSet<FontFamilyNode>();     otherFamilySet.addAll(families);     for (int i = 1, n = root.getChildCount(); i < n; i++) {       FontCollectionNode fcn = (FontCollectionNode) root.getChildAt(i);       for (FontFamilyNode ffn : fcn.families()) {         otherFamilySet.remove(ffn);       }     }     ArrayList<FontFamilyNode> otherFamilies = new ArrayList<FontFamilyNode>();     for (FontFamilyNode ffn : otherFamilySet) {       otherFamilies.add(ffn.clone());     }     Collections.sort(otherFamilies);     others.addAll(otherFamilies);     root.add(others);     fireTreeStructureChanged(this, new TreePath(root));}", "nl": "Sets the fonts of the DefaultFontChooserModel"}
{"code": "public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {     this(pathPrototype, bezierPrototype, null);}", "nl": "Creates a new instance"}
{"code": "@SuppressWarnings(\"unchecked\")   public ODGPropertiesPanel() {     initComponents();          opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);     opacityPopupButton.add(opacitySlider);     opacityPopupButton.putClientProperty(\"JButton.buttonType\",\"toolbar\");     add(opacityPopupButton);     opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));     opacityFieldHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacityField, editor);     opacitySliderHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacitySlider, editor);     linkFieldHandler = new FigureAttributeEditorHandler<String>(LINK, linkField, editor);               Font font = getFont().deriveFont(11f);     for (Component c : getComponents()) {       c.setFont(font);     }     opacitySlider.setFont(font);}", "nl": "Creates new instance"}
{"code": "public ODGBezierFigure() {     this(false);}", "nl": "Creates a new instance"}
{"code": "public CombineAction(DrawingEditor editor) {     super(editor, new ODGPathFigure());     labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.odg.Labels\");     labels.configureAction(this, ID);}", "nl": "Creates a new instance"}
{"code": "public static ComponentUI createUI(JComponent c) {     return new PaletteFormattedTextFieldUI();}", "nl": "Creates a UI for a JTextField"}
{"code": "public void setRubberbandColor(Color c) {     rubberbandColor = c;}", "nl": "Sets the rubberband color for the tool"}
{"code": "@Override   public void mousePressed(MouseEvent e) {     TextHolderFigure textHolder = null;                         DrawingView v = getView();     Point2D.Double p = v.viewToDrawing(e.getPoint());     Figure pressedFigure = null;     if (true ) {       for (Figure f : v.getSelectedFigures()) {         if (f.contains(p)) {           pressedFigure = f;           break;         }       }     }               if (pressedFigure == null) {       pressedFigure = getDrawing().findFigureInside(p);     }          if (pressedFigure instanceof TextHolderFigure) {       textHolder = (TextHolderFigure) pressedFigure;         textHolder = null;     }     if (textHolder != null) {       createdFigure = null;       beginEdit(textHolder);       return;     }     if (typingTarget != null) {       endEdit();       if (isToolDoneAfterCreation()) {         fireToolDone();       }     } else {       super.mousePressed(e);}}", "nl": "Creates a new figure at the mouse location"}
{"code": "public MultiIcon(Image[] images) {     this.icons = new Icon[images.length];     for (int i=0, n = icons.length; i < n; i++) {       if (images[i] != null) {         icons[i] = new ImageIcon(images[i]);       }     }     generateMissingIcons();}", "nl": "Creates a new instance from an array of images"}
{"code": "public void add(Point2D.Double c0) {     add(new Node(0, c0, c0, c0));}", "nl": "Convenience method for adding a control point with a single coordinate C0"}
{"code": "public double getRelativePositionOnPath(Point2D.Double find, double flatness) {          double len = getLengthOfPath(flatness);     double relativeLen = 0d;     Node v1, v2;     BezierPath tempPath = new BezierPath();     Node t1, t2;     tempPath.add(t1 = new Node());     tempPath.add(t2 = new Node());     for (int i = 0, n = size() - 1; i < n; i++) {       v1 = get(i);       v2 = get(i + 1);       if (v1.mask == 0 && v2.mask == 0) {         if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {           relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);           return relativeLen / len;         } else {           relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);         }       } else {         t1.setTo(v1);         t2.setTo(v2);         tempPath.invalidatePath();         if (tempPath.outlineContains(find, flatness)) {           relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);           return relativeLen / len;         } else {           relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);         }       }     }     if (isClosed && size() > 1) {       v1 = get(size() - 1);       v2 = get(0);       if (v1.mask == 0 && v2.mask == 0) {         if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {           relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);           return relativeLen / len;         }       } else {         t1.setTo(v1);         t2.setTo(v2);         tempPath.invalidatePath();         if (tempPath.outlineContains(find, flatness)) {           relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);           return relativeLen / len;         }       }     }     return -1;}", "nl": "Returns the relative position of the specified point on the path"}
{"code": "public BezierPath clone() {     BezierPath that = (BezierPath) super.clone();     for (int i = 0, n = this.size(); i < n; i++) {       that.set(i, (Node) this.get(i).clone());     }     return that;}", "nl": "Creates a deep copy of the BezierPath"}
{"code": "public Point2D.Double getCenter() {     double sx = 0;     double sy = 0;     for (Node p : this) {       sx += p.x[0];       sy += p.y[0];     }     int n = size();     return new Point2D.Double(sx / n, sy / n);}", "nl": "Returns the point at the center of the bezier path"}
{"code": "public int splitSegment(Point2D.Double split, double tolerance) {     int i = findSegment(split, tolerance);     int nextI = (i + 1) % size();     if (i != -1) {       if ((get(i).mask & C2_MASK) == C2_MASK           && (get(nextI).mask & C1_MASK) == 0) {                  add(i + 1, new Node(C2_MASK, split, split, split));       } else if ((get(i).mask & C2_MASK) == 0           && (get(nextI).mask & C1_MASK) == C1_MASK) {                  add(i + 1, new Node(C1_MASK, split, split, split));       } else if ((get(i).mask & C2_MASK) == C2_MASK           && (get(nextI).mask & C1_MASK) == C1_MASK) {                  add(i + 1, new Node(C1_MASK | C2_MASK, split, split, split));       } else {                  add(i + 1, new Node(split));       }     }     return i + 1;}", "nl": "Splits the segment at the given Point2D . Double if a segment was hit"}
{"code": "public static BezierPath fitBezierPath(BezierPath digitizedPoints, double error) {     ArrayList<Point2D.Double> d = new ArrayList<Point2D.Double>(digitizedPoints.size());     for (BezierPath.Node n : digitizedPoints) {       d.add(new Point2D.Double(n.x[0], n.y[0]));     }     return fitBezierPath(d, error);}", "nl": "Fits a bezier path to the specified list of digitized points"}
{"code": "private static double v2Length(Point2D.Double a) {     return Math.sqrt(v2SquaredLength(a));}", "nl": "Returns length of input vector"}
{"code": "private static Point2D.Double v2Scale(Point2D.Double v, double newlen) {     double len = v2Length(v);     if (len != 0.0) {       v.x *= newlen / len;       v.y *= newlen / len;     }     return v;}", "nl": "Scales the input vector to the new length and returns it"}
{"code": "public static ArrayList<Integer> findCorners(java.util.List<Point2D.Double> digitizedPoints, double minAngle, double minDistance) {     ArrayList<Integer> cornerIndices = new ArrayList<Integer>();     double squaredDistance = minDistance * minDistance;     int previousCorner = -1;     double previousCornerAngle = 0;     for (int i = 1, n = digitizedPoints.size(); i < n - 1; i++) {       Point2D.Double p = digitizedPoints.get(i);              Point2D.Double prev = null;       boolean intersectsPreviousCorner = false;       for (int j = i - 1; j >= 0; j--) {         if (j == previousCorner || v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {           prev = digitizedPoints.get(j);           intersectsPreviousCorner = j < previousCorner;           break;         }       }       if (prev == null) {         continue;       }              Point2D.Double next = null;       for (int j = i + 1; j < n; j++) {         if (v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {           next = digitizedPoints.get(j);           break;         }       }       if (next == null) {         continue;       }       double aPrev = Math.atan2(prev.y - p.y, prev.x - p.x);       double aNext = Math.atan2(next.y - p.y, next.x - p.x);       double angle = Math.abs(aPrev - aNext);       if (angle < Math.PI - minAngle || angle > Math.PI + minAngle) {         if (intersectsPreviousCorner) {           cornerIndices.set(cornerIndices.size() - 1, i);         } else {           cornerIndices.add(i);         }         previousCorner = i;         previousCornerAngle = angle;       }     }     return cornerIndices;}", "nl": "Finds corners in the provided point list , and returns their indices"}
{"code": "private static Point2D.Double[] generateBezier(ArrayList<Point2D.Double> d, int first, int last, double[] uPrime, Point2D.Double tHat1, Point2D.Double tHat2) {     Point2D.Double[] bezCurve;     bezCurve = new Point2D.Double[4];     for (int i = 0; i < bezCurve.length; i++) {       bezCurve[i] = new Point2D.Double();     }           double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;     bezCurve[0] = d.get(first);     bezCurve[3] = d.get(last);     v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);     v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);     return (bezCurve);}", "nl": "Use least - squares method to find Bezier control points for region"}
{"code": "private static ArrayList<Point2D.Double> removeCoincidentPoints(java.util.List<Point2D.Double> digitizedPoints) {     java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();     if (digitizedPoints.size() > 0) {       Point2D.Double prev = digitizedPoints.get(0);       cleaned.add(prev);       for (Point2D.Double p : digitizedPoints) {         if (!prev.equals(p)) {           cleaned.add(p);           prev = p;         }       }     }     return cleaned;}", "nl": "Removes sequences of coincident points"}
{"code": "public int getWindingRule() {     return path.getWindingRule();}", "nl": "Return the winding rule for determining the interior of the path"}
{"code": "public int currentSegment(float[] coords) {     int numCoords = 0;     int type = 0;     if (index == path.size()) {              if (path.size() > 1) {         BezierPath.Node previous = path.get(path.size() - 1);         BezierPath.Node current = path.get(0);                  if ((previous.mask & BezierPath.C2_MASK) == 0) {           if ((current.mask & BezierPath.C1_MASK) == 0) {             numCoords = 1;             type = SEG_LINETO;             coords[0] = (float) current.x[0];             coords[1] = (float) current.y[0];           } else {             numCoords = 2;             type = SEG_QUADTO;             coords[0] = (float) current.x[1];             coords[1] = (float) current.y[1];             coords[2] = (float) current.x[0];             coords[3] = (float) current.y[0];           }         } else {           if ((current.mask & BezierPath.C1_MASK) == 0) {             numCoords = 2;             type = SEG_QUADTO;             coords[0] = (float) previous.x[2];             coords[1] = (float) previous.y[2];             coords[2] = (float) current.x[0];             coords[3] = (float) current.y[0];           } else {             numCoords = 3;             type = SEG_CUBICTO;             coords[0] = (float) previous.x[2];             coords[1] = (float) previous.y[2];             coords[2] = (float) current.x[1];             coords[3] = (float) current.y[1];             coords[4] = (float) current.x[0];             coords[5] = (float) current.y[0];           }         }       }     } else if (index > path.size()) {              return SEG_CLOSE;     } else if (index == 0) {       BezierPath.Node current = path.get(index);       coords[0] = (float) current.x[0];       coords[1] = (float) current.y[0];       numCoords = 1;       type = SEG_MOVETO;            } else if (index < path.size()) {       BezierPath.Node current = path.get(index);       BezierPath.Node previous = path.get(index - 1);              if ((previous.mask & BezierPath.C2_MASK) == 0) {         if ((current.mask & BezierPath.C1_MASK) == 0) {           numCoords = 1;           type = SEG_LINETO;           coords[0] = (float) current.x[0];           coords[1] = (float) current.y[0];                    } else {           numCoords = 2;           type = SEG_QUADTO;           coords[0] = (float) current.x[1];           coords[1] = (float) current.y[1];           coords[2] = (float) current.x[0];           coords[3] = (float) current.y[0];         }       } else {         if ((current.mask & BezierPath.C1_MASK) == 0) {           numCoords = 2;           type = SEG_QUADTO;           coords[0] = (float) previous.x[2];           coords[1] = (float) previous.y[2];           coords[2] = (float) current.x[0];           coords[3] = (float) current.y[0];         } else {           numCoords = 3;           type = SEG_CUBICTO;           coords[0] = (float) previous.x[2];           coords[1] = (float) previous.y[2];           coords[2] = (float) current.x[1];           coords[3] = (float) current.y[1];           coords[4] = (float) current.x[0];           coords[5] = (float) current.y[0];         }       }     }               if (affine != null) {       affine.transform(coords, 0, coords, 0, numCoords);     }     return type;}", "nl": "Returns the coordinates and type of the current path segment in the iteration"}
{"code": "public static boolean isRightTurn2D(Point.Double p1, Point.Double p2, Point.Double p3) {     if (p1.equals(p2)||p2.equals(p3)) {              return false;     }          double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);     return val > 0;}", "nl": "Returns true , if the three given points make a right turn"}
{"code": "public static boolean isRightTurn(Point p1, Point p2, Point p3) {     if (p1.equals(p2)||p2.equals(p3)) {              return false;     }     double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);     return val > 0;}", "nl": "Returns true , if the three given points make a right turn"}
{"code": "public boolean isSelectBehindEnabled() {     return isSelectBehindEnabled;}", "nl": "Returns the value of the selectBehindEnabled property"}
{"code": "protected SelectAreaTracker getSelectAreaTracker() {     if (selectAreaTracker == null) {       selectAreaTracker = new DefaultSelectAreaTracker();     }     return selectAreaTracker;}", "nl": "Method to get a SelectAreaTracker which handles user interaction for selecting an area on the drawing"}
{"code": "protected Drawing createDrawing() {     Drawing drawing = new QuadTreeDrawing();     DOMStorableInputOutputFormat ioFormat =         new DOMStorableInputOutputFormat(new DrawFigureFactory());          drawing.addInputFormat(ioFormat);     ImageFigure prototype = new ImageFigure();     drawing.addInputFormat(new ImageInputFormat(prototype));     drawing.addInputFormat(new TextInputFormat(new TextFigure()));     TextAreaFigure taf = new TextAreaFigure();     taf.setBounds(new Point2D.Double(10,10), new Point2D.Double(60,40));     drawing.addInputFormat(new TextInputFormat(taf));          drawing.addOutputFormat(ioFormat);     drawing.addOutputFormat(new ImageOutputFormat());     return drawing;}", "nl": "Creates a new Drawing for this view"}
{"code": "@SuppressWarnings(\"unchecked\")      private void initComponents() {     setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);     pack();}", "nl": "This method is called from within the constructor to initialize the form"}
{"code": "private void initComponents() {     toolButtonGroup = new javax.swing.ButtonGroup();     drawingPanel = new org.jhotdraw.samples.draw.DrawingPanel();     jToolBar1 = new javax.swing.JToolBar();     loadButton = new javax.swing.JButton();     saveButton = new javax.swing.JButton();     FormListener formListener = new FormListener();     getContentPane().add(drawingPanel, java.awt.BorderLayout.CENTER);     jToolBar1.setFloatable(false);     loadButton.setText(\"Laden\");     loadButton.addActionListener(formListener);     jToolBar1.add(loadButton);     saveButton.setText(\"Speichern\");     saveButton.addActionListener(formListener);     jToolBar1.add(saveButton);     getContentPane().add(jToolBar1, java.awt.BorderLayout.SOUTH);}", "nl": "This method is called from within the init method to initialize the form"}
{"code": "public void init() {               try {       UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());     } catch (Throwable e) {                          }               Container c = getContentPane();     c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));     String[] lines = getAppletInfo().split(\"\\n\");     for (int i = 0; i < lines.length; i++) {       c.add(new JLabel(lines[i]));     }               new Worker<Drawing>() {       protected Drawing construct() throws IOException {         Drawing result;         if (getParameter(\"data\") != null && getParameter(\"data\").length() > 0) {           NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), new StringReader(getParameter(\"data\")));           result = (Drawing) domi.readObject(0);         } else if (getParameter(\"datafile\") != null) {           InputStream in = null;           try {             URL url = new URL(getDocumentBase(), getParameter(\"datafile\"));             in = url.openConnection().getInputStream();             NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), in);             result = (Drawing) domi.readObject(0);           } finally {             if (in != null) {               in.close();             }           }         } else {           result = null;         }         return result;       }       protected void done(Drawing result) {         Container c = getContentPane();         c.setLayout(new BorderLayout());         c.removeAll();         initComponents();         if (result != null) {           setDrawing(result);         }       }       @Override       protected void failed(Throwable result) {         Container c = getContentPane();         c.setLayout(new BorderLayout());         c.removeAll();         initComponents();         getDrawing().add(new TextFigure(result.toString()));         result.printStackTrace();       }       protected void finished() {         Container c = getContentPane();         boolean isLiveConnect;         try {           Class.forName(\"netscape.javascript.JSObject\");           isLiveConnect = true;         } catch (Throwable t) {           isLiveConnect = false;         }         loadButton.setEnabled(isLiveConnect && getParameter(\"dataread\") != null);         saveButton.setEnabled(isLiveConnect && getParameter(\"datawrite\") != null);         if (isLiveConnect) {           String methodName = getParameter(\"dataread\");           JSObject win = JSObject.getWindow(DrawLiveConnectApplet.this);           Object data = win.call(methodName, new Object[0]);           if (data instanceof String) {             setData((String) data);           }         }         c.validate();       }     }.start();}", "nl": "Initializes the applet DrawApplet"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public ProgressIndicator() {     this(null, null);}", "nl": "Creates new instance"}
{"code": "public int getMinimum() {     return progressModel.getMinimum();}", "nl": "Returns the minimum value - - the lower end of the progress value"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public int getDefaultPropertyIndex() {     return defaultPropertyIndex;}", "nl": "A bean may have a default property that is the property that will mostly commonly be initially chosen for update by human ' s who are customizing the bean"}
{"code": "public TextAreaFigure() {     this(ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\").         getString(\"TextFigure.defaultText\"));}", "nl": "Creates a new instance"}
{"code": "public String getText() {     return (String) get(TEXT);}", "nl": "Gets the text shown by the text figure"}
{"code": "private ODGFigure readPolygonElement(IXMLElement elem)       throws IOException {     AffineTransform viewBoxTransform = readViewBoxTransform(elem);     String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute(\"points\", DRAWING_NAMESPACE, null));     Point2D.Double[] points = new Point2D.Double[coords.length / 2];     for (int i = 0; i < coords.length; i += 2) {       Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));       points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);     }     String styleName = elem.getAttribute(\"style-name\", DRAWING_NAMESPACE, null);     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     a.putAll(styles.getAttributes(styleName, \"graphic\"));     readCommonDrawingShapeAttributes(elem, a);     ODGFigure f = createPolygonFigure(points, a);     return f;}", "nl": "The & lt ; draw : polygon & gt ; element represents a polygon"}
{"code": "public java.util.List<Figure> sort(Collection<Figure> c) {     ensureSorted();     ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());     for (Figure f : children) {       if (c.contains(f)) {         sorted.add(f);       }     }     return sorted;}", "nl": "Implementation note : Sorting can not be done for orphaned children"}
{"code": "private CompositeFigure createGroupFigure()       throws IOException {     ODGGroupFigure figure = new ODGGroupFigure();     return figure;}", "nl": "Creates a ODGGroupFigure"}
{"code": "private void readDrawingElement(IXMLElement elem)       throws IOException {          for (IXMLElement node : elem.getChildren()) {       if (node instanceof IXMLElement) {         IXMLElement child = (IXMLElement) node;         if (child.getNamespace() == null ||             child.getNamespace().equals(DRAWING_NAMESPACE)) {           String name = child.getName();           if (name.equals(\"page\")) {             readPageElement(child);}}}}}", "nl": "Reads an ODG office : drawing element"}
{"code": "@Override   public Tool getTool(Point2D.Double p) {     if (isEditable() && contains(p)) {       TextEditingTool t = new TextEditingTool(this);       return t;     }     return null;}", "nl": "Returns a specialized tool for the given coordinate"}
{"code": "public String getText() {     return get(TEXT);}", "nl": "Gets the text shown by the text figure"}
{"code": "public RoundRectangleFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "@SuppressWarnings(\"unchecked\")   public void readFiguresFromDocumentContent(InputStream in, Drawing drawing, boolean replace) throws IOException {     this.figures = new LinkedList<Figure>();     IXMLParser parser;     try {       parser = XMLParserFactory.createDefaultXMLParser();     } catch (Exception ex) {       InternalError e = new InternalError(\"Unable to instantiate NanoXML Parser\");       e.initCause(ex);       throw e;     }     IXMLReader reader = new StdXMLReader(in);     parser.setReader(reader);     try {       document = (IXMLElement) parser.parse();     } catch (XMLException ex) {       IOException e = new IOException(ex.getMessage());       e.initCause(ex);       throw e;     }     if (styles == null) {       styles = new ODGStylesReader();     }     styles.read(document);                IXMLElement drawingElem = document;     Stack<Iterator> stack = new Stack<Iterator>();     LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();     ll.add(document);     stack.push(ll.iterator());     while (!stack.empty() && stack.peek().hasNext()) {       Iterator<IXMLElement> iter = stack.peek();       IXMLElement node = iter.next();       Iterator<IXMLElement> children = node.getChildren().iterator();       if (!iter.hasNext()) {         stack.pop();       }       if (children.hasNext()) {         stack.push(children);       }       if (node.getName() != null &&           node.getName().equals(\"drawing\") &&           (node.getNamespace() == null ||           node.getNamespace().equals(OFFICE_NAMESPACE))) {         drawingElem = node;         break;       }     }     if (drawingElem.getName() == null ||         !drawingElem.getName().equals(\"drawing\") ||         (drawingElem.getNamespace() != null &&         !drawingElem.getNamespace().equals(OFFICE_NAMESPACE))) {       throw new IOException(\"'office:drawing' element expected: \" + drawingElem.getName());     }     readDrawingElement(drawingElem);     if (replace) {       drawing.removeAllChildren();     }     drawing.addAll(figures);}", "nl": "Reads figures from the content . xml file of an ODG open document drawing document"}
{"code": "@Override   public void transform(AffineTransform tx) {     super.transform(tx);     updateConnection();}", "nl": "Ensures that a connection is updated if the connection was moved"}
{"code": "@Override   public Collection<Handle> createHandles(int detailLevel) {     ArrayList<Handle> handles = new ArrayList<Handle>(getNodeCount());     switch (detailLevel) {       case -1:          handles.add(new BezierOutlineHandle(this, true));         break;       case 0:         handles.add(new BezierOutlineHandle(this));         if (getLiner() == null) {           for (int i = 1, n = getNodeCount() - 1; i < n; i++) {             handles.add(new BezierNodeHandle(this, i));           }         }         handles.add(new ConnectionStartHandle(this));         handles.add(new ConnectionEndHandle(this));         break;     }     return handles;}", "nl": "Gets the handles of the figure"}
{"code": "public ODGPathFigure() {     add(new ODGBezierFigure());     ODGAttributeKeys.setDefaults(this);}", "nl": "Creates a new instance"}
{"code": "public AlignAction(DrawingEditor editor) {     super(editor);}", "nl": "Creates a new instance"}
{"code": "public TriangleFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public boolean contains(Point2D.Double p) {     Shape triangle = getBezierPath();          double grow = AttributeKeys.getPerpendicularHitGrowth(this);     if (grow != 0d) {       GrowStroke gs = new GrowStroke((float) grow,           (float) (AttributeKeys.getStrokeTotalWidth(this) *           get(STROKE_MITER_LIMIT))           );       triangle =gs.createStrokedShape(triangle);     }     return triangle.contains(p);}", "nl": "Checks if a Point2D . Double is inside the figure"}
{"code": "public boolean isUpdatEnabledState() {     return eventHandler != null;}", "nl": "Returns true , if this action automatically updates its enabled state to reflect the enabled state of the active DrawingView"}
{"code": "public AbstractSelectedAction(DrawingEditor editor) {     setEditor(editor);     updateEnabledState();}", "nl": "Creates an action which acts on the selected figures on the current view of the specified editor"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public void setImageData(byte[] imageData) {     willChange();     this.imageData = imageData;     this.bufferedImage = null;     changed();}", "nl": "Sets the image data"}
{"code": "public MethodDescriptor[] getMethodDescriptors() {     return getMdescriptor();}", "nl": "Gets the bean ' s MethodDescriptors"}
{"code": "public void transform(AffineTransform tx) {     if (get(TRANSFORM) != null ||         (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {       if (get(TRANSFORM) == null) {         TRANSFORM.setClone(this, tx);       } else {         AffineTransform t = TRANSFORM.getClone(this);         t.preConcatenate(tx);         set(TRANSFORM,  t);       }     } else {       Point2D.Double anchor = getStartPoint();       Point2D.Double lead = getEndPoint();       setBounds(           (Point2D.Double) tx.transform(anchor, anchor),           (Point2D.Double) tx.transform(lead, lead));       if (get(FILL_GRADIENT) != null &&           !get(FILL_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = FILL_GRADIENT.getClone(this);         g.transform(tx);         set(FILL_GRADIENT,  g);       }       if (get(STROKE_GRADIENT) != null &&           !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {         Gradient g = STROKE_GRADIENT.getClone(this);         g.transform(tx);         set(STROKE_GRADIENT,  g);       }     }     invalidate();}", "nl": "Transforms the figure"}
{"code": "public CanvasToolBar() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(getID() + \".toolbar\"));     setDisclosureStateCount(3);}", "nl": "Creates new instance"}
{"code": "public void setArcHeight(double newValue) {     double oldValue = roundrect.archeight;     roundrect.archeight = newValue;     firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);}", "nl": "Sets the arc height"}
{"code": "public SVGRectFigure() {     this(0, 0, 0, 0);}", "nl": "Creates a new instance"}
{"code": "public void setArcWidth(double newValue) {     double oldValue = roundrect.arcwidth;     roundrect.arcwidth = newValue;     firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);}", "nl": "Sets the arc width"}
{"code": "public int getDefaultEventIndex() {     return defaultEventIndex;}", "nl": "A bean may have a default event that is the event that will mostly commonly be used by human ' s when using the bean"}
{"code": "public Dimension2DDouble getPreferredTextSize(double maxWidth) {     Rectangle2D.Double textRect = new Rectangle2D.Double();     if (getText() != null) {       Font font = getFont();       boolean isUnderlined = get(FONT_UNDERLINE);       float leftMargin = 0;       float rightMargin = (float) maxWidth - 1;       float verticalPos = 0;       float maxVerticalPos = Float.MAX_VALUE;       if (leftMargin < rightMargin) {         float tabWidth = (float) (getTabSize() * font.getStringBounds(\"m\", getFontRenderContext()).getWidth());         float[] tabStops = new float[(int) (textRect.width / tabWidth)];         for (int i = 0; i < tabStops.length; i++) {           tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));         }         if (getText() != null) {           String[] paragraphs = getText().split(\"\\n\");           for (int i = 0; i < paragraphs.length; i++) {             if (paragraphs[i].length() == 0) {               paragraphs[i] = \" \";             }             AttributedString as = new AttributedString(paragraphs[i]);             as.addAttribute(TextAttribute.FONT, font);             if (isUnderlined) {               as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);             }             int tabCount = paragraphs[i].split(\"\\t\").length - 1;             Rectangle2D.Double paragraphBounds = appendParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);             verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);             textRect.add(paragraphBounds);           }         }       }     }     return new Dimension2DDouble(Math.abs(textRect.x) + textRect.width, Math.abs(textRect.y) + textRect.height);}", "nl": "Returns the preferred text size of the TextAreaFigure"}
{"code": "public Insets2D.Double getInsets() {     double sw = (get(STROKE_COLOR) == null) ? 0 : Math.ceil(get(STROKE_WIDTH) / 2);     Insets2D.Double insets = new Insets2D.Double(0, 0, 0, 0);     return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);}", "nl": "Returns the insets used to draw text"}
{"code": "public SVGTextFigure() {     this(\"Text\");}", "nl": "Creates a new instance"}
{"code": "public void setText(String newText) {     set(TEXT, newText);}", "nl": "Sets the text shown by the text figure"}
{"code": "public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {     this(editor, key, null, icon);}", "nl": "Creates a new instance"}
{"code": "public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {     this(editor, key, null, null);}", "nl": "Creates a new instance"}
{"code": "public boolean isBorderOpaque() {     return false;}", "nl": "Returns true if the border is opaque"}
{"code": "public Action getRedoAction() {     return redoAction;}", "nl": "Gets the redo action for use as a Redo menu item"}
{"code": "public CompositeEdit(boolean isSignificant) {     this.isSignificant = isSignificant;}", "nl": "Creates a new CompositeEdit which uses the specified significance"}
{"code": "public boolean addEdit(UndoableEdit anEdit) {     if (anEdit == this) {         end();       return true;     } else if (isInProgress() && (anEdit instanceof CompositeEdit)) {       return true;     } else {       return super.addEdit(anEdit);}}", "nl": "If this edit is inProgress , accepts anEdit and returns true"}
{"code": "public static Object invoke(Object obj, String methodName, float newValue)   throws NoSuchMethodException {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[] { Float.TYPE} );       return method.invoke(obj, new Object[] { new Float(newValue)});     } catch (IllegalAccessException e) {       throw new NoSuchMethodException(methodName+\" is not accessible\");     } catch (InvocationTargetException e) {              throw new InternalError(e.getMessage());}}", "nl": "Invokes the specified setter method if it exists"}
{"code": "public static Object invoke(Object obj, String methodName, boolean newValue)   throws NoSuchMethodException {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[] { Boolean.TYPE} );        return method.invoke(obj, new Object[] { new Boolean(newValue)});     } catch (IllegalAccessException e) {       throw new NoSuchMethodException(methodName+\" is not accessible\");     } catch (InvocationTargetException e) {              throw new InternalError(e.getMessage());}}", "nl": "Invokes the specified setter method if it exists"}
{"code": "public static Object invoke(Object obj, String methodName)   throws NoSuchMethodException {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[0]);       Object result = method.invoke(obj, new Object[0]);       return result;     } catch (IllegalAccessException e) {       throw new NoSuchMethodException(methodName+\" is not accessible\");     } catch (InvocationTargetException e) {              throw new InternalError(e.getMessage());}}", "nl": "Invokes the specified accessible parameterless method if it exists"}
{"code": "public static long invokeGetter(Object obj, String methodName, long defaultValue) {     try {       Method method =  obj.getClass().getMethod(methodName,  new Class[0]);       Object result = method.invoke(obj, new Object[0]);       return ((Long) result).longValue();     } catch (NoSuchMethodException e) {       return defaultValue;     } catch (IllegalAccessException e) {       return defaultValue;     } catch (InvocationTargetException e) {       return defaultValue;}}", "nl": "Invokes the specified getter method if it exists"}
{"code": "public ResourceBundleUtil(String baseName, Locale locale) {     this.locale = locale;     this.baseName = baseName;     this.resource = ResourceBundle.getBundle(baseName, locale);}", "nl": "Creates a new ResouceBundleUtil which wraps the provided resource bundle"}
{"code": "public char getMnemonic(String key) {     String s = getStringRecursive(key);     return (s == null || s.length() == 0) ? '\\0' : s.charAt(0);}", "nl": "Get a Mnemonic from the ResourceBundle"}
{"code": "public static ResourceBundleUtil getBundle(String baseName, Locale locale)       throws MissingResourceException {     ResourceBundleUtil r;     r = new ResourceBundleUtil(baseName, locale);     return r;}", "nl": "Get the appropriate ResourceBundle subclass"}
{"code": "public ResourceBundle getWrappedBundle() {     return resource;}", "nl": "Returns the wrapped resource bundle"}
{"code": "public Integer getInteger(String key) {     try {       return Integer.valueOf(getStringRecursive(key));     } catch (MissingResourceException e) {       if (isVerbose) {         System.err.println(\"Warning ResourceBundleUtil[\" + baseName + \"] \\\"\" + key + \"\\\" not found.\");                }       return new Integer(-1);}}", "nl": "Get an Integer from the ResourceBundle"}
{"code": "public String getFormatted(String key, Object... arguments) {     return MessageFormat.format(getString(key), arguments);}", "nl": "Returns a formatted string using javax . text . MessageFormat"}
{"code": "private void initActions() {     getActionMap().put(UndoAction.ID, undo.getUndoAction());     getActionMap().put(RedoAction.ID, undo.getRedoAction());}", "nl": "Initializes view specific actions"}
{"code": "public void write(URI f, URIChooser chooser) throws IOException {       Drawing drawing = view.getDrawing();       OutputFormat outputFormat = drawing.getOutputFormats().get(0);       outputFormat.write(new File(f), drawing);}", "nl": "Writes the view to the specified uri"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public static Paint getFillPaint(Figure f) {     double opacity = f.get(FILL_OPACITY);     if (f.get(FILL_GRADIENT) != null) {       return f.get(FILL_GRADIENT).getPaint(f, opacity);     }     Color color = f.get(FILL_COLOR);     if (color != null) {       if (opacity != 1) {         color = new Color(             (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,             true);       }     }     return color;}", "nl": "Gets the fill paint for the specified figure based on the attributes FILL _ GRADIENT , FILL _ OPACITY , FILL _ PAINT and the bounds of the figure"}
{"code": "public static void setDefaults(Figure f) {          f.set(FILL_COLOR, Color.black);     f.set(WINDING_RULE, WindingRule.NON_ZERO);               f.set(STROKE_COLOR, null);     f.set(STROKE_WIDTH, 1d);     f.set(STROKE_CAP, BasicStroke.CAP_BUTT);     f.set(STROKE_JOIN, BasicStroke.JOIN_MITER);     f.set(STROKE_MITER_LIMIT, 4d);     f.set(IS_STROKE_MITER_LIMIT_FACTOR, false);     f.set(STROKE_DASHES, null);     f.set(STROKE_DASH_PHASE, 0d);     f.set(IS_STROKE_DASH_FACTOR, false);}", "nl": "Sets ODG default values"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "@Override   public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public FontToolBar() {     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.svg.Labels\");     setName(labels.getString(\"font.toolbar\"));     JFontChooser.loadAllFonts();     setDisclosureStateCount(3);}", "nl": "Creates new instance"}
{"code": "public void addText(String text) {     String old = current.getContent();     if (old == null) {       current.setContent(text);     } else {       current.setContent(old+text);}}", "nl": "Adds a text to current element of the DOM Document"}
{"code": "public void openElement(String tagName) {     XMLElement newElement = new XMLElement();     newElement.setName(tagName);     current.addChild(newElement);     stack.push(current);     current = newElement;}", "nl": "Puts a new element into the DOM Document"}
{"code": "public void openElement(String tagName) {     int count = 0;     NodeList list = current.getChildNodes();     int len = list.getLength();     for (int i=0; i < len; i++) {       Node node = list.item(i);       if ((node instanceof Element)       && ((Element) node).getTagName().equals(tagName)) {         current = node;         return;       }     }     throw new IllegalArgumentException(\"element not found:\"+tagName);}", "nl": "Opens the last element with the specified name and makes it the current node"}
{"code": "protected static DocumentBuilder getBuilder() throws IOException {     if (documentBuilder == null) {       DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();       factory.setNamespaceAware(true);       factory.setValidating(false);       factory.setXIncludeAware(false);       try {         factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);         documentBuilder = factory.newDocumentBuilder();       } catch (Exception ex) {         InternalError error = new InternalError(\"Unable to create DocumentBuilder\");         error.initCause(ex);         throw error;       }     }     return documentBuilder;}", "nl": "Lazily create the document builder and keep a reference to it for performance improvement"}
{"code": "public int getAttribute(String name, int defaultValue) {     String value = ((Element) current).getAttribute(name);     return (value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public String getAttribute(String name, String defaultValue) {     String value = ((Element) current).getAttribute(name);     return (value.length() == 0) ? defaultValue : value;}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public void openElement(String tagName) {     Element newElement = document.createElement(tagName);     current.appendChild(newElement);     current = newElement;}", "nl": "Puts a new element into the DOM Document"}
{"code": "public void addAttribute(String name, int value) {     ((Element) current).setAttribute(name, Integer.toString(value));}", "nl": "Adds an attribute to current element of the DOM Document"}
{"code": "public String getTagName() {     return current.getName();}", "nl": "Returns the tag name of the current element"}
{"code": "public String getAttribute(String name, String defaultValue) {     String value = (String) current.getAttribute(name);     return (value == null || value.length() == 0) ? defaultValue : value;}", "nl": "Gets an attribute of the current element of the DOM Document"}
{"code": "public void setParameter(String name, String filename, InputStream is) throws IOException {   boundary();   writeName(name);   write(\"; filename=\\\"\");   write(filename);   write('\"');   newline();   write(\"Content-Type: \");   String type = URLConnection.guessContentTypeFromName(filename);   if (type == null) type = \"application/octet-stream\";   writeln(type);   newline();   pipe(is, _os);   newline();}", "nl": "adds a file parameter to the request name file from IOException"}
{"code": "public ClientHttpRequest(URLConnection connection) throws IOException {   this._connection = connection;   connection.setDoOutput(true);   connection.setDoInput(true);   connection.setRequestProperty(\"Content-Type\",                   \"multipart/form-data; boundary=\" + boundary);}", "nl": "Creates a new multipart POST HTTP request on a freshly opened URLConnection connection IOException"}
{"code": "public void setParameter(String name, File file) throws IOException {   setParameter(name, file.getPath(), new FileInputStream(file));}", "nl": "adds a file parameter to the request name upload IOException"}
{"code": "public static InputStream post(URL url, Map parameters) throws IOException {   return new ClientHttpRequest(url).post(parameters);}", "nl": "posts a new request to specified URL , with parameters that are passed in the argument parameters @ return input stream with the server response IOException # setParameters"}
{"code": "public void setParameter(String name, String value) throws IOException {     if (name == null) {       throw new InvalidParameterException(\"setParameter(\"+name+\",\"+value+\") name must not be null\");     }     if (value == null) {       throw new InvalidParameterException(\"setParameter(\"+name+\",\"+value+\") value must not be null\");     }   boundary();   writeName(name);   newline(); newline();   writeln(value);}", "nl": "adds a string parameter to the request name value IOException"}
{"code": "public InputStream post(String[] cookies, Object[] parameters) throws IOException {   setCookies(cookies);   postCookies();   setParameters(parameters);   return doPost();}", "nl": "posts the requests to the server , with all the cookies and parameters that were added before , and with cookies and parameters that are passed in the arguments cookies parameters @ return input stream with the server response IOException # setParameters # setCookies"}
{"code": "public static InputStream post(URL url, Object[] parameters) throws IOException {   return new ClientHttpRequest(url).post(parameters);}", "nl": "posts a new request to specified URL , with parameters that are passed in the argument parameters @ return input stream with the server response IOException # setParameters"}
{"code": "public static InputStream post(URL url, String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {   return new ClientHttpRequest(url).post(name1, value1, name2, value2, name3, value3);}", "nl": "post the POST request to specified URL , with the specified parameters name1 first parameter name value1 first parameter value name2 second parameter name value2 second parameter value name3 third parameter name value3 third parameter value @ return input stream with the server response IOException # setParameter"}
{"code": "public List<TaskFigure> getSuccessors() {     LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();     for (DependencyFigure c : getDependencies()) {       if (c.getStartFigure() == this) {         list.add((TaskFigure) c.getEndFigure());       }     }     return list;}", "nl": "Returns dependent PertTasks which are directly connected via a PertDependency to this TaskFigure"}
{"code": "public List<TaskFigure> getPredecessors() {     LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();     for (DependencyFigure c : getDependencies()) {       if (c.getEndFigure() == this) {         list.add((TaskFigure) c.getStartFigure());       }     }     return list;}", "nl": "Returns predecessor PertTasks which are directly connected via a PertDependency to this TaskFigure"}
{"code": "public BeanDescriptor getBeanDescriptor() {     return getBdescriptor();}", "nl": "Gets the bean ' s BeanDescriptors"}
{"code": "private void readMasterPageElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {     if (DEBUG) {       System.out.println(\"ODGStylesReader unsupported <\" + elem.getName() + \"> element.\");}}", "nl": "Reads a & lt ; style : master - page & gt ; element from the specified XML element"}
{"code": "private void readLayerSetElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {     if (DEBUG) {       System.out.println(\"ODGStylesReader unsupported <\" + elem.getName() + \"> element.\");}}", "nl": "Reads a & lt ; draw : layer - put & gt ; element from the specified XML element"}
{"code": "public ODGStylesReader() {     reset();}", "nl": "Creates a new instance"}
{"code": "public java.util.List<JToolBar> createToolBars(Application a, View pr) {     ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle(\"org.jhotdraw.draw.Labels\");     ResourceBundleUtil labels = ResourceBundleUtil.getBundle(\"org.jhotdraw.samples.pert.Labels\");     PertView p = (PertView) pr;     DrawingEditor editor;     if (p == null) {       editor = getSharedEditor();     } else {       editor = p.getEditor();     }     LinkedList<JToolBar> list = new LinkedList<JToolBar>();     JToolBar tb;     tb = new JToolBar();     addCreationButtonsTo(tb, editor);     tb.setName(drawLabels.getString(\"window.drawToolBar.title\"));     list.add(tb);     tb = new JToolBar();     ButtonFactory.addAttributesButtonsTo(tb, editor);     tb.setName(drawLabels.getString(\"window.attributesToolBar.title\"));     list.add(tb);     tb = new JToolBar();     ButtonFactory.addAlignmentButtonsTo(tb, editor);     tb.setName(drawLabels.getString(\"window.alignmentToolBar.title\"));     list.add(tb);     return list;}", "nl": "Creates toolbars for the application"}
{"code": "public Matcher(Document document, String findString, boolean matchCase, MatchType matchType) {     this.document = document;     this.findString = findString;     startIndex = 0;               if (matchCase) {       matchLowerCase = matchUpperCase = findString.toCharArray();     } else {       matchUpperCase = findString.toUpperCase().toCharArray();       matchLowerCase = findString.toLowerCase().toCharArray();     }          this.matchType = matchType;}", "nl": "Creates a new instance of Matcher examined searched"}
{"code": "protected short getLeftInset() {     short left = super.getLeftInset();     return (viewFactory.isLineNumbersVisible()) ? (short) (left + NUMBERS_WIDTH) : left;}", "nl": "Gets the left inset"}
{"code": "@Override   public void write(URI f, URIChooser chooser) throws IOException {     Drawing drawing = view.getDrawing();     OutputFormat outputFormat = drawing.getOutputFormats().get(0);     outputFormat.write(new File(f), drawing);}", "nl": "Writes the view to the specified uri"}
{"code": "public JavaNumberFormatter(double min, double max, double scaleFactor, boolean allowsNullValue, boolean appendsDotZero) {     super();     setMinimum(min);     setMaximum(max);     setScaleFactor(scaleFactor);     setAllowsNullValue(allowsNullValue);     setAppendsDotZero(appendsDotZero);     setOverwriteMode(false);}", "nl": "Creates a NumberFormatter with the specified Format instance"}
{"code": "public static AbstractFormatterFactory createFormatterFactory(double min, double max, double scaleFactor) {     return createFormatterFactory(min, max, scaleFactor, false, false);}", "nl": "Convenience method for creating a formatter factory with a ScalableNumberFormatter and a Java - style DecimalFormat"}
{"code": "public void setLineSeparator(String lineSeparator) {     this.lineSeparator = lineSeparator;}", "nl": "Sets the line separator for the println methods"}
{"code": "public String getLineSeparator() {     return lineSeparator;}", "nl": "Gets the line separator of the println methods"}
{"code": "private Figure readSVGElement(IXMLElement elem)       throws IOException {          Viewport viewport = new Viewport();     String widthValue = readAttribute(elem, \"width\", \"100%\");     String heightValue = readAttribute(elem, \"height\", \"100%\");     viewport.width = toWidth(elem, widthValue);     viewport.height = toHeight(elem, heightValue);     if (readAttribute(elem, \"viewBox\", \"none\").equals(\"none\")) {       viewport.viewBox.width = viewport.width;       viewport.viewBox.height = viewport.height;     } else {       String[] viewBoxValues = toWSOrCommaSeparatedArray(readAttribute(elem, \"viewBox\", \"none\"));       viewport.viewBox.x = toNumber(elem, viewBoxValues[0]);       viewport.viewBox.y = toNumber(elem, viewBoxValues[1]);       viewport.viewBox.width = toNumber(elem, viewBoxValues[2]);       viewport.viewBox.height = toNumber(elem, viewBoxValues[3]);              if (widthValue.indexOf('%') > 0) {         viewport.width = viewport.viewBox.width;       }       if (heightValue.indexOf('%') > 0) {         viewport.height = viewport.viewBox.height;       }     }     if (viewportStack.size() == 1) {                     viewport.isPreserveAspectRatio = true;     } else {       viewport.isPreserveAspectRatio = !readAttribute(elem, \"preserveAspectRatio\", \"none\").equals(\"none\");     }     viewport.widthPercentFactor = viewport.viewBox.width / 100d;     viewport.heightPercentFactor = viewport.viewBox.height / 100d;     viewport.numberFactor = Math.min(         viewport.width / viewport.viewBox.width,         viewport.height / viewport.viewBox.height);     AffineTransform viewBoxTransform = new AffineTransform();     viewBoxTransform.translate(         -viewport.viewBox.x * viewport.width / viewport.viewBox.width,         -viewport.viewBox.y * viewport.height / viewport.viewBox.height);     if (viewport.isPreserveAspectRatio) {       double factor = Math.min(           viewport.width / viewport.viewBox.width,           viewport.height / viewport.viewBox.height);       viewBoxTransform.scale(factor, factor);     } else {       viewBoxTransform.scale(           viewport.width / viewport.viewBox.width,           viewport.height / viewport.viewBox.height);     }     viewportStack.push(viewport);     readViewportAttributes(elem, viewportStack.firstElement().attributes);           for (IXMLElement node : elem.getChildren()) {       if (node instanceof IXMLElement) {         IXMLElement child = (IXMLElement) node;         Figure childFigure = readElement(child);                  if (readAttribute(child, \"visibility\", \"visible\").equals(\"visible\") &&             !readAttribute(child, \"display\", \"inline\").equals(\"none\")) {           if (childFigure != null) {             childFigure.transform(viewBoxTransform);             figures.add(childFigure);           }         }       }     }     viewportStack.pop();     return null;}", "nl": "Reads an SVG svg element"}
{"code": "private double toDouble(IXMLElement elem, String value, double defaultValue, double min, double max) throws IOException {     try {       double d = Double.valueOf(value);       return Math.max(Math.min(d, max), min);     } catch (NumberFormatException e) {       return defaultValue;}}", "nl": "Reads a double attribute"}
{"code": "private void readDefsElement(IXMLElement elem)       throws IOException {     for (IXMLElement node : elem.getChildren()) {       if (node instanceof IXMLElement) {         IXMLElement child = (IXMLElement) node;         Figure childFigure = readElement(child);}}}", "nl": "Reads an SVG defs element"}
{"code": "private void readTransformAttribute(IXMLElement elem, HashMap<AttributeKey, Object> a)       throws IOException {     String value;     value = readAttribute(elem, \"transform\", \"none\");     if (!value.equals(\"none\")) {       TRANSFORM.put(a, toTransform(elem, value));}}", "nl": "Reads the transform attribute as specified in http : www . w3 . org TR SVGMobile12 coords . html # TransformAttribute"}
{"code": "private BezierPath[] toPath(IXMLElement elem, String str) throws IOException {     LinkedList<BezierPath> paths = new LinkedList<BezierPath>();     BezierPath path = null;     Point2D.Double p = new Point2D.Double();     Point2D.Double c1 = new Point2D.Double();     Point2D.Double c2 = new Point2D.Double();     StreamPosTokenizer tt;     if (toPathTokenizer == null) {       tt = new StreamPosTokenizer(new StringReader(str));       tt.resetSyntax();       tt.parseNumbers();       tt.parseExponents();       tt.parsePlusAsNumber();       tt.whitespaceChars(0, ' ');       tt.whitespaceChars(',', ',');       toPathTokenizer = tt;     } else {       tt = toPathTokenizer;       tt.setReader(new StringReader(str));     }      char nextCommand = 'M';     char command = 'M';     Commands:     while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {       if (tt.ttype > 0) {         command = (char) tt.ttype;       } else {         command = nextCommand;         tt.pushBack();       }       BezierPath.Node node;       switch (command) {         case 'M':                      if (path != null) {             paths.add(path);           }           path = new BezierPath();           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'M' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'M' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.moveTo(p.x, p.y);           nextCommand = 'L';           break;         case 'm':                      if (path != null) {             paths.add(path);           }           path = new BezierPath();           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'm' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'm' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.moveTo(p.x, p.y);           nextCommand = 'l';           break;         case 'Z':         case 'z':                      p.x = path.get(0).x[0];           p.y = path.get(0).y[0];                                 if (path.size() > 1) {             BezierPath.Node first = path.get(0);             BezierPath.Node last = path.get(path.size() - 1);             if (first.x[0] == last.x[0] &&                 first.y[0] == last.y[0]) {               if ((last.mask & BezierPath.C1_MASK) != 0) {                 first.mask |= BezierPath.C1_MASK;                 first.x[1] = last.x[1];                 first.y[1] = last.y[1];               }               path.remove(path.size() - 1);             }           }           path.setClosed(true);           break;         case 'L':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'L' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'L' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'L';           break;         case 'l':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'l' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'l' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'l';           break;         case 'H':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'H' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'H';           break;         case 'h':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'h' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'h';           break;         case 'V':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'V' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'V';           break;         case 'v':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'v' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.lineTo(p.x, p.y);           nextCommand = 'v';           break;         case 'C':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x1 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y1 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x2 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y2 coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'C' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 'C';           break;         case 'c':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx1 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy1 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx2 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy2 coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'c' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 'c';           break;         case 'S':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x2 coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y2 coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'S' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 'S';           break;         case 's':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx2 coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy2 coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           c2.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 's' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);           nextCommand = 's';           break;         case 'Q':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x1 coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y1 coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'Q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 'Q';           break;         case 'q':                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx1 coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.x = p.x + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy1 coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           c1.y = p.y + tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 'q' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 'q';           break;         case 'T':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'T' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'T' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 'T';           break;         case 't':                      node = path.get(path.size() - 1);           c1.x = node.x[0] * 2d - node.x[1];           c1.y = node.y[0] * 2d - node.y[1];           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dx coordinate missing for 't' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"dy coordinate missing for 't' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.quadTo(c1.x, c1.y, p.x, p.y);           nextCommand = 's';           break;          case 'A': {                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"rx coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }                                 double rx = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"ry coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double ry = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x-axis-rotation missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double xAxisRotation = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"large-arc-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean largeArcFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"sweep-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean sweepFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y = tt.nval;           path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);           nextCommand = 'A';           break;         }         case 'a': {                      if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"rx coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }                                 double rx = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"ry coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double ry = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x-axis-rotation missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           double xAxisRotation = tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"large-arc-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean largeArcFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"sweep-flag missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           boolean sweepFlag = tt.nval != 0;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"x coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.x += tt.nval;           if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {             throw new IOException(\"y coordinate missing for 'A' at position \" + tt.getStartPosition() + \" in \" + str);           }           p.y += tt.nval;           path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);           nextCommand = 'a';           break;         }         default:           if (DEBUG) {             System.out.println(\"SVGInputFormat.toPath aborting after illegal path command: \" + command + \" found in path \" + str);           }           break Commands;                }     }     if (path != null) {       paths.add(path);     }     return paths.toArray(new BezierPath[paths.size()]);}", "nl": "Returns a value as a BezierPath array"}
{"code": "private String readAttribute(IXMLElement elem, String attributeName, String defaultValue) {     if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {       String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);       if (value.equals(\"inherit\")) {         return readAttribute(elem.getParent(), attributeName, defaultValue);       } else {         return value;       }     } else if (elem.hasAttribute(attributeName)) {       String value = elem.getAttribute(attributeName, null);       if (value.equals(\"inherit\")) {         return readAttribute(elem.getParent(), attributeName, defaultValue);       } else {         return value;       }     } else {       return defaultValue;}}", "nl": "Reads an attribute that is not inherited , unless its value is inherit"}
{"code": "private void identifyElements(IXMLElement elem) {     identifiedElements.put(elem.getAttribute(\"id\"), elem);     identifiedElements.put(elem.getAttribute(\"xml:id\"), elem);     for (IXMLElement child : elem.getChildren()) {       identifyElements(child);}}", "nl": "Puts all elments with an id or an xml : id attribute into the hashtable identifiedElements"}
{"code": "public static String[] toCommaSeparatedArray(String str) throws IOException {     return str.split(\"\\\\s*,\\\\s*\");}", "nl": "Returns a value as a String array"}
{"code": "private double toLength(IXMLElement elem, String str, double percentFactor) throws IOException {     double scaleFactor = 1d;     if (str == null || str.length() == 0 || str.equals(\"none\")) {       return 0d;     }     if (str.endsWith(\"%\")) {       str = str.substring(0, str.length() - 1);       scaleFactor = percentFactor;     } else if (str.endsWith(\"px\")) {       str = str.substring(0, str.length() - 2);     } else if (str.endsWith(\"pt\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 1.25;     } else if (str.endsWith(\"pc\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 15;     } else if (str.endsWith(\"mm\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 3.543307;     } else if (str.endsWith(\"cm\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 35.43307;     } else if (str.endsWith(\"in\")) {       str = str.substring(0, str.length() - 2);       scaleFactor = 90;     } else if (str.endsWith(\"em\")) {       str = str.substring(0, str.length() - 2);              scaleFactor = toLength(elem, readAttribute(elem, \"font-size\", \"0\"), percentFactor);     } else {       scaleFactor = 1d;     }     return Double.parseDouble(str) * scaleFactor;}", "nl": "Returns a value as a length"}
{"code": "public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {     String[] result = str.split(\"(\\\\s*,\\\\s*|\\\\s+)\");     if (result.length == 1 && result[0].equals(\"\")) {       return new String[0];     } else {       return result;}}", "nl": "Returns a value as a String array"}
{"code": "private void readRadialGradientElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     double cx = toLength(elem, readAttribute(elem, \"cx\", \"0.5\"), 0.01);     double cy = toLength(elem, readAttribute(elem, \"cy\", \"0.5\"), 0.01);     double fx = toLength(elem, readAttribute(elem, \"fx\", readAttribute(elem, \"cx\", \"0.5\")), 0.01);     double fy = toLength(elem, readAttribute(elem, \"fy\", readAttribute(elem, \"cy\", \"0.5\")), 0.01);     double r = toLength(elem, readAttribute(elem, \"r\", \"0.5\"), 0.01);     boolean isRelativeToFigureBounds =         readAttribute(elem, \"gradientUnits\", \"objectBoundingBox\").equals(\"objectBoundingBox\");     ArrayList<IXMLElement> stops = elem.getChildrenNamed(\"stop\", SVG_NAMESPACE);     if (stops.size() == 0) {       stops = elem.getChildrenNamed(\"stop\");     }     if (stops.size() == 0) {              String xlink = readAttribute(elem, \"xlink:href\", \"\");       if (xlink.startsWith(\"#\") &&           identifiedElements.get(xlink.substring(1)) != null) {         stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(\"stop\", SVG_NAMESPACE);         if (stops.size() == 0) {           stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(\"stop\");         }       }     }     double[] stopOffsets = new double[stops.size()];     Color[] stopColors = new Color[stops.size()];     double[] stopOpacities = new double[stops.size()];     for (int i = 0; i < stops.size(); i++) {       IXMLElement stopElem = stops.get(i);       String offsetStr = readAttribute(stopElem, \"offset\", \"0\");       if (offsetStr.endsWith(\"%\")) {         stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;       } else {         stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);       }                                                                      stopColors[i] = toColor(stopElem, readAttribute(stopElem, \"stop-color\", \"black\"));       if (stopColors[i] == null) {         stopColors[i] = new Color(0x0, true);                }                                                                      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, \"stop-opacity\", \"1\"), 1, 0, 1);     }     AffineTransform tx = toTransform(elem, readAttribute(elem, \"gradientTransform\", \"none\"));     Gradient gradient = factory.createRadialGradient(         cx, cy, fx, fy, r,         stopOffsets, stopColors, stopOpacities,         isRelativeToFigureBounds,         tx);     elementObjects.put(elem, gradient);}", "nl": "Reads an SVG radialGradient element"}
{"code": "private Figure readTextAreaElement(IXMLElement elem)       throws IOException {     HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();     readCoreAttributes(elem, a);     readTransformAttribute(elem, a);     readOpacityAttribute(elem, a);     readShapeAttributes(elem, a);     readFontAttributes(elem, a);     readTextAttributes(elem, a);     readTextFlowAttributes(elem, a);     double x = toNumber(elem, readAttribute(elem, \"x\", \"0\"));     double y = toNumber(elem, readAttribute(elem, \"y\", \"0\"));     double w = toWidth(elem, readAttribute(elem, \"width\", \"0\"));     double h = toHeight(elem, readAttribute(elem, \"height\", \"0\"));     DefaultStyledDocument doc = new DefaultStyledDocument();     try {       if (elem.getContent() != null) {         doc.insertString(0, toText(elem, elem.getContent()), null);       } else {         for (IXMLElement node : elem.getChildren()) {           if (node.getName() == null) {             doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);           } else if (node.getName().equals(\"tbreak\")) {             doc.insertString(doc.getLength(), \"\\n\", null);           } else if (node.getName().equals(\"tspan\")) {             readTSpanElement((IXMLElement) node, doc);           } else {             if (DEBUG) {               System.out.println(\"SVGInputFormat unknown  text node \" + node.getName());             }           }         }       }     } catch (BadLocationException e) {       InternalError ex = new InternalError(e.getMessage());       ex.initCause(e);       throw ex;     }     Figure figure = factory.createTextArea(x, y, w, h, doc, a);     elementObjects.put(elem, figure);     return figure;}", "nl": "Reads an SVG textArea element"}
{"code": "private void writeViewportAttributes(IXMLElement elem, Map<AttributeKey, Object> a)       throws IOException {     Object value;     Double doubleValue;     if (VIEWPORT_WIDTH.get(a) != null && VIEWPORT_HEIGHT.get(a) != null) {              writeAttribute(elem, \"width\", toNumber(VIEWPORT_WIDTH.get(a)), null);              writeAttribute(elem, \"height\", toNumber(VIEWPORT_HEIGHT.get(a)), null);     }                                                  writeAttribute(elem, \"viewport-fill\", toColor(VIEWPORT_FILL.get(a)), \"none\");                                                  writeAttribute(elem, \"viewport-fill-opacity\", VIEWPORT_FILL_OPACITY.get(a), 1.0);}", "nl": "Writes viewport attributes"}
{"code": "public static String toTransform(AffineTransform t) throws IOException {     StringBuilder buf = new StringBuilder();     switch (t.getType()) {       case AffineTransform.TYPE_IDENTITY:         buf.append(\"none\");         break;       case AffineTransform.TYPE_TRANSLATION:                           buf.append(\"translate(\");         buf.append(toNumber(t.getTranslateX()));         if (t.getTranslateY() != 0d) {           buf.append(' ');           buf.append(toNumber(t.getTranslateY()));         }         buf.append(')');         break;              case AffineTransform.TYPE_UNIFORM_SCALE:                                    buf.append(\"scale(\");         buf.append(toNumber(t.getScaleX()));         buf.append(')');         break;       case AffineTransform.TYPE_GENERAL_SCALE:       case AffineTransform.TYPE_MASK_SCALE:                                    buf.append(\"scale(\");         buf.append(toNumber(t.getScaleX()));         buf.append(' ');         buf.append(toNumber(t.getScaleY()));         buf.append(')');         break;       default:                                             buf.append(\"matrix(\");         double[] matrix = new double[6];         t.getMatrix(matrix);         for (int i = 0; i < matrix.length; i++) {           if (i != 0) {             buf.append(' ');           }           buf.append(toNumber(matrix[i]));         }         buf.append(')');         break;     }     return buf.toString();}", "nl": "Converts an AffineTransform into an SVG transform attribute value as specified in http : www . w3 . org TR SVGMobile12 coords . html # TransformAttribute"}
{"code": "@Override   public String getParameter(String name) {     try {       return super.getParameter(name);     } catch (NullPointerException e) {       return null;}}", "nl": "Same as Applet . getParameter but doesn ' t throw a NullPointerException when used without an Applet context"}
{"code": "private static String htmlencode(String str) {     if (str == null) {       return \"\";     } else {       StringBuilder buf = new StringBuilder();       for (char ch : str.toCharArray()) {         switch (ch) {           case '<':             buf.append(\"&lt;\");             break;           case '>':             buf.append(\"&gt;\");             break;           case '&':             buf.append(\"&amp;\");             break;           default:             buf.append(ch);             break;         }         }       return buf.toString();}}", "nl": "Escapes all ' ' and ' & ' characters in a string"}
{"code": "public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype) {     super(imagePrototype);     this.groupPrototype = groupPrototype;     this.imagePrototype = imagePrototype;}", "nl": "Creates a new instance"}
{"code": "public SVGApplicationModel() {     gridConstrainer = new GridConstrainer(12, 12);}", "nl": "Creates a new instance"}
{"code": "public EventSetDescriptor[] getEventSetDescriptors() {     return getEdescriptor();}", "nl": "Gets the bean ' s EventSetDescriptors"}
{"code": "public PropertyDescriptor[] getPropertyDescriptors() {     return getPdescriptor();}", "nl": "Gets the bean ' s PropertyDescriptors"}
{"code": "@Override   public int splitSegment(Point2D.Double split, double tolerance) {          if (get(TRANSFORM) != null) {       try {         split = (Point2D.Double) get(TRANSFORM).inverseTransform(split, new Point2D.Double());       } catch (NoninvertibleTransformException ex) {         System.err.println(\"Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.\");       }     }     int i = getBezierPath().findSegment(split, tolerance);     if (i != -1) {       addNode(i + 1, new BezierPath.Node(split));     }     return i + 1;}", "nl": "Splits the segment at the given Point2D . Double if a segment was hit"}
{"code": "protected Drawing createDrawing() {     return svgPanel.createDrawing();}", "nl": "Creates a new Drawing for this View"}
{"code": "public static JFreeChart createLineChart(String title, String categoryAxisLabel,                          String valueAxisLabel, CategoryDataset data,                          boolean legend) {      JFreeChart chart = null;    try {       Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);     Axis valueAxis = new VerticalNumberAxis(valueAxisLabel);     Plot plot = new LinePlot(categoryAxis, valueAxis);     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createLineChart(...) : axis not compatible.\");   }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createLineChart(...) : plot not compatible.\");   }      return chart;}", "nl": "Creates a line chart with default settings"}
{"code": "public static JFreeChart createHighLowChart(String title, String timeAxisLabel,                         String valueAxisLabel, HighLowDataset data,                         boolean legend) {      JFreeChart chart = null;    try {     Axis timeAxis = new HorizontalDateAxis(timeAxisLabel);     NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);     HighLowPlot plot = new HighLowPlot(timeAxis, valueAxis);     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createHighLowChart(...) : axis not compatible.\");   }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createHighLowChart(...) : plot not compatible.\");   }      return chart;}", "nl": "Creates and returns a default instance of a high - low - open - close chart based on the specified dataset"}
{"code": "public static JFreeChart createScatterPlot(String title, String xAxisLabel, String yAxisLabel,                          XYDataset data, boolean legend) {      JFreeChart chart = null;    try {       Axis xAxis = new HorizontalNumberAxis(xAxisLabel);     Axis yAxis = new VerticalNumberAxis(yAxisLabel);       XYPlot plot = new XYPlot(xAxis, yAxis);       plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.SHAPES));     chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);   }   catch (AxisNotCompatibleException e) {            System.err.println(\"ChartFactory.createScatterPlot(...) : axis not compatible.\");   }   catch (PlotNotCompatibleException e) {            System.err.println(\"ChartFactory.createScatterPlot(...) : plot not compatible.\");   }      return chart;}", "nl": "Creates a scatter plot with default settings"}
{"code": "public static JFreeChart createStackedVerticalBarChart(String title, String categoryAxisLabel,                              String valueAxisLabel, CategoryDataset data,                              boolean legend) {      JFreeChart chart = null;      try {       Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);       Axis valueAxis = new VerticalNumberAxis(valueAxisLabel);       VerticalBarPlot plot = new VerticalBarPlot(categoryAxis, valueAxis);       plot.setRenderer(new StackedVerticalBarRenderer());       chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);     }   catch (AxisNotCompatibleException e) {            System.err.println(         \"ChartFactory.createStackedVerticalBarChart(...) : axis not compatible.\");     }   catch (PlotNotCompatibleException e) {            System.err.println(         \"ChartFactory.createStackedVerticalBarChart(...) : plot not compatible.\");     }      return chart;}", "nl": "Creates a stacked vertical bar chart with default settings"}
{"code": "public BarPlot(Axis horizontal, Axis vertical, Insets insets,        double introGapPercent, double trailGapPercent,            double categoryGapsPercent, double itemGapsPercent)       throws AxisNotCompatibleException, PlotNotCompatibleException {    super(horizontal, vertical);   this.insets = insets;   this.introGapPercent = introGapPercent;   this.trailGapPercent = trailGapPercent;   this.categoryGapsPercent = categoryGapsPercent;   this.itemGapsPercent = itemGapsPercent;}", "nl": "Standard constructor : returns a BarPlot with attributes specified by the caller"}
{"code": "public CategoryDataset getDataset() {   return (CategoryDataset)chart.getDataset();}", "nl": "A convenience method that returns the dataset for the plot , cast as a CategoryDataset"}
{"code": "public void setTickMarkStroke(Stroke stroke) {           if (stroke==null) {       throw new IllegalArgumentException(\"Axis.setTickMarkStroke(...): null not permitted.\");     }         if (!this.tickMarkStroke.equals(stroke)) {     this.tickMarkStroke = stroke;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the pen brush used to draw tick marks"}
{"code": "public String getLabel() {   return label;}", "nl": "Returns the label for the axis"}
{"code": "public Font getLabelFont() {   return labelFont;}", "nl": "Returns the font for the axis label"}
{"code": "protected double getMaxTickLabelWidth(Graphics2D g2, Rectangle2D plotArea) {    double maxWidth = 0.0;   Font font = getTickLabelFont();   FontRenderContext frc = g2.getFontRenderContext();    Iterator iterator = this.ticks.iterator();   while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);     if (labelBounds.getWidth()>maxWidth) {     maxWidth = labelBounds.getWidth();     }   }   return maxWidth;}", "nl": "Returns the maximum width of the ticks in the working list )"}
{"code": "public void setPlot(Plot plot) throws PlotNotCompatibleException {      if (this.isCompatiblePlot(plot)) {     this.plot = plot;     }     else throw new PlotNotCompatibleException(\"Axis.setPlot(...): \"                          +\"plot not compatible with axis.\");}", "nl": "Sets a reference to the plot that the axis is assigned to"}
{"code": "public void setTickLabelsVisible(boolean flag) {    if (flag!=tickLabelsVisible) {     tickLabelsVisible = flag;     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the flag that determines whether or not the tick labels are visible"}
{"code": "public CategoryAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,       boolean showCategoryLabels, Font categoryLabelFont, Paint categoryLabelPaint,       Insets categoryLabelInsets, boolean showTickMarks, Stroke tickMarkStroke) {    super(label, labelFont, labelPaint, labelInsets,       showCategoryLabels, categoryLabelFont, categoryLabelPaint, categoryLabelInsets,       showTickMarks, tickMarkStroke);}", "nl": "Standard constructor : returns a new CategoryAxis with attributes as specified by the caller"}
{"code": "public Date getMinimumDate() {   return this.minimumDate;}", "nl": "Returns the earliest date visible on the axis"}
{"code": "public SimpleDateFormat getTickLabelFormatter() {   return tickLabelFormatter;}", "nl": "Returns the format object used to format tick labels"}
{"code": "protected Date previousStandardDate(Date date, int field, int units) {   int milliseconds;   int seconds;   int minutes;   int hours;   int days;   int months;   int years;   Calendar calendar = Calendar.getInstance();   calendar.setTime(date);   int current = calendar.get(field);   int value = units*(current/units);   switch (field) {    case(Calendar.MILLISECOND) : {     calendar.set(Calendar.MILLISECOND, value);   }    case(Calendar.SECOND)    : {     years = calendar.get(Calendar.YEAR);     months = calendar.get(Calendar.MONTH);     days = calendar.get(Calendar.DATE);     hours = calendar.get(Calendar.HOUR_OF_DAY);     minutes = calendar.get(Calendar.MINUTE);     calendar.clear(Calendar.MILLISECOND);     calendar.set(years, months, days, hours, minutes, value);     return calendar.getTime();   }    case(Calendar.MINUTE)    : {     years = calendar.get(Calendar.YEAR);     months = calendar.get(Calendar.MONTH);     days = calendar.get(Calendar.DATE);     hours = calendar.get(Calendar.HOUR_OF_DAY);     calendar.clear(Calendar.MILLISECOND);     calendar.set(years, months, days, hours, value, 0);     return calendar.getTime();   }    case(Calendar.HOUR_OF_DAY)    : {     years = calendar.get(Calendar.YEAR);     months = calendar.get(Calendar.MONTH);     days = calendar.get(Calendar.DATE);     calendar.clear(Calendar.MILLISECOND);     calendar.set(years, months, days, value, 0, 0);     return calendar.getTime();   }    case(Calendar.DATE)    : {     years = calendar.get(Calendar.YEAR);     months = calendar.get(Calendar.MONTH);     calendar.clear(Calendar.MILLISECOND);     calendar.set(years, months, value, 0, 0, 0);     return calendar.getTime();   }    case(Calendar.MONTH)     : {     years = calendar.get(Calendar.YEAR);     calendar.clear(Calendar.MILLISECOND);     calendar.set(years, value, 1, 0, 0, 0);     return calendar.getTime();   }    case(Calendar.YEAR)    : {     calendar.clear(Calendar.MILLISECOND);     calendar.set(value, 0, 1, 0, 0, 0);     return calendar.getTime();   }    default: return null;}}", "nl": "Returns the previous standard date"}
{"code": "public void setInsets(Insets insets) {     if (!this.insets.equals(insets)) {       this.insets = insets;       notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the insets for the title , and notifies registered listeners of the change"}
{"code": "public boolean getNotify() {     return this.notify;}", "nl": "Returns the flag that indicates whether or not the notification mechanism is enabled"}
{"code": "public void setVerticalAlignment(int alignment) {     if (this.verticalAlignment!=alignment) {       this.verticalAlignment = alignment;       notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the vertical alignment for the title , and notifies any registered listeners of the change"}
{"code": "public VerticalNumberAxis() {     this(null);}", "nl": "Consrtucts a vertical number axis , using default values where necessary"}
{"code": "public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {   this.ticks.clear();   g2.setFont(tickLabelFont);   if (this.autoTickUnit) {     selectAutoTickUnit(g2, drawArea, plotArea);   }   double size = this.tickUnit.getValue().doubleValue();   int count = this.calculateVisibleTickCount();   double lowestTickValue = this.calculateLowestVisibleTickValue();      for (int i=0; i<count; i++) {     Number currentTickValue = new Double(lowestTickValue+(i*size));     double yy = this.translatedValue(currentTickValue, plotArea);     String tickLabel = this.valueToString(currentTickValue);     Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,                                     g2.getFontRenderContext());     float x = (float)(plotArea.getX()                 -tickLabelBounds.getWidth()                 -tickLabelInsets.left-tickLabelInsets.right);     float y = (float)(yy+(tickLabelBounds.getHeight()/2));     Tick tick = new Tick(currentTickValue, tickLabel, x, y);     ticks.add(tick);}}", "nl": "Calculates the positions of the tick labels for the axis , storing the results in the tick label list"}
{"code": "public VerticalNumberAxis(String label) {   this(label,        Axis.DEFAULT_AXIS_LABEL_FONT,        NumberAxis.DEFAULT_MINIMUM_AXIS_VALUE,        NumberAxis.DEFAULT_MAXIMUM_AXIS_VALUE);     this.autoRange = true;}", "nl": "Constructs a vertical number axis , using default values where necessary"}
{"code": "public VerticalXYBarPlot(Axis horizontalAxis, Axis verticalAxis)     throws AxisNotCompatibleException, PlotNotCompatibleException   {      super(horizontalAxis, verticalAxis);}", "nl": "Standard constructor"}
{"code": "public boolean isCompatibleHorizontalAxis(Axis axis) {     if (axis instanceof HorizontalNumberAxis) return true;     else if (axis instanceof HorizontalDateAxis) return true;     else return false;}", "nl": "Returns true if the specified axis is compatible with the plot with regard to operating as the horizontal axis"}
{"code": "public VerticalCategoryAxis(String label) {   super(label);   this.verticalLabel = true;}", "nl": "Standard constructor - builds a VerticalCategoryAxis with mostly default attributes"}
{"code": "public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {   this.ticks.clear();   CategoryPlot categoryPlot = (CategoryPlot)plot;     Dataset data = categoryPlot.getDataset();     if (data!=null) {       Font font = this.getTickLabelFont();     g2.setFont(font);     FontRenderContext frc = g2.getFontRenderContext();     int categoryIndex = 0;     Iterator iterator = categoryPlot.getDataset().getCategories().iterator();       while (iterator.hasNext()) {       Object category = iterator.next();       String label = category.toString();       Rectangle2D labelBounds = font.getStringBounds(label, frc);       LineMetrics metrics = font.getLineMetrics(label, frc);       float xx = (float)(plotArea.getX()-tickLabelInsets.right-labelBounds.getWidth());       float yy = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)+            labelBounds.getHeight()/2);       Tick tick = new Tick(category, label, xx, yy);       ticks.add(tick);       categoryIndex = categoryIndex+1;}}}", "nl": "Creates a temporary list of ticks that can be used when drawing the axis"}
{"code": "public VerticalBarPlot3D(Axis horizontalAxis, Axis verticalAxis)     throws AxisNotCompatibleException, PlotNotCompatibleException   {   this(horizontalAxis, verticalAxis, new Insets(2,2,2,2), 0.1, 0.1, 0.2, 0.0);}", "nl": "Standard constructor - builds a VerticalBarPlot with mostly default attributes"}
{"code": "public VerticalBarPlot3D(Axis horizontal, Axis vertical, Insets insets,          double introGap, double trailGap, double categoryGap, double seriesGap)   throws AxisNotCompatibleException, PlotNotCompatibleException   {   super(horizontal, vertical, insets,       introGap, trailGap, categoryGap, seriesGap);}", "nl": "Standard constructor : returns a BarPlot with attributes specified by the caller"}
{"code": "public XYPlot(Axis horizontalAxis, Axis verticalAxis) throws AxisNotCompatibleException,                                  PlotNotCompatibleException   {   super(horizontalAxis, verticalAxis);     this.renderer = new StandardXYItemRenderer();}", "nl": "Constructs an XYPlot with the specified axes"}
{"code": "public void addHorizontalLine(Number location, Paint color) {     if (horizontalLines == null) {       horizontalLines = new ArrayList();       horizontalColors = new ArrayList();     }     horizontalColors.add(color);     horizontalLines.add(location);}", "nl": "Adds a horizontal line at location with given color"}
{"code": "public String getPlotType() {   return \"Bar Plot\";}", "nl": "Returns a short string describing the type of plot"}
{"code": "public void setXYItemRenderer(XYItemRenderer renderer) {     this.renderer = renderer;     this.notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the item renderer , and notifies all listeners of a change to the plot"}
{"code": "public void addVerticalLine(Number location) {     addVerticalLine(location, Color.blue);}", "nl": "Adds a vertical line at location with default color blue"}
{"code": "public Number getMinimumVerticalDataValue() {   Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumRangeValue(data);   }   else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the vertical axis for BarPlot"}
{"code": "public void drawBar(Graphics2D g2, Rectangle2D plotArea, BarPlot plot, ValueAxis valueAxis,             CategoryDataset data, int series, Object category, int categoryIndex,             double translatedZero, double itemWidth,             double categorySpan, double categoryGapSpan,             double itemSpan, double itemGapSpan) {          Number value = data.getValue(series, category);     if (value!=null) {              double rectX = plotArea.getX()+plotArea.getWidth()*plot.getIntroGapPercent();       int categories = data.getCategoryCount();       int seriesCount = data.getSeriesCount();       if (categories>1) {         rectX = rectX                          + categoryIndex*(categorySpan/categories)                          + (categoryIndex*(categoryGapSpan/(categories-1))                          + (series*itemSpan/(categories*seriesCount)));         if (seriesCount>1) {           rectX = rectX               + (series*itemGapSpan/(categories*(seriesCount-1)));         }       }       else {         rectX = rectX                          + (series*itemSpan/(categories*seriesCount));         if (seriesCount>1) {           rectX = rectX               + (series*itemGapSpan/(categories*(seriesCount-1)));         }       }              double translatedValue = valueAxis.translatedValue(value, plotArea);       double rectY = Math.min(translatedZero, translatedValue);              double rectWidth = itemWidth;              double rectHeight = Math.abs(translatedValue-translatedZero);       Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);       Paint seriesPaint = plot.getSeriesPaint(series);       g2.setPaint(seriesPaint);       g2.fill(bar);       if (itemWidth>3) {         g2.setStroke(plot.getSeriesStroke(series));         g2.setPaint(plot.getSeriesOutlinePaint(series));         g2.draw(bar);}}}", "nl": "Handles the rendering of a single bar"}
{"code": "public void setGridPaint(Paint paint) {   gridPaint = paint;   notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the Paint used to color the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "public void setAutoRange(boolean auto) {   if (this.autoRange!=auto) {     this.autoRange=auto;     if (autoRange) autoAdjustRange();     notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets a flag that determines whether or not the axis range is automatically adjusted to fit the data , and notifies registered listeners that the axis has been modified"}
{"code": "public boolean isAutoTickUnit() {   return autoTickUnit;}", "nl": "Returns A flag indicating whether or not the tick unit is automatically selected from a range of standard tick units"}
{"code": "public VerticalNumberAxis3D() {   super(null);}", "nl": "Default constructor"}
{"code": "public double getEffect3d() {     return effect3d;}", "nl": "Return axis 3d deep along ' Z ' axis"}
{"code": "public void draw(Graphics2D g2, Rectangle2D titleArea) {     if (this.position == TOP || this.position == BOTTOM) {       drawHorizontal(g2, titleArea);     }     else throw new RuntimeException(\"TextTitle.draw(...) - invalid title position.\");}", "nl": "incoherencetype"}
{"code": "public Paint getPaint() {     return this.paint;}", "nl": "Returns the paint used to display the title"}
{"code": "public void setFont(Font font) {     if (!this.font.equals(font)) {       this.font = font;       notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the title font to the specified font and notifies registered listeners that the title has been modified"}
{"code": "protected void drawHorizontal(Graphics2D g2, Rectangle2D titleArea) {     g2.setFont(this.font);     g2.setPaint(this.paint);     FontRenderContext frc = g2.getFontRenderContext();     Rectangle2D titleBounds = font.getStringBounds(text, frc);     LineMetrics lineMetrics = font.getLineMetrics(text, frc);     double titleWidth = titleBounds.getWidth();     double titleHeight = lineMetrics.getHeight();     double titleY = titleArea.getY()+insets.top;          if (this.verticalAlignment==TOP) {       titleY = titleY+titleHeight-lineMetrics.getLeading()-lineMetrics.getDescent();     }     else if (this.verticalAlignment==MIDDLE) {       double space = (titleArea.getHeight()-insets.top-insets.bottom-titleHeight);       titleY = titleY+(space/2)+titleHeight-lineMetrics.getLeading()-lineMetrics.getDescent();     }     else if (this.verticalAlignment==BOTTOM) {       titleY = titleArea.getMaxY()-insets.bottom-lineMetrics.getLeading()-lineMetrics.getDescent();     }          double titleX = titleArea.getX()+insets.left;     if (this.horizontalAlignment==CENTER) {       titleX = titleX+((titleArea.getWidth()-insets.left-insets.right)/2)-(titleWidth/2);     }     else if (this.horizontalAlignment==LEFT) {       titleX = titleArea.getX()+insets.left;     }     else if (this.horizontalAlignment == RIGHT) {       titleX = titleArea.getMaxX()-insets.right-titleWidth;     }     g2.drawString(text, (float)(titleX), (float)(titleY));}", "nl": "incoherencetype"}
{"code": "public ChartChangeEvent(Object source, JFreeChart chart) {     this(source, chart, GENERAL);}", "nl": "Standard constructor : returns a new ChartChangeEvent object , type GENERAL"}
{"code": "public boolean getPlotShapes() {     return this.plotShapes;}", "nl": "Returns true if shapes are being plotted by the renderer"}
{"code": "public void drawBar(Graphics2D g2, Rectangle2D plotArea, BarPlot plot, ValueAxis valueAxis,             CategoryDataset data, int series, Object category, int categoryIndex,             double translatedZero, double itemWidth,             double categorySpan, double categoryGapSpan,             double itemSpan, double itemGapSpan) {           Number value = data.getValue(series, category);     if (value!=null) {               double translatedValue = valueAxis.translatedValue(value, plotArea);       double rectX = Math.min(translatedZero, translatedValue);               double rectY = plotArea.getY() + plotArea.getHeight()*plot.getIntroGapPercent();        int categories = data.getCategoryCount();       int seriesCount = data.getSeriesCount();       if (categories>1) {         rectY = rectY                          + (categoryIndex*categorySpan/categories)                          + (categoryIndex*categoryGapSpan/(categories-1))                          + (series*itemSpan/(categories*seriesCount));         if (seriesCount>1) {           rectY = rectY               + (series*itemGapSpan/(categories*(seriesCount-1)));         }       }       else {         rectY = rectY                          + (series*itemSpan/(categories*seriesCount));         if (seriesCount>1) {           rectY = rectY               + (series*itemGapSpan/(categories*(seriesCount-1)));         }       }               double rectWidth = Math.abs(translatedValue-translatedZero);               double rectHeight = itemWidth;               Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);       Paint seriesPaint = plot.getSeriesPaint(series);       g2.setPaint(seriesPaint);       g2.fill(bar);       if (itemWidth>BAR_OUTLINE_WIDTH_THRESHOLD) {         g2.setStroke(plot.getSeriesStroke(series));         g2.setPaint(plot.getSeriesOutlinePaint(series));         g2.draw(bar);}}}", "nl": "Draws the bar for a single data item"}
{"code": "public String getSeriesName(int series) {     if (series==0) {       return \"y = cosine(x)\";     }     else if (series==1) {       return \"y = 2*sine(x)\";     }     else return \"Error\";}", "nl": "Returns the name of the series"}
{"code": "public double translatedValue(Date date, Rectangle2D plotArea) {   double value = (double)date.getTime();   double axisMin = (double)minimumDate.getTime();   double axisMax = (double)maximumDate.getTime();   double plotX = plotArea.getX();   double plotMaxX = plotArea.getMaxX();   return plotX + ((value - axisMin)/(axisMax - axisMin)) * (plotMaxX - plotX);}", "nl": "Translates the data value to the display coordinates of the chart"}
{"code": "public void setVerticalTickLabels(boolean flag) {   this.verticalTickLabels = flag;   this.notifyListeners(new com.jrefinery.chart.event.AxisChangeEvent(this));}", "nl": "Sets the flag that determines whether the tick labels are drawn ' vertically '"}
{"code": "public HorizontalDateAxis(String label, Font labelFont,           Date minimumDate, Date maximumDate) {    this(label, labelFont, Color.black, new Insets(4, 4, 4, 4),      true, new Font(\"Arial\", Font.PLAIN, 10), Color.black, new Insets(1, 2, 1, 1),      true, true, new BasicStroke(1),      false, minimumDate, maximumDate, false, new DateUnit(Calendar.DATE, 1),      new SimpleDateFormat(), false, null, null);}", "nl": "Standard constructor : returns a HorizontalValueAxis with some default attributes"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {      if (this.label!=null) {     g2.setFont(labelFont);     g2.setPaint(labelPaint);     FontRenderContext frc = g2.getFontRenderContext();     Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);     LineMetrics lm = labelFont.getLineMetrics(label, frc);     float labelx = (float)(plotArea.getX()+plotArea.getWidth()/2-labelBounds.getWidth()/2);     float labely = (float)(drawArea.getMaxY()-labelInsets.bottom-lm.getDescent()-lm.getLeading());     g2.drawString(label, labelx, labely);   }      this.refreshTicks(g2, drawArea, plotArea);   float maxY = (float)plotArea.getMaxY();   g2.setFont(getTickLabelFont());    Iterator iterator = ticks.iterator();   while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     float xx = (float)this.translatedValue(tick.getNumericalValue(), plotArea);      if (tickLabelsVisible) {     g2.setPaint(this.tickLabelPaint);     if (this.verticalTickLabels) {       drawVerticalString(tick.getText(), g2, tick.getX(), tick.getY());     }     else {       g2.drawString(tick.getText(), tick.getX(), tick.getY());     }     }      if (tickMarksVisible) {     g2.setStroke(this.getTickMarkStroke());     Line2D mark = new Line2D.Float(xx, maxY-2, xx, maxY+2);     g2.draw(mark);     }      if (showGridLines) {     g2.setStroke(gridStroke);     g2.setPaint(gridPaint);     Line2D gridline = new Line2D.Float(xx, (float)plotArea.getMaxY(), xx,                (float)plotArea.getMinY());     g2.draw(gridline);}}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis)   {   if (axis instanceof VerticalNumberAxis)     return true;   else     return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public ValueAxis getHorizontalValueAxis() {   return (ValueAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a HorizontalValueAxis"}
{"code": "public Number getMinimumHorizontalDataValue() {    Dataset data = this.getChart().getDataset();   if (data!=null) {     return Datasets.getMinimumRangeValue(data);   }   else return null;}", "nl": "Returns the minimum value in the range , since this is plotted against the horizontal axis for a HorizontalBarPlot"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {   if (axis instanceof VerticalCategoryAxis) {     return true;   }   else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "public Line2D getCloseTickLine() {   return getTickLine(getLine().getX1(), getValue(CLOSE), getTickSize());}", "nl": "Returns the line"}
{"code": "public void setValue(int valueType, double newValue) {   if (valueType == OPEN)     open = newValue;   else     close = newValue;}", "nl": "Sets either OPEN or Close value depending on the valueType"}
{"code": "public HighLow(double x, double high, double low, double open, double close) {   this(x, high, low, open, close, new BasicStroke(), Color.blue);}", "nl": "Constructs a high - low item , with default values for the colors"}
{"code": "public int getCount() {   return this.count;}", "nl": "Returns the number of units"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,              double reservedWidth) {       LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());   double labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;       double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;   if (tickLabelsVisible) {     g2.setFont(tickLabelFont);     this.refreshTicks(g2, drawArea, drawArea);     tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,                   this.verticalTickLabels);   }   return new Rectangle2D.Double(drawArea.getX(), drawArea.getMaxY(),             drawArea.getWidth()-reservedWidth,             labelHeight+tickLabelHeight);}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public HorizontalNumberAxis(String label,                 Font labelFont, Paint labelPaint, Insets labelInsets,         boolean tickLabelsVisible,                 Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,         boolean verticalTickLabels,         boolean tickMarksVisible, Stroke tickMarkStroke,                 boolean autoRange, boolean autoRangeIncludesZero,                 Number autoRangeMinimumSize,         Number minimumAxisValue, Number maximumAxisValue,         boolean autoTickUnitSelection, NumberTickUnit tickUnit,         boolean gridLinesVisible,                 Stroke gridStroke, Paint gridPaint) {    super(label,         labelFont, labelPaint, labelInsets,       tickLabelsVisible,         tickLabelFont, tickLabelPaint, tickLabelInsets,       tickMarksVisible, tickMarkStroke,       autoRange, autoRangeIncludesZero,         autoRangeMinimumSize,       minimumAxisValue, maximumAxisValue,         autoTickUnitSelection, tickUnit,       gridLinesVisible,         gridStroke, gridPaint);    this.verticalTickLabels = verticalTickLabels;}", "nl": "Constructs a horizontal number axis"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {       g2.setFont(labelFont);   g2.setPaint(labelPaint);   FontRenderContext frc = g2.getFontRenderContext();   Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);   LineMetrics lm = labelFont.getLineMetrics(label, frc);   float labelx = (float)(plotArea.getX()+plotArea.getWidth()/2-labelBounds.getWidth()/2);   float labely = (float)(drawArea.getMaxY()-labelInsets.bottom                  -lm.getDescent()-lm.getLeading());   g2.drawString(label, labelx, labely);       if (this.tickLabelsVisible) {     g2.setFont(tickLabelFont);     g2.setPaint(tickLabelPaint);     this.refreshTicks(g2, drawArea, plotArea);     Iterator iterator = ticks.iterator();     while (iterator.hasNext()) {     Tick tick = (Tick)iterator.next();     if (this.verticalCategoryLabels) {       this.drawVerticalString(tick.getText(), g2, tick.getX(), tick.getY());     }     else {       g2.drawString(tick.getText(), tick.getX(), tick.getY());}}}}", "nl": "Draws the HorizontalCategoryAxis on a Java 2D graphics device"}
{"code": "public HorizontalCategoryAxis(String label) {   super(label);   this.verticalCategoryLabels = false;}", "nl": "Standard constructor - builds a HorizontalCategoryAxis with defaults for most attributes"}
{"code": "private Date createDate(int year, int month, int day) {     GregorianCalendar calendar = new GregorianCalendar(year, month, day);     return calendar.getTime();}", "nl": "Returns a java . util . Date for the specified year , month and day"}
{"code": "private void displayPieChartTwo() {      if (pieChartTwoFrame==null) {               String title = \"Pie Chart\";       CategoryDataset data = createCategoryDataset();       PieDataset extracted = Datasets.createPieDataset(data, \"Category 2\");       JFreeChart chart = ChartFactory.createPieChart(title, extracted, true);               chart.setLegend(null);       chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 0, 1000, Color.orange));       PiePlot pie = (PiePlot)chart.getPlot();       pie.setSectionLabelType(PiePlot.NAME_AND_PERCENT_LABELS);               pieChartTwoFrame = new JFreeChartFrame(\"Pie Chart 2\", chart);       pieChartTwoFrame.pack();       SwingRefinery.positionFrameRandomly(pieChartTwoFrame);       pieChartTwoFrame.show();      }     else {       pieChartTwoFrame.show();       pieChartTwoFrame.requestFocus();}}", "nl": "Displays pie chart two in its own frame"}
{"code": "private void displayTimeSeriesChart() {      if (this.timeSeriesChartFrame==null) {               String title = \"Time Series Chart\";       String xAxisLabel = \"Date\";       String yAxisLabel = \"USD per GBP\";       XYDataset data = createXYDataset();       JFreeChart chart = ChartFactory.createTimeSeriesChart(title, xAxisLabel, yAxisLabel, data,                                 true);               TextTitle subtitle = new TextTitle(\"Value of GBP\", new Font(\"Arial\", Font.BOLD, 12));       chart.addTitle(subtitle);       chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.blue));       Plot plot = chart.getPlot();               timeSeriesChartFrame = new JFreeChartFrame(\"Time Series Chart\", chart);       timeSeriesChartFrame.pack();       SwingRefinery.positionFrameRandomly(timeSeriesChartFrame);       timeSeriesChartFrame.show();      }     else {       timeSeriesChartFrame.show();       timeSeriesChartFrame.requestFocus();}}", "nl": "Displays a vertical bar chart in its own frame"}
{"code": "public CategoryDataset createCategoryDataset() {      Number[][] data = new Integer[][]       { { new Integer(10), new Integer(4), new Integer(15), new Integer(14) },         { new Integer(-5), new Integer(-7), new Integer(14), new Integer(-3) },         { new Integer(6), new Integer(17), new Integer(-12), new Integer(7) },         { new Integer(7), new Integer(15), new Integer(11), new Integer(0) },         { new Integer(-8), new Integer(-6), new Integer(10), new Integer(-9) },         { new Integer(9), new Integer(8), null, new Integer(6) },         { new Integer(-10), new Integer(9), new Integer(7), new Integer(7) },         { new Integer(11), new Integer(13), new Integer(9), new Integer(9) },         { new Integer(-3), new Integer(7), new Integer(11), new Integer(-10) } };      return new DefaultCategoryDataset(data);}", "nl": "Creates and returns a category dataset for the demo charts"}
{"code": "private void displayPieChartOne() {      if (pieChartOneFrame==null) {               String title = \"Pie Chart\";       CategoryDataset data = createCategoryDataset();       PieDataset extracted = Datasets.createPieDataset(data, 0);       JFreeChart chart = ChartFactory.createPieChart(title, extracted, true);               chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 0, 1000, Color.orange));       PiePlot plot = (PiePlot)chart.getPlot();       plot.setCircular(false);              plot.setRadiusPercent(0.60);       plot.setExplodePercent(1, 1.00);               pieChartOneFrame = new JFreeChartFrame(\"Pie Chart 1\", chart);       pieChartOneFrame.pack();       SwingRefinery.positionFrameRandomly(pieChartOneFrame);       pieChartOneFrame.show();      }     else {       pieChartOneFrame.show();       pieChartOneFrame.requestFocus();}}", "nl": "Displays pie chart one in its own frame"}
{"code": "public CategoryDataset createSingleCategoryDataset() {      Number[][] data = new Integer[][]       { { new Integer(10) },         { new Integer(-5) },         { new Integer(6) },         { new Integer(7) },         { new Integer(-8) },         { new Integer(9) },         { new Integer(-10) },         { new Integer(11) },         { new Integer(-3) } };      return new DefaultCategoryDataset(data);}", "nl": "Creates and returns a category dataset with JUST ONE CATEGORY for the demo charts"}
{"code": "public Dimension getPreferredSize() {     return PREFERRED_SIZE;}", "nl": "Returns the preferred size for the frame"}
{"code": "public XYDataset createTestXYDataset() {      Object[][][] data = new Object[][][] { {       { createDateTime(2000, Calendar.OCTOBER, 18, 9, 5), new Double(10921.0) },       { createDateTime(2000, Calendar.OCTOBER, 18, 10, 6), new Double(10886.7) },       { createDateTime(2000, Calendar.OCTOBER, 18, 11, 6), new Double(10846.6) },       { createDateTime(2000, Calendar.OCTOBER, 18, 12, 6), new Double(10843.7) },       { createDateTime(2000, Calendar.OCTOBER, 18, 13, 6), new Double(10841.2) },       { createDateTime(2000, Calendar.OCTOBER, 18, 14, 6), new Double(10830.7) },       { createDateTime(2000, Calendar.OCTOBER, 18, 15, 6), new Double(10795.8) },       { createDateTime(2000, Calendar.OCTOBER, 18, 16, 7), new Double(10733.8) }     } };      return new DefaultXYDataset(data);}", "nl": "Creates and returns a XYDataset for the demo charts"}
{"code": "public String getSeriesName(int series) {     return null;}", "nl": "Returns the name of the series"}
{"code": "public Number getYValue(int series, int item) {     return yValues[series][item];}", "nl": "Returns the y - value for the specified series and item"}
{"code": "public int getSeriesCount() {     return 1;}", "nl": "Returns the number of series in the data source , ONE in this sample"}
{"code": "public Number getYValue(int series, int item) {     if (series==0) {       return closes[item];     }     else return null;}", "nl": "Returns the y - value for the specified series and item"}
{"code": "public boolean isTickLabelsVisible() {     return showTickLabelsCheckBox.isSelected();}", "nl": "Returns a flag that indicates whether or not the tick labels are visible"}
{"code": "public void attemptTickLabelFontSelection() {      FontChooserPanel panel = new FontChooserPanel(tickLabelFont);     int result = JOptionPane.showConfirmDialog(this, panel, \"Font Selection\",       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       tickLabelFont = panel.getSelectedFont();       tickLabelFontField.setText(tickLabelFont.getFontName()+\" \"+tickLabelFont.getSize());}}", "nl": "Presents a tick label font selection dialog to the user"}
{"code": "public void setAxisProperties(Axis axis) {     axis.setLabel(this.getLabel());     axis.setLabelFont(this.getLabelFont());     axis.setLabelPaint(this.getLabelPaint());     axis.setTickMarksVisible(this.isTickMarksVisible());          axis.setTickLabelsVisible(this.isTickLabelsVisible());     axis.setTickLabelFont(this.getTickLabelFont());     axis.setTickLabelPaint(this.getTickLabelPaint());     axis.setTickLabelInsets(this.getTickLabelInsets());     axis.setLabelInsets(this.getLabelInsets());}", "nl": "Sets the properties of the specified axis to match the properties defined on this panel"}
{"code": "public Font getTickLabelFont() {     return tickLabelFont;}", "nl": "Returns the font used to draw the tick labels"}
{"code": "private void attemptGridStrokeSelection() {     StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);     int result = JOptionPane.showConfirmDialog(this, panel, \"Stroke Selection\",       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       gridStrokeSample.setStroke(panel.getSelectedStroke());}}", "nl": "Handle a grid stroke selection"}
{"code": "public boolean isAutoRange() {     return autoRange;}", "nl": "Returns the current setting of the auto - range property"}
{"code": "public Paint getSeriesPaint() {     return seriesPaint.getPaint();}", "nl": "Returns the current series label paint"}
{"code": "private void attemptModifyOutlineStroke() {     StrokeChooserPanel panel = new StrokeChooserPanel(outlineStroke, availableStrokeSamples);     int result = JOptionPane.showConfirmDialog(this, panel, \"Pen/Stroke Selection\",       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       outlineStroke.setStroke(panel.getSelectedStroke());}}", "nl": "Allows the user the opportunity to change the outline stroke"}
{"code": "private void attemptOutlinePaintSelection() {     Color c;     c = JColorChooser.showDialog(this, \"Outline Color\", Color.blue);     if (c!=null) {       outlinePaintSample.setPaint(c);}}", "nl": "Allow the user to change the outline paint"}
{"code": "public Stroke getOutlineStroke() {     return outlineStrokeSample.getStroke();}", "nl": "Returns the current outline stroke"}
{"code": "private void attemptBackgroundPaintSelection() {     Color c;     c = JColorChooser.showDialog(this, \"Background Color\", Color.blue);     if (c!=null) {       backgroundPaintSample.setPaint(c);}}", "nl": "Allow the user to change the background paint"}
{"code": "public LegendPropertyEditPanel getLegendPropertyEditPanel() {     return legendPropertiesPanel;}", "nl": "Returns a reference to the legend property sub - panel"}
{"code": "public Paint getTitlePaint() {     return titlePaint.getPaint();}", "nl": "Returns the paint selected in the panel"}
{"code": "public void attemptFontSelection() {      FontChooserPanel panel = new FontChooserPanel(titleFont);     int result = JOptionPane.showConfirmDialog(this, panel, \"Font Selection\",       JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {       titleFont = panel.getSelectedFont();       fontfield.setText(titleFont.getFontName()+\" \"+titleFont.getSize());}}", "nl": "Presents a font selection dialog to the user"}
{"code": "public Line2D getOpenTickLine() {    return getTickLine(getLine().getX1(), getValue(OPEN), (-1) * getTickSize());}", "nl": "Returns the line for open tick"}
{"code": "public double getValue(int valueType) {    if (valueType == OPEN)      return open;    else      return close;}", "nl": "Returns either OPEN or Close value depending on the valueType"}
{"code": "public void setHorizontalAlignment(int alignment) {      if (this.horizontalAlignment!=alignment) {        this.horizontalAlignment = alignment;        notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the horizontal alignment for the title , and notifies any registered listeners of the change"}
{"code": "public void setVerticalAlignment(int alignment) {      if (this.verticalAlignment!=alignment) {        this.verticalAlignment = alignment;        notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the vertical alignment for the title , and notifies any registered listeners of the change"}
{"code": "double calculateBarWidth(Rectangle2D plotArea) {    CategoryDataset data = getDataset();        int categoryCount = data.getCategoryCount();    int seriesCount = data.getSeriesCount();    int barCount = renderer.barWidthsPerCategory(data)*categoryCount;        double usable = plotArea.getHeight() *                    (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);      if (renderer.barWidthsPerCategory(data)>1) {       }        return usable/barCount;}", "nl": "Returns the width of each bar in the chart"}
{"code": "public void removeChangeListener(TitleChangeListener listener) {      listeners.remove(listener);}", "nl": "Unregisters an object for notification of changes to the chart title"}
{"code": "public void setPosition(int position) {      if (this.position!=position) {                this.position = position;        notifyListeners(new TitleChangeEvent(this));}}", "nl": "Sets the position for the title"}
{"code": "public int getPosition() {      return this.position;}", "nl": "Returns the relative position of the title - - - represented by one of four integer constants defined in this class : TOP , BOTTOM , RIGHT or LEFT"}
{"code": "public void setRenderer(HorizontalBarRenderer renderer) {      this.renderer = renderer;      this.notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the renderer for the bar plot"}
{"code": "public double getCategoryCoordinate(int category, Rectangle2D area) {            double result = area.getY()+(area.getHeight()*introGapPercent);            int categoryCount = getDataset().getCategoryCount();      if (categoryCount>1) {      double categorySpan = area.getHeight()                    *(1-introGapPercent-trailGapPercent-categoryGapsPercent);        double categoryGapSpan = area.getHeight()*categoryGapsPercent;        result = result             + (category+0.5)*(categorySpan/categoryCount)             + (category)*(categoryGapSpan/(categoryCount-1));      }      else {        result = result             + (category+0.5)*area.getHeight()*(1-introGapPercent-trailGapPercent);      }      return result;}", "nl": "Returns the x - coordinate of the center of the specified category"}
{"code": "public DateUnit(int field, int count) {    this.field = field;    this.count = count;}", "nl": "Builds a DateUnit"}
{"code": "public static JFreeChart createStackedVerticalBarChart3D(String title, String categoryAxisLabel,                              String valueAxisLabel, CategoryDataset data,                              boolean legend) {      CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);      ValueAxis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);      VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);                  plot.setInsets(new Insets(20, 2, 2, 2));      plot.setRenderer(new StackedVerticalBarRenderer3D());      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates a stacked vertical bar chart with default settings"}
{"code": "public static JFreeChart createScatterPlot(String title, String xAxisLabel, String yAxisLabel,                           XYDataset data, boolean legend) {      ValueAxis xAxis = new HorizontalNumberAxis(xAxisLabel);      ValueAxis yAxis = new VerticalNumberAxis(yAxisLabel);      XYPlot plot = new XYPlot(xAxis, yAxis);      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.SHAPES));      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates a scatter plot with default settings"}
{"code": "public static JFreeChart createVerticalXYBarChart(String title, String xAxisLabel,                              String yAxisLabel, IntervalXYDataset data,                              boolean legend) {      HorizontalDateAxis timeAxis = new HorizontalDateAxis(xAxisLabel);      ValueAxis valueAxis = new VerticalNumberAxis(yAxisLabel);                  XYPlot plot = new XYPlot(timeAxis, valueAxis, new Insets(0,0,0,0), Color.white,                   new BasicStroke(), Color.gray);      plot.setXYItemRenderer(new VerticalXYBarRenderer());      JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);      return chart;}", "nl": "Creates and returns a default instance of a VerticalXYBarChart based on the specified dataset"}
{"code": "public static CombinedChart createCombinableHighLowChart(ValueAxis horizontal,                                 ValueAxis vertical,                                 Dataset data) {      XYPlot plot = new XYPlot(horizontal, vertical);        plot.setXYItemRenderer(new HighLowRenderer());        return createCombinableChart(data, plot);}", "nl": "Creates and returns a default instance of a high - low - open - close combinable chart based on the specified dataset"}
{"code": "protected Date previousStandardDate(Date date, int field, int units) {    int milliseconds;    int seconds;    int minutes;    int hours;    int days;    int months;    int years;    Calendar calendar = Calendar.getInstance();    calendar.setTime(date);    int current = calendar.get(field);    int value = units*(current/units);    switch (field) {    case(Calendar.MILLISECOND) : {        years = calendar.get(Calendar.YEAR);        months = calendar.get(Calendar.MONTH);        days = calendar.get(Calendar.DATE);        hours = calendar.get(Calendar.HOUR_OF_DAY);        minutes = calendar.get(Calendar.MINUTE);        seconds = calendar.get(Calendar.SECOND);        calendar.set(years, months, days, hours, minutes, seconds);        calendar.set(Calendar.MILLISECOND, value);        return calendar.getTime();   }    case(Calendar.SECOND)    : {      years = calendar.get(Calendar.YEAR);      months = calendar.get(Calendar.MONTH);      days = calendar.get(Calendar.DATE);      hours = calendar.get(Calendar.HOUR_OF_DAY);      minutes = calendar.get(Calendar.MINUTE);      calendar.clear(Calendar.MILLISECOND);      calendar.set(years, months, days, hours, minutes, value);      return calendar.getTime();    }    case(Calendar.MINUTE)    : {      years = calendar.get(Calendar.YEAR);      months = calendar.get(Calendar.MONTH);      days = calendar.get(Calendar.DATE);      hours = calendar.get(Calendar.HOUR_OF_DAY);      calendar.clear(Calendar.MILLISECOND);      calendar.set(years, months, days, hours, value, 0);      return calendar.getTime();    }    case(Calendar.HOUR_OF_DAY)    : {      years = calendar.get(Calendar.YEAR);      months = calendar.get(Calendar.MONTH);      days = calendar.get(Calendar.DATE);      calendar.clear(Calendar.MILLISECOND);      calendar.set(years, months, days, value, 0, 0);      return calendar.getTime();    }    case(Calendar.DATE)    : {      years = calendar.get(Calendar.YEAR);      months = calendar.get(Calendar.MONTH);      calendar.clear(Calendar.MILLISECOND);      calendar.set(years, months, value, 0, 0, 0);      return calendar.getTime();    }    case(Calendar.MONTH)     : {      years = calendar.get(Calendar.YEAR);      calendar.clear(Calendar.MILLISECOND);      calendar.set(years, value, 1, 0, 0, 0);      return calendar.getTime();    }    case(Calendar.YEAR)    : {      calendar.clear(Calendar.MILLISECOND);      calendar.set(value, 0, 1, 0, 0, 0);      return calendar.getTime();    }    default: return null;}}", "nl": "Returns the previous standard date"}
{"code": "public Bar(double x, double y, double width, double height,         Stroke outlineStroke, Paint outlinePaint, Paint fillPaint)    {    this.area = new Rectangle2D.Double(x, y, width, height);    this.outlineStroke = outlineStroke;    this.outlinePaint = outlinePaint;    this.fillPaint = fillPaint;}", "nl": "Full constructor : returns a new Bar object with attributes as defined by the caller"}
{"code": "public Date getAnchorDate() {    return this.anchorDate;}", "nl": "Returns the anchor date for the axis"}
{"code": "public DateUnit getTickUnit() {    return tickUnit;}", "nl": "Returns the tick unit for the axis"}
{"code": "public Date getMaximumDate() {    return this.maximumDate;}", "nl": "Returns the latest date visible on the axis"}
{"code": "protected Axis(String label) {    this(label,         DEFAULT_AXIS_LABEL_FONT,         DEFAULT_AXIS_LABEL_PAINT,         DEFAULT_AXIS_LABEL_INSETS,         true,           DEFAULT_TICK_LABEL_FONT,         DEFAULT_TICK_LABEL_PAINT,         DEFAULT_TICK_LABEL_INSETS,         true,           DEFAULT_TICK_STROKE);}", "nl": "Constructs an axis , using default values where necessary"}
{"code": "public Insets getLabelInsets() {    return this.labelInsets;}", "nl": "Returns the insets for the label"}
{"code": "public boolean isTickMarksVisible() {    return tickMarksVisible;}", "nl": "Returns the flag that indicates whether or not the tick marks are showing"}
{"code": "public Insets getTickLabelInsets() {    return this.tickLabelInsets;}", "nl": "Returns the insets for the tick labels"}
{"code": "public String getLabel() {    return label;}", "nl": "Returns the label for the axis"}
{"code": "protected double getMaxTickLabelWidth(Graphics2D g2, Rectangle2D plotArea) {    double maxWidth = 0.0;    Font font = getTickLabelFont();    FontRenderContext frc = g2.getFontRenderContext();    Iterator iterator = this.ticks.iterator();    while (iterator.hasNext()) {      Tick tick = (Tick)iterator.next();      Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);      if (labelBounds.getWidth()>maxWidth) {      maxWidth = labelBounds.getWidth();      }    }    return maxWidth;}", "nl": "Returns the maximum width of the ticks in the working list )"}
{"code": "protected BarPlot(Axis horizontalAxis, Axis verticalAxis,              Insets insets,          double introGapPercent, double trailGapPercent,              double categoryGapsPercent, double itemGapsPercent,              CategoryToolTipGenerator toolTipGenerator) {    super(horizontalAxis, verticalAxis);      this.insets = insets;    this.introGapPercent = introGapPercent;    this.trailGapPercent = trailGapPercent;    this.categoryGapsPercent = categoryGapsPercent;    this.itemGapsPercent = itemGapsPercent;      this.toolTipGenerator = toolTipGenerator;}", "nl": "Constructs a bar plot"}
{"code": "public void setCategoryGapsPercent(double percent) {            if ((percent<0.0) || (percent>MAX_CATEGORY_GAPS_PERCENT)) {        throw new IllegalArgumentException(\"BarPlot.setCategoryGapsPercent(double): argument \"                          +\"outside valid range.\");      }          if (this.categoryGapsPercent!=percent) {        this.categoryGapsPercent=percent;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the gap between the last bar in one category and the first bar in the next category , and notifies registered listeners that the plot has been modified"}
{"code": "public double getCategoryGapsPercent() {    return categoryGapsPercent;}", "nl": "Returns the percentage of the drawing space that is allocated to providing gaps between the categories"}
{"code": "public PeriodMarkerPlot(Axis horizontal, Axis vertical) throws AxisNotCompatibleException,                                     PlotNotCompatibleException {        super(horizontal, vertical);}", "nl": "Creates new SignalsPlot"}
{"code": "public Number getMaximumHorizontalDataValue() {             XYDataset data = getTempXYDataset();    if( data ==null )        return null;      long maximum = Long.MIN_VALUE;      int seriesCount = data.getSeriesCount();      for (int series=0; series<seriesCount; series++) {        int itemCount = data.getItemCount(series);        for(int itemIndex = 0; itemIndex < itemCount; itemIndex++){          Number value = data.getXValue(series, itemIndex);           if (value!=null)            maximum = Math.max(maximum, value.longValue());        }      }      return new Long(maximum);}", "nl": "Returns the maximum value in the domain , since this is plotted against the horizontal axis for a HighLowPlot"}
{"code": "public Number getMinimumVerticalDataValue() {      return new Double(Double.POSITIVE_INFINITY);}", "nl": "Returns the minimum value in the range , since this is plotted against the vertical axis for a HighLowPlot"}
{"code": "public VerticalNumberAxis getValueAxis() {    return (VerticalNumberAxis)verticalAxis;}", "nl": "A convenience method that returns a reference to the vertical axis cast as a VerticalNumberAxis"}
{"code": "public double getTrailGapPercent() {      return this.introGapPercent;}", "nl": "Returns the trail gap"}
{"code": "public TickUnits getStandardTickUnits() {      return this.standardTickUnits;}", "nl": "Returns the standard tick units for the axis"}
{"code": "public void setLowerMargin(double margin) {      this.lowerMargin = margin;      notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the lower margin"}
{"code": "public int calculateVisibleTickCount() {            double unit = getTickUnit().getValue().doubleValue();    return (int)(Math.floor(maximumAxisValue/unit)-Math.ceil(minimumAxisValue/unit)+1);}", "nl": "Calculates the number of visible ticks"}
{"code": "public double getLowerMargin() {      return this.lowerMargin;}", "nl": "Returns the margin by which the minimum axis value is less than the minimum data value"}
{"code": "public LineAndShapeRenderer(int type) {      if (type==SHAPES) this.plotShapes=true;      if (type==LINES) this.plotLines=true;      if (type==SHAPES_AND_LINES) {        this.plotShapes = true;        this.plotLines = true;}}", "nl": "Constructs a renderer of the specified type"}
{"code": "public LineAndShapeRenderer() {      this(SHAPES_AND_LINES);}", "nl": "Constructs a renderer that draws shapes only"}
{"code": "public void setSectionLabelFont(Font font) {            if (font==null) {        throw new IllegalArgumentException(\"PiePlot.setSectionLabelFont(...): \"                           +\"null font not allowed.\");      }            if (!this.sectionLabelFont.equals(font)) {      this.sectionLabelFont = font;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the section label font"}
{"code": "protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded,                       double startAngle, double extent, double explodePercent) {      if (explodePercent==0.0) {        return unexploded;      }      else {        Arc2D arc1 = new Arc2D.Double(unexploded, startAngle, extent/2, Arc2D.OPEN);        Point2D point1 = arc1.getEndPoint();        Arc2D.Double arc2 = new Arc2D.Double(exploded, startAngle, extent/2, Arc2D.OPEN);        Point2D point2 = arc2.getEndPoint();        double deltaX = (point1.getX()-point2.getX())*explodePercent;        double deltaY = (point1.getY()-point2.getY())*explodePercent;        return new Rectangle2D.Double(unexploded.getX()-deltaX, unexploded.getY()-deltaY,                        unexploded.getWidth(), unexploded.getHeight());}}", "nl": "Returns a rectangle that can be used to create a pie section"}
{"code": "public Collection getCategories() {    return getDataset().getCategories();}", "nl": "Returns a collection of the categories in the dataset"}
{"code": "public Paint getSectionLabelPaint() {    return this.sectionLabelPaint;}", "nl": "Returns the section label paint"}
{"code": "public double getSectionLabelGapPercent() {      return this.sectionLabelGapPercent;}", "nl": "Returns the section label gap , measures as a percentage of the radius"}
{"code": "public int getSectionLabelType() {      return this.sectionLabelType;}", "nl": "Returns the section label type"}
{"code": "public void axisChanged(AxisChangeEvent event) {    notifyListeners(new PlotChangeEvent(this));}", "nl": "Receives notification of a change to one of the plot ' s axes"}
{"code": "public JFreeChart getChart() {    return chart;}", "nl": "Returns a reference to the chart that this plot belongs to"}
{"code": "public void setVerticalAxis(Axis axis) throws AxisNotCompatibleException {      if (isCompatibleVerticalAxis(axis)) {        if (axis!=null) {          try {            axis.setPlot(this);          }          catch (PlotNotCompatibleException e) {            throw new AxisNotCompatibleException(\"Plot.setVerticalAxis(...): \"                              +\"plot not compatible with axis.\");          }          axis.addChangeListener(this);        }                if (this.verticalAxis!=null) {        this.verticalAxis.removeChangeListener(this);        }        this.verticalAxis = axis;      }      else throw new AxisNotCompatibleException(\"Plot.setVerticalAxis(...): \"                           +\"axis not compatible with plot.\");}", "nl": "Sets the vertical axis for the plot"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, DrawInfo info) {            if (insets!=null) {        drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,                          drawArea.getY()+insets.top,                          drawArea.getWidth()-insets.left-insets.right,                          drawArea.getHeight()-insets.top-insets.bottom);      }            HorizontalAxis ha = getHorizontalAxis();      VerticalAxis va = getVerticalAxis();      double hAxisAreaHeight = ha.reserveHeight(g2, this, drawArea);      Rectangle2D vAxisArea = va.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);      Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),                              drawArea.getY(),                              drawArea.getWidth()-vAxisArea.getWidth(),                              drawArea.getHeight()-hAxisAreaHeight);            drawOutlineAndBackground(g2, plotArea);      getDomainAxis().draw(g2, drawArea, plotArea);      getRangeAxis().draw(g2, drawArea, plotArea);            IntervalXYDataset data = (IntervalXYDataset)chart.getDataset();      if (data!=null) {        Shape savedClip = g2.getClip();        g2.clip(plotArea);        double translatedVerticalZero = getRangeAxis().translateValueToJava2D(0.0, plotArea);        int seriesCount = data.getSeriesCount();        for (int series = 0; series<seriesCount; series++) {          int itemCount = data.getItemCount(series);          for (int item = 0; item<itemCount; item++) {            drawBar(g2, plotArea, data, series, item, getDomainAxis(), getRangeAxis(),                translatedVerticalZero);          }        }        g2.setClip(savedClip);}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public Paint getBackgroundPaint() {    return this.backgroundPaint;}", "nl": "Returns the background color of the plot area"}
{"code": "public Paint getSeriesOutlinePaint(int index) {    return seriesOutlinePaint[index % seriesOutlinePaint.length];}", "nl": "Returns the Paint used to outline any shapes for the specified series"}
{"code": "public void setSeriesStroke(Stroke[] stroke) {    this.seriesStroke = stroke;    notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the stroke used to draw any shapes representing series , and notifies registered listeners that the chart has been modified"}
{"code": "public void setBackgroundPaint(Paint paint) {      if (!this.backgroundPaint.equals(paint)) {      this.backgroundPaint = paint;      notifyListeners(new PlotChangeEvent(this));}}", "nl": "Sets the background color of the plot area , and notifies registered listeners that the plot has been modified"}
{"code": "public void setXYItemRenderer(XYItemRenderer renderer) {      this.renderer = renderer;      this.notifyListeners(new PlotChangeEvent(this));}", "nl": "Sets the item renderer , and notifies all listeners of a change to the plot"}
{"code": "public void addHorizontalLine(Number value) {      addHorizontalLine(value, Color.red);      this.notifyListeners(new PlotChangeEvent(this));}", "nl": "Adds a horizontal line at the specified data value , using the default color red"}
{"code": "public ValueAxis getDomainAxis() {    return (ValueAxis)horizontalAxis;}", "nl": "A convenience method that returns a reference to the horizontal axis cast as a ValueAxis"}
{"code": "public void addVerticalLine(Number location) {      addVerticalLine(location, Color.blue);}", "nl": "Adds a vertical line at location with default color blue"}
{"code": "public void addVerticalLine(Number location, Paint color) {      if (verticalLines == null) {        verticalLines = new ArrayList();        verticalColors = new ArrayList();      }      verticalColors.add(color);      verticalLines.add(location);}", "nl": "Adds a vertical of the given color at location with the given color"}
{"code": "public double getEffect3d() {      return effect3d;}", "nl": "Return axis 3d deep along ' Z ' axis"}
{"code": "public AbstractAxisRange(Object min, Object max) {      this.min = min;      this.max = max;}", "nl": "Creates an AbstractAxisRange object"}
{"code": "public void combine(AxisRange range) {      Object otherMin = range.getMin();      Object otherMax = range.getMax();      if (before(otherMin, min)) {        min = otherMin;      }      if (after(otherMax, max)) {        max = otherMax;}}", "nl": "Combines this with range"}
{"code": "public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {        double labelWidth = 0.0;    if (label!=null) {      Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());      labelWidth = labelInsets.left+labelInsets.right;      if (this.labelDrawnVertical) {      labelWidth = labelWidth + labelBounds.getHeight();        }      else {      labelWidth = labelWidth + labelBounds.getWidth();      }    }        double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;    if (tickLabelsVisible) {      this.refreshTicks(g2, drawArea, drawArea);      tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);    }    return labelWidth+tickLabelWidth;}", "nl": "Returns the width required to draw the axis in the specified draw area"}
{"code": "public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {    this.ticks.clear();    g2.setFont(tickLabelFont);    if (this.autoTickUnitSelection) {      selectAutoTickUnit(g2, drawArea, plotArea);    }    double size = this.tickUnit.getValue().doubleValue();    int count = this.calculateVisibleTickCount();    double lowestTickValue = this.calculateLowestVisibleTickValue();        for (int i=0; i<count; i++) {      Number currentTickValue = new Double(lowestTickValue+(i*size));      double yy = this.translateValueToJava2D(currentTickValue.doubleValue(), plotArea);      String tickLabel = this.valueToString(currentTickValue.doubleValue());      Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,                                      g2.getFontRenderContext());      float x = (float)(plotArea.getX()                  -tickLabelBounds.getWidth()                  -tickLabelInsets.left-tickLabelInsets.right);      float y = (float)(yy+(tickLabelBounds.getHeight()/2));      Tick tick = new Tick(currentTickValue, tickLabel, x, y);      ticks.add(tick);}}", "nl": "Calculates the positions of the tick labels for the axis , storing the results in the tick label list"}
{"code": "public ValueAxis getRangeAxis() {    return (ValueAxis)verticalAxis;}", "nl": "Returns the range axis"}
{"code": "double calculateBarWidth(Rectangle2D plotArea) {    CategoryDataset data = getDataset();        int categoryCount = data.getCategoryCount();    int seriesCount = data.getSeriesCount();    int barCount = renderer.barWidthsPerCategory(data)*categoryCount;          double usable = plotArea.getWidth() *                    (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);      if (renderer.barWidthsPerCategory(data)>1) {       }        return usable/barCount;}", "nl": "Returns the width of each bar in the chart"}
{"code": "public boolean isCompatibleVerticalAxis(Axis axis) {    if (axis instanceof VerticalNumberAxis) {      return true;    }    else return false;}", "nl": "Checks the compatibility of a vertical axis , returning true if the axis is compatible with the plot , and false otherwise"}
{"code": "protected void drawBars(Graphics2D g2,                Shape backgroundPlotArea, Rectangle2D dataArea,                DrawInfo info) {            CategoryDataset data = this.getDataset();      if (data!=null) {        Shape savedClip = g2.getClip();        g2.clip(backgroundPlotArea);        int seriesCount = data.getSeriesCount();        int categoryCount = data.getCategoryCount();        int barCount = renderer.barWidthsPerCategory(data);        double translatedZero = getRangeAxis().translateValueToJava2D(0.0, dataArea);                double categorySpan = 0.0;        double categoryGapSpan = 0.0;        if (categoryCount>1) {          categorySpan = dataArea.getWidth()                   * (1-introGapPercent-trailGapPercent-categoryGapsPercent);          categoryGapSpan = dataArea.getWidth()*categoryGapsPercent;        }        else {          categorySpan = dataArea.getWidth()*(1-introGapPercent-trailGapPercent);        }                double itemSpan = categorySpan;        double itemGapSpan = 0.0;        if (seriesCount>1) {          if (renderer.hasItemGaps()) {            itemGapSpan = dataArea.getWidth()*itemGapsPercent;            itemSpan = itemSpan - itemGapSpan;          }        }        double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));        int categoryIndex = 0;      Iterator iterator = data.getCategories().iterator();      while (iterator.hasNext()) {      Object category = iterator.next();      for (int series=0; series<seriesCount; series++) {            Shape tooltipArea = renderer.drawBar(g2,                               dataArea, this,                               getRangeAxis(),                               data, series,                               category, categoryIndex,                               translatedZero, itemWidth,                               categorySpan, categoryGapSpan,                               itemSpan, itemGapSpan);                        if (info!=null) {              ToolTipsCollection tooltips = info.getToolTipsCollection();              if (tooltips!=null) {                if (this.toolTipGenerator==null) {                  toolTipGenerator = new StandardCategoryToolTipGenerator();                }                String tip = this.toolTipGenerator.generateToolTip(data, series,                                           category);                if (tooltipArea!=null) {                  tooltips.addToolTip(tip, tooltipArea);                }              }            }          }          categoryIndex++;        }                Line2D baseline = new Line2D.Double(dataArea.getX(), translatedZero,                          dataArea.getMaxX(), translatedZero);        g2.setStroke(new BasicStroke());        g2.draw(baseline);        g2.setClip(savedClip);}}", "nl": "Draws charts bars g2 The graphics device ; clipped drawn"}
{"code": "public void setMaximumAxisValue(double value) {    if (this.maximumAxisValue!=value) {      this.maximumAxisValue = value;        this.autoRange = false;        notifyListeners(new AxisChangeEvent(this));}}", "nl": "Sets the maximum value for the axis"}
{"code": "public double getMinimumAxisValue() {    return minimumAxisValue;}", "nl": "Returns the minimum value for the axis"}
{"code": "public boolean isCrosshairVisible() {      return this.crosshairVisible;}", "nl": "Returns a flag indicating whether or not a crosshair is visible for this axis"}
{"code": "public void setGridPaint(Paint paint) {            if (paint==null) {        throw new IllegalArgumentException(\"ValueAxis.setGridPaint(...): null not permitted\");      }    gridPaint = paint;    notifyListeners(new AxisChangeEvent(this));}", "nl": "Sets the Paint used to color the grid lines and notifies registered listeners that the axis has been modified"}
{"code": "public boolean isAutoRange() {    return autoRange;}", "nl": "Returns true if the axis range is automatically adjusted to fit the data , and false otherwise"}
{"code": "public boolean isCrosshairLockedOnData() {      return this.crosshairLockedOnData;}", "nl": "Returns a flag indicating whether or not the crosshair should lock - on to actual data values"}
{"code": "public boolean hasItemGaps() {      return true;}", "nl": "Returns true , since for this renderer there are gaps between the items in one category"}
{"code": "public int barWidthsPerCategory(CategoryDataset data) {      return data.getSeriesCount();}", "nl": "Returns the number of bar - widths displayed in each category"}
{"code": "public VerticalBarPlot3D(CategoryAxis horizontalAxis, ValueAxis verticalAxis) {    this(horizontalAxis, verticalAxis,         Plot.DEFAULT_INSETS,         0.1, 0.1, 0.2, 0.0,         null);}", "nl": "Constructs a vertical bar plot with 3D effect"}
{"code": "protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {    VerticalAxis vAxis = getVerticalAxis();    double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();      GeneralPath backgroundPlotArea = new GeneralPath();      backgroundPlotArea.moveTo((float) plotArea.getX(), (float)plotArea.getY());      backgroundPlotArea.lineTo((float)(plotArea.getX()+effect3d),                    (float)(plotArea.getY()-effect3d));      backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),                    (float)(plotArea.getY()-effect3d));      backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),                    (float)(plotArea.getY()+plotArea.getHeight()-effect3d));      backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()-effect3d),                    (float)(plotArea.getY()+plotArea.getHeight()));      backgroundPlotArea.lineTo((float) plotArea.getX(),                    (float)(plotArea.getY()+plotArea.getHeight()));      backgroundPlotArea.lineTo((float) plotArea.getX(),                    (float) plotArea.getY());      return backgroundPlotArea;}", "nl": "Returns the shape of the background for the 3D - effect bar plot"}
{"code": "public void setChart(JFreeChart chart) {      this.chart = chart;}", "nl": "Sets the chart that generated the change event"}
{"code": "public ChartChangeEvent(Object source, JFreeChart chart) {      this(source, chart, GENERAL);}", "nl": "Standard constructor : returns a new ChartChangeEvent object , type GENERAL"}
{"code": "public boolean isVisible() {      return visible;}", "nl": "Is this axis visible ? Is is drawn ?"}
{"code": "public CombinedHorizontalDateAxis(HorizontalDateAxis axis, boolean visible) {      super(axis.getLabel(),          axis.getLabelFont(),          axis.getLabelPaint(),          axis.getLabelInsets(),          axis.isTickLabelsVisible(),          axis.getTickLabelFont(),          axis.getTickLabelPaint(),          axis.getTickLabelInsets(),          axis.getVerticalTickLabels(),          axis.isTickMarksVisible(),          axis.getTickMarkStroke(),          axis.isAutoRange(),          axis.getMinimumDate(),          axis.getMaximumDate(),          axis.isAutoTickUnitSelection(),          axis.getTickUnit(),          axis.getTickLabelFormatter(),          axis.isGridLinesVisible(),          axis.getGridStroke(),          axis.getGridPaint(),          axis.getCrosshairDate(),          axis.getCrosshairStroke(),          axis.getCrosshairPaint());      this.axis = axis;      this.visible = visible;}", "nl": "Constructs a combined horizontal date axis"}
{"code": "public void setVisible(boolean flag) {      visible = flag;}", "nl": "Sets the visible flag on or off for this combined axis"}
{"code": "public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {      if (visible) {        axis.draw(g2, drawArea, plotArea);      } else if (gridLinesVisible) {        refreshTicks(g2, drawArea, plotArea);        g2.setStroke(gridStroke);        g2.setPaint(gridPaint);        double xx = plotArea.getX();        Iterator iterator = ticks.iterator();        while (iterator.hasNext()) {          Tick tick = (Tick)iterator.next();          float yy = (float)this.translateValueToJava2D(tick.getNumericalValue(), plotArea);          Line2D gridline = new Line2D.Double(xx, yy, plotArea.getMaxX(), yy);          g2.draw(gridline);}}}", "nl": "Draws the plot on a Java 2D graphics device"}
{"code": "public double getPrimitive() {      return primitive;}", "nl": "Just use double value - should be fast"}
{"code": "public Number getPrimitiveAsObject() {      return new Double(primitive);}", "nl": "Creates a Number object every time the primitive is accessed - should be really slow"}
{"code": "protected void adjustPlotsMinMax() {      adjustPlotsMinMax((type != HORIZONTAL), (type != VERTICAL));}", "nl": "Adjusts both of our axes ranges"}
{"code": "public int getSeriesCount() {      return 2;}", "nl": "Returns the number of series in the data source"}
{"code": "public Number getMinimumHorizontalDataValue() {      if (charts.size() == 0) {        return null;      }      Number min = new Double(Double.MAX_VALUE);      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        HorizontalValuePlot plot = (HorizontalValuePlot)chartInfo.plot;        Number x = plot.getMinimumHorizontalDataValue();        if (x.doubleValue() < min.doubleValue()) {          min = x;        }      }      return min;}", "nl": "Returns the minimum value in the domain of all the charts , since this is plotted against the horizontal axis for a combined plot"}
{"code": "public void add(CombinedChart chart) throws AxisNotCompatibleException {      add(chart, 1);}", "nl": "Adds a CombinedChart to the CombinedPlot"}
{"code": "protected void setHorizontalAxisHeight(double height) {      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        Plot plot = chartInfo.plot;        CombinableAxis axis = (CombinableAxis)plot.getHorizontalAxis();        axis.setReserveDimension(height);        if (plot instanceof CombinedPlot) {          ((CombinedPlot)plot).setHorizontalAxisHeight(height);}}}", "nl": "Sets the height of the non - shared horizontal axis of all combined sub - plots to"}
{"code": "public Number getMaximumVerticalDataValue() {      if (charts.size() == 0) {        return null;      }      Number max = new Double(Double.MIN_VALUE);      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        VerticalValuePlot plot = (VerticalValuePlot)chartInfo.plot;        Number x = plot.getMaximumVerticalDataValue();        if (x.doubleValue() > max.doubleValue()) {          max = x;        }      }      return max;}", "nl": "Returns the maximum value displayed against the vertical axis"}
{"code": "protected boolean verticalAxisVisible(boolean firstPlot, boolean lastPlot, Plot subPlot) {      if (type == VERTICAL) {        return true;      } else if (firstPlot) {        return true;      } else {        return false;}}", "nl": "Returns true is a vertical axis is visible"}
{"code": "private void setAxisRangeSet(int type, boolean flag) {      axisRangeSet[type] = flag;      Iterator iter = charts.iterator();      while (iter.hasNext()) {        ChartInfo chartInfo = (ChartInfo)iter.next();        Plot plot = chartInfo.plot;        if (plot instanceof CombinedPlot) {          ((CombinedPlot)plot).setAxisRangeSet(type, flag);}}}", "nl": "Recursively sets the axisRangeSet [ type ] flag to true for this and all its CombinedPlot sub - plots"}
{"code": "public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {      if (!visible) {        return 0;      }      else if (reserveHeight > 0) {        return reserveHeight;      }      else {        return axis.reserveHeight(g2, plot, drawArea);}}", "nl": "Returns the height required to draw the axis in the specified draw area"}
{"code": "public void setVisible(boolean flag) {      visible = flag;}", "nl": "Sets the visible flag on or off for this combined axis"}
{"code": "public SampleHighLowDataset() {      this.initialiseData();}", "nl": "Default constructor"}
{"code": "public int getSeriesCount() {      return 1;}", "nl": "Returns the number of series in the data source , ONE in this sample"}
{"code": "public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,                       double reservedWidth) {      Rectangle2D empty = new Rectangle2D.Double();      Iterator iter = axes.iterator();      while (iter.hasNext()) {        HorizontalAxis axis = (HorizontalAxis)iter.next();        Rectangle2D area = axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);        if (!area.equals(empty)) {          return area;        }      }      return empty;}", "nl": "Returns area in which the axis will be displayed"}
{"code": "public AxisRange getRange() {      return plot.getRange(axes);}", "nl": "Returns the AxisRange of our Axis"}
{"code": "private Date createDate(int year, int month, int day) {      GregorianCalendar calendar = new GregorianCalendar(year, month, day);      return calendar.getTime();}", "nl": "Returns a java . util . Date for the specified year , month and day"}
{"code": "public SampleXYDataset2() {      for (int series=0; series<SERIES_COUNT; series++) {        for (int item=0; item<ITEM_COUNT; item++) {          double x = (Math.random()-0.5) * RANGE;          xValues[series][item] = new Double(x);          yValues[series][item] = new Double((Math.random() - 0.5) * x * x);}}}", "nl": "Default constructor"}
{"code": "public void clearToolTips() {      tooltips.clear();}", "nl": "Clears the tooltips"}
{"code": "public PlotPropertyEditPanel getPlotPropertyEditPanel() {      return plotPropertiesPanel;}", "nl": "Returns a reference to the plot property sub - panel"}
{"code": "private void attemptLabelFontSelection() {      FontChooserPanel panel = new FontChooserPanel(labelFont);      int result = JOptionPane.showConfirmDialog(this, panel, \"Font Selection\",        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        labelFont = panel.getSelectedFont();        labelFontField.setText(labelFont.getFontName()+\" \"+labelFont.getSize());}}", "nl": "Presents a font selection dialog to the user"}
{"code": "public Insets getLabelInsets() {      return (_labelInsets == null) ? new Insets(0,0,0,0) : _labelInsets;}", "nl": "Returns the current label insets value"}
{"code": "private void editTickLabelInsets() {      InsetsChooserPanel panel = new InsetsChooserPanel(_tickLabelInsets);      int result =        JOptionPane.showConfirmDialog(this, panel, \"Edit Insets\",                        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        _tickLabelInsets = panel.getInsets();        tickLabelInsetsTextField.setInsets(_tickLabelInsets);}}", "nl": "Presents insets chooser panel allowing user to modify tick label ' s individual insets values"}
{"code": "private void editLabelInsets() {      InsetsChooserPanel panel = new InsetsChooserPanel(_labelInsets);      int result =        JOptionPane.showConfirmDialog(this, panel, \"Edit Insets\",                      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        _labelInsets = panel.getInsets();        labelInsetsTextField.setInsets(_labelInsets);}}", "nl": "Presents insets chooser panel allowing user to modify label ' s individual insets values"}
{"code": "public Stroke getOutlineStroke() {      return outlineStrokeSample.getStroke();}", "nl": "Returns the current outline stroke"}
{"code": "private void attemptOutlinePaintSelection() {      Color c;      c = JColorChooser.showDialog(this, \"Outline Color\", Color.blue);      if (c!=null) {        outlinePaintSample.setPaint(c);}}", "nl": "Allow the user to change the outline paint"}
{"code": "public void actionPerformed(ActionEvent event) {      String command = event.getActionCommand();      if (command.equals(\"BackgroundPaint\")) {        attemptBackgroundPaintSelection();      }      else if (command.equals(\"OutlineStroke\")) {        attemptOutlineStrokeSelection();      }      else if (command.equals(\"OutlinePaint\")) {        attemptOutlinePaintSelection();      }      else if (command.equals(\"Insets\")) {        editInsets();}}", "nl": "Handles user actions generated within the panel"}
{"code": "private void attemptGridStrokeSelection() {      StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);      int result = JOptionPane.showConfirmDialog(this, panel, \"Stroke Selection\",        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);      if (result==JOptionPane.OK_OPTION) {        gridStrokeSample.setStroke(panel.getSelectedStroke());}}", "nl": "Handle a grid stroke selection"}
{"code": "private void attemptModifyBackgroundPaint() {      Color c;      c = JColorChooser.showDialog(this, \"Background Color\", Color.blue);      if (c!=null) {        backgroundPaint.setPaint(c);}}", "nl": "Allows the user the opportunity to change the background paint"}
{"code": "public Paint getSeriesPaint() {      return seriesPaint.getPaint();}", "nl": "Returns the current series label paint"}
{"code": "public void setTitleProperties(Title title) {      if (title instanceof StandardTitle) {          StandardTitle standard = (StandardTitle)title;        standard.setTitle(this.getTitle());        standard.setTitleFont(this.getTitleFont());        standard.setTitlePaint(this.getTitlePaint());}}", "nl": "Sets the properties of the specified title to match the properties defined on this panel"}
{"code": "public void attemptPaintSelection() {      Color c = JColorChooser.showDialog(this, \"Title Color\", Color.blue);      if (c!=null) {        titlePaint.setPaint(c);}}", "nl": "Allow the user the opportunity to select a Paint object"}

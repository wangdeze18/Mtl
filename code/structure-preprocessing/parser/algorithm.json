{"code": "\n\n\n\n\npublic class LinearRegression {\n    private final double intercept, slope;\n    private final double r2;\n    private final double svar0, svar1;\n\n   \n    public LinearRegression(double[] x, double[] y) {\n        if (x.length != y.length) {\n            throw new IllegalArgumentException(\"array lengths are not equal\");\n        }\n        int n = x.length;\n\n        double sumx = 0.0, sumy = 0.0, sumx2 = 0.0;\n        for (int i = 0; i < n; i++) {\n            sumx  += x[i];\n            sumx2 += x[i]*x[i];\n            sumy  += y[i];\n        }\n        double xbar = sumx / n;\n        double ybar = sumy / n;\n\n        double xxbar = 0.0, yybar = 0.0, xybar = 0.0;\n        for (int i = 0; i < n; i++) {\n            xxbar += (x[i] - xbar) * (x[i] - xbar);\n            yybar += (y[i] - ybar) * (y[i] - ybar);\n            xybar += (x[i] - xbar) * (y[i] - ybar);\n        }\n        slope  = xybar / xxbar;\n        intercept = ybar - slope * xbar;\n\n        double rss = 0.0;      // residual sum of squares\n        double ssr = 0.0;      // regression sum of squares\n        for (int i = 0; i < n; i++) {\n            double fit = slope*x[i] + intercept;\n            rss += (fit - y[i]) * (fit - y[i]);\n            ssr += (fit - ybar) * (fit - ybar);\n        }\n\n        int degreesOfFreedom = n-2;\n        r2    = ssr / yybar;\n        double svar  = rss / degreesOfFreedom;\n        svar1 = svar / xxbar;\n        svar0 = svar/n + xbar*xbar*svar1;\n    }\n\n   \n    public double intercept() {\n        return intercept;\n    }\n\n   \n    public double slope() {\n        return slope;\n    }\n\n   \n    public double R2() {\n        return r2;\n    }\n\n   \n    public double interceptStdErr() {\n        return Math.sqrt(svar0);\n    }\n\n   \n    public double slopeStdErr() {\n        return Math.sqrt(svar1);\n    }\n\n   \n    public double predict(double x) {\n        return slope*x + intercept;\n    }\n\n   \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(String.format(\"%.2f n + %.2f\", slope(), intercept()));\n        s.append(\"  (R^2 = \" + String.format(\"%.3f\", R2()) + \")\");\n        return s.toString();\n    }\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\n\npublic class StopwatchCPU {\n    private static final double NANOSECONDS_PER_SECOND = 1000000000;\n\n    private final ThreadMXBean threadTimer;\n    private final long start;\n            \n    \n    public StopwatchCPU() {  \n        threadTimer = ManagementFactory.getThreadMXBean();\n        start = threadTimer.getCurrentThreadCpuTime();\n    }   \n        \n    \n    public double elapsedTime() {\n        long now = threadTimer.getCurrentThreadCpuTime();\n        return (now - start) / NANOSECONDS_PER_SECOND;\n    }\n\n    \n    public static void main(String[] args) {\n        int n = Integer.parseInt(args[0]);\n\n        StopwatchCPU timer1 = new StopwatchCPU();\n        double sum1 = 0.0;\n        for (int i = 1; i <= n; i++) {\n            sum1 += Math.sqrt(i);\n        }\n        double time1 = timer1.elapsedTime();\n        StdOut.printf(\"%e (%.2f seconds)\\n\", sum1, time1);\n\n        StopwatchCPU timer2 = new StopwatchCPU();\n        double sum2 = 0.0;\n        for (int i = 1; i <= n; i++) {\n            sum2 += Math.pow(i, 0.5);\n        }\n        double time2 = timer2.elapsedTime();\n        StdOut.printf(\"%e (%.2f seconds)\\n\", sum2, time2);\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class QuickBentleyMcIlroy {\n\n    private static final int INSERTION_SORT_CUTOFF = 8;\n\n    private static final int MEDIAN_OF_3_CUTOFF = 40;\n\n    private QuickBentleyMcIlroy() { }\n\n    \n    public static void sort(Comparable[] a) {\n        sort(a, 0, a.length - 1);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) { \n        int n = hi - lo + 1;\n\n        if (n <= INSERTION_SORT_CUTOFF) {\n            insertionSort(a, lo, hi);\n            return;\n        }\n\n        else if (n <= MEDIAN_OF_3_CUTOFF) {\n            int m = median3(a, lo, lo + n/2, hi);\n            exch(a, m, lo);\n        }\n\n        else  {\n            int eps = n/8;\n            int mid = lo + n/2;\n            int m1 = median3(a, lo, lo + eps, lo + eps + eps);\n            int m2 = median3(a, mid - eps, mid, mid + eps);\n            int m3 = median3(a, hi - eps - eps, hi - eps, hi); \n            int ninther = median3(a, m1, m2, m3);\n            exch(a, ninther, lo);\n        }\n\n        int i = lo, j = hi+1;\n        int p = lo, q = hi+1;\n        Comparable v = a[lo];\n        while (true) {\n            while (less(a[++i], v))\n                if (i == hi) break;\n            while (less(v, a[--j]))\n                if (j == lo) break;\n\n            if (i == j && eq(a[i], v))\n                exch(a, ++p, i);\n            if (i >= j) break;\n\n            exch(a, i, j);\n            if (eq(a[i], v)) exch(a, ++p, i);\n            if (eq(a[j], v)) exch(a, --q, j);\n        }\n\n\n        i = j + 1;\n        for (int k = lo; k <= p; k++)\n            exch(a, k, j--);\n        for (int k = hi; k >= q; k--)\n            exch(a, k, i++);\n\n        sort(a, lo, j);\n        sort(a, i, hi);\n    }\n\n\n    private static void insertionSort(Comparable[] a, int lo, int hi) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1]); j--)\n                exch(a, j, j-1);\n    }\n\n\n    private static int median3(Comparable[] a, int i, int j, int k) {\n        return (less(a[i], a[j]) ?\n               (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) :\n               (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i));\n    }\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        if (v == w) return false;    // optimization when reference equal\n        return v.compareTo(w) < 0;\n    }\n\n    private static boolean eq(Comparable v, Comparable w) {\n        if (v == w) return true;    // optimization when reference equal\n        return v.compareTo(w) == 0;\n    }\n        \n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 1; i < a.length; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        QuickBentleyMcIlroy.sort(a);\n        assert isSorted(a);\n        show(a);\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class HexDump {\n\n    private HexDump() { }\n\n    \n    public static void main(String[] args) {\n        int bytesPerLine = 16;\n        if (args.length == 1) {\n            bytesPerLine = Integer.parseInt(args[0]);\n        }\n\n        int i;\n        for (i = 0; !BinaryStdIn.isEmpty(); i++) {\n            if (bytesPerLine == 0) {\n                BinaryStdIn.readChar();\n                continue;\n            }\n            if (i == 0) StdOut.printf(\"\");\n            else if (i % bytesPerLine == 0) StdOut.printf(\"\\n\", i);\n            else StdOut.print(\" \");\n            char c = BinaryStdIn.readChar();\n            StdOut.printf(\"%02x\", c & 0xff);\n        }\n        if (bytesPerLine != 0) StdOut.println();\n        StdOut.println((i*8) + \" bits\");\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\n\n\npublic class Digraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;           // number of vertices in this digraph\n    private int E;                 // number of edges in this digraph\n    private Bag<Integer>[] adj;    // adj[v] = adjacency list for vertex v\n    private int[] indegree;        // indegree[v] = indegree of vertex v\n    \n    \n    public Digraph(int V) {\n        if (V < 0) throw new IllegalArgumentException(\"Number of vertices in a Digraph must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        indegree = new int[V];\n        adj = (Bag<Integer>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<Integer>();\n        }\n    }\n\n    \n    public Digraph(In in) {\n        try {\n            this.V = in.readInt();\n            if (V < 0) throw new IllegalArgumentException(\"number of vertices in a Digraph must be nonnegative\");\n            indegree = new int[V];\n            adj = (Bag<Integer>[]) new Bag[V];\n            for (int v = 0; v < V; v++) {\n                adj[v] = new Bag<Integer>();\n            }\n            int E = in.readInt();\n            if (E < 0) throw new IllegalArgumentException(\"number of edges in a Digraph must be nonnegative\");\n            for (int i = 0; i < E; i++) {\n                int v = in.readInt();\n                int w = in.readInt();\n                addEdge(v, w); \n            }\n        }\n        catch (NoSuchElementException e) {\n            throw new IllegalArgumentException(\"invalid input format in Digraph constructor\", e);\n        }\n    }\n\n    \n    public Digraph(Digraph G) {\n        this(G.V());\n        this.E = G.E();\n        for (int v = 0; v < V; v++)\n            this.indegree[v] = G.indegree(v);\n        for (int v = 0; v < G.V(); v++) {\n            Stack<Integer> reverse = new Stack<Integer>();\n            for (int w : G.adj[v]) {\n                reverse.push(w);\n            }\n            for (int w : reverse) {\n                adj[v].add(w);\n            }\n        }\n    }\n        \n    \n    public int V() {\n        return V;\n    }\n\n    \n    public int E() {\n        return E;\n    }\n\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public void addEdge(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        adj[v].add(w);\n        indegree[w]++;\n        E++;\n    }\n\n    \n    public Iterable<Integer> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    \n    public int outdegree(int v) {\n        validateVertex(v);\n        return adj[v].size();\n    }\n\n    \n    public int indegree(int v) {\n        validateVertex(v);\n        return indegree[v];\n    }\n\n    \n    public Digraph reverse() {\n        Digraph reverse = new Digraph(V);\n        for (int v = 0; v < V; v++) {\n            for (int w : adj(v)) {\n                reverse.addEdge(w, v);\n            }\n        }\n        return reverse;\n    }\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" vertices, \" + E + \" edges \" + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(String.format(\"%d: \", v));\n            for (int w : adj[v]) {\n                s.append(String.format(\"%d \", w));\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n        StdOut.println(G);\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Inversions {\n\n    private Inversions() { }\n\n    private static long merge(int[] a, int[] aux, int lo, int mid, int hi) {\n        long inversions = 0;\n\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k]; \n        }\n\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)           a[k] = aux[j++];\n            else if (j > hi)            a[k] = aux[i++];\n            else if (aux[j] < aux[i]) { a[k] = aux[j++]; inversions += (mid - i + 1); }\n            else                        a[k] = aux[i++];\n        }\n        return inversions;\n    }\n\n    private static long count(int[] a, int[] b, int[] aux, int lo, int hi) {\n        long inversions = 0;\n        if (hi <= lo) return 0;\n        int mid = lo + (hi - lo) / 2;\n        inversions += count(a, b, aux, lo, mid);  \n        inversions += count(a, b, aux, mid+1, hi);\n        inversions += merge(b, aux, lo, mid, hi);\n        assert inversions == brute(a, lo, hi);\n        return inversions;\n    }\n\n\n    \n    public static long count(int[] a) {\n        int[] b   = new int[a.length];\n        int[] aux = new int[a.length];\n        for (int i = 0; i < a.length; i++)\n            b[i] = a[i];\n        long inversions = count(a, b, aux, 0, a.length - 1);\n        return inversions;\n    }\n\n\n\n    private static <Key extends Comparable<Key>> long merge(Key[] a, Key[] aux, int lo, int mid, int hi) {\n        long inversions = 0;\n\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k]; \n        }\n\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)                a[k] = aux[j++];\n            else if (j > hi)                 a[k] = aux[i++];\n            else if (less(aux[j], aux[i])) { a[k] = aux[j++]; inversions += (mid - i + 1); }\n            else                             a[k] = aux[i++];\n        }\n        return inversions;\n    }\n\n    private static <Key extends Comparable<Key>> long count(Key[] a, Key[] b, Key[] aux, int lo, int hi) {\n        long inversions = 0;\n        if (hi <= lo) return 0;\n        int mid = lo + (hi - lo) / 2;\n        inversions += count(a, b, aux, lo, mid);  \n        inversions += count(a, b, aux, mid+1, hi);\n        inversions += merge(b, aux, lo, mid, hi);\n        assert inversions == brute(a, lo, hi);\n        return inversions;\n    }\n\n\n    \n    public static <Key extends Comparable<Key>> long count(Key[] a) {\n        Key[] b   = a.clone();\n        Key[] aux = a.clone();\n        long inversions = count(a, b, aux, 0, a.length - 1);\n        return inversions;\n    }\n\n\n    private static <Key extends Comparable<Key>> boolean less(Key v, Key w) {\n        return (v.compareTo(w) < 0);\n    }\n\n    private static <Key extends Comparable<Key>> long brute(Key[] a, int lo, int hi) {\n        long inversions = 0;\n        for (int i = lo; i <= hi; i++)\n            for (int j = i + 1; j <= hi; j++)\n                if (less(a[j], a[i])) inversions++;\n        return inversions;\n    }\n\n    private static long brute(int[] a, int lo, int hi) {\n        long inversions = 0;\n        for (int i = lo; i <= hi; i++)\n            for (int j = i + 1; j <= hi; j++)\n                if (a[j] < a[i]) inversions++;\n        return inversions;\n    }\n\n    \n    public static void main(String[] args) {\n        int[] a = StdIn.readAllInts();\n        int n = a.length;\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++)\n            b[i] = a[i];\n        StdOut.println(Inversions.count(a));\n        StdOut.println(Inversions.count(b));\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class BellmanFordSP {\n    private double[] distTo;               // distTo[v] = distance  of shortest s->v path\n    private DirectedEdge[] edgeTo;         // edgeTo[v] = last edge on shortest s->v path\n    private boolean[] onQueue;             // onQueue[v] = is v currently on the queue?\n    private Queue<Integer> queue;          // queue of vertices to relax\n    private int cost;                      // number of calls to relax()\n    private Iterable<DirectedEdge> cycle;  // negative cycle (or null if no such cycle)\n\n    \n    public BellmanFordSP(EdgeWeightedDigraph G, int s) {\n        distTo  = new double[G.V()];\n        edgeTo  = new DirectedEdge[G.V()];\n        onQueue = new boolean[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = Double.POSITIVE_INFINITY;\n        distTo[s] = 0.0;\n\n        queue = new Queue<Integer>();\n        queue.enqueue(s);\n        onQueue[s] = true;\n        while (!queue.isEmpty() && !hasNegativeCycle()) {\n            int v = queue.dequeue();\n            onQueue[v] = false;\n            relax(G, v);\n        }\n\n        assert check(G, s);\n    }\n\n    private void relax(EdgeWeightedDigraph G, int v) {\n        for (DirectedEdge e : G.adj(v)) {\n            int w = e.to();\n            if (distTo[w] > distTo[v] + e.weight()) {\n                distTo[w] = distTo[v] + e.weight();\n                edgeTo[w] = e;\n                if (!onQueue[w]) {\n                    queue.enqueue(w);\n                    onQueue[w] = true;\n                }\n            }\n            if (cost++ % G.V() == 0) {\n                findNegativeCycle();\n                if (hasNegativeCycle()) return;  // found a negative cycle\n            }\n        }\n    }\n\n    \n    public boolean hasNegativeCycle() {\n        return cycle != null;\n    }\n\n    \n    public Iterable<DirectedEdge> negativeCycle() {\n        return cycle;\n    }\n\n    private void findNegativeCycle() {\n        int V = edgeTo.length;\n        EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);\n        for (int v = 0; v < V; v++)\n            if (edgeTo[v] != null)\n                spt.addEdge(edgeTo[v]);\n\n        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);\n        cycle = finder.cycle();\n    }\n\n    \n    public double distTo(int v) {\n        validateVertex(v);\n        if (hasNegativeCycle())\n            throw new UnsupportedOperationException(\"Negative cost cycle exists\");\n        return distTo[v];\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return distTo[v] < Double.POSITIVE_INFINITY;\n    }\n\n    \n    public Iterable<DirectedEdge> pathTo(int v) {\n        validateVertex(v);\n        if (hasNegativeCycle())\n            throw new UnsupportedOperationException(\"Negative cost cycle exists\");\n        if (!hasPathTo(v)) return null;\n        Stack<DirectedEdge> path = new Stack<DirectedEdge>();\n        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {\n            path.push(e);\n        }\n        return path;\n    }\n\n    private boolean check(EdgeWeightedDigraph G, int s) {\n\n        if (hasNegativeCycle()) {\n            double weight = 0.0;\n            for (DirectedEdge e : negativeCycle()) {\n                weight += e.weight();\n            }\n            if (weight >= 0.0) {\n                System.err.println(\"error: weight of negative cycle = \" + weight);\n                return false;\n            }\n        }\n\n        else {\n\n            if (distTo[s] != 0.0 || edgeTo[s] != null) {\n                System.err.println(\"distanceTo[s] and edgeTo[s] inconsistent\");\n                return false;\n            }\n            for (int v = 0; v < G.V(); v++) {\n                if (v == s) continue;\n                if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {\n                    System.err.println(\"distTo[] and edgeTo[] inconsistent\");\n                    return false;\n                }\n            }\n\n            for (int v = 0; v < G.V(); v++) {\n                for (DirectedEdge e : G.adj(v)) {\n                    int w = e.to();\n                    if (distTo[v] + e.weight() < distTo[w]) {\n                        System.err.println(\"edge \" + e + \" not relaxed\");\n                        return false;\n                    }\n                }\n            }\n\n            for (int w = 0; w < G.V(); w++) {\n                if (edgeTo[w] == null) continue;\n                DirectedEdge e = edgeTo[w];\n                int v = e.from();\n                if (w != e.to()) return false;\n                if (distTo[v] + e.weight() != distTo[w]) {\n                    System.err.println(\"edge \" + e + \" on shortest path not tight\");\n                    return false;\n                }\n            }\n        }\n\n        StdOut.println(\"Satisfies optimality conditions\");\n        StdOut.println();\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = distTo.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        int s = Integer.parseInt(args[1]);\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);\n\n        BellmanFordSP sp = new BellmanFordSP(G, s);\n\n        if (sp.hasNegativeCycle()) {\n            for (DirectedEdge e : sp.negativeCycle())\n                StdOut.println(e);\n        }\n\n        else {\n            for (int v = 0; v < G.V(); v++) {\n                if (sp.hasPathTo(v)) {\n                    StdOut.printf(\"%d to %d (%5.2f)  \", s, v, sp.distTo(v));\n                    for (DirectedEdge e : sp.pathTo(v)) {\n                        StdOut.print(e + \"   \");\n                    }\n                    StdOut.println();\n                }\n                else {\n                    StdOut.printf(\"%d to %d           no path\\n\", s, v);\n                }\n            }\n        }\n\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class LinkedQueue<Item> implements Iterable<Item> {\n    private int n;         // number of elements on queue\n    private Node first;    // beginning of queue\n    private Node last;     // end of queue\n\n    private class Node {\n        private Item item;\n        private Node next;\n    }\n\n    \n    public LinkedQueue() {\n        first = null;\n        last  = null;\n        n = 0;\n        assert check();\n    }\n\n    \n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    \n    public int size() {\n        return n;     \n    }\n\n    \n    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        return first.item;\n    }\n\n    \n    public void enqueue(Item item) {\n        Node oldlast = last;\n        last = new Node();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else           oldlast.next = last;\n        n++;\n        assert check();\n    }\n\n    \n    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        Item item = first.item;\n        first = first.next;\n        n--;\n        if (isEmpty()) last = null;   // to avoid loitering\n        assert check();\n        return item;\n    }\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this)\n            s.append(item + \" \");\n        return s.toString();\n    } \n\n    private boolean check() {\n        if (n < 0) {\n            return false;\n        }\n        else if (n == 0) {\n            if (first != null) return false;\n            if (last  != null) return false;\n        }\n        else if (n == 1) {\n            if (first == null || last == null) return false;\n            if (first != last)                 return false;\n            if (first.next != null)            return false;\n        }\n        else {\n            if (first == null || last == null) return false;\n            if (first == last)      return false;\n            if (first.next == null) return false;\n            if (last.next  != null) return false;\n\n            int numberOfNodes = 0;\n            for (Node x = first; x != null && numberOfNodes <= n; x = x.next) {\n                numberOfNodes++;\n            }\n            if (numberOfNodes != n) return false;\n\n            Node lastNode = first;\n            while (lastNode.next != null) {\n                lastNode = lastNode.next;\n            }\n            if (last != lastNode) return false;\n        }\n\n        return true;\n    } \n \n\n    \n    public Iterator<Item> iterator()  {\n        return new ListIterator();  \n    }\n\n    private class ListIterator implements Iterator<Item> {\n        private Node current = first;\n\n        public boolean hasNext()  { return current != null;                     }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = current.item;\n            current = current.next; \n            return item;\n        }\n    }\n\n\n    \n    public static void main(String[] args) {\n        LinkedQueue<String> queue = new LinkedQueue<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\"))\n                queue.enqueue(item);\n            else if (!queue.isEmpty())\n                StdOut.print(queue.dequeue() + \" \");\n        }\n        StdOut.println(\"(\" + queue.size() + \" left on queue)\");\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class RunLength {\n    private static final int R    = 256;\n    private static final int LG_R = 8;\n\n    private RunLength() { }\n\n    \n    public static void expand() { \n        boolean b = false; \n        while (!BinaryStdIn.isEmpty()) {\n            int run = BinaryStdIn.readInt(LG_R);\n            for (int i = 0; i < run; i++)\n                BinaryStdOut.write(b);\n            b = !b;\n        }\n        BinaryStdOut.close();\n    }\n\n    \n    public static void compress() { \n        char run = 0; \n        boolean old = false;\n        while (!BinaryStdIn.isEmpty()) { \n            boolean b = BinaryStdIn.readBoolean();\n            if (b != old) {\n                BinaryStdOut.write(run, LG_R);\n                run = 1;\n                old = !old;\n            }\n            else { \n                if (run == R-1) { \n                    BinaryStdOut.write(run, LG_R);\n                    run = 0;\n                    BinaryStdOut.write(run, LG_R);\n                }\n                run++;\n            } \n        } \n        BinaryStdOut.write(run, LG_R);\n        BinaryStdOut.close();\n    }\n\n\n    \n    public static void main(String[] args) {\n        if      (args[0].equals(\"-\")) compress();\n        else if (args[0].equals(\"+\")) expand();\n        else throw new IllegalArgumentException(\"Illegal command line argument\");\n    }\n\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\npublic class GabowSCC {\n\n    private boolean[] marked;        // marked[v] = has v been visited?\n    private int[] id;                // id[v] = id of strong component containing v\n    private int[] preorder;          // preorder[v] = preorder of v\n    private int pre;                 // preorder number counter\n    private int count;               // number of strongly-connected components\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n\n    \n    public GabowSCC(Digraph G) {\n        marked = new boolean[G.V()];\n        stack1 = new Stack<Integer>();\n        stack2 = new Stack<Integer>();\n        id = new int[G.V()]; \n        preorder = new int[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            id[v] = -1;\n\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v]) dfs(G, v);\n        }\n\n        assert check(G);\n    }\n\n    private void dfs(Digraph G, int v) { \n        marked[v] = true;\n        preorder[v] = pre++;\n        stack1.push(v);\n        stack2.push(v);\n        for (int w : G.adj(v)) {\n            if (!marked[w]) dfs(G, w);\n            else if (id[w] == -1) {\n                while (preorder[stack2.peek()] > preorder[w])\n                    stack2.pop();\n            }\n        }\n\n        if (stack2.peek() == v) {\n            stack2.pop();\n            int w;\n            do {\n                w = stack1.pop();\n                id[w] = count;\n            } while (w != v);\n            count++;\n        }\n    }\n\n    \n    public int count() {\n        return count;\n    }\n\n    \n    public boolean stronglyConnected(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return id[v] == id[w];\n    }\n\n    \n    public int id(int v) {\n        validateVertex(v);\n        return id[v];\n    }\n\n    private boolean check(Digraph G) {\n        TransitiveClosure tc = new TransitiveClosure(G);\n        for (int v = 0; v < G.V(); v++) {\n            for (int w = 0; w < G.V(); w++) {\n                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n        GabowSCC scc = new GabowSCC(G);\n\n        int m = scc.count();\n        StdOut.println(m + \" components\");\n\n        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];\n        for (int i = 0; i < m; i++) {\n            components[i] = new Queue<Integer>();\n        }\n        for (int v = 0; v < G.V(); v++) {\n            components[scc.id(v)].enqueue(v);\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int v : components[i]) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Shell {\n\n    private Shell() { }\n\n    \n    public static void sort(Comparable[] a) {\n        int n = a.length;\n\n        int h = 1;\n        while (h < n/3) h = 3*h + 1; \n\n        while (h >= 1) {\n            for (int i = h; i < n; i++) {\n                for (int j = i; j >= h && less(a[j], a[j-h]); j -= h) {\n                    exch(a, j, j-h);\n                }\n            }\n            assert isHsorted(a, h); \n            h /= 3;\n        }\n        assert isSorted(a);\n    }\n\n\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n        \n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 1; i < a.length; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static boolean isHsorted(Comparable[] a, int h) {\n        for (int i = h; i < a.length; i++)\n            if (less(a[i], a[i-h])) return false;\n        return true;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        Shell.sort(a);\n        show(a);\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class Huffman {\n\n    private static final int R = 256;\n\n    private Huffman() { }\n\n    private static class Node implements Comparable<Node> {\n        private final char ch;\n        private final int freq;\n        private final Node left, right;\n\n        Node(char ch, int freq, Node left, Node right) {\n            this.ch    = ch;\n            this.freq  = freq;\n            this.left  = left;\n            this.right = right;\n        }\n\n        private boolean isLeaf() {\n            assert ((left == null) && (right == null)) || ((left != null) && (right != null));\n            return (left == null) && (right == null);\n        }\n\n        public int compareTo(Node that) {\n            return this.freq - that.freq;\n        }\n    }\n\n    \n    public static void compress() {\n        String s = BinaryStdIn.readString();\n        char[] input = s.toCharArray();\n\n        int[] freq = new int[R];\n        for (int i = 0; i < input.length; i++)\n            freq[input[i]]++;\n\n        Node root = buildTrie(freq);\n\n        String[] st = new String[R];\n        buildCode(st, root, \"\");\n\n        writeTrie(root);\n\n        BinaryStdOut.write(input.length);\n\n        for (int i = 0; i < input.length; i++) {\n            String code = st[input[i]];\n            for (int j = 0; j < code.length(); j++) {\n                if (code.charAt(j) == '0') {\n                    BinaryStdOut.write(false);\n                }\n                else if (code.charAt(j) == '1') {\n                    BinaryStdOut.write(true);\n                }\n                else throw new IllegalStateException(\"Illegal state\");\n            }\n        }\n\n        BinaryStdOut.close();\n    }\n\n    private static Node buildTrie(int[] freq) {\n\n        MinPQ<Node> pq = new MinPQ<Node>();\n        for (char i = 0; i < R; i++)\n            if (freq[i] > 0)\n                pq.insert(new Node(i, freq[i], null, null));\n\n        if (pq.size() == 1) {\n            if (freq['\\0'] == 0) pq.insert(new Node('\\0', 0, null, null));\n            else                 pq.insert(new Node('\\1', 0, null, null));\n        }\n\n        while (pq.size() > 1) {\n            Node left  = pq.delMin();\n            Node right = pq.delMin();\n            Node parent = new Node('\\0', left.freq + right.freq, left, right);\n            pq.insert(parent);\n        }\n        return pq.delMin();\n    }\n\n\n    private static void writeTrie(Node x) {\n        if (x.isLeaf()) {\n            BinaryStdOut.write(true);\n            BinaryStdOut.write(x.ch, 8);\n            return;\n        }\n        BinaryStdOut.write(false);\n        writeTrie(x.left);\n        writeTrie(x.right);\n    }\n\n    private static void buildCode(String[] st, Node x, String s) {\n        if (!x.isLeaf()) {\n            buildCode(st, x.left,  s + '0');\n            buildCode(st, x.right, s + '1');\n        }\n        else {\n            st[x.ch] = s;\n        }\n    }\n\n    \n    public static void expand() {\n\n        Node root = readTrie(); \n\n        int length = BinaryStdIn.readInt();\n\n        for (int i = 0; i < length; i++) {\n            Node x = root;\n            while (!x.isLeaf()) {\n                boolean bit = BinaryStdIn.readBoolean();\n                if (bit) x = x.right;\n                else     x = x.left;\n            }\n            BinaryStdOut.write(x.ch, 8);\n        }\n        BinaryStdOut.close();\n    }\n\n\n    private static Node readTrie() {\n        boolean isLeaf = BinaryStdIn.readBoolean();\n        if (isLeaf) {\n            return new Node(BinaryStdIn.readChar(), -1, null, null);\n        }\n        else {\n            return new Node('\\0', -1, readTrie(), readTrie());\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        if      (args[0].equals(\"-\")) compress();\n        else if (args[0].equals(\"+\")) expand();\n        else throw new IllegalArgumentException(\"Illegal command line argument\");\n    }\n\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class KMP {\n    private final int R;       // the radix\n    private int[][] dfa;       // the KMP automoton\n\n    private char[] pattern;    // either the character array for the pattern\n    private String pat;        // or the pattern string\n\n    \n    public KMP(String pat) {\n        this.R = 256;\n        this.pat = pat;\n\n        int m = pat.length();\n        dfa = new int[R][m]; \n        dfa[pat.charAt(0)][0] = 1; \n        for (int x = 0, j = 1; j < m; j++) {\n            for (int c = 0; c < R; c++) \n                dfa[c][j] = dfa[c][x];     // Copy mismatch cases. \n            dfa[pat.charAt(j)][j] = j+1;   // Set match case. \n            x = dfa[pat.charAt(j)][x];     // Update restart state. \n        } \n    } \n\n    \n    public KMP(char[] pattern, int R) {\n        this.R = R;\n        this.pattern = new char[pattern.length];\n        for (int j = 0; j < pattern.length; j++)\n            this.pattern[j] = pattern[j];\n\n        int m = pattern.length;\n        dfa = new int[R][m]; \n        dfa[pattern[0]][0] = 1; \n        for (int x = 0, j = 1; j < m; j++) {\n            for (int c = 0; c < R; c++) \n                dfa[c][j] = dfa[c][x];     // Copy mismatch cases. \n            dfa[pattern[j]][j] = j+1;      // Set match case. \n            x = dfa[pattern[j]][x];        // Update restart state. \n        } \n    } \n\n    \n    public int search(String txt) {\n\n        int m = pat.length();\n        int n = txt.length();\n        int i, j;\n        for (i = 0, j = 0; i < n && j < m; i++) {\n            j = dfa[txt.charAt(i)][j];\n        }\n        if (j == m) return i - m;    // found\n        return n;                    // not found\n    }\n\n    \n    public int search(char[] text) {\n\n        int m = pattern.length;\n        int n = text.length;\n        int i, j;\n        for (i = 0, j = 0; i < n && j < m; i++) {\n            j = dfa[text[i]][j];\n        }\n        if (j == m) return i - m;    // found\n        return n;                    // not found\n    }\n\n\n    \n    public static void main(String[] args) {\n        String pat = args[0];\n        String txt = args[1];\n        char[] pattern = pat.toCharArray();\n        char[] text    = txt.toCharArray();\n\n        KMP kmp1 = new KMP(pat);\n        int offset1 = kmp1.search(txt);\n\n        KMP kmp2 = new KMP(pattern, 256);\n        int offset2 = kmp2.search(text);\n\n        StdOut.println(\"text:    \" + txt);\n\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset1; i++)\n            StdOut.print(\" \");\n        StdOut.println(pat);\n\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset2; i++)\n            StdOut.print(\" \");\n        StdOut.println(pat);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class KruskalMST {\n    private static final double FLOATING_POINT_EPSILON = 1E-12;\n\n    private double weight;                        // weight of MST\n    private Queue<Edge> mst = new Queue<Edge>();  // edges in MST\n\n    \n    public KruskalMST(EdgeWeightedGraph G) {\n        MinPQ<Edge> pq = new MinPQ<Edge>();\n        for (Edge e : G.edges()) {\n            pq.insert(e);\n        }\n\n        UF uf = new UF(G.V());\n        while (!pq.isEmpty() && mst.size() < G.V() - 1) {\n            Edge e = pq.delMin();\n            int v = e.either();\n            int w = e.other(v);\n            if (!uf.connected(v, w)) { // v-w does not create a cycle\n                uf.union(v, w);  // merge v and w components\n                mst.enqueue(e);  // add edge e to mst\n                weight += e.weight();\n            }\n        }\n\n        assert check(G);\n    }\n\n    \n    public Iterable<Edge> edges() {\n        return mst;\n    }\n\n    \n    public double weight() {\n        return weight;\n    }\n    \n    private boolean check(EdgeWeightedGraph G) {\n\n        double total = 0.0;\n        for (Edge e : edges()) {\n            total += e.weight();\n        }\n        if (Math.abs(total - weight()) > FLOATING_POINT_EPSILON) {\n            System.err.printf(\"Weight of edges does not equal weight(): %f vs. %f\\n\", total, weight());\n            return false;\n        }\n\n        UF uf = new UF(G.V());\n        for (Edge e : edges()) {\n            int v = e.either(), w = e.other(v);\n            if (uf.connected(v, w)) {\n                System.err.println(\"Not a forest\");\n                return false;\n            }\n            uf.union(v, w);\n        }\n\n        for (Edge e : G.edges()) {\n            int v = e.either(), w = e.other(v);\n            if (!uf.connected(v, w)) {\n                System.err.println(\"Not a spanning forest\");\n                return false;\n            }\n        }\n\n        for (Edge e : edges()) {\n\n            uf = new UF(G.V());\n            for (Edge f : mst) {\n                int x = f.either(), y = f.other(x);\n                if (f != e) uf.union(x, y);\n            }\n            \n            for (Edge f : G.edges()) {\n                int x = f.either(), y = f.other(x);\n                if (!uf.connected(x, y)) {\n                    if (f.weight() < e.weight()) {\n                        System.err.println(\"Edge \" + f + \" violates cut optimality conditions\");\n                        return false;\n                    }\n                }\n            }\n\n        }\n\n        return true;\n    }\n\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedGraph G = new EdgeWeightedGraph(in);\n        KruskalMST mst = new KruskalMST(G);\n        for (Edge e : mst.edges()) {\n            StdOut.println(e);\n        }\n        StdOut.printf(\"%.5f\\n\", mst.weight());\n    }\n\n}\n\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class BinarySearch {\n\n    \n    private BinarySearch() { }\n\n    \n    public static int indexOf(int[] a, int key) {\n        int lo = 0;\n        int hi = a.length - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if      (key < a[mid]) hi = mid - 1;\n            else if (key > a[mid]) lo = mid + 1;\n            else return mid;\n        }\n        return -1;\n    }\n\n    \n    @Deprecated\n    public static int rank(int key, int[] a) {\n        return indexOf(a, key);\n    }\n\n    \n    public static void main(String[] args) {\n\n        In in = new In(args[0]);\n        int[] whitelist = in.readAllInts();\n\n        Arrays.sort(whitelist);\n\n        while (!StdIn.isEmpty()) {\n            int key = StdIn.readInt();\n            if (BinarySearch.indexOf(whitelist, key) == -1)\n                StdOut.println(key);\n        }\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class DirectedEulerianPath {\n    private Stack<Integer> path = null;   // Eulerian path; null if no suh path\n\n    \n    public DirectedEulerianPath(Digraph G) {\n\n        int deficit = 0;\n        int s = nonIsolatedVertex(G);\n        for (int v = 0; v < G.V(); v++) {\n            if (G.outdegree(v) > G.indegree(v)) {\n                deficit += (G.outdegree(v) - G.indegree(v));\n                s = v;\n            }\n        }\n\n        if (deficit > 1) return;\n\n        if (s == -1) s = 0;\n\n        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            adj[v] = G.adj(v).iterator();\n\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(s);\n        path = new Stack<Integer>();\n        while (!stack.isEmpty()) {\n            int v = stack.pop();\n            while (adj[v].hasNext()) {\n                stack.push(v);\n                v = adj[v].next();\n            }\n            path.push(v);\n        }\n            \n        if (path.size() != G.E() + 1)\n            path = null;\n\n        assert check(G);\n    }\n\n    \n    public Iterable<Integer> path() {\n        return path;\n    }\n\n    \n    public boolean hasEulerianPath() {\n        return path != null;\n    }\n\n\n    private static int nonIsolatedVertex(Digraph G) {\n        for (int v = 0; v < G.V(); v++)\n            if (G.outdegree(v) > 0)\n                return v;\n        return -1;\n    }\n\n\n    \n\n    private static boolean satisfiesNecessaryAndSufficientConditions(Digraph G) {\n        if (G.E() == 0) return true;\n\n        int deficit = 0;\n        for (int v = 0; v < G.V(); v++)\n            if (G.outdegree(v) > G.indegree(v))\n                deficit += (G.outdegree(v) - G.indegree(v));\n        if (deficit > 1) return false;\n\n        Graph H = new Graph(G.V());\n        for (int v = 0; v < G.V(); v++)\n            for (int w : G.adj(v))\n                H.addEdge(v, w);\n        \n        int s = nonIsolatedVertex(G);\n        BreadthFirstPaths bfs = new BreadthFirstPaths(H, s);\n        for (int v = 0; v < G.V(); v++)\n            if (H.degree(v) > 0 && !bfs.hasPathTo(v))\n                return false;\n\n        return true;\n    }\n\n\n    private boolean check(Digraph G) {\n\n        if (hasEulerianPath() == (path() == null)) return false;\n\n        if (hasEulerianPath() != satisfiesNecessaryAndSufficientConditions(G)) return false;\n\n        if (path == null) return true;\n\n        if (path.size() != G.E() + 1) return false;\n\n\n        return true;\n    }\n\n\n    private static void unitTest(Digraph G, String description) {\n        StdOut.println(description);\n        StdOut.println(\"-------------------------------------\");\n        StdOut.print(G);\n\n        DirectedEulerianPath euler = new DirectedEulerianPath(G);\n\n        StdOut.print(\"Eulerian path:  \");\n        if (euler.hasEulerianPath()) {\n            for (int v : euler.path()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n        else {\n            StdOut.println(\"none\");\n        }\n        StdOut.println();\n    }\n\n    \n    public static void main(String[] args) {\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n\n\n        Digraph G1 = DigraphGenerator.eulerianCycle(V, E);\n        unitTest(G1, \"Eulerian cycle\");\n\n        Digraph G2 = DigraphGenerator.eulerianPath(V, E);\n        unitTest(G2, \"Eulerian path\");\n\n        Digraph G3 = new Digraph(G2);\n        G3.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));\n        unitTest(G3, \"one random edge added to Eulerian path\");\n\n        Digraph G4 = new Digraph(V);\n        int v4 = StdRandom.uniform(V);\n        G4.addEdge(v4, v4);\n        unitTest(G4, \"single self loop\");\n\n        Digraph G5 = new Digraph(V);\n        G5.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));\n        unitTest(G5, \"single edge\");\n\n        Digraph G6 = new Digraph(V);\n        unitTest(G6, \"empty digraph\");\n\n        Digraph G7 = DigraphGenerator.simple(V, E);\n        unitTest(G7, \"simple digraph\");\n\n        Digraph G8 = new Digraph(new In(\"eulerianD.txt\"));\n        unitTest(G8, \"4-vertex Eulerian digraph\");\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class DoublingRatio {\n    private static final int MAXIMUM_INTEGER = 1000000;\n\n    private DoublingRatio() { }\n\n    \n    public static double timeTrial(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = StdRandom.uniform(-MAXIMUM_INTEGER, MAXIMUM_INTEGER);\n        }\n        Stopwatch timer = new Stopwatch();\n        ThreeSum.count(a);\n        return timer.elapsedTime();\n    }\n\n    \n    public static void main(String[] args) { \n        double prev = timeTrial(125);\n        for (int n = 250; true; n += n) {\n            double time = timeTrial(n);\n            StdOut.printf(\"%7d %7.1f %5.1f\\n\", n, time, time/prev);\n            prev = time;\n        } \n    } \n} \n\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class DirectedCycle {\n    private boolean[] marked;        // marked[v] = has vertex v been marked?\n    private int[] edgeTo;            // edgeTo[v] = previous vertex on path to v\n    private boolean[] onStack;       // onStack[v] = is vertex on the stack?\n    private Stack<Integer> cycle;    // directed cycle (or null if no such cycle)\n\n    \n    public DirectedCycle(Digraph G) {\n        marked  = new boolean[G.V()];\n        onStack = new boolean[G.V()];\n        edgeTo  = new int[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            if (!marked[v] && cycle == null) dfs(G, v);\n    }\n\n    private void dfs(Digraph G, int v) {\n        onStack[v] = true;\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n\n            if (cycle != null) return;\n\n            else if (!marked[w]) {\n                edgeTo[w] = v;\n                dfs(G, w);\n            }\n\n            else if (onStack[w]) {\n                cycle = new Stack<Integer>();\n                for (int x = v; x != w; x = edgeTo[x]) {\n                    cycle.push(x);\n                }\n                cycle.push(w);\n                cycle.push(v);\n                assert check();\n            }\n        }\n        onStack[v] = false;\n    }\n\n    \n    public boolean hasCycle() {\n        return cycle != null;\n    }\n\n    \n    public Iterable<Integer> cycle() {\n        return cycle;\n    }\n\n\n    private boolean check() {\n\n        if (hasCycle()) {\n            int first = -1, last = -1;\n            for (int v : cycle()) {\n                if (first == -1) first = v;\n                last = v;\n            }\n            if (first != last) {\n                System.err.printf(\"cycle begins with %d and ends with %d\\n\", first, last);\n                return false;\n            }\n        }\n\n\n        return true;\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n\n        DirectedCycle finder = new DirectedCycle(G);\n        if (finder.hasCycle()) {\n            StdOut.print(\"Directed cycle: \");\n            for (int v : finder.cycle()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n\n        else {\n            StdOut.println(\"No directed cycle\");\n        }\n        StdOut.println();\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class QuickX {\n\n    private static final int INSERTION_SORT_CUTOFF = 8;\n\n    private QuickX() { }\n\n    \n    public static void sort(Comparable[] a) {\n        sort(a, 0, a.length - 1);\n        assert isSorted(a);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) { \n        if (hi <= lo) return;\n\n        int n = hi - lo + 1;\n        if (n <= INSERTION_SORT_CUTOFF) {\n            Insertion.sort(a, lo, hi + 1);\n            return;\n        }\n\n        int j = partition(a, lo, hi);\n        sort(a, lo, j-1);\n        sort(a, j+1, hi);\n    }\n\n    private static int partition(Comparable[] a, int lo, int hi) {\n        int n = hi - lo + 1;\n        int m = median3(a, lo, lo + n/2, hi);\n        exch(a, m, lo);\n\n        int i = lo;\n        int j = hi + 1;\n        Comparable v = a[lo];\n\n        while (less(a[++i], v)) {\n            if (i == hi) { exch(a, lo, hi); return hi; }\n        }\n\n        while (less(v, a[--j])) {\n            if (j == lo + 1) return lo;\n        }\n\n        while (i < j) { \n            exch(a, i, j);\n            while (less(a[++i], v)) ;\n            while (less(v, a[--j])) ;\n        }\n\n        exch(a, lo, j);\n\n        return j;\n    }\n\n    private static int median3(Comparable[] a, int i, int j, int k) {\n        return (less(a[i], a[j]) ?\n               (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) :\n               (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i));\n    }\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 1; i < a.length; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        QuickX.sort(a);\n        assert isSorted(a);\n        show(a);\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\n\npublic class QuickFindUF {\n    private int[] id;    // id[i] = component identifier of i\n    private int count;   // number of components\n\n    \n    public QuickFindUF(int n) {\n        count = n;\n        id = new int[n];\n        for (int i = 0; i < n; i++)\n            id[i] = i;\n    }\n\n    \n    public int count() {\n        return count;\n    }\n  \n    \n    public int find(int p) {\n        validate(p);\n        return id[p];\n    }\n\n    private void validate(int p) {\n        int n = id.length;\n        if (p < 0 || p >= n) {\n            throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1));\n        }\n    }\n\n    \n    public boolean connected(int p, int q) {\n        validate(p);\n        validate(q);\n        return id[p] == id[q];\n    }\n  \n    \n    public void union(int p, int q) {\n        validate(p);\n        validate(q);\n        int pID = id[p];   // needed for correctness\n        int qID = id[q];   // to reduce the number of array accesses\n\n        if (pID == qID) return;\n\n        for (int i = 0; i < id.length; i++)\n            if (id[i] == pID) id[i] = qID;\n        count--;\n    }\n\n    \n    public static void main(String[] args) {\n        int n = StdIn.readInt();\n        QuickFindUF uf = new QuickFindUF(n);\n        while (!StdIn.isEmpty()) {\n            int p = StdIn.readInt();\n            int q = StdIn.readInt();\n            if (uf.connected(p, q)) continue;\n            uf.union(p, q);\n            StdOut.println(p + \" \" + q);\n        }\n        StdOut.println(uf.count() + \" components\");\n    }\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class ThreeSumFast {\n\n    private ThreeSumFast() { }\n\n    private static boolean containsDuplicates(int[] a) {\n        for (int i = 1; i < a.length; i++)\n            if (a[i] == a[i-1]) return true;\n        return false;\n    }\n\n    \n    public static void printAll(int[] a) {\n        int n = a.length;\n        Arrays.sort(a);\n        if (containsDuplicates(a)) throw new IllegalArgumentException(\"array contains duplicate integers\");\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                int k = Arrays.binarySearch(a, -(a[i] + a[j]));\n                if (k > j) StdOut.println(a[i] + \" \" + a[j] + \" \" + a[k]);\n            }\n        }\n    } \n\n    \n    public static int count(int[] a) {\n        int n = a.length;\n        Arrays.sort(a);\n        if (containsDuplicates(a)) throw new IllegalArgumentException(\"array contains duplicate integers\");\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                int k = Arrays.binarySearch(a, -(a[i] + a[j]));\n                if (k > j) count++;\n            }\n        }\n        return count;\n    } \n\n    \n    public static void main(String[] args)  { \n        In in = new In(args[0]);\n        int[] a = in.readAllInts();\n        int count = count(a);\n        StdOut.println(count);\n    } \n} \n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class DegreesOfSeparation {\n\n    private DegreesOfSeparation() { }\n\n    \n    public static void main(String[] args) {\n        String filename  = args[0];\n        String delimiter = args[1];\n        String source    = args[2];\n\n\n        SymbolGraph sg = new SymbolGraph(filename, delimiter);\n        Graph G = sg.graph();\n        if (!sg.contains(source)) {\n            StdOut.println(source + \" not in database.\");\n            return;\n        }\n\n        int s = sg.indexOf(source);\n        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\n\n        while (!StdIn.isEmpty()) {\n            String sink = StdIn.readLine();\n            if (sg.contains(sink)) {\n                int t = sg.indexOf(sink);\n                if (bfs.hasPathTo(t)) {\n                    for (int v : bfs.pathTo(t)) {\n                        StdOut.println(\"   \" + sg.nameOf(v));\n                    }\n                }\n                else {\n                    StdOut.println(\"Not connected\");\n                }\n            }\n            else {\n                StdOut.println(\"   Not in database.\");\n            }\n        }\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class AmericanFlagX {\n    private static final int R      = 256;   // extend ASCII alphabet size\n    private static final int CUTOFF =  15;   // cutoff to insertion sort\n\n    private AmericanFlagX() { } \n\n    private static int charAt(String s, int d) {\n        assert d >= 0 && d <= s.length();\n        if (d == s.length()) return -1;\n        return s.charAt(d);\n    }\n\n    \n    public static void sort(String[] a) {\n        sort(a, 0, a.length - 1);\n    }\n\n    public static void sort(String[] a, int lo, int hi) {\n        Stack<Integer> st = new Stack<Integer>();\n        int[] count = new int[R+1];\n        int d = 0; // character index to sort by\n\n        st.push(lo);\n        st.push(hi);\n        st.push(d);\n        \n        while (!st.isEmpty()) {\n            d = st.pop();\n            hi = st.pop();\n            lo = st.pop();\n\n            if (hi <= lo + CUTOFF) {\n                insertion(a, lo, hi, d);\n                continue;\n            }\n\n            for (int i = lo; i <= hi; i++) {\n                int c = charAt(a[i], d) + 1; // account for -1 representing end-of-string\n                count[c]++;\n            }\n\n            count[0] += lo;\n            for (int c = 0; c < R; c++) {\n                count[c+1] += count[c];\n            \n                if (c > 0 && count[c+1]-1 > count[c]) { \n                    st.push(count[c]);\n                    st.push(count[c+1]-1);\n                    st.push(d+1); \n                }\n            }\n\n            for (int r = hi; r >= lo; r--) {\n\n                int c = charAt(a[r], d) + 1;\n                while (r >= lo && count[c]-1 <= r) {\n                    if (count[c]-1 == r) count[c]--;\n                    r--;\n                    if (r >= lo) c = charAt(a[r], d) + 1;\n                }\n\n                if (r < lo) break;\n            \n                while (--count[c] != r) {\n                    exch(a, r, count[c]);\n                    c = charAt(a[r], d) + 1;\n                }\n            }\n          \n            for (int c = 0; c < R+1; c++)\n                count[c] = 0;\n        }\n    }\n    \n    private static void insertion(String[] a, int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)\n                exch(a, j, j-1);\n    }\n\n    private static void exch(String[] a, int i, int j) {\n        String temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    private static boolean less(String v, String w, int d) {\n        for (int i = d; i <  Math.min(v.length(), w.length()); i++) {\n            if (v.charAt(i) < w.charAt(i)) return true;\n            if (v.charAt(i) > w.charAt(i)) return false;\n        }\n        return v.length() < w.length();\n    }\n        \n    \n    public static void main(String[] args) {      \n        String[] a = StdIn.readAllStrings();\n        sort(a);\n        for (int i = 0; i < a.length; i++)\n            StdOut.println(a[i]);\n    }\n}\n\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class BTree<Key extends Comparable<Key>, Value>  {\n    private static final int M = 4;\n\n    private Node root;       // root of the B-tree\n    private int height;      // height of the B-tree\n    private int n;           // number of key-value pairs in the B-tree\n\n    private static final class Node {\n        private int m;                             // number of children\n        private Entry[] children = new Entry[M];   // the array of children\n\n        private Node(int k) {\n            m = k;\n        }\n    }\n\n    private static class Entry {\n        private Comparable key;\n        private final Object val;\n        private Node next;     // helper field to iterate over array entries\n        public Entry(Comparable key, Object val, Node next) {\n            this.key  = key;\n            this.val  = val;\n            this.next = next;\n        }\n    }\n\n    \n    public BTree() {\n        root = new Node(0);\n    }\n \n    \n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public int height() {\n        return height;\n    }\n\n\n    \n    public Value get(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to get() is null\");\n        return search(root, key, height);\n    }\n\n    private Value search(Node x, Key key, int ht) {\n        Entry[] children = x.children;\n\n        if (ht == 0) {\n            for (int j = 0; j < x.m; j++) {\n                if (eq(key, children[j].key)) return (Value) children[j].val;\n            }\n        }\n\n        else {\n            for (int j = 0; j < x.m; j++) {\n                if (j+1 == x.m || less(key, children[j+1].key))\n                    return search(children[j].next, key, ht-1);\n            }\n        }\n        return null;\n    }\n\n\n    \n    public void put(Key key, Value val) {\n        if (key == null) throw new IllegalArgumentException(\"argument key to put() is null\");\n        Node u = insert(root, key, val, height); \n        n++;\n        if (u == null) return;\n\n        Node t = new Node(2);\n        t.children[0] = new Entry(root.children[0].key, null, root);\n        t.children[1] = new Entry(u.children[0].key, null, u);\n        root = t;\n        height++;\n    }\n\n    private Node insert(Node h, Key key, Value val, int ht) {\n        int j;\n        Entry t = new Entry(key, val, null);\n\n        if (ht == 0) {\n            for (j = 0; j < h.m; j++) {\n                if (less(key, h.children[j].key)) break;\n            }\n        }\n\n        else {\n            for (j = 0; j < h.m; j++) {\n                if ((j+1 == h.m) || less(key, h.children[j+1].key)) {\n                    Node u = insert(h.children[j++].next, key, val, ht-1);\n                    if (u == null) return null;\n                    t.key = u.children[0].key;\n                    t.next = u;\n                    break;\n                }\n            }\n        }\n\n        for (int i = h.m; i > j; i--)\n            h.children[i] = h.children[i-1];\n        h.children[j] = t;\n        h.m++;\n        if (h.m < M) return null;\n        else         return split(h);\n    }\n\n    private Node split(Node h) {\n        Node t = new Node(M/2);\n        h.m = M/2;\n        for (int j = 0; j < M/2; j++)\n            t.children[j] = h.children[M/2+j]; \n        return t;    \n    }\n\n    \n    public String toString() {\n        return toString(root, height, \"\") + \"\\n\";\n    }\n\n    private String toString(Node h, int ht, String indent) {\n        StringBuilder s = new StringBuilder();\n        Entry[] children = h.children;\n\n        if (ht == 0) {\n            for (int j = 0; j < h.m; j++) {\n                s.append(indent + children[j].key + \" \" + children[j].val + \"\\n\");\n            }\n        }\n        else {\n            for (int j = 0; j < h.m; j++) {\n                if (j > 0) s.append(indent + \"(\" + children[j].key + \")\\n\");\n                s.append(toString(children[j].next, ht-1, indent + \"     \"));\n            }\n        }\n        return s.toString();\n    }\n\n\n    private boolean less(Comparable k1, Comparable k2) {\n        return k1.compareTo(k2) < 0;\n    }\n\n    private boolean eq(Comparable k1, Comparable k2) {\n        return k1.compareTo(k2) == 0;\n    }\n\n\n    \n    public static void main(String[] args) {\n        BTree<String, String> st = new BTree<String, String>();\n\n        st.put(\"www.cs.princeton.edu\", \"128.112.136.12\");\n        st.put(\"www.cs.princeton.edu\", \"128.112.136.11\");\n        st.put(\"www.princeton.edu\",    \"128.112.128.15\");\n        st.put(\"www.yale.edu\",         \"130.132.143.21\");\n        st.put(\"www.simpsons.com\",     \"209.052.165.60\");\n        st.put(\"www.apple.com\",        \"17.112.152.32\");\n        st.put(\"www.amazon.com\",       \"207.171.182.16\");\n        st.put(\"www.ebay.com\",         \"66.135.192.87\");\n        st.put(\"www.cnn.com\",          \"64.236.16.20\");\n        st.put(\"www.google.com\",       \"216.239.41.99\");\n        st.put(\"www.nytimes.com\",      \"199.239.136.200\");\n        st.put(\"www.microsoft.com\",    \"207.126.99.140\");\n        st.put(\"www.dell.com\",         \"143.166.224.230\");\n        st.put(\"www.slashdot.org\",     \"66.35.250.151\");\n        st.put(\"www.espn.com\",         \"199.181.135.201\");\n        st.put(\"www.weather.com\",      \"63.111.66.11\");\n        st.put(\"www.yahoo.com\",        \"216.109.118.65\");\n\n\n        StdOut.println(\"cs.princeton.edu:  \" + st.get(\"www.cs.princeton.edu\"));\n        StdOut.println(\"hardvardsucks.com: \" + st.get(\"www.harvardsucks.com\"));\n        StdOut.println(\"simpsons.com:      \" + st.get(\"www.simpsons.com\"));\n        StdOut.println(\"apple.com:         \" + st.get(\"www.apple.com\"));\n        StdOut.println(\"ebay.com:          \" + st.get(\"www.ebay.com\"));\n        StdOut.println(\"dell.com:          \" + st.get(\"www.dell.com\"));\n        StdOut.println();\n\n        StdOut.println(\"size:    \" + st.size());\n        StdOut.println(\"height:  \" + st.height());\n        StdOut.println(st);\n        StdOut.println();\n    }\n\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class FordFulkerson {\n    private static final double FLOATING_POINT_EPSILON = 1E-11;\n\n    private final int V;          // number of vertices\n    private boolean[] marked;     // marked[v] = true iff s->v path in residual graph\n    private FlowEdge[] edgeTo;    // edgeTo[v] = last edge on shortest residual s->v path\n    private double value;         // current value of max flow\n  \n    \n    public FordFulkerson(FlowNetwork G, int s, int t) {\n        V = G.V();\n        validate(s);\n        validate(t);\n        if (s == t)               throw new IllegalArgumentException(\"Source equals sink\");\n        if (!isFeasible(G, s, t)) throw new IllegalArgumentException(\"Initial flow is infeasible\");\n\n        value = excess(G, t);\n        while (hasAugmentingPath(G, s, t)) {\n\n            double bottle = Double.POSITIVE_INFINITY;\n            for (int v = t; v != s; v = edgeTo[v].other(v)) {\n                bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v));\n            }\n\n            for (int v = t; v != s; v = edgeTo[v].other(v)) {\n                edgeTo[v].addResidualFlowTo(v, bottle); \n            }\n\n            value += bottle;\n        }\n\n        assert check(G, s, t);\n    }\n\n    \n    public double value()  {\n        return value;\n    }\n\n    \n    public boolean inCut(int v)  {\n        validate(v);\n        return marked[v];\n    }\n\n    private void validate(int v)  {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n\n    private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {\n        edgeTo = new FlowEdge[G.V()];\n        marked = new boolean[G.V()];\n\n        Queue<Integer> queue = new Queue<Integer>();\n        queue.enqueue(s);\n        marked[s] = true;\n        while (!queue.isEmpty() && !marked[t]) {\n            int v = queue.dequeue();\n\n            for (FlowEdge e : G.adj(v)) {\n                int w = e.other(v);\n\n                if (e.residualCapacityTo(w) > 0) {\n                    if (!marked[w]) {\n                        edgeTo[w] = e;\n                        marked[w] = true;\n                        queue.enqueue(w);\n                    }\n                }\n            }\n        }\n\n        return marked[t];\n    }\n\n\n\n    private double excess(FlowNetwork G, int v) {\n        double excess = 0.0;\n        for (FlowEdge e : G.adj(v)) {\n            if (v == e.from()) excess -= e.flow();\n            else               excess += e.flow();\n        }\n        return excess;\n    }\n\n    private boolean isFeasible(FlowNetwork G, int s, int t) {\n\n        for (int v = 0; v < G.V(); v++) {\n            for (FlowEdge e : G.adj(v)) {\n                if (e.flow() < -FLOATING_POINT_EPSILON || e.flow() > e.capacity() + FLOATING_POINT_EPSILON) {\n                    System.err.println(\"Edge does not satisfy capacity constraints: \" + e);\n                    return false;\n                }\n            }\n        }\n\n        if (Math.abs(value + excess(G, s)) > FLOATING_POINT_EPSILON) {\n            System.err.println(\"Excess at source = \" + excess(G, s));\n            System.err.println(\"Max flow         = \" + value);\n            return false;\n        }\n        if (Math.abs(value - excess(G, t)) > FLOATING_POINT_EPSILON) {\n            System.err.println(\"Excess at sink   = \" + excess(G, t));\n            System.err.println(\"Max flow         = \" + value);\n            return false;\n        }\n        for (int v = 0; v < G.V(); v++) {\n            if (v == s || v == t) continue;\n            else if (Math.abs(excess(G, v)) > FLOATING_POINT_EPSILON) {\n                System.err.println(\"Net flow out of \" + v + \" doesn't equal zero\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n\n    private boolean check(FlowNetwork G, int s, int t) {\n\n        if (!isFeasible(G, s, t)) {\n            System.err.println(\"Flow is infeasible\");\n            return false;\n        }\n\n        if (!inCut(s)) {\n            System.err.println(\"source \" + s + \" is not on source side of min cut\");\n            return false;\n        }\n        if (inCut(t)) {\n            System.err.println(\"sink \" + t + \" is on source side of min cut\");\n            return false;\n        }\n\n        double mincutValue = 0.0;\n        for (int v = 0; v < G.V(); v++) {\n            for (FlowEdge e : G.adj(v)) {\n                if ((v == e.from()) && inCut(e.from()) && !inCut(e.to()))\n                    mincutValue += e.capacity();\n            }\n        }\n\n        if (Math.abs(mincutValue - value) > FLOATING_POINT_EPSILON) {\n            System.err.println(\"Max flow value = \" + value + \", min cut value = \" + mincutValue);\n            return false;\n        }\n\n        return true;\n    }\n\n\n    \n    public static void main(String[] args) {\n\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n        int s = 0, t = V-1;\n        FlowNetwork G = new FlowNetwork(V, E);\n        StdOut.println(G);\n\n        FordFulkerson maxflow = new FordFulkerson(G, s, t);\n        StdOut.println(\"Max flow from \" + s + \" to \" + t);\n        for (int v = 0; v < G.V(); v++) {\n            for (FlowEdge e : G.adj(v)) {\n                if ((v == e.from()) && e.flow() > 0)\n                    StdOut.println(\"   \" + e);\n            }\n        }\n\n        StdOut.print(\"Min cut: \");\n        for (int v = 0; v < G.V(); v++) {\n            if (maxflow.inCut(v)) StdOut.print(v + \" \");\n        }\n        StdOut.println();\n\n        StdOut.println(\"Max flow value = \" +  maxflow.value());\n    }\n\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\n\npublic class Insertion {\n\n    private Insertion() { }\n\n    \n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j > 0 && less(a[j], a[j-1]); j--) {\n                exch(a, j, j-1);\n            }\n            assert isSorted(a, 0, i);\n        }\n        assert isSorted(a);\n    }\n\n    \n    public static void sort(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i < hi; i++) {\n            for (int j = i; j > lo && less(a[j], a[j-1]); j--) {\n                exch(a, j, j-1);\n            }\n        }\n        assert isSorted(a, lo, hi);\n    }\n\n    \n    public static void sort(Object[] a, Comparator comparator) {\n        int n = a.length;\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j > 0 && less(a[j], a[j-1], comparator); j--) {\n                exch(a, j, j-1);\n            }\n            assert isSorted(a, 0, i, comparator);\n        }\n        assert isSorted(a, comparator);\n    }\n\n    \n    public static void sort(Object[] a, int lo, int hi, Comparator comparator) {\n        for (int i = lo + 1; i < hi; i++) {\n            for (int j = i; j > lo && less(a[j], a[j-1], comparator); j--) {\n                exch(a, j, j-1);\n            }\n        }\n        assert isSorted(a, lo, hi, comparator);\n    }\n\n\n    \n    public static int[] indexSort(Comparable[] a) {\n        int n = a.length;\n        int[] index = new int[n];\n        for (int i = 0; i < n; i++)\n            index[i] = i;\n\n        for (int i = 1; i < n; i++)\n            for (int j = i; j > 0 && less(a[index[j]], a[index[j-1]]); j--)\n                exch(index, j, j-1);\n\n        return index;\n    }\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n    private static boolean less(Object v, Object w, Comparator comparator) {\n        return comparator.compare(v, w) < 0;\n    }\n        \n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n    private static void exch(int[] a, int i, int j) {\n        int swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i < hi; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static boolean isSorted(Object[] a, Comparator comparator) {\n        return isSorted(a, 0, a.length, comparator);\n    }\n\n    private static boolean isSorted(Object[] a, int lo, int hi, Comparator comparator) {\n        for (int i = lo + 1; i < hi; i++)\n            if (less(a[i], a[i-1], comparator)) return false;\n        return true;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        Insertion.sort(a);\n        show(a);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\n\npublic class MinPQ<Key> implements Iterable<Key> {\n    private Key[] pq;                    // store items at indices 1 to n\n    private int n;                       // number of items on priority queue\n    private Comparator<Key> comparator;  // optional comparator\n\n    \n    public MinPQ(int initCapacity) {\n        pq = (Key[]) new Object[initCapacity + 1];\n        n = 0;\n    }\n\n    \n    public MinPQ() {\n        this(1);\n    }\n\n    \n    public MinPQ(int initCapacity, Comparator<Key> comparator) {\n        this.comparator = comparator;\n        pq = (Key[]) new Object[initCapacity + 1];\n        n = 0;\n    }\n\n    \n    public MinPQ(Comparator<Key> comparator) {\n        this(1, comparator);\n    }\n\n    \n    public MinPQ(Key[] keys) {\n        n = keys.length;\n        pq = (Key[]) new Object[keys.length + 1];\n        for (int i = 0; i < n; i++)\n            pq[i+1] = keys[i];\n        for (int k = n/2; k >= 1; k--)\n            sink(k);\n        assert isMinHeap();\n    }\n\n    \n    public boolean isEmpty() {\n        return n == 0;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public Key min() {\n        if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\");\n        return pq[1];\n    }\n\n    private void resize(int capacity) {\n        assert capacity > n;\n        Key[] temp = (Key[]) new Object[capacity];\n        for (int i = 1; i <= n; i++) {\n            temp[i] = pq[i];\n        }\n        pq = temp;\n    }\n\n    \n    public void insert(Key x) {\n        if (n == pq.length - 1) resize(2 * pq.length);\n\n        pq[++n] = x;\n        swim(n);\n        assert isMinHeap();\n    }\n\n    \n    public Key delMin() {\n        if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\");\n        Key min = pq[1];\n        exch(1, n--);\n        sink(1);\n        pq[n+1] = null;     // to avoid loiterig and help with garbage collection\n        if ((n > 0) && (n == (pq.length - 1) / 4)) resize(pq.length / 2);\n        assert isMinHeap();\n        return min;\n    }\n\n\n   \n\n    private void swim(int k) {\n        while (k > 1 && greater(k/2, k)) {\n            exch(k, k/2);\n            k = k/2;\n        }\n    }\n\n    private void sink(int k) {\n        while (2*k <= n) {\n            int j = 2*k;\n            if (j < n && greater(j, j+1)) j++;\n            if (!greater(k, j)) break;\n            exch(k, j);\n            k = j;\n        }\n    }\n\n   \n    private boolean greater(int i, int j) {\n        if (comparator == null) {\n            return ((Comparable<Key>) pq[i]).compareTo(pq[j]) > 0;\n        }\n        else {\n            return comparator.compare(pq[i], pq[j]) > 0;\n        }\n    }\n\n    private void exch(int i, int j) {\n        Key swap = pq[i];\n        pq[i] = pq[j];\n        pq[j] = swap;\n    }\n\n    private boolean isMinHeap() {\n        return isMinHeap(1);\n    }\n\n    private boolean isMinHeap(int k) {\n        if (k > n) return true;\n        int left = 2*k;\n        int right = 2*k + 1;\n        if (left  <= n && greater(k, left))  return false;\n        if (right <= n && greater(k, right)) return false;\n        return isMinHeap(left) && isMinHeap(right);\n    }\n\n\n    \n    public Iterator<Key> iterator() {\n        return new HeapIterator();\n    }\n\n    private class HeapIterator implements Iterator<Key> {\n        private MinPQ<Key> copy;\n\n        public HeapIterator() {\n            if (comparator == null) copy = new MinPQ<Key>(size());\n            else                    copy = new MinPQ<Key>(size(), comparator);\n            for (int i = 1; i <= n; i++)\n                copy.insert(pq[i]);\n        }\n\n        public boolean hasNext()  { return !copy.isEmpty();                     }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Key next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            return copy.delMin();\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        MinPQ<String> pq = new MinPQ<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\")) pq.insert(item);\n            else if (!pq.isEmpty()) StdOut.print(pq.delMin() + \" \");\n        }\n        StdOut.println(\"(\" + pq.size() + \" left on pq)\");\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class MSD {\n    private static final int BITS_PER_BYTE =   8;\n    private static final int BITS_PER_INT  =  32;   // each Java int is 32 bits \n    private static final int R             = 256;   // extended ASCII alphabet size\n    private static final int CUTOFF        =  15;   // cutoff to insertion sort\n\n    private MSD() { } \n\n   \n    public static void sort(String[] a) {\n        int n = a.length;\n        String[] aux = new String[n];\n        sort(a, 0, n-1, 0, aux);\n    }\n\n    private static int charAt(String s, int d) {\n        assert d >= 0 && d <= s.length();\n        if (d == s.length()) return -1;\n        return s.charAt(d);\n    }\n\n    private static void sort(String[] a, int lo, int hi, int d, String[] aux) {\n\n        if (hi <= lo + CUTOFF) {\n            insertion(a, lo, hi, d);\n            return;\n        }\n\n        int[] count = new int[R+2];\n        for (int i = lo; i <= hi; i++) {\n            int c = charAt(a[i], d);\n            count[c+2]++;\n        }\n\n        for (int r = 0; r < R+1; r++)\n            count[r+1] += count[r];\n\n        for (int i = lo; i <= hi; i++) {\n            int c = charAt(a[i], d);\n            aux[count[c+1]++] = a[i];\n        }\n\n        for (int i = lo; i <= hi; i++) \n            a[i] = aux[i - lo];\n\n\n        for (int r = 0; r < R; r++)\n            sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);\n    }\n\n\n    private static void insertion(String[] a, int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)\n                exch(a, j, j-1);\n    }\n\n    private static void exch(String[] a, int i, int j) {\n        String temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    private static boolean less(String v, String w, int d) {\n        for (int i = d; i < Math.min(v.length(), w.length()); i++) {\n            if (v.charAt(i) < w.charAt(i)) return true;\n            if (v.charAt(i) > w.charAt(i)) return false;\n        }\n        return v.length() < w.length();\n    }\n\n\n   \n    public static void sort(int[] a) {\n        int n = a.length;\n        int[] aux = new int[n];\n        sort(a, 0, n-1, 0, aux);\n    }\n\n    private static void sort(int[] a, int lo, int hi, int d, int[] aux) {\n\n        if (hi <= lo + CUTOFF) {\n            insertion(a, lo, hi, d);\n            return;\n        }\n\n        int[] count = new int[R+1];\n        int mask = R - 1;   // 0xFF;\n        int shift = BITS_PER_INT - BITS_PER_BYTE*d - BITS_PER_BYTE;\n        for (int i = lo; i <= hi; i++) {\n            int c = (a[i] >> shift) & mask;\n            count[c + 1]++;\n        }\n\n        for (int r = 0; r < R; r++)\n            count[r+1] += count[r];\n\n\n        for (int i = lo; i <= hi; i++) {\n            int c = (a[i] >> shift) & mask;\n            aux[count[c]++] = a[i];\n        }\n\n        for (int i = lo; i <= hi; i++) \n            a[i] = aux[i - lo];\n\n        if (d == 4) return;\n\n        if (count[0] > 0)\n            sort(a, lo, lo + count[0] - 1, d+1, aux);\n        for (int r = 0; r < R; r++)\n            if (count[r+1] > count[r])\n                sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);\n    }\n\n    private static void insertion(int[] a, int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && a[j] < a[j-1]; j--)\n                exch(a, j, j-1);\n    }\n\n    private static void exch(int[] a, int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        int n = a.length;\n        sort(a);\n        for (int i = 0; i < n; i++)\n            StdOut.println(a[i]);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\n\npublic class NonrecursiveDFS {\n    private boolean[] marked;  // marked[v] = is there an s-v path?\n    \n    public NonrecursiveDFS(Graph G, int s) {\n        marked = new boolean[G.V()];\n\n        validateVertex(s);\n\n        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            adj[v] = G.adj(v).iterator();\n\n        Stack<Integer> stack = new Stack<Integer>();\n        marked[s] = true;\n        stack.push(s);\n        while (!stack.isEmpty()) {\n            int v = stack.peek();\n            if (adj[v].hasNext()) {\n                int w = adj[v].next();\n                if (!marked[w]) {\n                    marked[w] = true;\n                    stack.push(w);\n                }\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n\n    \n    public boolean marked(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Graph G = new Graph(in);\n        int s = Integer.parseInt(args[1]);\n        NonrecursiveDFS dfs = new NonrecursiveDFS(G, s);\n        for (int v = 0; v < G.V(); v++)\n            if (dfs.marked(v))\n                StdOut.print(v + \" \");\n        StdOut.println();\n    }\n\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class MergeX {\n    private static final int CUTOFF = 7;  // cutoff to insertion sort\n\n    private MergeX() { }\n\n    private static void merge(Comparable[] src, Comparable[] dst, int lo, int mid, int hi) {\n\n        assert isSorted(src, lo, mid);\n        assert isSorted(src, mid+1, hi);\n\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)              dst[k] = src[j++];\n            else if (j > hi)               dst[k] = src[i++];\n            else if (less(src[j], src[i])) dst[k] = src[j++];   // to ensure stability\n            else                           dst[k] = src[i++];\n        }\n\n        assert isSorted(dst, lo, hi);\n    }\n\n    private static void sort(Comparable[] src, Comparable[] dst, int lo, int hi) {\n        if (hi <= lo + CUTOFF) { \n            insertionSort(dst, lo, hi);\n            return;\n        }\n        int mid = lo + (hi - lo) / 2;\n        sort(dst, src, lo, mid);\n        sort(dst, src, mid+1, hi);\n\n\n        if (!less(src[mid+1], src[mid])) {\n            System.arraycopy(src, lo, dst, lo, hi - lo + 1);\n            return;\n        }\n\n        merge(src, dst, lo, mid, hi);\n    }\n\n    \n    public static void sort(Comparable[] a) {\n        Comparable[] aux = a.clone();\n        sort(aux, a, 0, a.length-1);  \n        assert isSorted(a);\n    }\n\n    private static void insertionSort(Comparable[] a, int lo, int hi) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1]); j--)\n                exch(a, j, j-1);\n    }\n\n\n    \n\n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n    private static boolean less(Comparable a, Comparable b) {\n        return a.compareTo(b) < 0;\n    }\n\n    private static boolean less(Object a, Object b, Comparator comparator) {\n        return comparator.compare(a, b) < 0;\n    }\n\n\n    \n\n    \n    public static void sort(Object[] a, Comparator comparator) {\n        Object[] aux = a.clone();\n        sort(aux, a, 0, a.length-1, comparator);\n        assert isSorted(a, comparator);\n    }\n\n    private static void merge(Object[] src, Object[] dst, int lo, int mid, int hi, Comparator comparator) {\n\n        assert isSorted(src, lo, mid, comparator);\n        assert isSorted(src, mid+1, hi, comparator);\n\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)                          dst[k] = src[j++];\n            else if (j > hi)                           dst[k] = src[i++];\n            else if (less(src[j], src[i], comparator)) dst[k] = src[j++];\n            else                                       dst[k] = src[i++];\n        }\n\n        assert isSorted(dst, lo, hi, comparator);\n    }\n\n\n    private static void sort(Object[] src, Object[] dst, int lo, int hi, Comparator comparator) {\n        if (hi <= lo + CUTOFF) { \n            insertionSort(dst, lo, hi, comparator);\n            return;\n        }\n        int mid = lo + (hi - lo) / 2;\n        sort(dst, src, lo, mid, comparator);\n        sort(dst, src, mid+1, hi, comparator);\n\n        if (!less(src[mid+1], src[mid], comparator)) {\n            System.arraycopy(src, lo, dst, lo, hi - lo + 1);\n            return;\n        }\n\n        merge(src, dst, lo, mid, hi, comparator);\n    }\n\n    private static void insertionSort(Object[] a, int lo, int hi, Comparator comparator) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1], comparator); j--)\n                exch(a, j, j-1);\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static boolean isSorted(Object[] a, Comparator comparator) {\n        return isSorted(a, 0, a.length - 1, comparator);\n    }\n\n    private static boolean isSorted(Object[] a, int lo, int hi, Comparator comparator) {\n        for (int i = lo + 1; i <= hi; i++)\n            if (less(a[i], a[i-1], comparator)) return false;\n        return true;\n    }\n\n    private static void show(Object[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        MergeX.sort(a);\n        show(a);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class Cat { \n\n    private Cat() { }\n\n    \n    public static void main(String[] args) { \n        Out out = new Out(args[args.length - 1]);\n        for (int i = 0; i < args.length - 1; i++) {\n            In in = new In(args[i]);\n            String s = in.readAll();\n            out.println(s);\n            in.close();\n        }\n        out.close();\n    }\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\n\npublic class Stopwatch { \n\n    private final long start;\n\n    \n    public Stopwatch() {\n        start = System.currentTimeMillis();\n    } \n\n\n    \n    public double elapsedTime() {\n        long now = System.currentTimeMillis();\n        return (now - start) / 1000.0;\n    }\n\n    \n    \n    public static void main(String[] args) {\n        int n = Integer.parseInt(args[0]);\n\n        Stopwatch timer1 = new Stopwatch();\n        double sum1 = 0.0;\n        for (int i = 1; i <= n; i++) {\n            sum1 += Math.sqrt(i);\n        }\n        double time1 = timer1.elapsedTime();\n        StdOut.printf(\"%e (%.2f seconds)\\n\", sum1, time1);\n\n        Stopwatch timer2 = new Stopwatch();\n        double sum2 = 0.0;\n        for (int i = 1; i <= n; i++) {\n            sum2 += Math.pow(i, 0.5);\n        }\n        double time2 = timer2.elapsedTime();\n        StdOut.printf(\"%e (%.2f seconds)\\n\", sum2, time2);\n    }\n} \n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class FenwickTree {\n\n    int[] array; // 1-indexed array, In this array We save cumulative information to perform efficient range queries and updates\n\n    public FenwickTree(int size) {\n        array = new int[size + 1];\n    }\n\n    \n    public int rsq(int ind) {\n        assert ind > 0;\n        int sum = 0;\n        while (ind > 0) {\n            sum += array[ind];\n            ind -= ind & (-ind);\n        }\n\n        return sum;\n    }\n\n    \n    public int rsq(int a, int b) {\n        assert b >= a && a > 0 && b > 0;\n\n        return rsq(b) - rsq(a - 1);\n    }\n\n    \n    public void update(int ind, int value) {\n        assert ind > 0;\n        while (ind < array.length) {\n            array[ind] += value;\n            ind += ind & (-ind);\n        }\n    }\n\n    public int size() {\n        return array.length - 1;\n    }\n\n\n    \n    public static void main(String[] args) {\n\n\n        FenwickTree ft = null;\n\n        String cmd = \"cmp\";\n        while (true) {\n            String[] line = StdIn.readLine().split(\" \");\n\n            if (line[0].equals(\"exit\")) break;\n\n            int arg1 = 0, arg2 = 0;\n\n            if (line.length > 1) {\n                arg1 = Integer.parseInt(line[1]);\n            }\n            if (line.length > 2) {\n                arg2 = Integer.parseInt(line[2]);\n            }\n\n            if ((!line[0].equals(\"set\") && !line[0].equals(\"init\")) && ft == null) {\n                StdOut.println(\"FenwickTree not initialized\");\n                continue;\n            }\n\n            if (line[0].equals(\"init\")) {\n                ft = new FenwickTree(arg1);\n                for (int i = 1; i <= ft.size(); i++) {\n                    StdOut.print(ft.rsq(i, i) + \" \");\n                }\n                StdOut.println();\n            }\n            else if (line[0].equals(\"set\")) {\n                ft = new FenwickTree(line.length - 1);\n                for (int i = 1; i <= line.length - 1; i++) {\n                    ft.update(i, Integer.parseInt(line[i]));\n                }\n            }\n\n            else if (line[0].equals(\"up\")) {\n                ft.update(arg1, arg2);\n                for (int i = 1; i <= ft.size(); i++) {\n                    StdOut.print(ft.rsq(i, i) + \" \");\n                }\n                StdOut.println();\n            }\n            else if (line[0].equals(\"rsq\")) {\n                StdOut.printf(\"Sum from %d to %d = %d%n\", arg1, arg2, ft.rsq(arg1, arg2));\n            }\n            else {\n                StdOut.println(\"Invalid command\");\n            }\n\n        }\n    }\n\n\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\n\npublic class StaticSETofInts {\n    private int[] a;\n\n    \n    public StaticSETofInts(int[] keys) {\n\n        a = new int[keys.length];\n        for (int i = 0; i < keys.length; i++)\n            a[i] = keys[i];\n\n        Arrays.sort(a);\n\n        for (int i = 1; i < a.length; i++)\n            if (a[i] == a[i-1])\n                throw new IllegalArgumentException(\"Argument arrays contains duplicate keys.\");\n    }\n\n    \n    public boolean contains(int key) {\n        return rank(key) != -1;\n    }\n\n    \n    public int rank(int key) {\n        int lo = 0;\n        int hi = a.length - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if      (key < a[mid]) hi = mid - 1;\n            else if (key > a[mid]) lo = mid + 1;\n            else return mid;\n        }\n        return -1;\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class DeDup {  \n\n    private DeDup() { }\n\n    public static void main(String[] args) {\n        SET<String> set = new SET<String>();\n\n        while (!StdIn.isEmpty()) {\n            String key = StdIn.readString();\n            if (!set.contains(key)) {\n                set.add(key);\n                StdOut.println(key);\n            }\n        }\n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\n\n\npublic class LinkedStack<Item> implements Iterable<Item> {\n    private int n;          // size of the stack\n    private Node first;     // top of stack\n\n    private class Node {\n        private Item item;\n        private Node next;\n    }\n\n    \n    public LinkedStack() {\n        first = null;\n        n = 0;\n        assert check();\n    }\n\n    \n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public void push(Item item) {\n        Node oldfirst = first;\n        first = new Node();\n        first.item = item;\n        first.next = oldfirst;\n        n++;\n        assert check();\n    }\n\n    \n    public Item pop() {\n        if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\");\n        Item item = first.item;        // save item to return\n        first = first.next;            // delete first node\n        n--;\n        assert check();\n        return item;                   // return the saved item\n    }\n\n\n    \n    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\");\n        return first.item;\n    }\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this)\n            s.append(item + \" \");\n        return s.toString();\n    }\n       \n    \n    public Iterator<Item> iterator() {\n        return new ListIterator();\n    }\n\n    private class ListIterator implements Iterator<Item> {\n        private Node current = first;\n        public boolean hasNext()  { return current != null;                     }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = current.item;\n            current = current.next; \n            return item;\n        }\n    }\n\n\n    private boolean check() {\n\n        if (n < 0) {\n            return false;\n        }\n        if (n == 0) {\n            if (first != null) return false;\n        }\n        else if (n == 1) {\n            if (first == null)      return false;\n            if (first.next != null) return false;\n        }\n        else {\n            if (first == null)      return false;\n            if (first.next == null) return false;\n        }\n\n        int numberOfNodes = 0;\n        for (Node x = first; x != null && numberOfNodes <= n; x = x.next) {\n            numberOfNodes++;\n        }\n        if (numberOfNodes != n) return false;\n\n        return true;\n    }\n\n    \n    public static void main(String[] args) {\n        LinkedStack<String> stack = new LinkedStack<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\"))\n                stack.push(item);\n            else if (!stack.isEmpty())\n                StdOut.print(stack.pop() + \" \");\n        }\n        StdOut.println(\"(\" + stack.size() + \" left on stack)\");\n    }\n}\n\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class SequentialSearchST<Key, Value> {\n    private int n;           // number of key-value pairs\n    private Node first;      // the linked list of key-value pairs\n\n    private class Node {\n        private Key key;\n        private Value val;\n        private Node next;\n\n        public Node(Key key, Value val, Node next)  {\n            this.key  = key;\n            this.val  = val;\n            this.next = next;\n        }\n    }\n\n    \n    public SequentialSearchST() {\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    \n    public boolean contains(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    \n    public Value get(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to get() is null\"); \n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key))\n                return x.val;\n        }\n        return null;\n    }\n\n    \n    public void put(Key key, Value val) {\n        if (key == null) throw new IllegalArgumentException(\"first argument to put() is null\"); \n        if (val == null) {\n            delete(key);\n            return;\n        }\n\n        for (Node x = first; x != null; x = x.next) {\n            if (key.equals(x.key)) {\n                x.val = val;\n                return;\n            }\n        }\n        first = new Node(key, val, first);\n        n++;\n    }\n\n    \n    public void delete(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\"); \n        first = delete(first, key);\n    }\n\n    private Node delete(Node x, Key key) {\n        if (x == null) return null;\n        if (key.equals(x.key)) {\n            n--;\n            return x.next;\n        }\n        x.next = delete(x.next, key);\n        return x;\n    }\n\n\n    \n    public Iterable<Key> keys()  {\n        Queue<Key> queue = new Queue<Key>();\n        for (Node x = first; x != null; x = x.next)\n            queue.enqueue(x.key);\n        return queue;\n    }\n\n\n    \n    public static void main(String[] args) {\n        SequentialSearchST<String, Integer> st = new SequentialSearchST<String, Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n        for (String s : st.keys())\n            StdOut.println(s + \" \" + st.get(s));\n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\n\npublic class ST<Key extends Comparable<Key>, Value> implements Iterable<Key> {\n\n    private TreeMap<Key, Value> st;\n\n    \n    public ST() {\n        st = new TreeMap<Key, Value>();\n    }\n\n\n    \n    public Value get(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"calls get() with null key\");\n        return st.get(key);\n    }\n\n    \n    public void put(Key key, Value val) {\n        if (key == null) throw new IllegalArgumentException(\"calls put() with null key\");\n        if (val == null) st.remove(key);\n        else             st.put(key, val);\n    }\n\n    \n    public void delete(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"calls delete() with null key\");\n        st.remove(key);\n    }\n\n    \n    public boolean contains(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"calls contains() with null key\");\n        return st.containsKey(key);\n    }\n\n    \n    public int size() {\n        return st.size();\n    }\n\n    \n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    \n    public Iterable<Key> keys() {\n        return st.keySet();\n    }\n\n    \n    @Deprecated\n    public Iterator<Key> iterator() {\n        return st.keySet().iterator();\n    }\n\n    \n    public Key min() {\n        if (isEmpty()) throw new NoSuchElementException(\"calls min() with empty symbol table\");\n        return st.firstKey();\n    }\n\n    \n    public Key max() {\n        if (isEmpty()) throw new NoSuchElementException(\"calls max() with empty symbol table\");\n        return st.lastKey();\n    }\n\n    \n    public Key ceiling(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to ceiling() is null\");\n        Key k = st.ceilingKey(key);\n        if (k == null) throw new NoSuchElementException(\"all keys are less than \" + key);\n        return k;\n    }\n\n    \n    public Key floor(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to floor() is null\");\n        Key k = st.floorKey(key);\n        if (k == null) throw new NoSuchElementException(\"all keys are greater than \" + key);\n        return k;\n    }\n\n    \n    public static void main(String[] args) {\n        ST<String, Integer> st = new ST<String, Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n        for (String s : st.keys())\n            StdOut.println(s + \" \" + st.get(s));\n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class DepthFirstOrder {\n    private boolean[] marked;          // marked[v] = has v been marked in dfs?\n    private int[] pre;                 // pre[v]    = preorder  number of v\n    private int[] post;                // post[v]   = postorder number of v\n    private Queue<Integer> preorder;   // vertices in preorder\n    private Queue<Integer> postorder;  // vertices in postorder\n    private int preCounter;            // counter or preorder numbering\n    private int postCounter;           // counter for postorder numbering\n\n    \n    public DepthFirstOrder(Digraph G) {\n        pre    = new int[G.V()];\n        post   = new int[G.V()];\n        postorder = new Queue<Integer>();\n        preorder  = new Queue<Integer>();\n        marked    = new boolean[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            if (!marked[v]) dfs(G, v);\n\n        assert check();\n    }\n\n    \n    public DepthFirstOrder(EdgeWeightedDigraph G) {\n        pre    = new int[G.V()];\n        post   = new int[G.V()];\n        postorder = new Queue<Integer>();\n        preorder  = new Queue<Integer>();\n        marked    = new boolean[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            if (!marked[v]) dfs(G, v);\n    }\n\n    private void dfs(Digraph G, int v) {\n        marked[v] = true;\n        pre[v] = preCounter++;\n        preorder.enqueue(v);\n        for (int w : G.adj(v)) {\n            if (!marked[w]) {\n                dfs(G, w);\n            }\n        }\n        postorder.enqueue(v);\n        post[v] = postCounter++;\n    }\n\n    private void dfs(EdgeWeightedDigraph G, int v) {\n        marked[v] = true;\n        pre[v] = preCounter++;\n        preorder.enqueue(v);\n        for (DirectedEdge e : G.adj(v)) {\n            int w = e.to();\n            if (!marked[w]) {\n                dfs(G, w);\n            }\n        }\n        postorder.enqueue(v);\n        post[v] = postCounter++;\n    }\n\n    \n    public int pre(int v) {\n        validateVertex(v);\n        return pre[v];\n    }\n\n    \n    public int post(int v) {\n        validateVertex(v);\n        return post[v];\n    }\n\n    \n    public Iterable<Integer> post() {\n        return postorder;\n    }\n\n    \n    public Iterable<Integer> pre() {\n        return preorder;\n    }\n\n    \n    public Iterable<Integer> reversePost() {\n        Stack<Integer> reverse = new Stack<Integer>();\n        for (int v : postorder)\n            reverse.push(v);\n        return reverse;\n    }\n\n\n    private boolean check() {\n\n        int r = 0;\n        for (int v : post()) {\n            if (post(v) != r) {\n                StdOut.println(\"post(v) and post() inconsistent\");\n                return false;\n            }\n            r++;\n        }\n\n        r = 0;\n        for (int v : pre()) {\n            if (pre(v) != r) {\n                StdOut.println(\"pre(v) and pre() inconsistent\");\n                return false;\n            }\n            r++;\n        }\n\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n\n        DepthFirstOrder dfs = new DepthFirstOrder(G);\n        StdOut.println(\"   v  pre post\");\n        StdOut.println(\"--------------\");\n        for (int v = 0; v < G.V(); v++) {\n            StdOut.printf(\"%4d %4d %4d\\n\", v, dfs.pre(v), dfs.post(v));\n        }\n\n        StdOut.print(\"Preorder:  \");\n        for (int v : dfs.pre()) {\n            StdOut.print(v + \" \");\n        }\n        StdOut.println();\n\n        StdOut.print(\"Postorder: \");\n        for (int v : dfs.post()) {\n            StdOut.print(v + \" \");\n        }\n        StdOut.println();\n\n        StdOut.print(\"Reverse postorder: \");\n        for (int v : dfs.reversePost()) {\n            StdOut.print(v + \" \");\n        }\n        StdOut.println();\n\n\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class LinkedBag<Item> implements Iterable<Item> {\n    private Node first;    // beginning of bag\n    private int n;         // number of elements in bag\n\n    private class Node {\n        private Item item;\n        private Node next;\n    }\n\n    \n    public LinkedBag() {\n        first = null;\n        n = 0;\n    }\n\n    \n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public void add(Item item) {\n        Node oldfirst = first;\n        first = new Node();\n        first.item = item;\n        first.next = oldfirst;\n        n++;\n    }\n\n\n    \n    public Iterator<Item> iterator()  {\n        return new ListIterator();  \n    }\n\n    private class ListIterator implements Iterator<Item> {\n        private Node current;\n\n        public ListIterator() {\n            current = first;\n        }\n\n        public boolean hasNext() {\n            return current != null;\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = current.item;\n            current = current.next; \n            return item;\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        LinkedBag<String> bag = new LinkedBag<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            bag.add(item);\n        }\n\n        StdOut.println(\"size of bag = \" + bag.size());\n        for (String s : bag) {\n            StdOut.println(s);\n        }\n    }\n\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class BreadthFirstPaths {\n    private static final int INFINITY = Integer.MAX_VALUE;\n    private boolean[] marked;  // marked[v] = is there an s-v path\n    private int[] edgeTo;      // edgeTo[v] = previous edge on shortest s-v path\n    private int[] distTo;      // distTo[v] = number of edges shortest s-v path\n\n    \n    public BreadthFirstPaths(Graph G, int s) {\n        marked = new boolean[G.V()];\n        distTo = new int[G.V()];\n        edgeTo = new int[G.V()];\n        validateVertex(s);\n        bfs(G, s);\n\n        assert check(G, s);\n    }\n\n    \n    public BreadthFirstPaths(Graph G, Iterable<Integer> sources) {\n        marked = new boolean[G.V()];\n        distTo = new int[G.V()];\n        edgeTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = INFINITY;\n        validateVertices(sources);\n        bfs(G, sources);\n    }\n\n\n    private void bfs(Graph G, int s) {\n        Queue<Integer> q = new Queue<Integer>();\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = INFINITY;\n        distTo[s] = 0;\n        marked[s] = true;\n        q.enqueue(s);\n\n        while (!q.isEmpty()) {\n            int v = q.dequeue();\n            for (int w : G.adj(v)) {\n                if (!marked[w]) {\n                    edgeTo[w] = v;\n                    distTo[w] = distTo[v] + 1;\n                    marked[w] = true;\n                    q.enqueue(w);\n                }\n            }\n        }\n    }\n\n    private void bfs(Graph G, Iterable<Integer> sources) {\n        Queue<Integer> q = new Queue<Integer>();\n        for (int s : sources) {\n            marked[s] = true;\n            distTo[s] = 0;\n            q.enqueue(s);\n        }\n        while (!q.isEmpty()) {\n            int v = q.dequeue();\n            for (int w : G.adj(v)) {\n                if (!marked[w]) {\n                    edgeTo[w] = v;\n                    distTo[w] = distTo[v] + 1;\n                    marked[w] = true;\n                    q.enqueue(w);\n                }\n            }\n        }\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    \n    public int distTo(int v) {\n        validateVertex(v);\n        return distTo[v];\n    }\n\n    \n    public Iterable<Integer> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v)) return null;\n        Stack<Integer> path = new Stack<Integer>();\n        int x;\n        for (x = v; distTo[x] != 0; x = edgeTo[x])\n            path.push(x);\n        path.push(x);\n        return path;\n    }\n\n\n    private boolean check(Graph G, int s) {\n\n        if (distTo[s] != 0) {\n            StdOut.println(\"distance of source \" + s + \" to itself = \" + distTo[s]);\n            return false;\n        }\n\n        for (int v = 0; v < G.V(); v++) {\n            for (int w : G.adj(v)) {\n                if (hasPathTo(v) != hasPathTo(w)) {\n                    StdOut.println(\"edge \" + v + \"-\" + w);\n                    StdOut.println(\"hasPathTo(\" + v + \") = \" + hasPathTo(v));\n                    StdOut.println(\"hasPathTo(\" + w + \") = \" + hasPathTo(w));\n                    return false;\n                }\n                if (hasPathTo(v) && (distTo[w] > distTo[v] + 1)) {\n                    StdOut.println(\"edge \" + v + \"-\" + w);\n                    StdOut.println(\"distTo[\" + v + \"] = \" + distTo[v]);\n                    StdOut.println(\"distTo[\" + w + \"] = \" + distTo[w]);\n                    return false;\n                }\n            }\n        }\n\n        for (int w = 0; w < G.V(); w++) {\n            if (!hasPathTo(w) || w == s) continue;\n            int v = edgeTo[w];\n            if (distTo[w] != distTo[v] + 1) {\n                StdOut.println(\"shortest path edge \" + v + \"-\" + w);\n                StdOut.println(\"distTo[\" + v + \"] = \" + distTo[v]);\n                StdOut.println(\"distTo[\" + w + \"] = \" + distTo[w]);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    private void validateVertices(Iterable<Integer> vertices) {\n        if (vertices == null) {\n            throw new IllegalArgumentException(\"argument is null\");\n        }\n        int V = marked.length;\n        for (int v : vertices) {\n            if (v < 0 || v >= V) {\n                throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n            }\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Graph G = new Graph(in);\n\n        int s = Integer.parseInt(args[1]);\n        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\n\n        for (int v = 0; v < G.V(); v++) {\n            if (bfs.hasPathTo(v)) {\n                StdOut.printf(\"%d to %d (%d):  \", s, v, bfs.distTo(v));\n                for (int x : bfs.pathTo(v)) {\n                    if (x == s) StdOut.print(x);\n                    else        StdOut.print(\"-\" + x);\n                }\n                StdOut.println();\n            }\n\n            else {\n                StdOut.printf(\"%d to %d (-):  not connected\\n\", s, v);\n            }\n\n        }\n    }\n\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Quick {\n\n    private Quick() { }\n\n    \n    public static void sort(Comparable[] a) {\n        StdRandom.shuffle(a);\n        sort(a, 0, a.length - 1);\n        assert isSorted(a);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) { \n        if (hi <= lo) return;\n        int j = partition(a, lo, hi);\n        sort(a, lo, j-1);\n        sort(a, j+1, hi);\n        assert isSorted(a, lo, hi);\n    }\n\n    private static int partition(Comparable[] a, int lo, int hi) {\n        int i = lo;\n        int j = hi + 1;\n        Comparable v = a[lo];\n        while (true) { \n\n            while (less(a[++i], v)) {\n                if (i == hi) break;\n            }\n\n            while (less(v, a[--j])) {\n                if (j == lo) break;      // redundant since a[lo] acts as sentinel\n            }\n\n            if (i >= j) break;\n\n            exch(a, i, j);\n        }\n\n        exch(a, lo, j);\n\n        return j;\n    }\n\n    \n    public static Comparable select(Comparable[] a, int k) {\n        if (k < 0 || k >= a.length) {\n            throw new IllegalArgumentException(\"index is not between 0 and \" + a.length + \": \" + k);\n        }\n        StdRandom.shuffle(a);\n        int lo = 0, hi = a.length - 1;\n        while (hi > lo) {\n            int i = partition(a, lo, hi);\n            if      (i > k) hi = i - 1;\n            else if (i < k) lo = i + 1;\n            else return a[i];\n        }\n        return a[lo];\n    }\n\n\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        if (v == w) return false;   // optimization when reference equals\n        return v.compareTo(w) < 0;\n    }\n        \n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        Quick.sort(a);\n        show(a);\n        assert isSorted(a);\n\n        StdRandom.shuffle(a);\n\n        StdOut.println();\n        for (int i = 0; i < a.length; i++) {\n            String ith = (String) Quick.select(a, i);\n            StdOut.println(ith);\n        }\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class KWIK {\n\n    private KWIK() { }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        int context = Integer.parseInt(args[1]);\n\n        String text = in.readAll().replaceAll(\"\\\\s+\", \" \");\n        int n = text.length();\n\n        SuffixArray sa = new SuffixArray(text);\n\n        while (StdIn.hasNextLine()) {\n            String query = StdIn.readLine();\n            for (int i = sa.rank(query); i < n; i++) {\n                int from1 = sa.index(i);\n                int to1   = Math.min(n, from1 + query.length());\n                if (!query.equals(text.substring(from1, to1))) break;\n                int from2 = Math.max(0, sa.index(i) - context);\n                int to2   = Math.min(n, sa.index(i) + context + query.length());\n                StdOut.println(text.substring(from2, to2));\n            }\n            StdOut.println();\n        }\n    } \n} \n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class DepthFirstDirectedPaths {\n    private boolean[] marked;  // marked[v] = true iff v is reachable from s\n    private int[] edgeTo;      // edgeTo[v] = last edge on path from s to v\n    private final int s;       // source vertex\n\n    \n    public DepthFirstDirectedPaths(Digraph G, int s) {\n        marked = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n        this.s = s;\n        validateVertex(s);\n        dfs(G, s);\n    }\n\n    private void dfs(Digraph G, int v) { \n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w]) {\n                edgeTo[w] = v;\n                dfs(G, w);\n            }\n        }\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    \n    \n    public Iterable<Integer> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v)) return null;\n        Stack<Integer> path = new Stack<Integer>();\n        for (int x = v; x != s; x = edgeTo[x])\n            path.push(x);\n        path.push(s);\n        return path;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n\n        int s = Integer.parseInt(args[1]);\n        DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, s);\n\n        for (int v = 0; v < G.V(); v++) {\n            if (dfs.hasPathTo(v)) {\n                StdOut.printf(\"%d to %d:  \", s, v);\n                for (int x : dfs.pathTo(v)) {\n                    if (x == s) StdOut.print(x);\n                    else        StdOut.print(\"-\" + x);\n                }\n                StdOut.println();\n            }\n\n            else {\n                StdOut.printf(\"%d to %d:  not connected\\n\", s, v);\n            }\n\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Complex {\n    private final double re;   // the real part\n    private final double im;   // the imaginary part\n\n    \n    public Complex(double real, double imag) {\n        re = real;\n        im = imag;\n    }\n\n    \n    public String toString() {\n        if (im == 0) return re + \"\";\n        if (re == 0) return im + \"i\";\n        if (im <  0) return re + \" - \" + (-im) + \"i\";\n        return re + \" + \" + im + \"i\";\n    }\n\n    \n    public double abs() {\n        return Math.hypot(re, im);\n    }\n\n    \n    public double phase() {\n        return Math.atan2(im, re);\n    }\n\n    \n    public Complex plus(Complex that) {\n        double real = this.re + that.re;\n        double imag = this.im + that.im;\n        return new Complex(real, imag);\n    }\n\n    \n    public Complex minus(Complex that) {\n        double real = this.re - that.re;\n        double imag = this.im - that.im;\n        return new Complex(real, imag);\n    }\n\n    \n    public Complex times(Complex that) {\n        double real = this.re * that.re - this.im * that.im;\n        double imag = this.re * that.im + this.im * that.re;\n        return new Complex(real, imag);\n    }\n\n    \n    public Complex scale(double alpha) {\n        return new Complex(alpha * re, alpha * im);\n    }\n\n    \n    @Deprecated\n    public Complex times(double alpha) {\n        return new Complex(alpha * re, alpha * im);\n    }\n\n    \n    public Complex conjugate() {\n        return new Complex(re, -im);\n    }\n\n    \n    public Complex reciprocal() {\n        double scale = re*re + im*im;\n        return new Complex(re / scale, -im / scale);\n    }\n\n    \n    public double re() {\n        return re;\n    }\n\n    \n    public double im() {\n        return im;\n    }\n\n    \n    public Complex divides(Complex that) {\n        return this.times(that.reciprocal());\n    }\n\n    \n    public Complex exp() {\n        return new Complex(Math.exp(re) * Math.cos(im), Math.exp(re) * Math.sin(im));\n    }\n\n    \n    public Complex sin() {\n        return new Complex(Math.sin(re) * Math.cosh(im), Math.cos(re) * Math.sinh(im));\n    }\n\n    \n    public Complex cos() {\n        return new Complex(Math.cos(re) * Math.cosh(im), -Math.sin(re) * Math.sinh(im));\n    }\n\n    \n    public Complex tan() {\n        return sin().divides(cos());\n    }\n    \n\n    \n    public static void main(String[] args) {\n        Complex a = new Complex(5.0, 6.0);\n        Complex b = new Complex(-3.0, 4.0);\n\n        StdOut.println(\"a            = \" + a);\n        StdOut.println(\"b            = \" + b);\n        StdOut.println(\"Re(a)        = \" + a.re());\n        StdOut.println(\"Im(a)        = \" + a.im());\n        StdOut.println(\"b + a        = \" + b.plus(a));\n        StdOut.println(\"a - b        = \" + a.minus(b));\n        StdOut.println(\"a * b        = \" + a.times(b));\n        StdOut.println(\"b * a        = \" + b.times(a));\n        StdOut.println(\"a / b        = \" + a.divides(b));\n        StdOut.println(\"(a / b) * b  = \" + a.divides(b).times(b));\n        StdOut.println(\"conj(a)      = \" + a.conjugate());\n        StdOut.println(\"|a|          = \" + a.abs());\n        StdOut.println(\"tan(a)       = \" + a.tan());\n    }\n\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\npublic class Polynomial {\n    private int[] coef;   // coefficients p(x) = sum { coef[i] * x^i }\n    private int degree;   // degree of polynomial (-1 for the zero polynomial)\n\n    \n    public Polynomial(int a, int b) {\n        if (b < 0) {\n            throw new IllegalArgumentException(\"exponent cannot be negative: \" + b);\n        }\n        coef = new int[b+1];\n        coef[b] = a;\n        reduce();\n    }\n\n    private void reduce() {\n        degree = -1;\n        for (int i = coef.length - 1; i >= 0; i--) {\n            if (coef[i] != 0) {\n                degree = i;\n                return;\n            }\n        }\n    }\n\n    \n    public int degree() {\n        return degree;\n    }\n\n    \n    public Polynomial plus(Polynomial that) {\n        Polynomial poly = new Polynomial(0, Math.max(this.degree, that.degree));\n        for (int i = 0; i <= this.degree; i++) poly.coef[i] += this.coef[i];\n        for (int i = 0; i <= that.degree; i++) poly.coef[i] += that.coef[i];\n        poly.reduce();\n        return poly;\n    }\n\n    \n    public Polynomial minus(Polynomial that) {\n        Polynomial poly = new Polynomial(0, Math.max(this.degree, that.degree));\n        for (int i = 0; i <= this.degree; i++) poly.coef[i] += this.coef[i];\n        for (int i = 0; i <= that.degree; i++) poly.coef[i] -= that.coef[i];\n        poly.reduce();\n        return poly;\n    }\n\n    \n    public Polynomial times(Polynomial that) {\n        Polynomial poly = new Polynomial(0, this.degree + that.degree);\n        for (int i = 0; i <= this.degree; i++)\n            for (int j = 0; j <= that.degree; j++)\n                poly.coef[i+j] += (this.coef[i] * that.coef[j]);\n        poly.reduce();\n        return poly;\n    }\n\n    \n    public Polynomial compose(Polynomial that) {\n        Polynomial poly = new Polynomial(0, 0);\n        for (int i = this.degree; i >= 0; i--) {\n            Polynomial term = new Polynomial(this.coef[i], 0);\n            poly = term.plus(that.times(poly));\n        }\n        return poly;\n    }\n\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (other == this) return true;\n        if (other == null) return false;\n        if (other.getClass() != this.getClass()) return false;\n        Polynomial that = (Polynomial) other;\n        if (this.degree != that.degree) return false;\n        for (int i = this.degree; i >= 0; i--)\n            if (this.coef[i] != that.coef[i]) return false;\n        return true;\n    }\n\n    \n    public Polynomial differentiate() {\n        if (degree == 0) return new Polynomial(0, 0);\n        Polynomial poly = new Polynomial(0, degree - 1);\n        poly.degree = degree - 1;\n        for (int i = 0; i < degree; i++)\n            poly.coef[i] = (i + 1) * coef[i + 1];\n        return poly;\n    }\n\n    \n    public int evaluate(int x) {\n        int p = 0;\n        for (int i = degree; i >= 0; i--)\n            p = coef[i] + (x * p);\n        return p;\n    }\n\n    \n    public int compareTo(Polynomial that) {\n        if (this.degree < that.degree) return -1;\n        if (this.degree > that.degree) return +1;\n        for (int i = this.degree; i >= 0; i--) {\n            if (this.coef[i] < that.coef[i]) return -1;\n            if (this.coef[i] > that.coef[i]) return +1;\n        }\n        return 0;\n    }\n\n    \n    @Override\n    public String toString() {\n        if      (degree == -1) return \"0\";\n        else if (degree ==  0) return \"\" + coef[0];\n        else if (degree ==  1) return coef[1] + \"x + \" + coef[0];\n        String s = coef[degree] + \"x^\" + degree;\n        for (int i = degree - 1; i >= 0; i--) {\n            if      (coef[i] == 0) continue;\n            else if (coef[i]  > 0) s = s + \" + \" + (coef[i]);\n            else if (coef[i]  < 0) s = s + \" - \" + (-coef[i]);\n            if      (i == 1) s = s + \"x\";\n            else if (i >  1) s = s + \"x^\" + i;\n        }\n        return s;\n    }\n\n    \n    public static void main(String[] args) { \n        Polynomial zero = new Polynomial(0, 0);\n\n        Polynomial p1   = new Polynomial(4, 3);\n        Polynomial p2   = new Polynomial(3, 2);\n        Polynomial p3   = new Polynomial(1, 0);\n        Polynomial p4   = new Polynomial(2, 1);\n        Polynomial p    = p1.plus(p2).plus(p3).plus(p4);   // 4x^3 + 3x^2 + 1\n\n        Polynomial q1   = new Polynomial(3, 2);\n        Polynomial q2   = new Polynomial(5, 0);\n        Polynomial q    = q1.plus(q2);                     // 3x^2 + 5\n\n\n        Polynomial r    = p.plus(q);\n        Polynomial s    = p.times(q);\n        Polynomial t    = p.compose(q);\n        Polynomial u    = p.minus(p);\n\n        StdOut.println(\"zero(x)     = \" + zero);\n        StdOut.println(\"p(x)        = \" + p);\n        StdOut.println(\"q(x)        = \" + q);\n        StdOut.println(\"p(x) + q(x) = \" + r);\n        StdOut.println(\"p(x) * q(x) = \" + s);\n        StdOut.println(\"p(q(x))     = \" + t);\n        StdOut.println(\"p(x) - p(x) = \" + u);\n        StdOut.println(\"0 - p(x)    = \" + zero.minus(p));\n        StdOut.println(\"p(3)        = \" + p.evaluate(3));\n        StdOut.println(\"p'(x)       = \" + p.differentiate());\n        StdOut.println(\"p''(x)      = \" + p.differentiate().differentiate());\n    }\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\n\npublic class DijkstraSP {\n    private double[] distTo;          // distTo[v] = distance  of shortest s->v path\n    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on shortest s->v path\n    private IndexMinPQ<Double> pq;    // priority queue of vertices\n\n    \n    public DijkstraSP(EdgeWeightedDigraph G, int s) {\n        for (DirectedEdge e : G.edges()) {\n            if (e.weight() < 0)\n                throw new IllegalArgumentException(\"edge \" + e + \" has negative weight\");\n        }\n\n        distTo = new double[G.V()];\n        edgeTo = new DirectedEdge[G.V()];\n\n        validateVertex(s);\n\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = Double.POSITIVE_INFINITY;\n        distTo[s] = 0.0;\n\n        pq = new IndexMinPQ<Double>(G.V());\n        pq.insert(s, distTo[s]);\n        while (!pq.isEmpty()) {\n            int v = pq.delMin();\n            for (DirectedEdge e : G.adj(v))\n                relax(e);\n        }\n\n        assert check(G, s);\n    }\n\n    private void relax(DirectedEdge e) {\n        int v = e.from(), w = e.to();\n        if (distTo[w] > distTo[v] + e.weight()) {\n            distTo[w] = distTo[v] + e.weight();\n            edgeTo[w] = e;\n            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);\n            else                pq.insert(w, distTo[w]);\n        }\n    }\n\n    \n    public double distTo(int v) {\n        validateVertex(v);\n        return distTo[v];\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return distTo[v] < Double.POSITIVE_INFINITY;\n    }\n\n    \n    public Iterable<DirectedEdge> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v)) return null;\n        Stack<DirectedEdge> path = new Stack<DirectedEdge>();\n        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {\n            path.push(e);\n        }\n        return path;\n    }\n\n\n    private boolean check(EdgeWeightedDigraph G, int s) {\n\n        for (DirectedEdge e : G.edges()) {\n            if (e.weight() < 0) {\n                System.err.println(\"negative edge weight detected\");\n                return false;\n            }\n        }\n\n        if (distTo[s] != 0.0 || edgeTo[s] != null) {\n            System.err.println(\"distTo[s] and edgeTo[s] inconsistent\");\n            return false;\n        }\n        for (int v = 0; v < G.V(); v++) {\n            if (v == s) continue;\n            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {\n                System.err.println(\"distTo[] and edgeTo[] inconsistent\");\n                return false;\n            }\n        }\n\n        for (int v = 0; v < G.V(); v++) {\n            for (DirectedEdge e : G.adj(v)) {\n                int w = e.to();\n                if (distTo[v] + e.weight() < distTo[w]) {\n                    System.err.println(\"edge \" + e + \" not relaxed\");\n                    return false;\n                }\n            }\n        }\n\n        for (int w = 0; w < G.V(); w++) {\n            if (edgeTo[w] == null) continue;\n            DirectedEdge e = edgeTo[w];\n            int v = e.from();\n            if (w != e.to()) return false;\n            if (distTo[v] + e.weight() != distTo[w]) {\n                System.err.println(\"edge \" + e + \" on shortest path not tight\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = distTo.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);\n        int s = Integer.parseInt(args[1]);\n\n        DijkstraSP sp = new DijkstraSP(G, s);\n\n\n        for (int t = 0; t < G.V(); t++) {\n            if (sp.hasPathTo(t)) {\n                StdOut.printf(\"%d to %d (%.2f)  \", s, t, sp.distTo(t));\n                for (DirectedEdge e : sp.pathTo(t)) {\n                    StdOut.print(e + \"   \");\n                }\n                StdOut.println();\n            }\n            else {\n                StdOut.printf(\"%d to %d         no path\\n\", s, t);\n            }\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Counter implements Comparable<Counter> {\n\n    private final String name;     // counter name\n    private int count = 0;         // current value\n\n    \n    public Counter(String id) {\n        name = id;\n    } \n\n    \n    public void increment() {\n        count++;\n    } \n\n    \n    public int tally() {\n        return count;\n    } \n\n    \n    public String toString() {\n        return count + \" \" + name;\n    } \n\n    \n    @Override\n    public int compareTo(Counter that) {\n        if      (this.count < that.count) return -1;\n        else if (this.count > that.count) return +1;\n        else                              return  0;\n    }\n\n\n    \n    public static void main(String[] args) { \n        int n = Integer.parseInt(args[0]);\n        int trials = Integer.parseInt(args[1]);\n\n        Counter[] hits = new Counter[n];\n        for (int i = 0; i < n; i++) {\n            hits[i] = new Counter(\"counter\" + i);\n        }\n\n        for (int t = 0; t < trials; t++) {\n            hits[StdRandom.uniform(n)].increment();\n        }\n\n        for (int i = 0; i < n; i++) {\n            StdOut.println(hits[i]);\n        }\n    } \n} \n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class LazyPrimMST {\n    private static final double FLOATING_POINT_EPSILON = 1E-12;\n\n    private double weight;       // total weight of MST\n    private Queue<Edge> mst;     // edges in the MST\n    private boolean[] marked;    // marked[v] = true iff v on tree\n    private MinPQ<Edge> pq;      // edges with one endpoint in tree\n\n    \n    public LazyPrimMST(EdgeWeightedGraph G) {\n        mst = new Queue<Edge>();\n        pq = new MinPQ<Edge>();\n        marked = new boolean[G.V()];\n        for (int v = 0; v < G.V(); v++)     // run Prim from all vertices to\n            if (!marked[v]) prim(G, v);     // get a minimum spanning forest\n\n        assert check(G);\n    }\n\n    private void prim(EdgeWeightedGraph G, int s) {\n        scan(G, s);\n        while (!pq.isEmpty()) {                        // better to stop when mst has V-1 edges\n            Edge e = pq.delMin();                      // smallest edge on pq\n            int v = e.either(), w = e.other(v);        // two endpoints\n            assert marked[v] || marked[w];\n            if (marked[v] && marked[w]) continue;      // lazy, both v and w already scanned\n            mst.enqueue(e);                            // add e to MST\n            weight += e.weight();\n            if (!marked[v]) scan(G, v);               // v becomes part of tree\n            if (!marked[w]) scan(G, w);               // w becomes part of tree\n        }\n    }\n\n    private void scan(EdgeWeightedGraph G, int v) {\n        assert !marked[v];\n        marked[v] = true;\n        for (Edge e : G.adj(v))\n            if (!marked[e.other(v)]) pq.insert(e);\n    }\n        \n    \n    public Iterable<Edge> edges() {\n        return mst;\n    }\n\n    \n    public double weight() {\n        return weight;\n    }\n\n    private boolean check(EdgeWeightedGraph G) {\n\n        double totalWeight = 0.0;\n        for (Edge e : edges()) {\n            totalWeight += e.weight();\n        }\n        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {\n            System.err.printf(\"Weight of edges does not equal weight(): %f vs. %f\\n\", totalWeight, weight());\n            return false;\n        }\n\n        UF uf = new UF(G.V());\n        for (Edge e : edges()) {\n            int v = e.either(), w = e.other(v);\n            if (uf.connected(v, w)) {\n                System.err.println(\"Not a forest\");\n                return false;\n            }\n            uf.union(v, w);\n        }\n\n        for (Edge e : G.edges()) {\n            int v = e.either(), w = e.other(v);\n            if (!uf.connected(v, w)) {\n                System.err.println(\"Not a spanning forest\");\n                return false;\n            }\n        }\n\n        for (Edge e : edges()) {\n\n            uf = new UF(G.V());\n            for (Edge f : mst) {\n                int x = f.either(), y = f.other(x);\n                if (f != e) uf.union(x, y);\n            }\n\n            for (Edge f : G.edges()) {\n                int x = f.either(), y = f.other(x);\n                if (!uf.connected(x, y)) {\n                    if (f.weight() < e.weight()) {\n                        System.err.println(\"Edge \" + f + \" violates cut optimality conditions\");\n                        return false;\n                    }\n                }\n            }\n\n        }\n\n        return true;\n    }\n    \n    \n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedGraph G = new EdgeWeightedGraph(in);\n        LazyPrimMST mst = new LazyPrimMST(G);\n        for (Edge e : mst.edges()) {\n            StdOut.println(e);\n        }\n        StdOut.printf(\"%.5f\\n\", mst.weight());\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class BoruvkaMST {\n    private static final double FLOATING_POINT_EPSILON = 1E-12;\n\n    private Bag<Edge> mst = new Bag<Edge>();    // edges in MST\n    private double weight;                      // weight of MST\n\n    \n    public BoruvkaMST(EdgeWeightedGraph G) {\n        UF uf = new UF(G.V());\n\n        for (int t = 1; t < G.V() && mst.size() < G.V() - 1; t = t + t) {\n\n            Edge[] closest = new Edge[G.V()];\n            for (Edge e : G.edges()) {\n                int v = e.either(), w = e.other(v);\n                int i = uf.find(v), j = uf.find(w);\n                if (i == j) continue;   // same tree\n                if (closest[i] == null || less(e, closest[i])) closest[i] = e;\n                if (closest[j] == null || less(e, closest[j])) closest[j] = e;\n            }\n\n            for (int i = 0; i < G.V(); i++) {\n                Edge e = closest[i];\n                if (e != null) {\n                    int v = e.either(), w = e.other(v);\n                    if (!uf.connected(v, w)) {\n                        mst.add(e);\n                        weight += e.weight();\n                        uf.union(v, w);\n                    }\n                }\n            }\n        }\n\n        assert check(G);\n    }\n\n    \n    public Iterable<Edge> edges() {\n        return mst;\n    }\n\n\n    \n    public double weight() {\n        return weight;\n    }\n\n    private static boolean less(Edge e, Edge f) {\n        return e.weight() < f.weight();\n    }\n\n    private boolean check(EdgeWeightedGraph G) {\n\n        double totalWeight = 0.0;\n        for (Edge e : edges()) {\n            totalWeight += e.weight();\n        }\n        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {\n            System.err.printf(\"Weight of edges does not equal weight(): %f vs. %f\\n\", totalWeight, weight());\n            return false;\n        }\n\n        UF uf = new UF(G.V());\n        for (Edge e : edges()) {\n            int v = e.either(), w = e.other(v);\n            if (uf.connected(v, w)) {\n                System.err.println(\"Not a forest\");\n                return false;\n            }\n            uf.union(v, w);\n        }\n\n        for (Edge e : G.edges()) {\n            int v = e.either(), w = e.other(v);\n            if (!uf.connected(v, w)) {\n                System.err.println(\"Not a spanning forest\");\n                return false;\n            }\n        }\n\n        for (Edge e : edges()) {\n\n            uf = new UF(G.V());\n            for (Edge f : mst) {\n                int x = f.either(), y = f.other(x);\n                if (f != e) uf.union(x, y);\n            }\n\n            for (Edge f : G.edges()) {\n                int x = f.either(), y = f.other(x);\n                if (!uf.connected(x, y)) {\n                    if (f.weight() < e.weight()) {\n                        System.err.println(\"Edge \" + f + \" violates cut optimality conditions\");\n                        return false;\n                    }\n                }\n            }\n\n        }\n\n        return true;\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedGraph G = new EdgeWeightedGraph(in);\n        BoruvkaMST mst = new BoruvkaMST(G);\n        for (Edge e : mst.edges()) {\n            StdOut.println(e);\n        }\n        StdOut.printf(\"%.5f\\n\", mst.weight());\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class DirectedCycleX {\n    private Stack<Integer> cycle;     // the directed cycle; null if digraph is acyclic\n\n    public DirectedCycleX(Digraph G) {\n\n        int[] indegree = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            indegree[v] = G.indegree(v);\n        }\n\n        Queue<Integer> queue = new Queue<Integer>();\n        for (int v = 0; v < G.V(); v++)\n            if (indegree[v] == 0) queue.enqueue(v);\n\n        while (!queue.isEmpty()) {\n            int v = queue.dequeue();\n            for (int w : G.adj(v)) {\n                indegree[w]--;\n                if (indegree[w] == 0) queue.enqueue(w);\n            }\n        }\n\n        int[] edgeTo = new int[G.V()];\n        int root = -1;  // any vertex with indegree >= -1\n        for (int v = 0; v < G.V(); v++) {\n            if (indegree[v] == 0) continue;\n            else root = v;\n            for (int w : G.adj(v)) {\n                if (indegree[w] > 0) {\n                    edgeTo[w] = v;\n                }\n            }\n        }\n\n        if (root != -1) {\n\n            boolean[] visited = new boolean[G.V()];\n            while (!visited[root]) {\n                visited[root] = true;\n                root = edgeTo[root];\n            }\n\n            cycle = new Stack<Integer>();\n            int v = root;\n            do {\n                cycle.push(v);\n                v = edgeTo[v];\n            } while (v != root);\n            cycle.push(root);\n        }\n\n        assert check();\n    }\n\n    \n    public Iterable<Integer> cycle() {\n        return cycle;\n    }\n\n    \n    public boolean hasCycle() {\n        return cycle != null;\n    }\n\n    private boolean check() {\n\n        if (hasCycle()) {\n            int first = -1, last = -1;\n            for (int v : cycle()) {\n                if (first == -1) first = v;\n                last = v;\n            }\n            if (first != last) {\n                System.err.printf(\"cycle begins with %d and ends with %d\\n\", first, last);\n                return false;\n            }\n        }\n\n\n        return true;\n    }\n\n\n    public static void main(String[] args) {\n\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n        int F = Integer.parseInt(args[2]);\n        Digraph G = DigraphGenerator.dag(V, E);\n\n        for (int i = 0; i < F; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            G.addEdge(v, w);\n        }\n\n        StdOut.println(G);\n\n\n        DirectedCycleX finder = new DirectedCycleX(G);\n        if (finder.hasCycle()) {\n            StdOut.print(\"Directed cycle: \");\n            for (int v : finder.cycle()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n\n        else {\n            StdOut.println(\"No directed cycle\");\n        }\n        StdOut.println();\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class InplaceMSD {\n    private static final int R             = 256;   // extended ASCII alphabet size\n    private static final int CUTOFF        =  15;   // cutoff to insertion sort\n\n    private InplaceMSD() { } \n\n   \n    public static void sort(String[] a) {\n        int n = a.length;\n        sort(a, 0, n-1, 0);\n    }\n\n    private static int charAt(String s, int d) {\n        assert d >= 0 && d <= s.length();\n        if (d == s.length()) return -1;\n        return s.charAt(d);\n    }\n\n    private static void sort(String[] a, int lo, int hi, int d) {\n\n        if (hi <= lo + CUTOFF) {\n            insertion(a, lo, hi, d);\n            return;\n        }\n\n        int[] heads = new int[R+2];\n        int[] tails = new int[R+1];\n        for (int i = lo; i <= hi; i++) {\n            int c = charAt(a[i], d);\n            heads[c+2]++;\n        }\n\n        heads[0] = lo;\n        for (int r = 0; r < R+1; r++) {\n            heads[r+1] += heads[r];\n            tails[r] = heads[r+1];\n        }\n\n        for (int r = 0; r < R+1; r++) {\n            while (heads[r] < tails[r]) {\n                int c = charAt(a[heads[r]], d);\n                while (c + 1 != r) {\n                    exch(a, heads[r], heads[c+1]++);\n                    c = charAt(a[heads[r]], d);\n                }\n                heads[r]++;\n            }\n        }\n              \n        for (int r = 0; r < R; r++)\n            sort(a, tails[r], tails[r+1] - 1, d+1);\n    }\n\n\n    private static void insertion(String[] a, int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)\n                exch(a, j, j-1);\n    }\n\n    private static void exch(String[] a, int i, int j) {\n        String temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    private static boolean less(String v, String w, int d) {\n        for (int i = d; i < Math.min(v.length(), w.length()); i++) {\n            if (v.charAt(i) < w.charAt(i)) return true;\n            if (v.charAt(i) > w.charAt(i)) return false;\n        }\n        return v.length() < w.length();\n    }\n\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        int n = a.length;\n        sort(a);\n        for (int i = 0; i < n; i++)\n            StdOut.println(a[i]);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class DepthFirstPaths {\n    private boolean[] marked;    // marked[v] = is there an s-v path?\n    private int[] edgeTo;        // edgeTo[v] = last edge on s-v path\n    private final int s;         // source vertex\n\n    \n    public DepthFirstPaths(Graph G, int s) {\n        this.s = s;\n        edgeTo = new int[G.V()];\n        marked = new boolean[G.V()];\n        validateVertex(s);\n        dfs(G, s);\n    }\n\n    private void dfs(Graph G, int v) {\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w]) {\n                edgeTo[w] = v;\n                dfs(G, w);\n            }\n        }\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    \n    public Iterable<Integer> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v)) return null;\n        Stack<Integer> path = new Stack<Integer>();\n        for (int x = v; x != s; x = edgeTo[x])\n            path.push(x);\n        path.push(s);\n        return path;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Graph G = new Graph(in);\n        int s = Integer.parseInt(args[1]);\n        DepthFirstPaths dfs = new DepthFirstPaths(G, s);\n\n        for (int v = 0; v < G.V(); v++) {\n            if (dfs.hasPathTo(v)) {\n                StdOut.printf(\"%d to %d:  \", s, v);\n                for (int x : dfs.pathTo(v)) {\n                    if (x == s) StdOut.print(x);\n                    else        StdOut.print(\"-\" + x);\n                }\n                StdOut.println();\n            }\n\n            else {\n                StdOut.printf(\"%d to %d:  not connected\\n\", s, v);\n            }\n\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class PrimMST {\n    private static final double FLOATING_POINT_EPSILON = 1E-12;\n\n    private Edge[] edgeTo;        // edgeTo[v] = shortest edge from tree vertex to non-tree vertex\n    private double[] distTo;      // distTo[v] = weight of shortest such edge\n    private boolean[] marked;     // marked[v] = true if v on tree, false otherwise\n    private IndexMinPQ<Double> pq;\n\n    \n    public PrimMST(EdgeWeightedGraph G) {\n        edgeTo = new Edge[G.V()];\n        distTo = new double[G.V()];\n        marked = new boolean[G.V()];\n        pq = new IndexMinPQ<Double>(G.V());\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = Double.POSITIVE_INFINITY;\n\n        for (int v = 0; v < G.V(); v++)      // run from each vertex to find\n            if (!marked[v]) prim(G, v);      // minimum spanning forest\n\n        assert check(G);\n    }\n\n    private void prim(EdgeWeightedGraph G, int s) {\n        distTo[s] = 0.0;\n        pq.insert(s, distTo[s]);\n        while (!pq.isEmpty()) {\n            int v = pq.delMin();\n            scan(G, v);\n        }\n    }\n\n    private void scan(EdgeWeightedGraph G, int v) {\n        marked[v] = true;\n        for (Edge e : G.adj(v)) {\n            int w = e.other(v);\n            if (marked[w]) continue;         // v-w is obsolete edge\n            if (e.weight() < distTo[w]) {\n                distTo[w] = e.weight();\n                edgeTo[w] = e;\n                if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);\n                else                pq.insert(w, distTo[w]);\n            }\n        }\n    }\n\n    \n    public Iterable<Edge> edges() {\n        Queue<Edge> mst = new Queue<Edge>();\n        for (int v = 0; v < edgeTo.length; v++) {\n            Edge e = edgeTo[v];\n            if (e != null) {\n                mst.enqueue(e);\n            }\n        }\n        return mst;\n    }\n\n    \n    public double weight() {\n        double weight = 0.0;\n        for (Edge e : edges())\n            weight += e.weight();\n        return weight;\n    }\n\n\n    private boolean check(EdgeWeightedGraph G) {\n\n        double totalWeight = 0.0;\n        for (Edge e : edges()) {\n            totalWeight += e.weight();\n        }\n        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {\n            System.err.printf(\"Weight of edges does not equal weight(): %f vs. %f\\n\", totalWeight, weight());\n            return false;\n        }\n\n        UF uf = new UF(G.V());\n        for (Edge e : edges()) {\n            int v = e.either(), w = e.other(v);\n            if (uf.connected(v, w)) {\n                System.err.println(\"Not a forest\");\n                return false;\n            }\n            uf.union(v, w);\n        }\n\n        for (Edge e : G.edges()) {\n            int v = e.either(), w = e.other(v);\n            if (!uf.connected(v, w)) {\n                System.err.println(\"Not a spanning forest\");\n                return false;\n            }\n        }\n\n        for (Edge e : edges()) {\n\n            uf = new UF(G.V());\n            for (Edge f : edges()) {\n                int x = f.either(), y = f.other(x);\n                if (f != e) uf.union(x, y);\n            }\n\n            for (Edge f : G.edges()) {\n                int x = f.either(), y = f.other(x);\n                if (!uf.connected(x, y)) {\n                    if (f.weight() < e.weight()) {\n                        System.err.println(\"Edge \" + f + \" violates cut optimality conditions\");\n                        return false;\n                    }\n                }\n            }\n\n        }\n\n        return true;\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedGraph G = new EdgeWeightedGraph(in);\n        PrimMST mst = new PrimMST(G);\n        for (Edge e : mst.edges()) {\n            StdOut.println(e);\n        }\n        StdOut.printf(\"%.5f\\n\", mst.weight());\n    }\n\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class EdgeWeightedGraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;\n    private int E;\n    private Bag<Edge>[] adj;\n    \n    \n    public EdgeWeightedGraph(int V) {\n        if (V < 0) throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        adj = (Bag<Edge>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<Edge>();\n        }\n    }\n\n    \n    public EdgeWeightedGraph(int V, int E) {\n        this(V);\n        if (E < 0) throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = Math.round(100 * StdRandom.uniform()) / 100.0;\n            Edge e = new Edge(v, w, weight);\n            addEdge(e);\n        }\n    }\n\n    \n    public EdgeWeightedGraph(In in) {\n        this(in.readInt());\n        int E = in.readInt();\n        if (E < 0) throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = in.readInt();\n            int w = in.readInt();\n            validateVertex(v);\n            validateVertex(w);\n            double weight = in.readDouble();\n            Edge e = new Edge(v, w, weight);\n            addEdge(e);\n        }\n    }\n\n    \n    public EdgeWeightedGraph(EdgeWeightedGraph G) {\n        this(G.V());\n        this.E = G.E();\n        for (int v = 0; v < G.V(); v++) {\n            Stack<Edge> reverse = new Stack<Edge>();\n            for (Edge e : G.adj[v]) {\n                reverse.push(e);\n            }\n            for (Edge e : reverse) {\n                adj[v].add(e);\n            }\n        }\n    }\n\n\n    \n    public int V() {\n        return V;\n    }\n\n    \n    public int E() {\n        return E;\n    }\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public void addEdge(Edge e) {\n        int v = e.either();\n        int w = e.other(v);\n        validateVertex(v);\n        validateVertex(w);\n        adj[v].add(e);\n        adj[w].add(e);\n        E++;\n    }\n\n    \n    public Iterable<Edge> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    \n    public int degree(int v) {\n        validateVertex(v);\n        return adj[v].size();\n    }\n\n    \n    public Iterable<Edge> edges() {\n        Bag<Edge> list = new Bag<Edge>();\n        for (int v = 0; v < V; v++) {\n            int selfLoops = 0;\n            for (Edge e : adj(v)) {\n                if (e.other(v) > v) {\n                    list.add(e);\n                }\n                else if (e.other(v) == v) {\n                    if (selfLoops % 2 == 0) list.add(e);\n                    selfLoops++;\n                }\n            }\n        }\n        return list;\n    }\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" \" + E + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(v + \": \");\n            for (Edge e : adj[v]) {\n                s.append(e + \"  \");\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedGraph G = new EdgeWeightedGraph(in);\n        StdOut.println(G);\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class NFA { \n\n    private Digraph graph;     // digraph of epsilon transitions\n    private String regexp;     // regular expression\n    private final int m;       // number of characters in regular expression\n\n    \n    public NFA(String regexp) {\n        this.regexp = regexp;\n        m = regexp.length();\n        Stack<Integer> ops = new Stack<Integer>(); \n        graph = new Digraph(m+1); \n        for (int i = 0; i < m; i++) { \n            int lp = i; \n            if (regexp.charAt(i) == '(' || regexp.charAt(i) == '|') \n                ops.push(i); \n            else if (regexp.charAt(i) == ')') {\n                int or = ops.pop(); \n\n                if (regexp.charAt(or) == '|') { \n                    lp = ops.pop();\n                    graph.addEdge(lp, or+1);\n                    graph.addEdge(or, i);\n                }\n                else if (regexp.charAt(or) == '(')\n                    lp = or;\n                else assert false;\n            } \n\n            if (i < m-1 && regexp.charAt(i+1) == '*') { \n                graph.addEdge(lp, i+1); \n                graph.addEdge(i+1, lp); \n            } \n            if (regexp.charAt(i) == '(' || regexp.charAt(i) == '*' || regexp.charAt(i) == ')') \n                graph.addEdge(i, i+1);\n        }\n        if (ops.size() != 0)\n            throw new IllegalArgumentException(\"Invalid regular expression\");\n    } \n\n    \n    public boolean recognizes(String txt) {\n        DirectedDFS dfs = new DirectedDFS(graph, 0);\n        Bag<Integer> pc = new Bag<Integer>();\n        for (int v = 0; v < graph.V(); v++)\n            if (dfs.marked(v)) pc.add(v);\n\n        for (int i = 0; i < txt.length(); i++) {\n            if (txt.charAt(i) == '*' || txt.charAt(i) == '|' || txt.charAt(i) == '(' || txt.charAt(i) == ')')\n                throw new IllegalArgumentException(\"text contains the metacharacter '\" + txt.charAt(i) + \"'\");\n\n            Bag<Integer> match = new Bag<Integer>();\n            for (int v : pc) {\n                if (v == m) continue;\n                if ((regexp.charAt(v) == txt.charAt(i)) || regexp.charAt(v) == '.')\n                    match.add(v+1); \n            }\n            dfs = new DirectedDFS(graph, match); \n            pc = new Bag<Integer>();\n            for (int v = 0; v < graph.V(); v++)\n                if (dfs.marked(v)) pc.add(v);\n\n            if (pc.size() == 0) return false;\n        }\n\n        for (int v : pc)\n            if (v == m) return true;\n        return false;\n    }\n\n    \n    public static void main(String[] args) {\n        String regexp = \"(\" + args[0] + \")\";\n        String txt = args[1];\n        NFA nfa = new NFA(regexp);\n        StdOut.println(nfa.recognizes(txt));\n    }\n\n} \n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class Cycle {\n    private boolean[] marked;\n    private int[] edgeTo;\n    private Stack<Integer> cycle;\n\n    \n    public Cycle(Graph G) {\n        if (hasSelfLoop(G)) return;\n        if (hasParallelEdges(G)) return;\n        marked = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            if (!marked[v])\n                dfs(G, -1, v);\n    }\n\n\n    private boolean hasSelfLoop(Graph G) {\n        for (int v = 0; v < G.V(); v++) {\n            for (int w : G.adj(v)) {\n                if (v == w) {\n                    cycle = new Stack<Integer>();\n                    cycle.push(v);\n                    cycle.push(v);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean hasParallelEdges(Graph G) {\n        marked = new boolean[G.V()];\n\n        for (int v = 0; v < G.V(); v++) {\n\n            for (int w : G.adj(v)) {\n                if (marked[w]) {\n                    cycle = new Stack<Integer>();\n                    cycle.push(v);\n                    cycle.push(w);\n                    cycle.push(v);\n                    return true;\n                }\n                marked[w] = true;\n            }\n\n            for (int w : G.adj(v)) {\n                marked[w] = false;\n            }\n        }\n        return false;\n    }\n\n    \n    public boolean hasCycle() {\n        return cycle != null;\n    }\n\n     \n    public Iterable<Integer> cycle() {\n        return cycle;\n    }\n\n    private void dfs(Graph G, int u, int v) {\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n\n            if (cycle != null) return;\n\n            if (!marked[w]) {\n                edgeTo[w] = v;\n                dfs(G, v, w);\n            }\n\n            else if (w != u) {\n                cycle = new Stack<Integer>();\n                for (int x = v; x != w; x = edgeTo[x]) {\n                    cycle.push(x);\n                }\n                cycle.push(w);\n                cycle.push(v);\n            }\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Graph G = new Graph(in);\n        Cycle finder = new Cycle(G);\n        if (finder.hasCycle()) {\n            for (int v : finder.cycle()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n        else {\n            StdOut.println(\"Graph is acyclic\");\n        }\n    }\n\n\n}\n\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class AmericanFlag {\n    private static final int BITS_PER_BYTE =   8;\n    private static final int BITS_PER_INT  =  32;   // each Java int is 32 bits \n    private static final int R             = 256;   // extend ASCII alphabet size\n    private static final int CUTOFF        =  15;   // cutoff to insertion sort\n\n    private AmericanFlag() { } \n\n    private static int charAt(String s, int d) {\n        assert d >= 0 && d <= s.length();\n        if (d == s.length()) return -1;\n        return s.charAt(d);\n    }\n\n    \n    public static void sort(String[] a) {\n        sort(a, 0, a.length - 1);\n    }\n\n    public static void sort(String[] a, int lo, int hi) {\n        Stack<Integer> st = new Stack<Integer>();\n        int[] first = new int[R+2];\n        int[] next  = new int[R+2];\n        int d = 0; // character index to sort by\n\n        st.push(lo);\n        st.push(hi);\n        st.push(d);\n        \n        while (!st.isEmpty()) {\n            d = st.pop();\n            hi = st.pop();\n            lo = st.pop();\n        \n            if (hi <= lo + CUTOFF) {\n                insertion(a, lo, hi, d);\n                continue;\n            }\n\n            for (int i = lo; i <= hi; i++) {\n                int c = charAt(a[i], d) + 1; // account for -1 representing end-of-string\n                first[c+1]++;\n            }\n\n            first[0] = lo;\n            for (int c = 0; c <= R; c++) {\n                first[c+1] += first[c];\n            \n                if (c > 0 && first[c+1]-1 > first[c]) { \n                    st.push(first[c]);\n                    st.push(first[c+1] - 1);\n                    st.push(d+1); \n                }\n            }\n\n            for (int c = 0; c < R+2; c++)\n                next[c] = first[c];\n\n            for (int k = lo; k <= hi; k++) {\n                int c = charAt(a[k], d) + 1;\n                while (first[c] > k) {\n                    exch(a, k, next[c]++);\n                    c = charAt(a[k], d) + 1;\n                }\n                next[c]++;\n            }\n          \n            for (int c = 0; c < R+2; c++) {\n                first[c] = 0;\n                next[c] = 0;\n            }\n        }\n    }\n    \n    private static void insertion(String[] a, int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)\n                exch(a, j, j-1);\n    }\n\n    private static void exch(String[] a, int i, int j) {\n        String temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    private static boolean less(String v, String w, int d) {\n        for (int i = d; i <  Math.min(v.length(), w.length()); i++) {\n            if (v.charAt(i) < w.charAt(i)) return true;\n            if (v.charAt(i) > w.charAt(i)) return false;\n        }\n        return v.length() < w.length();\n    }\n\n   \n    public static void sort(int[] a) {\n        sort(a, 0, a.length-1);\n    }\n\n    private static void sort(int[] a, int lo, int hi) {\n        Stack<Integer> st = new Stack<Integer>();\n        int[] first = new int[R+1];\n        int[] next  = new int[R+1];\n        int mask = R - 1;   // 0xFF;\n        int d = 0;          // byte to sort by\n\n        st.push(lo);\n        st.push(hi);\n        st.push(d);\n        \n        while (!st.isEmpty()) {\n            d = st.pop();\n            hi = st.pop();\n            lo = st.pop();\n        \n            if (hi <= lo + CUTOFF) {\n                insertion(a, lo, hi, d);\n                continue;\n            }\n          \n            int shift = BITS_PER_INT - BITS_PER_BYTE*d - BITS_PER_BYTE;\n            for (int i = lo; i <= hi; i++) {\n                int c = (a[i] >> shift) & mask;\n                first[c+1]++;\n            }\n\n            first[0] = lo;\n            for (int c = 0; c < R; c++) {\n                first[c+1] += first[c];\n            \n                if (d < 3 && first[c+1]-1 > first[c]) { \n                    st.push(first[c]);\n                    st.push(first[c+1] - 1);\n                    st.push(d+1); \n                }\n            }\n\n            for (int c = 0; c < R+1; c++)\n                next[c] = first[c];\n\n            for (int k = lo; k <= hi; k++) {\n                int c = (a[k] >> shift) & mask;\n                while (first[c] > k) {\n                    exch(a, k, next[c]++);\n                    c = (a[k] >> shift) & mask;\n                }\n                next[c]++;\n            }\n          \n            for (int c = 0; c < R+1; c++) {\n                first[c] = 0;\n                next[c] = 0;\n            }\n        }\n    }\n\n    private static void insertion(int[] a, int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)\n                exch(a, j, j-1);\n    }\n\n    private static void exch(int[] a, int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n    \n    private static boolean less(int v, int w, int d) {\n        int mask = R - 1;   // 0xFF;\n        for (int i = d; i < 4; i++) {\n            int shift = BITS_PER_INT - BITS_PER_BYTE*i - BITS_PER_BYTE;\n            int a = (v >> shift) & mask;\n            int b = (w >> shift) & mask;\n            if (a < b) return true;\n            if (a > b) return false;\n        }\n        return false;\n    }\n    \n    \n    public static void main(String[] args) {\n        if (args.length > 0 && args[0].equals(\"int\")) {\n            int[] a = StdIn.readAllInts();\n            sort(a);\n\n            for (int i = 0; i < a.length; i++)\n                StdOut.println(a[i]);\n        }\n\n        else {\n            String[] a = StdIn.readAllStrings();\n            sort(a);\n            for (int i = 0; i < a.length; i++)\n                StdOut.println(a[i]);\n        }\n    }\n}\n\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class EdgeWeightedDirectedCycle {\n    private boolean[] marked;             // marked[v] = has vertex v been marked?\n    private DirectedEdge[] edgeTo;        // edgeTo[v] = previous edge on path to v\n    private boolean[] onStack;            // onStack[v] = is vertex on the stack?\n    private Stack<DirectedEdge> cycle;    // directed cycle (or null if no such cycle)\n\n    \n    public EdgeWeightedDirectedCycle(EdgeWeightedDigraph G) {\n        marked  = new boolean[G.V()];\n        onStack = new boolean[G.V()];\n        edgeTo  = new DirectedEdge[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            if (!marked[v]) dfs(G, v);\n\n        assert check();\n    }\n\n    private void dfs(EdgeWeightedDigraph G, int v) {\n        onStack[v] = true;\n        marked[v] = true;\n        for (DirectedEdge e : G.adj(v)) {\n            int w = e.to();\n\n            if (cycle != null) return;\n\n            else if (!marked[w]) {\n                edgeTo[w] = e;\n                dfs(G, w);\n            }\n\n            else if (onStack[w]) {\n                cycle = new Stack<DirectedEdge>();\n\n                DirectedEdge f = e;\n                while (f.from() != w) {\n                    cycle.push(f);\n                    f = edgeTo[f.from()];\n                }\n                cycle.push(f);\n\n                return;\n            }\n        }\n\n        onStack[v] = false;\n    }\n\n    \n    public boolean hasCycle() {\n        return cycle != null;\n    }\n\n    \n    public Iterable<DirectedEdge> cycle() {\n        return cycle;\n    }\n\n\n    private boolean check() {\n\n        if (hasCycle()) {\n            DirectedEdge first = null, last = null;\n            for (DirectedEdge e : cycle()) {\n                if (first == null) first = e;\n                if (last != null) {\n                    if (last.to() != e.from()) {\n                        System.err.printf(\"cycle edges %s and %s not incident\\n\", last, e);\n                        return false;\n                    }\n                }\n                last = e;\n            }\n\n            if (last.to() != first.from()) {\n                System.err.printf(\"cycle edges %s and %s not incident\\n\", last, first);\n                return false;\n            }\n        }\n\n\n        return true;\n    }\n\n    \n    public static void main(String[] args) {\n\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n        int F = Integer.parseInt(args[2]);\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);\n        int[] vertices = new int[V];\n        for (int i = 0; i < V; i++)\n            vertices[i] = i;\n        StdRandom.shuffle(vertices);\n        for (int i = 0; i < E; i++) {\n            int v, w;\n            do {\n                v = StdRandom.uniform(V);\n                w = StdRandom.uniform(V);\n            } while (v >= w);\n            double weight = StdRandom.uniform();\n            G.addEdge(new DirectedEdge(v, w, weight));\n        }\n\n        for (int i = 0; i < F; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = StdRandom.uniform(0.0, 1.0);\n            G.addEdge(new DirectedEdge(v, w, weight));\n        }\n\n        StdOut.println(G);\n\n        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(G);\n        if (finder.hasCycle()) {\n            StdOut.print(\"Cycle: \");\n            for (DirectedEdge e : finder.cycle()) {\n                StdOut.print(e + \" \");\n            }\n            StdOut.println();\n        }\n\n        else {\n            StdOut.println(\"No directed cycle\");\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class ResizingArrayBag<Item> implements Iterable<Item> {\n    private Item[] a;         // array of items\n    private int n;            // number of elements on bag\n\n    \n    public ResizingArrayBag() {\n        a = (Item[]) new Object[2];\n        n = 0;\n    }\n\n    \n    public boolean isEmpty() {\n        return n == 0;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    private void resize(int capacity) {\n        assert capacity >= n;\n        Item[] temp = (Item[]) new Object[capacity];\n        for (int i = 0; i < n; i++)\n            temp[i] = a[i];\n        a = temp;\n    }\n\n    \n    public void add(Item item) {\n        if (n == a.length) resize(2*a.length);    // double size of array if necessary\n        a[n++] = item;                            // add item\n    }\n\n\n    \n    public Iterator<Item> iterator() {\n        return new ArrayIterator();\n    }\n\n    private class ArrayIterator implements Iterator<Item> {\n        private int i = 0;\n        public boolean hasNext()  { return i < n;                               }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            return a[i++];\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        ResizingArrayBag<String> bag = new ResizingArrayBag<String>();\n        bag.add(\"Hello\");\n        bag.add(\"World\");\n        bag.add(\"how\");\n        bag.add(\"are\");\n        bag.add(\"you\");\n\n        for (String s : bag)\n            StdOut.println(s);\n    }\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class DirectedEulerianCycle {\n    private Stack<Integer> cycle = null;  // Eulerian cycle; null if no such cylce\n\n    \n    public DirectedEulerianCycle(Digraph G) {\n\n        if (G.E() == 0) return;\n\n        for (int v = 0; v < G.V(); v++)\n            if (G.outdegree(v) != G.indegree(v))\n                return;\n\n        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            adj[v] = G.adj(v).iterator();\n\n        int s = nonIsolatedVertex(G);\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(s);\n\n        cycle = new Stack<Integer>();\n        while (!stack.isEmpty()) {\n            int v = stack.pop();\n            while (adj[v].hasNext()) {\n                stack.push(v);\n                v = adj[v].next();\n            }\n            cycle.push(v);\n        }\n\n        if (cycle.size() != G.E() + 1)\n            cycle = null;\n\n        assert certifySolution(G);\n    }\n\n    \n    public Iterable<Integer> cycle() {\n        return cycle;\n    }\n\n    \n    public boolean hasEulerianCycle() {\n        return cycle != null;\n    }\n\n    private static int nonIsolatedVertex(Digraph G) {\n        for (int v = 0; v < G.V(); v++)\n            if (G.outdegree(v) > 0)\n                return v;\n        return -1;\n    }\n\n\n    \n\n    private static boolean satisfiesNecessaryAndSufficientConditions(Digraph G) {\n\n        if (G.E() == 0) return false;\n\n        for (int v = 0; v < G.V(); v++)\n            if (G.outdegree(v) != G.indegree(v))\n                return false;\n\n        Graph H = new Graph(G.V());\n        for (int v = 0; v < G.V(); v++)\n            for (int w : G.adj(v))\n                H.addEdge(v, w);\n        \n        int s = nonIsolatedVertex(G);\n        BreadthFirstPaths bfs = new BreadthFirstPaths(H, s);\n        for (int v = 0; v < G.V(); v++)\n            if (H.degree(v) > 0 && !bfs.hasPathTo(v))\n                return false;\n\n        return true;\n    }\n\n    private boolean certifySolution(Digraph G) {\n\n        if (hasEulerianCycle() == (cycle() == null)) return false;\n\n        if (hasEulerianCycle() != satisfiesNecessaryAndSufficientConditions(G)) return false;\n\n        if (cycle == null) return true;\n\n        if (cycle.size() != G.E() + 1) return false;\n\n\n        return true;\n    }\n\n\n    private static void unitTest(Digraph G, String description) {\n        StdOut.println(description);\n        StdOut.println(\"-------------------------------------\");\n        StdOut.print(G);\n\n        DirectedEulerianCycle euler = new DirectedEulerianCycle(G);\n\n        StdOut.print(\"Eulerian cycle: \");\n        if (euler.hasEulerianCycle()) {\n            for (int v : euler.cycle()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n        else {\n            StdOut.println(\"none\");\n        }\n        StdOut.println();\n    }\n\n\n    \n    public static void main(String[] args) {\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n\n        Digraph G1 = DigraphGenerator.eulerianCycle(V, E);\n        unitTest(G1, \"Eulerian cycle\");\n\n        Digraph G2 = DigraphGenerator.eulerianPath(V, E);\n        unitTest(G2, \"Eulerian path\");\n\n        Digraph G3 = new Digraph(V);\n        unitTest(G3, \"empty digraph\");\n\n        Digraph G4 = new Digraph(V);\n        int v4 = StdRandom.uniform(V);\n        G4.addEdge(v4, v4);\n        unitTest(G4, \"single self loop\");\n\n        Digraph H1 = DigraphGenerator.eulerianCycle(V/2, E/2);\n        Digraph H2 = DigraphGenerator.eulerianCycle(V - V/2, E - E/2);\n        int[] perm = new int[V];\n        for (int i = 0; i < V; i++)\n            perm[i] = i;\n        StdRandom.shuffle(perm);\n        Digraph G5 = new Digraph(V);\n        for (int v = 0; v < H1.V(); v++)\n            for (int w : H1.adj(v))\n                G5.addEdge(perm[v], perm[w]);\n        for (int v = 0; v < H2.V(); v++)\n            for (int w : H2.adj(v))\n                G5.addEdge(perm[V/2 + v], perm[V/2 + w]);\n        unitTest(G5, \"Union of two disjoint cycles\");\n\n        Digraph G6 = DigraphGenerator.simple(V, E);\n        unitTest(G6, \"simple digraph\");\n\n        Digraph G7 = new Digraph(new In(\"eulerianD.txt\"));\n        unitTest(G7, \"4-vertex Eulerian digraph\");\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class LongestCommonSubstring {\n\n    private LongestCommonSubstring() { }\n\n    private static String lcp(String s, int p, String t, int q) {\n        int n = Math.min(s.length() - p, t.length() - q);\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(p + i) != t.charAt(q + i))\n                return s.substring(p, p + i);\n        }\n        return s.substring(p, p + n);\n    }\n\n    private static int compare(String s, int p, String t, int q) {\n        int n = Math.min(s.length() - p, t.length() - q);\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(p + i) != t.charAt(q + i))\n                return s.charAt(p+i) - t.charAt(q+i);\n        }\n        if      (s.length() - p < t.length() - q) return -1;\n        else if (s.length() - p > t.length() - q) return +1;\n        else                                      return  0;\n    }\n\n    \n    public static String lcs(String s, String t) {\n        SuffixArray suffix1 = new SuffixArray(s);\n        SuffixArray suffix2 = new SuffixArray(t);\n\n        String lcs = \"\";\n        int i = 0, j = 0;\n        while (i < s.length() && j < t.length()) {\n            int p = suffix1.index(i);\n            int q = suffix2.index(j);\n            String x = lcp(s, p, t, q);\n            if (x.length() > lcs.length()) lcs = x;\n            if (compare(s, p, t, q) < 0) i++;\n            else                         j++;\n        }\n        return lcs;\n    }\n\n    \n    public static void main(String[] args) {\n        In in1 = new In(args[0]);\n        In in2 = new In(args[1]);\n        String s = in1.readAll().trim().replaceAll(\"\\\\s+\", \" \");\n        String t = in2.readAll().trim().replaceAll(\"\\\\s+\", \" \");\n        StdOut.println(\"'\" + lcs(s, t) + \"'\");\n    }\n}\n\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\npublic class Alphabet {\n\n    \n    public static final Alphabet BINARY = new Alphabet(\"01\");\n\n    \n    public static final Alphabet OCTAL = new Alphabet(\"01234567\");\n\n    \n    public static final Alphabet DECIMAL = new Alphabet(\"0123456789\");\n\n    \n    public static final Alphabet HEXADECIMAL = new Alphabet(\"0123456789ABCDEF\");\n\n    \n    public static final Alphabet DNA = new Alphabet(\"ACGT\");\n\n    \n    public static final Alphabet LOWERCASE = new Alphabet(\"abcdefghijklmnopqrstuvwxyz\");\n\n    \n\n    public static final Alphabet UPPERCASE = new Alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\n    \n    public static final Alphabet PROTEIN = new Alphabet(\"ACDEFGHIKLMNPQRSTVWY\");\n\n    \n    public static final Alphabet BASE64 = new Alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\n    \n    public static final Alphabet ASCII = new Alphabet(128);\n\n    \n    public static final Alphabet EXTENDED_ASCII = new Alphabet(256);\n\n    \n    public static final Alphabet UNICODE16      = new Alphabet(65536);\n\n\n    private char[] alphabet;     // the characters in the alphabet\n    private int[] inverse;       // indices\n    private final int R;         // the radix of the alphabet\n\n    \n    public Alphabet(String alpha) {\n\n        boolean[] unicode = new boolean[Character.MAX_VALUE];\n        for (int i = 0; i < alpha.length(); i++) {\n            char c = alpha.charAt(i);\n            if (unicode[c])\n                throw new IllegalArgumentException(\"Illegal alphabet: repeated character = '\" + c + \"'\");\n            unicode[c] = true;\n        }\n\n        alphabet = alpha.toCharArray();\n        R = alpha.length();\n        inverse = new int[Character.MAX_VALUE];\n        for (int i = 0; i < inverse.length; i++)\n            inverse[i] = -1;\n\n        for (int c = 0; c < R; c++)\n            inverse[alphabet[c]] = c;\n    }\n\n    \n    private Alphabet(int radix) {\n        this.R = radix;\n        alphabet = new char[R];\n        inverse = new int[R];\n\n        for (int i = 0; i < R; i++)\n            alphabet[i] = (char) i;\n        for (int i = 0; i < R; i++)\n            inverse[i] = i;\n    }\n\n    \n    public Alphabet() {\n        this(256);\n    }\n\n    \n    public boolean contains(char c) {\n        return inverse[c] != -1;\n    }\n\n    \n    @Deprecated\n    public int R() {\n        return R;\n    }\n\n    \n    public int radix() {\n        return R;\n    }\n\n    \n    public int lgR() {\n        int lgR = 0;\n        for (int t = R-1; t >= 1; t /= 2)\n            lgR++;\n        return lgR;\n    }\n\n    \n    public int toIndex(char c) {\n        if (c >= inverse.length || inverse[c] == -1) {\n            throw new IllegalArgumentException(\"Character \" + c + \" not in alphabet\");\n        }\n        return inverse[c];\n    }\n\n    \n    public int[] toIndices(String s) {\n        char[] source = s.toCharArray();\n        int[] target  = new int[s.length()];\n        for (int i = 0; i < source.length; i++)\n            target[i] = toIndex(source[i]);\n        return target;\n    }\n\n    \n    public char toChar(int index) {\n        if (index < 0 || index >= R) {\n            throw new IllegalArgumentException(\"index must be between 0 and \" + R + \": \" + index);\n        }\n        return alphabet[index];\n    }\n\n    \n    public String toChars(int[] indices) {\n        StringBuilder s = new StringBuilder(indices.length);\n        for (int i = 0; i < indices.length; i++)\n            s.append(toChar(indices[i]));\n        return s.toString();\n    }\n\n    \n    public static void main(String[] args) {\n        int[]  encoded1 = Alphabet.BASE64.toIndices(\"NowIsTheTimeForAllGoodMen\");\n        String decoded1 = Alphabet.BASE64.toChars(encoded1);\n        StdOut.println(decoded1);\n \n        int[]  encoded2 = Alphabet.DNA.toIndices(\"AACGAACGGTTTACCCCG\");\n        String decoded2 = Alphabet.DNA.toChars(encoded2);\n        StdOut.println(decoded2);\n\n        int[]  encoded3 = Alphabet.DECIMAL.toIndices(\"01234567890123456789\");\n        String decoded3 = Alphabet.DECIMAL.toChars(encoded3);\n        StdOut.println(decoded3);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class WhiteFilter {  \n\n    private WhiteFilter() { }\n\n    public static void main(String[] args) {\n        SET<String> set = new SET<String>();\n\n        In in = new In(args[0]);\n        while (!in.isEmpty()) {\n            String word = in.readString();\n            set.add(word);\n        }\n\n        while (!StdIn.isEmpty()) {\n            String word = StdIn.readString();\n            if (set.contains(word))\n                StdOut.println(word);\n        }\n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class SparseVector {\n    private int d;                   // dimension\n    private ST<Integer, Double> st;  // the vector, represented by index-value pairs\n\n   \n    public SparseVector(int d) {\n        this.d  = d;\n        this.st = new ST<Integer, Double>();\n    }\n\n   \n    public void put(int i, double value) {\n        if (i < 0 || i >= d) throw new IllegalArgumentException(\"Illegal index\");\n        if (value == 0.0) st.delete(i);\n        else              st.put(i, value);\n    }\n\n   \n    public double get(int i) {\n        if (i < 0 || i >= d) throw new IllegalArgumentException(\"Illegal index\");\n        if (st.contains(i)) return st.get(i);\n        else                return 0.0;\n    }\n\n   \n    public int nnz() {\n        return st.size();\n    }\n\n   \n    @Deprecated\n    public int size() {\n        return d;\n    }\n\n   \n    public int dimension() {\n        return d;\n    }\n\n    \n    public double dot(SparseVector that) {\n        if (this.d != that.d) throw new IllegalArgumentException(\"Vector lengths disagree\");\n        double sum = 0.0;\n\n        if (this.st.size() <= that.st.size()) {\n            for (int i : this.st.keys())\n                if (that.st.contains(i)) sum += this.get(i) * that.get(i);\n        }\n        else  {\n            for (int i : that.st.keys())\n                if (this.st.contains(i)) sum += this.get(i) * that.get(i);\n        }\n        return sum;\n    }\n\n\n    \n    public double dot(double[] that) {\n        double sum = 0.0;\n        for (int i : st.keys())\n            sum += that[i] * this.get(i);\n        return sum;\n    }\n\n    \n    public double magnitude() {\n        return Math.sqrt(this.dot(this));\n    }\n\n\n    \n    @Deprecated\n    public double norm() {\n        return Math.sqrt(this.dot(this));\n    }\n\n    \n    public SparseVector scale(double alpha) {\n        SparseVector c = new SparseVector(d);\n        for (int i : this.st.keys()) c.put(i, alpha * this.get(i));\n        return c;\n    }\n\n    \n    public SparseVector plus(SparseVector that) {\n        if (this.d != that.d) throw new IllegalArgumentException(\"Vector lengths disagree\");\n        SparseVector c = new SparseVector(d);\n        for (int i : this.st.keys()) c.put(i, this.get(i));                // c = this\n        for (int i : that.st.keys()) c.put(i, that.get(i) + c.get(i));     // c = c + that\n        return c;\n    }\n\n   \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (int i : st.keys()) {\n            s.append(\"(\" + i + \", \" + st.get(i) + \") \");\n        }\n        return s.toString();\n    }\n\n\n    \n    public static void main(String[] args) {\n        SparseVector a = new SparseVector(10);\n        SparseVector b = new SparseVector(10);\n        a.put(3, 0.50);\n        a.put(9, 0.75);\n        a.put(6, 0.11);\n        a.put(6, 0.00);\n        b.put(3, 0.60);\n        b.put(4, 0.90);\n        StdOut.println(\"a = \" + a);\n        StdOut.println(\"b = \" + b);\n        StdOut.println(\"a dot b = \" + a.dot(b));\n        StdOut.println(\"a + b   = \" + a.plus(b));\n    }\n\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class DijkstraAllPairsSP {\n    private DijkstraSP[] all;\n\n    \n    public DijkstraAllPairsSP(EdgeWeightedDigraph G) {\n        all  = new DijkstraSP[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            all[v] = new DijkstraSP(G, v);\n    }\n\n    \n    public Iterable<DirectedEdge> path(int s, int t) {\n        validateVertex(s);\n        validateVertex(t);\n        return all[s].pathTo(t);\n    }\n\n    \n    public boolean hasPath(int s, int t) {\n        validateVertex(s);\n        validateVertex(t);\n        return dist(s, t) < Double.POSITIVE_INFINITY;\n    }\n\n    \n    public double dist(int s, int t) {\n        validateVertex(s);\n        validateVertex(t);\n        return all[s].distTo(t);\n    }\n\n    private void validateVertex(int v) {\n        int V = all.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n\n    \n    public static void main(String[] args) {\n\n        In in = new In(args[0]);\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);\n\n        DijkstraAllPairsSP spt = new DijkstraAllPairsSP(G);\n\n        StdOut.printf(\"  \");\n        for (int v = 0; v < G.V(); v++) {\n            StdOut.printf(\"%6d \", v);\n        }\n        StdOut.println();\n        for (int v = 0; v < G.V(); v++) {\n            StdOut.printf(\"%3d: \", v);\n            for (int w = 0; w < G.V(); w++) {\n                if (spt.hasPath(v, w)) StdOut.printf(\"%6.2f \", spt.dist(v, w));\n                else StdOut.printf(\"  Inf \");\n            }\n            StdOut.println();\n        }\n        StdOut.println();\n\n        for (int v = 0; v < G.V(); v++) {\n            for (int w = 0; w < G.V(); w++) {\n                if (spt.hasPath(v, w)) {\n                    StdOut.printf(\"%d to %d (%5.2f)  \", v, w, spt.dist(v, w));\n                    for (DirectedEdge e : spt.path(v, w))\n                        StdOut.print(e + \"  \");\n                    StdOut.println();\n                }\n                else {\n                    StdOut.printf(\"%d to %d no path\\n\", v, w);\n                }\n            }\n        }\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class FlowEdge {\n    private static final double FLOATING_POINT_EPSILON = 1E-10;\n\n    private final int v;             // from\n    private final int w;             // to \n    private final double capacity;   // capacity\n    private double flow;             // flow\n\n    \n    public FlowEdge(int v, int w, double capacity) {\n        if (v < 0) throw new IllegalArgumentException(\"vertex index must be a non-negative integer\");\n        if (w < 0) throw new IllegalArgumentException(\"vertex index must be a non-negative integer\");\n        if (!(capacity >= 0.0)) throw new IllegalArgumentException(\"Edge capacity must be non-negative\");\n        this.v         = v;\n        this.w         = w;  \n        this.capacity  = capacity;\n        this.flow      = 0.0;\n    }\n\n    \n    public FlowEdge(int v, int w, double capacity, double flow) {\n        if (v < 0) throw new IllegalArgumentException(\"vertex index must be a non-negative integer\");\n        if (w < 0) throw new IllegalArgumentException(\"vertex index must be a non-negative integer\");\n        if (!(capacity >= 0.0))  throw new IllegalArgumentException(\"edge capacity must be non-negative\");\n        if (!(flow <= capacity)) throw new IllegalArgumentException(\"flow exceeds capacity\");\n        if (!(flow >= 0.0))      throw new IllegalArgumentException(\"flow must be non-negative\");\n        this.v         = v;\n        this.w         = w;  \n        this.capacity  = capacity;\n        this.flow      = flow;\n    }\n\n    \n    public FlowEdge(FlowEdge e) {\n        this.v         = e.v;\n        this.w         = e.w;\n        this.capacity  = e.capacity;\n        this.flow      = e.flow;\n    }\n\n    \n    public int from() {\n        return v;\n    }  \n\n    \n    public int to() {\n        return w;\n    }  \n\n    \n    public double capacity() {\n        return capacity;\n    }\n\n    \n    public double flow() {\n        return flow;\n    }\n\n    \n    public int other(int vertex) {\n        if      (vertex == v) return w;\n        else if (vertex == w) return v;\n        else throw new IllegalArgumentException(\"invalid endpoint\");\n    }\n\n    \n    public double residualCapacityTo(int vertex) {\n        if      (vertex == v) return flow;              // backward edge\n        else if (vertex == w) return capacity - flow;   // forward edge\n        else throw new IllegalArgumentException(\"invalid endpoint\");\n    }\n\n    \n    public void addResidualFlowTo(int vertex, double delta) {\n        if (!(delta >= 0.0)) throw new IllegalArgumentException(\"Delta must be nonnegative\");\n\n        if      (vertex == v) flow -= delta;           // backward edge\n        else if (vertex == w) flow += delta;           // forward edge\n        else throw new IllegalArgumentException(\"invalid endpoint\");\n\n        if (Math.abs(flow) <= FLOATING_POINT_EPSILON)\n            flow = 0;\n        if (Math.abs(flow - capacity) <= FLOATING_POINT_EPSILON)\n            flow = capacity;\n\n        if (!(flow >= 0.0))      throw new IllegalArgumentException(\"Flow is negative\");\n        if (!(flow <= capacity)) throw new IllegalArgumentException(\"Flow exceeds capacity\");\n    }\n\n\n    \n    public String toString() {\n        return v + \"->\" + w + \" \" + flow + \"/\" + capacity;\n    }\n\n\n   \n    public static void main(String[] args) {\n        FlowEdge e = new FlowEdge(12, 23, 4.56);\n        StdOut.println(e);\n    }\n\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class TopM {   \n\n    private TopM() { }\n\n    \n    public static void main(String[] args) {\n        int m = Integer.parseInt(args[0]); \n        MinPQ<Transaction> pq = new MinPQ<Transaction>(m+1);\n\n        while (StdIn.hasNextLine()) {\n            String line = StdIn.readLine();\n            Transaction transaction = new Transaction(line);\n            pq.insert(transaction); \n\n            if (pq.size() > m) \n                pq.delMin();\n        }   // top m entries are on the PQ\n\n        Stack<Transaction> stack = new Stack<Transaction>();\n        for (Transaction transaction : pq)\n            stack.push(transaction);\n        for (Transaction transaction : stack)\n            StdOut.println(transaction);\n    } \n} \n\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class Interval2D {\n    private final Interval1D x;\n    private final Interval1D y;\n\n    \n    public Interval2D(Interval1D x, Interval1D y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    \n    public boolean intersects(Interval2D that) {\n        if (!this.x.intersects(that.x)) return false;\n        if (!this.y.intersects(that.y)) return false;\n        return true;\n    }\n\n    \n    public boolean contains(Point2D p) {\n        return x.contains(p.x())  && y.contains(p.y());\n    }\n\n    \n    public double area() {\n        return x.length() * y.length();\n    }\n        \n    \n    public String toString() {\n        return x + \" x \" + y;\n    }\n\n    \n    public boolean equals(Object other) {\n        if (other == this) return true;\n        if (other == null) return false;\n        if (other.getClass() != this.getClass()) return false;\n        Interval2D that = (Interval2D) other;\n        return this.x.equals(that.x) && this.y.equals(that.y);\n    }\n\n \n    \n    public int hashCode() {\n        int hash1 = x.hashCode();\n        int hash2 = y.hashCode();\n        return 31*hash1 + hash2;\n    }\n\n    \n    public void draw() {\n        double xc = (x.min() + x.max()) / 2.0;\n        double yc = (y.min() + y.max()) / 2.0;\n        StdDraw.rectangle(xc, yc, x.length() / 2.0, y.length() / 2.0);\n    }\n\n    \n    public static void main(String[] args) {\n        double xmin = Double.parseDouble(args[0]);\n        double xmax = Double.parseDouble(args[1]);\n        double ymin = Double.parseDouble(args[2]);\n        double ymax = Double.parseDouble(args[3]);\n        int trials = Integer.parseInt(args[4]);\n\n        Interval1D xInterval = new Interval1D(xmin, xmax);\n        Interval1D yInterval = new Interval1D(ymin, ymax);\n        Interval2D box = new Interval2D(xInterval, yInterval);\n        box.draw();\n\n        Counter counter = new Counter(\"hits\");\n        for (int t = 0; t < trials; t++) {\n            double x = StdRandom.uniform(0.0, 1.0);\n            double y = StdRandom.uniform(0.0, 1.0);\n            Point2D point = new Point2D(x, y);\n\n            if (box.contains(point)) counter.increment();\n            else                     point.draw();\n        }\n\n        StdOut.println(counter);\n        StdOut.printf(\"box area = %.2f\\n\", box.area());\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class SuffixArray {\n    private Suffix[] suffixes;\n\n    \n    public SuffixArray(String text) {\n        int n = text.length();\n        this.suffixes = new Suffix[n];\n        for (int i = 0; i < n; i++)\n            suffixes[i] = new Suffix(text, i);\n        Arrays.sort(suffixes);\n    }\n\n    private static class Suffix implements Comparable<Suffix> {\n        private final String text;\n        private final int index;\n\n        private Suffix(String text, int index) {\n            this.text = text;\n            this.index = index;\n        }\n        private int length() {\n            return text.length() - index;\n        }\n        private char charAt(int i) {\n            return text.charAt(index + i);\n        }\n\n        public int compareTo(Suffix that) {\n            if (this == that) return 0;  // optimization\n            int n = Math.min(this.length(), that.length());\n            for (int i = 0; i < n; i++) {\n                if (this.charAt(i) < that.charAt(i)) return -1;\n                if (this.charAt(i) > that.charAt(i)) return +1;\n            }\n            return this.length() - that.length();\n        }\n\n        public String toString() {\n            return text.substring(index);\n        }\n    }\n\n    \n    public int length() {\n        return suffixes.length;\n    }\n\n\n    \n    public int index(int i) {\n        if (i < 0 || i >= suffixes.length) throw new IllegalArgumentException();\n        return suffixes[i].index;\n    }\n\n\n    \n    public int lcp(int i) {\n        if (i < 1 || i >= suffixes.length) throw new IllegalArgumentException();\n        return lcpSuffix(suffixes[i], suffixes[i-1]);\n    }\n\n    private static int lcpSuffix(Suffix s, Suffix t) {\n        int n = Math.min(s.length(), t.length());\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != t.charAt(i)) return i;\n        }\n        return n;\n    }\n\n    \n    public String select(int i) {\n        if (i < 0 || i >= suffixes.length) throw new IllegalArgumentException();\n        return suffixes[i].toString();\n    }\n\n    \n    public int rank(String query) {\n        int lo = 0, hi = suffixes.length - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int cmp = compare(query, suffixes[mid]);\n            if (cmp < 0) hi = mid - 1;\n            else if (cmp > 0) lo = mid + 1;\n            else return mid;\n        }\n        return lo;\n    }\n\n    private static int compare(String query, Suffix suffix) {\n        int n = Math.min(query.length(), suffix.length());\n        for (int i = 0; i < n; i++) {\n            if (query.charAt(i) < suffix.charAt(i)) return -1;\n            if (query.charAt(i) > suffix.charAt(i)) return +1;\n        }\n        return query.length() - suffix.length();\n    }\n\n    \n    public static void main(String[] args) {\n        String s = StdIn.readAll().replaceAll(\"\\\\s+\", \" \").trim();\n        SuffixArray suffix = new SuffixArray(s);\n\n\n        StdOut.println(\"  i ind lcp rnk select\");\n        StdOut.println(\"---------------------------\");\n\n        for (int i = 0; i < s.length(); i++) {\n            int index = suffix.index(i);\n            String ith = \"\\\"\" + s.substring(index, Math.min(index + 50, s.length())) + \"\\\"\";\n            assert s.substring(index).equals(suffix.select(i));\n            int rank = suffix.rank(s.substring(index));\n            if (i == 0) {\n                StdOut.printf(\"%3d %3d %3s %3d %s\\n\", i, index, \"-\", rank, ith);\n            }\n            else {\n                int lcp = suffix.lcp(i);\n                StdOut.printf(\"%3d %3d %3d %3d %s\\n\", i, index, lcp, rank, ith);\n            }\n        }\n    }\n\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class LSD {\n    private static final int BITS_PER_BYTE = 8;\n\n    private LSD() { }\n\n   \n    public static void sort(String[] a, int w) {\n        int n = a.length;\n        int R = 256;   // extend ASCII alphabet size\n        String[] aux = new String[n];\n\n        for (int d = w-1; d >= 0; d--) {\n\n            int[] count = new int[R+1];\n            for (int i = 0; i < n; i++)\n                count[a[i].charAt(d) + 1]++;\n\n            for (int r = 0; r < R; r++)\n                count[r+1] += count[r];\n\n            for (int i = 0; i < n; i++)\n                aux[count[a[i].charAt(d)]++] = a[i];\n\n            for (int i = 0; i < n; i++)\n                a[i] = aux[i];\n        }\n    }\n\n   \n    public static void sort(int[] a) {\n        final int BITS = 32;                 // each int is 32 bits \n        final int R = 1 << BITS_PER_BYTE;    // each bytes is between 0 and 255\n        final int MASK = R - 1;              // 0xFF\n        final int w = BITS / BITS_PER_BYTE;  // each int is 4 bytes\n\n        int n = a.length;\n        int[] aux = new int[n];\n\n        for (int d = 0; d < w; d++) {         \n\n            int[] count = new int[R+1];\n            for (int i = 0; i < n; i++) {           \n                int c = (a[i] >> BITS_PER_BYTE*d) & MASK;\n                count[c + 1]++;\n            }\n\n            for (int r = 0; r < R; r++)\n                count[r+1] += count[r];\n\n            if (d == w-1) {\n                int shift1 = count[R] - count[R/2];\n                int shift2 = count[R/2];\n                for (int r = 0; r < R/2; r++)\n                    count[r] += shift1;\n                for (int r = R/2; r < R; r++)\n                    count[r] -= shift2;\n            }\n\n            for (int i = 0; i < n; i++) {\n                int c = (a[i] >> BITS_PER_BYTE*d) & MASK;\n                aux[count[c]++] = a[i];\n            }\n\n            for (int i = 0; i < n; i++)\n                a[i] = aux[i];\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        int n = a.length;\n\n        int w = a[0].length();\n        for (int i = 0; i < n; i++)\n            assert a[i].length() == w : \"Strings must have fixed length\";\n\n        sort(a, w);\n\n        for (int i = 0; i < n; i++)\n            StdOut.println(a[i]);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class EulerianPath {\n    private Stack<Integer> path = null;   // Eulerian path; null if no suh path\n\n    private static class Edge {\n        private final int v;\n        private final int w;\n        private boolean isUsed;\n\n        public Edge(int v, int w) {\n            this.v = v;\n            this.w = w;\n            isUsed = false;\n        }\n\n        public int other(int vertex) {\n            if      (vertex == v) return w;\n            else if (vertex == w) return v;\n            else throw new IllegalArgumentException(\"Illegal endpoint\");\n        }\n    }\n\n    \n    public EulerianPath(Graph G) {\n\n        int oddDegreeVertices = 0;\n        int s = nonIsolatedVertex(G);\n        for (int v = 0; v < G.V(); v++) {\n            if (G.degree(v) % 2 != 0) {\n                oddDegreeVertices++;\n                s = v;\n            }\n        }\n\n        if (oddDegreeVertices > 2) return;\n\n        if (s == -1) s = 0;\n\n        Queue<Edge>[] adj = (Queue<Edge>[]) new Queue[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            adj[v] = new Queue<Edge>();\n\n        for (int v = 0; v < G.V(); v++) {\n            int selfLoops = 0;\n            for (int w : G.adj(v)) {\n                if (v == w) {\n                    if (selfLoops % 2 == 0) {\n                        Edge e = new Edge(v, w);\n                        adj[v].enqueue(e);\n                        adj[w].enqueue(e);\n                    }\n                    selfLoops++;\n                }\n                else if (v < w) {\n                    Edge e = new Edge(v, w);\n                    adj[v].enqueue(e);\n                    adj[w].enqueue(e);\n                }\n            }\n        }\n\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(s);\n\n        path = new Stack<Integer>();\n        while (!stack.isEmpty()) {\n            int v = stack.pop();\n            while (!adj[v].isEmpty()) {\n                Edge edge = adj[v].dequeue();\n                if (edge.isUsed) continue;\n                edge.isUsed = true;\n                stack.push(v);\n                v = edge.other(v);\n            }\n            path.push(v);\n        }\n\n        if (path.size() != G.E() + 1)\n            path = null;\n\n        assert certifySolution(G);\n    }\n\n    \n    public Iterable<Integer> path() {\n        return path;\n    }\n\n    \n    public boolean hasEulerianPath() {\n        return path != null;\n    }\n\n\n    private static int nonIsolatedVertex(Graph G) {\n        for (int v = 0; v < G.V(); v++)\n            if (G.degree(v) > 0)\n                return v;\n        return -1;\n    }\n\n\n    \n\n    private static boolean satisfiesNecessaryAndSufficientConditions(Graph G) {\n        if (G.E() == 0) return true;\n\n        int oddDegreeVertices = 0;\n        for (int v = 0; v < G.V(); v++)\n            if (G.degree(v) % 2 != 0)\n                oddDegreeVertices++;\n        if (oddDegreeVertices > 2) return false;\n\n        int s = nonIsolatedVertex(G);\n        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\n        for (int v = 0; v < G.V(); v++)\n            if (G.degree(v) > 0 && !bfs.hasPathTo(v))\n                return false;\n\n        return true;\n    }\n\n    private boolean certifySolution(Graph G) {\n\n        if (hasEulerianPath() == (path() == null)) return false;\n\n        if (hasEulerianPath() != satisfiesNecessaryAndSufficientConditions(G)) return false;\n\n        if (path == null) return true;\n\n        if (path.size() != G.E() + 1) return false;\n\n\n        return true;\n    }\n\n\n    private static void unitTest(Graph G, String description) {\n        StdOut.println(description);\n        StdOut.println(\"-------------------------------------\");\n        StdOut.print(G);\n\n        EulerianPath euler = new EulerianPath(G);\n\n        StdOut.print(\"Eulerian path:  \");\n        if (euler.hasEulerianPath()) {\n            for (int v : euler.path()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n        else {\n            StdOut.println(\"none\");\n        }\n        StdOut.println();\n    }\n\n\n    \n    public static void main(String[] args) {\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n\n\n        Graph G1 = GraphGenerator.eulerianCycle(V, E);\n        unitTest(G1, \"Eulerian cycle\");\n\n        Graph G2 = GraphGenerator.eulerianPath(V, E);\n        unitTest(G2, \"Eulerian path\");\n\n        Graph G3 = new Graph(G2);\n        G3.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));\n        unitTest(G3, \"one random edge added to Eulerian path\");\n\n        Graph G4 = new Graph(V);\n        int v4 = StdRandom.uniform(V);\n        G4.addEdge(v4, v4);\n        unitTest(G4, \"single self loop\");\n\n        Graph G5 = new Graph(V);\n        G5.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));\n        unitTest(G5, \"single edge\");\n\n        Graph G6 = new Graph(V);\n        unitTest(G6, \"empty graph\");\n\n        Graph G7 = GraphGenerator.simple(V, E);\n        unitTest(G7, \"simple graph\");\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class RabinKarp {\n    private String pat;      // the pattern  // needed only for Las Vegas\n    private long patHash;    // pattern hash value\n    private int m;           // pattern length\n    private long q;          // a large prime, small enough to avoid long overflow\n    private int R;           // radix\n    private long RM;         // R^(M-1) % Q\n\n    \n    public RabinKarp(char[] pattern, int R) {\n        this.pat = String.valueOf(pattern);\n        this.R = R;        \n        throw new UnsupportedOperationException(\"Operation not supported yet\");\n    }\n\n    \n    public RabinKarp(String pat) {\n        this.pat = pat;      // save pattern (needed only for Las Vegas)\n        R = 256;\n        m = pat.length();\n        q = longRandomPrime();\n\n        RM = 1;\n        for (int i = 1; i <= m-1; i++)\n            RM = (R * RM) % q;\n        patHash = hash(pat, m);\n    } \n\n    private long hash(String key, int m) { \n        long h = 0; \n        for (int j = 0; j < m; j++) \n            h = (R * h + key.charAt(j)) % q;\n        return h;\n    }\n\n    private boolean check(String txt, int i) {\n        for (int j = 0; j < m; j++) \n            if (pat.charAt(j) != txt.charAt(i + j)) \n                return false; \n        return true;\n    }\n\n \n    \n    public int search(String txt) {\n        int n = txt.length(); \n        if (n < m) return n;\n        long txtHash = hash(txt, m); \n\n        if ((patHash == txtHash) && check(txt, 0))\n            return 0;\n\n        for (int i = m; i < n; i++) {\n            txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q; \n            txtHash = (txtHash*R + txt.charAt(i)) % q; \n\n            int offset = i - m + 1;\n            if ((patHash == txtHash) && check(txt, offset))\n                return offset;\n        }\n\n        return n;\n    }\n\n\n    private static long longRandomPrime() {\n        BigInteger prime = BigInteger.probablePrime(31, new Random());\n        return prime.longValue();\n    }\n\n    \n    public static void main(String[] args) {\n        String pat = args[0];\n        String txt = args[1];\n\n        RabinKarp searcher = new RabinKarp(pat);\n        int offset = searcher.search(txt);\n\n        StdOut.println(\"text:    \" + txt);\n\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset; i++)\n            StdOut.print(\" \");\n        StdOut.println(pat);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\n\npublic class CollisionSystem {\n    private static final double HZ = 0.5;    // number of redraw events per clock tick\n\n    private MinPQ<Event> pq;          // the priority queue\n    private double t  = 0.0;          // simulation clock time\n    private Particle[] particles;     // the array of particles\n\n    \n    public CollisionSystem(Particle[] particles) {\n        this.particles = particles.clone();   // defensive copy\n    }\n\n    private void predict(Particle a, double limit) {\n        if (a == null) return;\n\n        for (int i = 0; i < particles.length; i++) {\n            double dt = a.timeToHit(particles[i]);\n            if (t + dt <= limit)\n                pq.insert(new Event(t + dt, a, particles[i]));\n        }\n\n        double dtX = a.timeToHitVerticalWall();\n        double dtY = a.timeToHitHorizontalWall();\n        if (t + dtX <= limit) pq.insert(new Event(t + dtX, a, null));\n        if (t + dtY <= limit) pq.insert(new Event(t + dtY, null, a));\n    }\n\n    private void redraw(double limit) {\n        StdDraw.clear();\n        for (int i = 0; i < particles.length; i++) {\n            particles[i].draw();\n        }\n        StdDraw.show();\n        StdDraw.pause(20);\n        if (t < limit) {\n            pq.insert(new Event(t + 1.0 / HZ, null, null));\n        }\n    }\n\n      \n    \n    public void simulate(double limit) {\n        \n        pq = new MinPQ<Event>();\n        for (int i = 0; i < particles.length; i++) {\n            predict(particles[i], limit);\n        }\n        pq.insert(new Event(0, null, null));        // redraw event\n\n\n        while (!pq.isEmpty()) { \n\n            Event e = pq.delMin();\n            if (!e.isValid()) continue;\n            Particle a = e.a;\n            Particle b = e.b;\n\n            for (int i = 0; i < particles.length; i++)\n                particles[i].move(e.time - t);\n            t = e.time;\n\n            if      (a != null && b != null) a.bounceOff(b);              // particle-particle collision\n            else if (a != null && b == null) a.bounceOffVerticalWall();   // particle-wall collision\n            else if (a == null && b != null) b.bounceOffHorizontalWall(); // particle-wall collision\n            else if (a == null && b == null) redraw(limit);               // redraw event\n\n            predict(a, limit);\n            predict(b, limit);\n        }\n    }\n\n\n   \n    private static class Event implements Comparable<Event> {\n        private final double time;         // time that event is scheduled to occur\n        private final Particle a, b;       // particles involved in event, possibly null\n        private final int countA, countB;  // collision counts at event creation\n                \n        \n        public Event(double t, Particle a, Particle b) {\n            this.time = t;\n            this.a    = a;\n            this.b    = b;\n            if (a != null) countA = a.count();\n            else           countA = -1;\n            if (b != null) countB = b.count();\n            else           countB = -1;\n        }\n\n        public int compareTo(Event that) {\n            return Double.compare(this.time, that.time);\n        }\n        \n        public boolean isValid() {\n            if (a != null && a.count() != countA) return false;\n            if (b != null && b.count() != countB) return false;\n            return true;\n        }\n   \n    }\n\n\n    \n    public static void main(String[] args) {\n\n        StdDraw.setCanvasSize(600, 600);\n\n        StdDraw.enableDoubleBuffering();\n\n        Particle[] particles;\n\n        if (args.length == 1) {\n            int n = Integer.parseInt(args[0]);\n            particles = new Particle[n];\n            for (int i = 0; i < n; i++)\n                particles[i] = new Particle();\n        }\n\n        else {\n            int n = StdIn.readInt();\n            particles = new Particle[n];\n            for (int i = 0; i < n; i++) {\n                double rx     = StdIn.readDouble();\n                double ry     = StdIn.readDouble();\n                double vx     = StdIn.readDouble();\n                double vy     = StdIn.readDouble();\n                double radius = StdIn.readDouble();\n                double mass   = StdIn.readDouble();\n                int r         = StdIn.readInt();\n                int g         = StdIn.readInt();\n                int b         = StdIn.readInt();\n                Color color   = new Color(r, g, b);\n                particles[i] = new Particle(rx, ry, vx, vy, radius, mass, color);\n            }\n        }\n\n        CollisionSystem system = new CollisionSystem(particles);\n        system.simulate(10000);\n    }\n      \n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class CC {\n    private boolean[] marked;   // marked[v] = has vertex v been marked?\n    private int[] id;           // id[v] = id of connected component containing v\n    private int[] size;         // size[id] = number of vertices in given component\n    private int count;          // number of connected components\n\n    \n    public CC(Graph G) {\n        marked = new boolean[G.V()];\n        id = new int[G.V()];\n        size = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v]) {\n                dfs(G, v);\n                count++;\n            }\n        }\n    }\n\n    \n    public CC(EdgeWeightedGraph G) {\n        marked = new boolean[G.V()];\n        id = new int[G.V()];\n        size = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v]) {\n                dfs(G, v);\n                count++;\n            }\n        }\n    }\n\n    private void dfs(Graph G, int v) {\n        marked[v] = true;\n        id[v] = count;\n        size[count]++;\n        for (int w : G.adj(v)) {\n            if (!marked[w]) {\n                dfs(G, w);\n            }\n        }\n    }\n\n    private void dfs(EdgeWeightedGraph G, int v) {\n        marked[v] = true;\n        id[v] = count;\n        size[count]++;\n        for (Edge e : G.adj(v)) {\n            int w = e.other(v);\n            if (!marked[w]) {\n                dfs(G, w);\n            }\n        }\n    }\n\n\n    \n    public int id(int v) {\n        validateVertex(v);\n        return id[v];\n    }\n\n    \n    public int size(int v) {\n        validateVertex(v);\n        return size[id[v]];\n    }\n\n    \n    public int count() {\n        return count;\n    }\n\n    \n    public boolean connected(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return id(v) == id(w);\n    }\n\n    \n    @Deprecated\n    public boolean areConnected(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return id(v) == id(w);\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Graph G = new Graph(in);\n        CC cc = new CC(G);\n\n        int m = cc.count();\n        StdOut.println(m + \" components\");\n\n        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];\n        for (int i = 0; i < m; i++) {\n            components[i] = new Queue<Integer>();\n        }\n        for (int v = 0; v < G.V(); v++) {\n            components[cc.id(v)].enqueue(v);\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int v : components[i]) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class BinomialMinPQ<Key> implements Iterable<Key> {\n\tprivate Node head;    \t\t\t\t//head of the list of roots\n\tprivate final Comparator<Key> comp;\t//Comparator over the keys\n\t\n\tprivate class Node {\n\t\tKey key;\t\t\t\t\t\t//Key contained by the Node\n\t\tint order;\t\t\t\t\t\t//The order of the Binomial Tree rooted by this Node\n\t\tNode child, sibling;\t\t\t//child and sibling of this Node\n\t}\n\t\n\t\n\tpublic BinomialMinPQ() {\n\t\tcomp = new MyComparator();\n\t}\n\t\n\t\n\tpublic BinomialMinPQ(Comparator<Key> C) {\n\t\tcomp = C;\n\t}\n\t\n\t\n\tpublic BinomialMinPQ(Key[] a) {\n\t\tcomp = new MyComparator();\n\t\tfor (Key k : a) insert(k);\n\t}\n\t\n\t\n\tpublic BinomialMinPQ(Comparator<Key> C, Key[] a) {\n\t\tcomp = C;\n\t\tfor (Key k : a) insert(k);\n\t}\n\n\t\n\tpublic boolean isEmpty() {\n\t\treturn head == null;\n\t}\n\n\t\n\tpublic int size() {\n\t\tint result = 0, tmp;\n\t\tfor (Node node = head; node != null; node = node.sibling) {\n\t\t\tif (node.order > 30) { throw new ArithmeticException(\"The number of elements cannot be evaluated, but the priority queue is still valid.\"); }\n\t\t\ttmp = 1 << node.order;\n\t\t\tresult |= tmp;\n\t\t}\n\t\treturn result;\n\t}\n\n\t\n\tpublic void insert(Key key) {\n\t\tNode x = new Node();\n\t\tx.key = key;\n\t\tx.order = 0;\n\t\tBinomialMinPQ<Key> H = new BinomialMinPQ<Key>(); //The Comparator oh the H heap is not used\n\t\tH.head = x;\n\t\tthis.head = this.union(H).head;\n\t}\n\n\t\n\tpublic Key minKey() {\n\t\tif (isEmpty()) throw new NoSuchElementException(\"Priority queue is empty\");\n\t\tNode min = head;\n\t\tNode current = head;\n\t\twhile (current.sibling != null) {\n\t\t\tmin = (greater(min.key, current.sibling.key)) ? current : min;\n\t\t\tcurrent = current.sibling;\n\t\t}\n\t\treturn min.key;\n\t}\n\n\t\n\tpublic Key delMin() {\n\t\tif(isEmpty()) throw new NoSuchElementException(\"Priority queue is empty\");\n\t\tNode min = eraseMin();\n\t\tNode x = (min.child == null) ? min : min.child;\n\t\tif (min.child != null) {\n\t\t\tmin.child = null;\n\t\t\tNode prevx = null, nextx = x.sibling;\n\t\t\twhile (nextx != null) {\n\t\t\t\tx.sibling = prevx;\n\t\t\t\tprevx = x;\n\t\t\t\tx = nextx;nextx = nextx.sibling;\n\t\t\t}\n\t\t\tx.sibling = prevx;\n\t\t\tBinomialMinPQ<Key> H = new BinomialMinPQ<Key>();\n\t\t\tH.head = x;\n\t\t\thead = union(H).head;\n\t\t}\n\t\treturn min.key;\n\t}\n\t\n\t\n\tpublic BinomialMinPQ<Key> union(BinomialMinPQ<Key> heap) {\n\t\tif (heap == null) throw new IllegalArgumentException(\"Cannot merge a Binomial Heap with null\");\n\t\tthis.head = merge(new Node(), this.head, heap.head).sibling;\n\t\tNode x = this.head;\n\t\tNode prevx = null, nextx = x.sibling;\n\t\twhile (nextx != null) {\n\t\t\tif (x.order < nextx.order ||\n\t\t\t   (nextx.sibling != null && nextx.sibling.order == x.order)) {\n\t\t\t\tprevx = x; x = nextx;\n\t\t\t} else if (greater(nextx.key, x.key)) {\n\t\t\t\tx.sibling = nextx.sibling;\n\t\t\t\tlink(nextx, x);\n\t\t\t} else {\n\t\t\t\tif (prevx == null) { this.head = nextx; }\n\t\t\t\telse { prevx.sibling = nextx; }\n\t\t\t\tlink(x, nextx);\n\t\t\t\tx = nextx;\n\t\t\t}\n\t\t\tnextx = x.sibling;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t\n\t\n\tprivate boolean greater(Key n, Key m) {\n\t\tif (n == null) return false;\n\t\tif (m == null) return true;\n\t\treturn comp.compare(n, m) > 0;\n\t}\n\t\n\tprivate void link(Node root1, Node root2) {\n\t\troot1.sibling = root2.child;\n\t\troot2.child = root1;\n\t\troot2.order++;\n\t}\n\t\n\tprivate Node eraseMin() {\n\t\tNode min = head;\n\t\tNode previous = null;\n\t\tNode current = head;\n\t\twhile (current.sibling != null) {\n\t\t\tif (greater(min.key, current.sibling.key)) {\n\t\t\t\tprevious = current;\n\t\t\t\tmin = current.sibling;\n\t\t\t}\n\t\t\tcurrent = current.sibling;\n\t\t}\n\t\tprevious.sibling = min.sibling;\n\t\tif (min == head) head = min.sibling;\n\t\treturn min;\n\t}\n\t\n\t\n\t\n        private Node merge(Node h, Node x, Node y) {\n            if (x == null && y == null) return h;\n            else if (x == null) h.sibling = merge(y, null, y.sibling);\n            else if (y == null) h.sibling = merge(x, x.sibling, null);\n            else if (x.order < y.order) h.sibling = merge(x, x.sibling, y);\n            else                        h.sibling = merge(y, x, y.sibling);\n            return h;\n\t}\n\t\n\t\n\t\n\t\n\tpublic Iterator<Key> iterator() {\n\t\treturn new MyIterator();\n\t}\n\t\n\tprivate class MyIterator implements Iterator<Key> {\n\t\tBinomialMinPQ<Key> data;\n\t\t\n\t\tpublic MyIterator() {\n\t\t\tdata = new BinomialMinPQ<Key>(comp);\n\t\t\tdata.head = clone(head, null);\n\t\t}\n\t\t\n\t\tprivate Node clone(Node x, Node parent) {\n\t\t\tif (x == null) return null;\n\t\t\tNode node = new Node();\n\t\t\tnode.key = x.key;\n\t\t\tnode.sibling = clone(x.sibling, parent);\n\t\t\tnode.child = clone(x.child, node);\n\t\t\treturn node;\n\t\t}\n\t\t\n\t\tpublic boolean hasNext() {\n\t\t\treturn !data.isEmpty();\n\t\t}\n\t\t\n\t\tpublic Key next() {\n                        if (!hasNext()) throw new NoSuchElementException();\n\t\t\treturn data.delMin();\n\t\t}\n\t\t\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\t\n\t\n\t\n\tprivate class MyComparator implements Comparator<Key> {\n\t\t@Override\n\t\tpublic int compare(Key key1, Key key2) {\n\t\t\treturn ((Comparable<Key>) key1).compareTo(key2);\n\t\t}\n\t}\n\t\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\npublic class KosarajuSharirSCC {\n    private boolean[] marked;     // marked[v] = has vertex v been visited?\n    private int[] id;             // id[v] = id of strong component containing v\n    private int count;            // number of strongly-connected components\n\n    \n    public KosarajuSharirSCC(Digraph G) {\n\n        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());\n\n        marked = new boolean[G.V()];\n        id = new int[G.V()];\n        for (int v : dfs.reversePost()) {\n            if (!marked[v]) {\n                dfs(G, v);\n                count++;\n            }\n        }\n\n        assert check(G);\n    }\n\n    private void dfs(Digraph G, int v) { \n        marked[v] = true;\n        id[v] = count;\n        for (int w : G.adj(v)) {\n            if (!marked[w]) dfs(G, w);\n        }\n    }\n\n    \n    public int count() {\n        return count;\n    }\n\n    \n    public boolean stronglyConnected(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return id[v] == id[w];\n    }\n\n    \n    public int id(int v) {\n        validateVertex(v);\n        return id[v];\n    }\n\n    private boolean check(Digraph G) {\n        TransitiveClosure tc = new TransitiveClosure(G);\n        for (int v = 0; v < G.V(); v++) {\n            for (int w = 0; w < G.V(); w++) {\n                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n        KosarajuSharirSCC scc = new KosarajuSharirSCC(G);\n\n        int m = scc.count();\n        StdOut.println(m + \" strong components\");\n\n        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];\n        for (int i = 0; i < m; i++) {\n            components[i] = new Queue<Integer>();\n        }\n        for (int v = 0; v < G.V(); v++) {\n            components[scc.id(v)].enqueue(v);\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int v : components[i]) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class LZW {\n    private static final int R = 256;        // number of input chars\n    private static final int L = 4096;       // number of codewords = 2^W\n    private static final int W = 12;         // codeword width\n\n    private LZW() { }\n\n    \n    public static void compress() { \n        String input = BinaryStdIn.readString();\n        TST<Integer> st = new TST<Integer>();\n        for (int i = 0; i < R; i++)\n            st.put(\"\" + (char) i, i);\n        int code = R+1;  // R is codeword for EOF\n\n        while (input.length() > 0) {\n            String s = st.longestPrefixOf(input);  // Find max prefix match s.\n            BinaryStdOut.write(st.get(s), W);      // Print s's encoding.\n            int t = s.length();\n            if (t < input.length() && code < L)    // Add s to symbol table.\n                st.put(input.substring(0, t + 1), code++);\n            input = input.substring(t);            // Scan past s in input.\n        }\n        BinaryStdOut.write(R, W);\n        BinaryStdOut.close();\n    } \n\n    \n    public static void expand() {\n        String[] st = new String[L];\n        int i; // next available codeword value\n\n        for (i = 0; i < R; i++)\n            st[i] = \"\" + (char) i;\n        st[i++] = \"\";                        // (unused) lookahead for EOF\n\n        int codeword = BinaryStdIn.readInt(W);\n        if (codeword == R) return;           // expanded message is empty string\n        String val = st[codeword];\n\n        while (true) {\n            BinaryStdOut.write(val);\n            codeword = BinaryStdIn.readInt(W);\n            if (codeword == R) break;\n            String s = st[codeword];\n            if (i == codeword) s = val + val.charAt(0);   // special case hack\n            if (i < L) st[i++] = val + s.charAt(0);\n            val = s;\n        }\n        BinaryStdOut.close();\n    }\n\n    \n    public static void main(String[] args) {\n        if      (args[0].equals(\"-\")) compress();\n        else if (args[0].equals(\"+\")) expand();\n        else throw new IllegalArgumentException(\"Illegal command line argument\");\n    }\n\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class Heap {\n\n    private Heap() { }\n\n    \n    public static void sort(Comparable[] pq) {\n        int n = pq.length;\n        for (int k = n/2; k >= 1; k--)\n            sink(pq, k, n);\n        while (n > 1) {\n            exch(pq, 1, n--);\n            sink(pq, 1, n);\n        }\n    }\n\n   \n\n    private static void sink(Comparable[] pq, int k, int n) {\n        while (2*k <= n) {\n            int j = 2*k;\n            if (j < n && less(pq, j, j+1)) j++;\n            if (!less(pq, k, j)) break;\n            exch(pq, k, j);\n            k = j;\n        }\n    }\n\n   \n    private static boolean less(Comparable[] pq, int i, int j) {\n        return pq[i-1].compareTo(pq[j-1]) < 0;\n    }\n\n    private static void exch(Object[] pq, int i, int j) {\n        Object swap = pq[i-1];\n        pq[i-1] = pq[j-1];\n        pq[j-1] = swap;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        Heap.sort(a);\n        show(a);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class TopologicalX {\n    private Queue<Integer> order;     // vertices in topological order\n    private int[] ranks;              // ranks[v] = order where vertex v appers in order\n\n    \n    public TopologicalX(Digraph G) {\n\n        int[] indegree = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            indegree[v] = G.indegree(v);\n        }\n\n        ranks = new int[G.V()]; \n        order = new Queue<Integer>();\n        int count = 0;\n\n        Queue<Integer> queue = new Queue<Integer>();\n        for (int v = 0; v < G.V(); v++)\n            if (indegree[v] == 0) queue.enqueue(v);\n\n        while (!queue.isEmpty()) {\n            int v = queue.dequeue();\n            order.enqueue(v);\n            ranks[v] = count++;\n            for (int w : G.adj(v)) {\n                indegree[w]--;\n                if (indegree[w] == 0) queue.enqueue(w);\n            }\n        }\n\n        if (count != G.V()) {\n            order = null;\n        }\n\n        assert check(G);\n    }\n\n    \n    public TopologicalX(EdgeWeightedDigraph G) {\n\n        int[] indegree = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            indegree[v] = G.indegree(v);\n        }\n\n        ranks = new int[G.V()]; \n        order = new Queue<Integer>();\n        int count = 0;\n\n        Queue<Integer> queue = new Queue<Integer>();\n        for (int v = 0; v < G.V(); v++)\n            if (indegree[v] == 0) queue.enqueue(v);\n\n        while (!queue.isEmpty()) {\n            int v = queue.dequeue();\n            order.enqueue(v);\n            ranks[v] = count++;\n            for (DirectedEdge e : G.adj(v)) {\n                int w = e.to();\n                indegree[w]--;\n                if (indegree[w] == 0) queue.enqueue(w);\n            }\n        }\n\n        if (count != G.V()) {\n            order = null;\n        }\n\n        assert check(G);\n    }\n\n    \n    public Iterable<Integer> order() {\n        return order;\n    }\n\n    \n    public boolean hasOrder() {\n        return order != null;\n    }\n\n    \n    public int rank(int v) {\n        validateVertex(v);\n        if (hasOrder()) return ranks[v];\n        else            return -1;\n    }\n\n    private boolean check(Digraph G) {\n\n        if (hasOrder()) {\n            boolean[] found = new boolean[G.V()];\n            for (int i = 0; i < G.V(); i++) {\n                found[rank(i)] = true;\n            }\n            for (int i = 0; i < G.V(); i++) {\n                if (!found[i]) {\n                    System.err.println(\"No vertex with rank \" + i);\n                    return false;\n                }\n            }\n\n            for (int v = 0; v < G.V(); v++) {\n                for (int w : G.adj(v)) {\n                    if (rank(v) > rank(w)) {\n                        System.err.printf(\"%d-%d: rank(%d) = %d, rank(%d) = %d\\n\",\n                                          v, w, v, rank(v), w, rank(w));\n                        return false;\n                    }\n                }\n            }\n\n            int r = 0;\n            for (int v : order()) {\n                if (rank(v) != r) {\n                    System.err.println(\"order() and rank() inconsistent\");\n                    return false;\n                }\n                r++;\n            }\n        }\n\n\n        return true;\n    }\n\n    private boolean check(EdgeWeightedDigraph G) {\n\n        if (hasOrder()) {\n            boolean[] found = new boolean[G.V()];\n            for (int i = 0; i < G.V(); i++) {\n                found[rank(i)] = true;\n            }\n            for (int i = 0; i < G.V(); i++) {\n                if (!found[i]) {\n                    System.err.println(\"No vertex with rank \" + i);\n                    return false;\n                }\n            }\n\n            for (int v = 0; v < G.V(); v++) {\n                for (DirectedEdge e : G.adj(v)) {\n                    int w = e.to();\n                    if (rank(v) > rank(w)) {\n                        System.err.printf(\"%d-%d: rank(%d) = %d, rank(%d) = %d\\n\",\n                                          v, w, v, rank(v), w, rank(w));\n                        return false;\n                    }\n                }\n            }\n\n            int r = 0;\n            for (int v : order()) {\n                if (rank(v) != r) {\n                    System.err.println(\"order() and rank() inconsistent\");\n                    return false;\n                }\n                r++;\n            }\n        }\n\n\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = ranks.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n        int F = Integer.parseInt(args[2]);\n\n        Digraph G1 = DigraphGenerator.dag(V, E);\n\n        EdgeWeightedDigraph G2 = new EdgeWeightedDigraph(V);\n        for (int v = 0; v < G1.V(); v++)\n            for (int w : G1.adj(v))\n                G2.addEdge(new DirectedEdge(v, w, 0.0));\n\n        for (int i = 0; i < F; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            G1.addEdge(v, w);\n            G2.addEdge(new DirectedEdge(v, w, 0.0));\n        }\n\n        StdOut.println(G1);\n        StdOut.println();\n        StdOut.println(G2);\n\n        TopologicalX topological1 = new TopologicalX(G1);\n        if (!topological1.hasOrder()) {\n            StdOut.println(\"Not a DAG\");\n        }\n\n        else {\n            StdOut.print(\"Topological order: \");\n            for (int v : topological1.order()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n\n        TopologicalX topological2 = new TopologicalX(G2);\n        if (!topological2.hasOrder()) {\n            StdOut.println(\"Not a DAG\");\n        }\n\n        else {\n            StdOut.print(\"Topological order: \");\n            for (int v : topological2.order()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class DoublingTest {\n    private static final int MAXIMUM_INTEGER = 1000000;\n\n    private DoublingTest() { }\n\n    \n    public static double timeTrial(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = StdRandom.uniform(-MAXIMUM_INTEGER, MAXIMUM_INTEGER);\n        }\n        Stopwatch timer = new Stopwatch();\n        ThreeSum.count(a);\n        return timer.elapsedTime();\n    }\n\n    \n    public static void main(String[] args) { \n        for (int n = 250; true; n += n) {\n            double time = timeTrial(n);\n            StdOut.printf(\"%7d %7.1f\\n\", n, time);\n        } \n    } \n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class DirectedEdge { \n    private final int v;\n    private final int w;\n    private final double weight;\n\n    \n    public DirectedEdge(int v, int w, double weight) {\n        if (v < 0) throw new IllegalArgumentException(\"Vertex names must be nonnegative integers\");\n        if (w < 0) throw new IllegalArgumentException(\"Vertex names must be nonnegative integers\");\n        if (Double.isNaN(weight)) throw new IllegalArgumentException(\"Weight is NaN\");\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n\n    \n    public int from() {\n        return v;\n    }\n\n    \n    public int to() {\n        return w;\n    }\n\n    \n    public double weight() {\n        return weight;\n    }\n\n    \n    public String toString() {\n        return v + \"->\" + w + \" \" + String.format(\"%5.2f\", weight);\n    }\n\n    \n    public static void main(String[] args) {\n        DirectedEdge e = new DirectedEdge(12, 34, 5.67);\n        StdOut.println(e);\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class Accumulator {\n    private int n = 0;          // number of data values\n    private double sum = 0.0;   // sample variance * (n-1)\n    private double mu = 0.0;    // sample mean\n\n    \n    public Accumulator() {\n    }\n\n    \n    public void addDataValue(double x) {\n        n++;\n        double delta = x - mu;\n        mu  += delta / n;\n        sum += (double) (n - 1) / n * delta * delta;\n    }\n\n    \n    public double mean() {\n        return mu;\n    }\n\n    \n    public double var() {\n        if (n <= 1) return Double.NaN;\n        return sum / (n - 1);\n    }\n\n    \n    public double stddev() {\n        return Math.sqrt(this.var());\n    }\n\n    \n    public int count() {\n        return n;\n    }\n\n    \n    public String toString() {\n        return \"n = \" + n + \", mean = \" + mean() + \", stddev = \" + stddev();\n    }\n\n    \n    public static void main(String[] args) {\n        Accumulator stats = new Accumulator();\n        while (!StdIn.isEmpty()) {\n            double x = StdIn.readDouble();\n            stats.addDataValue(x);\n        }\n\n        StdOut.printf(\"n      = %d\\n\",   stats.count());\n        StdOut.printf(\"mean   = %.5f\\n\", stats.mean());\n        StdOut.printf(\"stddev = %.5f\\n\", stats.stddev());\n        StdOut.printf(\"var    = %.5f\\n\", stats.var());\n        StdOut.println(stats);\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class DepthFirstSearch {\n    private boolean[] marked;    // marked[v] = is there an s-v path?\n    private int count;           // number of vertices connected to s\n\n    \n    public DepthFirstSearch(Graph G, int s) {\n        marked = new boolean[G.V()];\n        validateVertex(s);\n        dfs(G, s);\n    }\n\n    private void dfs(Graph G, int v) {\n        count++;\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w]) {\n                dfs(G, w);\n            }\n        }\n    }\n\n    \n    public boolean marked(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    \n    public int count() {\n        return count;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Graph G = new Graph(in);\n        int s = Integer.parseInt(args[1]);\n        DepthFirstSearch search = new DepthFirstSearch(G, s);\n        for (int v = 0; v < G.V(); v++) {\n            if (search.marked(v))\n                StdOut.print(v + \" \");\n        }\n\n        StdOut.println();\n        if (search.count() != G.V()) StdOut.println(\"NOT connected\");\n        else                         StdOut.println(\"connected\");\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class CPM {\n\n    private CPM() { }\n\n    \n    public static void main(String[] args) {\n\n        int n = StdIn.readInt();\n\n        int source = 2*n;\n        int sink   = 2*n + 1;\n\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(2*n + 2);\n        for (int i = 0; i < n; i++) {\n            double duration = StdIn.readDouble();\n            G.addEdge(new DirectedEdge(source, i, 0.0));\n            G.addEdge(new DirectedEdge(i+n, sink, 0.0));\n            G.addEdge(new DirectedEdge(i, i+n,    duration));\n\n            int m = StdIn.readInt();\n            for (int j = 0; j < m; j++) {\n                int precedent = StdIn.readInt();\n                G.addEdge(new DirectedEdge(n+i, precedent, 0.0));\n            }\n        }\n\n        AcyclicLP lp = new AcyclicLP(G, source);\n\n        StdOut.println(\" job   start  finish\");\n        StdOut.println(\"--------------------\");\n        for (int i = 0; i < n; i++) {\n            StdOut.printf(\"%4d %7.1f %7.1f\\n\", i, lp.distTo(i), lp.distTo(i+n));\n        }\n        StdOut.printf(\"Finish time: %7.1f\\n\", lp.distTo(sink));\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class Graph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;\n    private int E;\n    private Bag<Integer>[] adj;\n    \n    \n    public Graph(int V) {\n        if (V < 0) throw new IllegalArgumentException(\"Number of vertices must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        adj = (Bag<Integer>[]) new Bag[V];\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<Integer>();\n        }\n    }\n\n    \n    public Graph(In in) {\n        try {\n            this.V = in.readInt();\n            if (V < 0) throw new IllegalArgumentException(\"number of vertices in a Graph must be nonnegative\");\n            adj = (Bag<Integer>[]) new Bag[V];\n            for (int v = 0; v < V; v++) {\n                adj[v] = new Bag<Integer>();\n            }\n            int E = in.readInt();\n            if (E < 0) throw new IllegalArgumentException(\"number of edges in a Graph must be nonnegative\");\n            for (int i = 0; i < E; i++) {\n                int v = in.readInt();\n                int w = in.readInt();\n                validateVertex(v);\n                validateVertex(w);\n                addEdge(v, w); \n            }\n        }\n        catch (NoSuchElementException e) {\n            throw new IllegalArgumentException(\"invalid input format in Graph constructor\", e);\n        }\n    }\n\n\n    \n    public Graph(Graph G) {\n        this(G.V());\n        this.E = G.E();\n        for (int v = 0; v < G.V(); v++) {\n            Stack<Integer> reverse = new Stack<Integer>();\n            for (int w : G.adj[v]) {\n                reverse.push(w);\n            }\n            for (int w : reverse) {\n                adj[v].add(w);\n            }\n        }\n    }\n\n    \n    public int V() {\n        return V;\n    }\n\n    \n    public int E() {\n        return E;\n    }\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public void addEdge(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        E++;\n        adj[v].add(w);\n        adj[w].add(v);\n    }\n\n\n    \n    public Iterable<Integer> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    \n    public int degree(int v) {\n        validateVertex(v);\n        return adj[v].size();\n    }\n\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" vertices, \" + E + \" edges \" + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(v + \": \");\n            for (int w : adj[v]) {\n                s.append(w + \" \");\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Graph G = new Graph(in);\n        StdOut.println(G);\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Quick3way {\n\n    private Quick3way() { }\n\n    \n    public static void sort(Comparable[] a) {\n        StdRandom.shuffle(a);\n        sort(a, 0, a.length - 1);\n        assert isSorted(a);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) { \n        if (hi <= lo) return;\n        int lt = lo, gt = hi;\n        Comparable v = a[lo];\n        int i = lo + 1;\n        while (i <= gt) {\n            int cmp = a[i].compareTo(v);\n            if      (cmp < 0) exch(a, lt++, i++);\n            else if (cmp > 0) exch(a, i, gt--);\n            else              i++;\n        }\n\n        sort(a, lo, lt-1);\n        sort(a, gt+1, hi);\n        assert isSorted(a, lo, hi);\n    }\n\n\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n        \n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        Quick3way.sort(a);\n        show(a);\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\n\n\npublic class Stack<Item> implements Iterable<Item> {\n    private Node<Item> first;     // top of stack\n    private int n;                // size of the stack\n\n    private static class Node<Item> {\n        private Item item;\n        private Node<Item> next;\n    }\n\n    \n    public Stack() {\n        first = null;\n        n = 0;\n    }\n\n    \n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public void push(Item item) {\n        Node<Item> oldfirst = first;\n        first = new Node<Item>();\n        first.item = item;\n        first.next = oldfirst;\n        n++;\n    }\n\n    \n    public Item pop() {\n        if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\");\n        Item item = first.item;        // save item to return\n        first = first.next;            // delete first node\n        n--;\n        return item;                   // return the saved item\n    }\n\n\n    \n    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\");\n        return first.item;\n    }\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this) {\n            s.append(item);\n            s.append(' ');\n        }\n        return s.toString();\n    }\n       \n\n    \n    public Iterator<Item> iterator() {\n        return new ListIterator(first);\n    }\n\n    private class ListIterator implements Iterator<Item> {\n        private Node<Item> current;\n\n        public ListIterator(Node<Item> first) {\n            current = first;\n        }\n\n        public boolean hasNext() {\n            return current != null;\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = current.item;\n            current = current.next; \n            return item;\n        }\n    }\n\n\n    \n    public static void main(String[] args) {\n        Stack<String> stack = new Stack<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\"))\n                stack.push(item);\n            else if (!stack.isEmpty())\n                StdOut.print(stack.pop() + \" \");\n        }\n        StdOut.println(\"(\" + stack.size() + \" left on stack)\");\n    }\n}\n\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class Multiway { \n\n    private Multiway() { }\n\n    private static void merge(In[] streams) {\n        int n = streams.length;\n        IndexMinPQ<String> pq = new IndexMinPQ<String>(n);\n        for (int i = 0; i < n; i++)\n            if (!streams[i].isEmpty())\n                pq.insert(i, streams[i].readString());\n\n        while (!pq.isEmpty()) {\n            StdOut.print(pq.minKey() + \" \");\n            int i = pq.delMin();\n            if (!streams[i].isEmpty())\n                pq.insert(i, streams[i].readString());\n        }\n        StdOut.println();\n    }\n\n\n    \n    public static void main(String[] args) {\n        int n = args.length;\n        In[] streams = new In[n];\n        for (int i = 0; i < n; i++)\n            streams[i] = new In(args[i]);\n        merge(streams);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\n\npublic class BipartiteX {\n    private static final boolean WHITE = false;\n    private static final boolean BLACK = true;\n\n    private boolean isBipartite;   // is the graph bipartite?\n    private boolean[] color;       // color[v] gives vertices on one side of bipartition\n    private boolean[] marked;      // marked[v] = true iff v has been visited in DFS\n    private int[] edgeTo;          // edgeTo[v] = last edge on path to v\n    private Queue<Integer> cycle;  // odd-length cycle\n\n    \n    public BipartiteX(Graph G) {\n        isBipartite = true;\n        color  = new boolean[G.V()];\n        marked = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n\n        for (int v = 0; v < G.V() && isBipartite; v++) {\n            if (!marked[v]) {\n                bfs(G, v);\n            }\n        }\n        assert check(G);\n    }\n\n    private void bfs(Graph G, int s) { \n        Queue<Integer> q = new Queue<Integer>();\n        color[s] = WHITE;\n        marked[s] = true;\n        q.enqueue(s);\n\n        while (!q.isEmpty()) {\n            int v = q.dequeue();\n            for (int w : G.adj(v)) {\n                if (!marked[w]) {\n                    marked[w] = true;\n                    edgeTo[w] = v;\n                    color[w] = !color[v];\n                    q.enqueue(w);\n                }\n                else if (color[w] == color[v]) {\n                    isBipartite = false;\n\n                    cycle = new Queue<Integer>();\n                    Stack<Integer> stack = new Stack<Integer>();\n                    int x = v, y = w;\n                    while (x != y) {\n                        stack.push(x);\n                        cycle.enqueue(y);\n                        x = edgeTo[x];\n                        y = edgeTo[y];\n                    }\n                    stack.push(x);\n                    while (!stack.isEmpty())\n                        cycle.enqueue(stack.pop());\n                    cycle.enqueue(w);\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    public boolean isBipartite() {\n        return isBipartite;\n    }\n \n    \n    public boolean color(int v) {\n        validateVertex(v);\n        if (!isBipartite)\n            throw new UnsupportedOperationException(\"Graph is not bipartite\");\n        return color[v];\n    }\n\n\n    \n    public Iterable<Integer> oddCycle() {\n        return cycle; \n    }\n\n    private boolean check(Graph G) {\n        if (isBipartite) {\n            for (int v = 0; v < G.V(); v++) {\n                for (int w : G.adj(v)) {\n                    if (color[v] == color[w]) {\n                        System.err.printf(\"edge %d-%d with %d and %d in same side of bipartition\\n\", v, w, v, w);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        else {\n            int first = -1, last = -1;\n            for (int v : oddCycle()) {\n                if (first == -1) first = v;\n                last = v;\n            }\n            if (first != last) {\n                System.err.printf(\"cycle begins with %d and ends with %d\\n\", first, last);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        int V1 = Integer.parseInt(args[0]);\n        int V2 = Integer.parseInt(args[1]);\n        int E  = Integer.parseInt(args[2]);\n        int F  = Integer.parseInt(args[3]);\n\n        Graph G = GraphGenerator.bipartite(V1, V2, E);\n        for (int i = 0; i < F; i++) {\n            int v = StdRandom.uniform(V1 + V2);\n            int w = StdRandom.uniform(V1 + V2);\n            G.addEdge(v, w);\n        }\n\n        StdOut.println(G);\n\n\n        BipartiteX b = new BipartiteX(G);\n        if (b.isBipartite()) {\n            StdOut.println(\"Graph is bipartite\");\n            for (int v = 0; v < G.V(); v++) {\n                StdOut.println(v + \": \" + b.color(v));\n            }\n        }\n        else {\n            StdOut.print(\"Graph has an odd-length cycle: \");\n            for (int x : b.oddCycle()) {\n                StdOut.print(x + \" \");\n            }\n            StdOut.println();\n        }\n    }\n\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class InsertionX {\n\n    private InsertionX() { }\n\n    \n    public static void sort(Comparable[] a) {\n        int n = a.length;\n\n        int exchanges = 0;\n        for (int i = n-1; i > 0; i--) {\n            if (less(a[i], a[i-1])) {\n                exch(a, i, i-1);\n                exchanges++;\n            }\n        }\n        if (exchanges == 0) return;\n\n\n        for (int i = 2; i < n; i++) {\n            Comparable v = a[i];\n            int j = i;\n            while (less(v, a[j-1])) {\n                a[j] = a[j-1];\n                j--;\n            }\n            a[j] = v;\n        }\n\n        assert isSorted(a);\n    }\n\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n        \n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 1; i < a.length; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        InsertionX.sort(a);\n        show(a);\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\n\npublic class Transaction implements Comparable<Transaction> {\n    private final String  who;      // customer\n    private final Date    when;     // date\n    private final double  amount;   // amount\n\n\n    \n    public Transaction(String who, Date when, double amount) {\n        if (Double.isNaN(amount) || Double.isInfinite(amount))\n            throw new IllegalArgumentException(\"Amount cannot be NaN or infinite\");\n        this.who    = who;\n        this.when   = when;\n        this.amount = amount;\n    }\n\n    \n    public Transaction(String transaction) {\n        String[] a = transaction.split(\"\\\\s+\");\n        who    = a[0];\n        when   = new Date(a[1]);\n        amount = Double.parseDouble(a[2]);\n        if (Double.isNaN(amount) || Double.isInfinite(amount))\n            throw new IllegalArgumentException(\"Amount cannot be NaN or infinite\");\n    }\n\n    \n    public String who() {\n        return who;\n    }\n \n    \n    public Date when() {\n        return when;\n    }\n \n    \n    public double amount() {\n        return amount;\n    }\n\n    \n    @Override\n    public String toString() {\n        return String.format(\"%-10s %10s %8.2f\", who, when, amount);\n    }\n\n    \n    public int compareTo(Transaction that) {\n        return Double.compare(this.amount, that.amount);\n    }    \n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (other == this) return true;\n        if (other == null) return false;\n        if (other.getClass() != this.getClass()) return false;\n        Transaction that = (Transaction) other;\n        return (this.amount == that.amount) && (this.who.equals(that.who))\n                                            && (this.when.equals(that.when));\n    }\n\n\n    \n    public int hashCode() {\n        int hash = 1;\n        hash = 31*hash + who.hashCode();\n        hash = 31*hash + when.hashCode();\n        hash = 31*hash + ((Double) amount).hashCode();\n        return hash;\n    }\n\n    \n    public static class WhoOrder implements Comparator<Transaction> {\n\n        @Override\n        public int compare(Transaction v, Transaction w) {\n            return v.who.compareTo(w.who);\n        }\n    }\n\n    \n    public static class WhenOrder implements Comparator<Transaction> {\n\n        @Override\n        public int compare(Transaction v, Transaction w) {\n            return v.when.compareTo(w.when);\n        }\n    }\n\n    \n    public static class HowMuchOrder implements Comparator<Transaction> {\n\n        @Override\n        public int compare(Transaction v, Transaction w) {\n            return Double.compare(v.amount, w.amount);\n        }\n    }\n\n\n    \n    public static void main(String[] args) {\n        Transaction[] a = new Transaction[4];\n        a[0] = new Transaction(\"Turing   6/17/1990  644.08\");\n        a[1] = new Transaction(\"Tarjan   3/26/2002 4121.85\");\n        a[2] = new Transaction(\"Knuth    6/14/1999  288.34\");\n        a[3] = new Transaction(\"Dijkstra 8/22/2007 2678.40\");\n\n        StdOut.println(\"Unsorted\");\n        for (int i = 0; i < a.length; i++)\n            StdOut.println(a[i]);\n        StdOut.println();\n        \n        StdOut.println(\"Sort by date\");\n        Arrays.sort(a, new Transaction.WhenOrder());\n        for (int i = 0; i < a.length; i++)\n            StdOut.println(a[i]);\n        StdOut.println();\n\n        StdOut.println(\"Sort by customer\");\n        Arrays.sort(a, new Transaction.WhoOrder());\n        for (int i = 0; i < a.length; i++)\n            StdOut.println(a[i]);\n        StdOut.println();\n\n        StdOut.println(\"Sort by amount\");\n        Arrays.sort(a, new Transaction.HowMuchOrder());\n        for (int i = 0; i < a.length; i++)\n            StdOut.println(a[i]);\n        StdOut.println();\n    }\n\n}\n\n\n\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class AssignmentProblem {\n    private static final double FLOATING_POINT_EPSILON = 1E-14;\n    private static final int UNMATCHED = -1;\n\n    private int n;              // number of rows and columns\n    private double[][] weight;  // the n-by-n cost matrix\n    private double minWeight;   // minimum value of any weight\n    private double[] px;        // px[i] = dual variable for row i\n    private double[] py;        // py[j] = dual variable for col j\n    private int[] xy;           // xy[i] = j means i-j is a match\n    private int[] yx;           // yx[j] = i means i-j is a match\n\n     \n    public AssignmentProblem(double[][] weight) {\n        if (weight == null) throw new IllegalArgumentException(\"constructor argument is null\");\n\n        n = weight.length;\n        this.weight = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (Double.isNaN(weight[i][j]))\n                    throw new IllegalArgumentException(\"weight \" + i + \"-\" + j  + \" is NaN\");\n                if (weight[i][j] < minWeight) minWeight = weight[i][j];\n                this.weight[i][j] = weight[i][j];\n            }\n        }\n\n        px = new double[n];\n        py = new double[n];\n\n        xy = new int[n];\n        yx = new int[n];\n        for (int i = 0; i < n; i++)\n             xy[i] = UNMATCHED;\n        for (int j = 0; j < n; j++)\n             yx[j] = UNMATCHED;\n\n        for (int k = 0; k < n; k++) {\n            assert isDualFeasible();\n            assert isComplementarySlack();\n            augment();\n        }\n        assert certifySolution();\n    }\n\n    private void augment() {\n\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(2*n+2);\n        int s = 2*n, t = 2*n+1;\n        for (int i = 0; i < n; i++) {\n            if (xy[i] == UNMATCHED)\n                G.addEdge(new DirectedEdge(s, i, 0.0));\n        }\n        for (int j = 0; j < n; j++) {\n            if (yx[j] == UNMATCHED)\n                G.addEdge(new DirectedEdge(n+j, t, py[j]));\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (xy[i] == j) G.addEdge(new DirectedEdge(n+j, i, 0.0));\n                else            G.addEdge(new DirectedEdge(i, n+j, reducedCost(i, j)));\n            }\n        }\n\n        DijkstraSP spt = new DijkstraSP(G, s);\n\n        for (DirectedEdge e : spt.pathTo(t)) {\n            int i = e.from(), j = e.to() - n;\n            if (i < n) {\n                xy[i] = j;\n                yx[j] = i;\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n            px[i] += spt.distTo(i);\n        for (int j = 0; j < n; j++)\n            py[j] += spt.distTo(n+j);\n    }\n\n    private double reducedCost(int i, int j) {\n        double reducedCost = (weight[i][j] - minWeight) + px[i] - py[j];\n\n        double magnitude = Math.abs(weight[i][j]) + Math.abs(px[i]) + Math.abs(py[j]);\n        if (Math.abs(reducedCost) <= FLOATING_POINT_EPSILON * magnitude) return 0.0;\n\n        assert reducedCost >= 0.0;\n        return reducedCost;\n    }\n\n    \n    public double dualRow(int i) {\n        validate(i);\n        return px[i];\n    }\n\n    \n    public double dualCol(int j) {\n        validate(j);\n        return py[j];\n    }\n\n    \n    public int sol(int i) {\n        validate(i);\n        return xy[i];\n    }\n\n    \n    public double weight() {\n        double total = 0.0;\n        for (int i = 0; i < n; i++) {\n            if (xy[i] != UNMATCHED)\n                total += weight[i][xy[i]];\n        }\n        return total;\n    }\n\n    private void validate(int i) {\n        if (i < 0 || i >= n) throw new IllegalArgumentException(\"index is not between 0 and \" + (n-1) + \": \" + i);\n    }\n\n\n    \n\n    private boolean isDualFeasible() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (reducedCost(i, j) < 0) {\n                    StdOut.println(\"Dual variables are not feasible\");\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private boolean isComplementarySlack() {\n\n        for (int i = 0; i < n; i++) {\n            if ((xy[i] != UNMATCHED) && (reducedCost(i, xy[i]) != 0)) {\n                StdOut.println(\"Primal and dual variables are not complementary slack\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isPerfectMatching() {\n\n        boolean[] perm = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (perm[xy[i]]) {\n                StdOut.println(\"Not a perfect matching\");\n                return false;\n            }\n            perm[xy[i]] = true;\n        }\n\n        for (int j = 0; j < n; j++) {\n            if (xy[yx[j]] != j) {\n                StdOut.println(\"xy[] and yx[] are not inverses\");\n                return false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (yx[xy[i]] != i) {\n                StdOut.println(\"xy[] and yx[] are not inverses\");\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private boolean certifySolution() {\n        return isPerfectMatching() && isDualFeasible() && isComplementarySlack();\n    }\n\n    \n    public static void main(String[] args) {\n\n        int n = Integer.parseInt(args[0]);\n        double[][] weight = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                weight[i][j] = StdRandom.uniform(900) + 100;  // 3 digits\n            }\n        }\n\n        AssignmentProblem assignment = new AssignmentProblem(weight);\n        StdOut.printf(\"weight = %.0f\\n\", assignment.weight());\n        StdOut.println();\n\n        if (n >= 20) return;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (j == assignment.sol(i))\n                    StdOut.printf(\"*%.0f \", weight[i][j]);\n                else\n                    StdOut.printf(\" %.0f \", weight[i][j]);\n            }\n            StdOut.println();\n        }\n    }\n\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class Merge {\n\n    private Merge() { }\n\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n        assert isSorted(a, lo, mid);\n        assert isSorted(a, mid+1, hi);\n\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k]; \n        }\n\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)              a[k] = aux[j++];\n            else if (j > hi)               a[k] = aux[i++];\n            else if (less(aux[j], aux[i])) a[k] = aux[j++];\n            else                           a[k] = aux[i++];\n        }\n\n        assert isSorted(a, lo, hi);\n    }\n\n    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\n        if (hi <= lo) return;\n        int mid = lo + (hi - lo) / 2;\n        sort(a, aux, lo, mid);\n        sort(a, aux, mid + 1, hi);\n        merge(a, aux, lo, mid, hi);\n    }\n\n    \n    public static void sort(Comparable[] a) {\n        Comparable[] aux = new Comparable[a.length];\n        sort(a, aux, 0, a.length-1);\n        assert isSorted(a);\n    }\n\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n        \n   \n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n\n   \n    private static void merge(Comparable[] a, int[] index, int[] aux, int lo, int mid, int hi) {\n\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = index[k]; \n        }\n\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)                    index[k] = aux[j++];\n            else if (j > hi)                     index[k] = aux[i++];\n            else if (less(a[aux[j]], a[aux[i]])) index[k] = aux[j++];\n            else                                 index[k] = aux[i++];\n        }\n    }\n\n    \n    public static int[] indexSort(Comparable[] a) {\n        int n = a.length;\n        int[] index = new int[n];\n        for (int i = 0; i < n; i++)\n            index[i] = i;\n\n        int[] aux = new int[n];\n        sort(a, index, aux, 0, n-1);\n        return index;\n    }\n\n    private static void sort(Comparable[] a, int[] index, int[] aux, int lo, int hi) {\n        if (hi <= lo) return;\n        int mid = lo + (hi - lo) / 2;\n        sort(a, index, aux, lo, mid);\n        sort(a, index, aux, mid + 1, hi);\n        merge(a, index, aux, lo, mid, hi);\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        Merge.sort(a);\n        show(a);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class SymbolGraph {\n    private ST<String, Integer> st;  // string -> index\n    private String[] keys;           // index  -> string\n    private Graph graph;             // the underlying graph\n\n    \n    public SymbolGraph(String filename, String delimiter) {\n        st = new ST<String, Integer>();\n\n        In in = new In(filename);\n        while (!in.isEmpty()) {\n            String[] a = in.readLine().split(delimiter);\n            for (int i = 0; i < a.length; i++) {\n                if (!st.contains(a[i]))\n                    st.put(a[i], st.size());\n            }\n        }\n\n        keys = new String[st.size()];\n        for (String name : st.keys()) {\n            keys[st.get(name)] = name;\n        }\n\n        graph = new Graph(st.size());\n        in = new In(filename);\n        while (in.hasNextLine()) {\n            String[] a = in.readLine().split(delimiter);\n            int v = st.get(a[0]);\n            for (int i = 1; i < a.length; i++) {\n                int w = st.get(a[i]);\n                graph.addEdge(v, w);\n            }\n        }\n    }\n\n    \n    public boolean contains(String s) {\n        return st.contains(s);\n    }\n\n    \n    @Deprecated\n    public int index(String s) {\n        return st.get(s);\n    }\n\n\n    \n    public int indexOf(String s) {\n        return st.get(s);\n    }\n\n    \n    @Deprecated\n    public String name(int v) {\n        validateVertex(v);\n        return keys[v];\n    }\n\n    \n    public String nameOf(int v) {\n        validateVertex(v);\n        return keys[v];\n    }\n\n    \n    @Deprecated\n    public Graph G() {\n        return graph;\n    }\n\n    \n    public Graph graph() {\n        return graph;\n    }\n\n    private void validateVertex(int v) {\n        int V = graph.V();\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n\n    \n    public static void main(String[] args) {\n        String filename  = args[0];\n        String delimiter = args[1];\n        SymbolGraph sg = new SymbolGraph(filename, delimiter);\n        Graph graph = sg.graph();\n        while (StdIn.hasNextLine()) {\n            String source = StdIn.readLine();\n            if (sg.contains(source)) {\n                int s = sg.index(source);\n                for (int v : graph.adj(s)) {\n                    StdOut.println(\"   \" + sg.name(v));\n                }\n            }\n            else {\n                StdOut.println(\"input not contain '\" + source + \"'\");\n            }\n        }\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class BlackFilter {  \n\n    private BlackFilter() { }\n\n    public static void main(String[] args) {\n        SET<String> set = new SET<String>();\n\n        In in = new In(args[0]);\n        while (!in.isEmpty()) {\n            String word = in.readString();\n            set.add(word);\n        }\n\n        while (!StdIn.isEmpty()) {\n            String word = StdIn.readString();\n            if (!set.contains(word))\n                StdOut.println(word);\n        }\n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class AcyclicSP {\n    private double[] distTo;         // distTo[v] = distance  of shortest s->v path\n    private DirectedEdge[] edgeTo;   // edgeTo[v] = last edge on shortest s->v path\n\n\n    \n    public AcyclicSP(EdgeWeightedDigraph G, int s) {\n        distTo = new double[G.V()];\n        edgeTo = new DirectedEdge[G.V()];\n\n        validateVertex(s);\n\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = Double.POSITIVE_INFINITY;\n        distTo[s] = 0.0;\n\n        Topological topological = new Topological(G);\n        if (!topological.hasOrder())\n            throw new IllegalArgumentException(\"Digraph is not acyclic.\");\n        for (int v : topological.order()) {\n            for (DirectedEdge e : G.adj(v))\n                relax(e);\n        }\n    }\n\n    private void relax(DirectedEdge e) {\n        int v = e.from(), w = e.to();\n        if (distTo[w] > distTo[v] + e.weight()) {\n            distTo[w] = distTo[v] + e.weight();\n            edgeTo[w] = e;\n        }       \n    }\n\n    \n    public double distTo(int v) {\n        validateVertex(v);\n        return distTo[v];\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return distTo[v] < Double.POSITIVE_INFINITY;\n    }\n\n    \n    public Iterable<DirectedEdge> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v)) return null;\n        Stack<DirectedEdge> path = new Stack<DirectedEdge>();\n        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {\n            path.push(e);\n        }\n        return path;\n    }\n\n    private void validateVertex(int v) {\n        int V = distTo.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        int s = Integer.parseInt(args[1]);\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);\n\n        AcyclicSP sp = new AcyclicSP(G, s);\n        for (int v = 0; v < G.V(); v++) {\n            if (sp.hasPathTo(v)) {\n                StdOut.printf(\"%d to %d (%.2f)  \", s, v, sp.distTo(v));\n                for (DirectedEdge e : sp.pathTo(v)) {\n                    StdOut.print(e + \"   \");\n                }\n                StdOut.println();\n            }\n            else {\n                StdOut.printf(\"%d to %d         no path\\n\", s, v);\n            }\n        }\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class Queue<Item> implements Iterable<Item> {\n    private Node<Item> first;    // beginning of queue\n    private Node<Item> last;     // end of queue\n    private int n;               // number of elements on queue\n\n    private static class Node<Item> {\n        private Item item;\n        private Node<Item> next;\n    }\n\n    \n    public Queue() {\n        first = null;\n        last  = null;\n        n = 0;\n    }\n\n    \n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        return first.item;\n    }\n\n    \n    public void enqueue(Item item) {\n        Node<Item> oldlast = last;\n        last = new Node<Item>();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else           oldlast.next = last;\n        n++;\n    }\n\n    \n    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        Item item = first.item;\n        first = first.next;\n        n--;\n        if (isEmpty()) last = null;   // to avoid loitering\n        return item;\n    }\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this) {\n            s.append(item);\n            s.append(' ');\n        }\n        return s.toString();\n    } \n\n    \n    public Iterator<Item> iterator()  {\n        return new ListIterator(first);  \n    }\n\n    private class ListIterator implements Iterator<Item> {\n        private Node<Item> current;\n\n        public ListIterator(Node<Item> first) {\n            current = first;\n        }\n\n        public boolean hasNext()  { return current != null;                     }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = current.item;\n            current = current.next; \n            return item;\n        }\n    }\n\n\n    \n    public static void main(String[] args) {\n        Queue<String> queue = new Queue<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\"))\n                queue.enqueue(item);\n            else if (!queue.isEmpty())\n                StdOut.print(queue.dequeue() + \" \");\n        }\n        StdOut.println(\"(\" + queue.size() + \" left on queue)\");\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class BoyerMoore {\n    private final int R;     // the radix\n    private int[] right;     // the bad-character skip array\n\n    private char[] pattern;  // store the pattern as a character array\n    private String pat;      // or as a string\n\n    \n    public BoyerMoore(String pat) {\n        this.R = 256;\n        this.pat = pat;\n\n        right = new int[R];\n        for (int c = 0; c < R; c++)\n            right[c] = -1;\n        for (int j = 0; j < pat.length(); j++)\n            right[pat.charAt(j)] = j;\n    }\n\n    \n    public BoyerMoore(char[] pattern, int R) {\n        this.R = R;\n        this.pattern = new char[pattern.length];\n        for (int j = 0; j < pattern.length; j++)\n            this.pattern[j] = pattern[j];\n\n        right = new int[R];\n        for (int c = 0; c < R; c++)\n            right[c] = -1;\n        for (int j = 0; j < pattern.length; j++)\n            right[pattern[j]] = j;\n    }\n\n    \n    public int search(String txt) {\n        int m = pat.length();\n        int n = txt.length();\n        int skip;\n        for (int i = 0; i <= n - m; i += skip) {\n            skip = 0;\n            for (int j = m-1; j >= 0; j--) {\n                if (pat.charAt(j) != txt.charAt(i+j)) {\n                    skip = Math.max(1, j - right[txt.charAt(i+j)]);\n                    break;\n                }\n            }\n            if (skip == 0) return i;    // found\n        }\n        return n;                       // not found\n    }\n\n\n    \n    public int search(char[] text) {\n        int m = pattern.length;\n        int n = text.length;\n        int skip;\n        for (int i = 0; i <= n - m; i += skip) {\n            skip = 0;\n            for (int j = m-1; j >= 0; j--) {\n                if (pattern[j] != text[i+j]) {\n                    skip = Math.max(1, j - right[text[i+j]]);\n                    break;\n                }\n            }\n            if (skip == 0) return i;    // found\n        }\n        return n;                       // not found\n    }\n\n\n    \n    public static void main(String[] args) {\n        String pat = args[0];\n        String txt = args[1];\n        char[] pattern = pat.toCharArray();\n        char[] text    = txt.toCharArray();\n\n        BoyerMoore boyermoore1 = new BoyerMoore(pat);\n        BoyerMoore boyermoore2 = new BoyerMoore(pattern, 256);\n        int offset1 = boyermoore1.search(txt);\n        int offset2 = boyermoore2.search(text);\n\n        StdOut.println(\"text:    \" + txt);\n\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset1; i++)\n            StdOut.print(\" \");\n        StdOut.println(pat);\n\n        StdOut.print(\"pattern: \");\n        for (int i = 0; i < offset2; i++)\n            StdOut.print(\" \");\n        StdOut.println(pat);\n    }\n}\n\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class SymbolDigraph {\n    private ST<String, Integer> st;  // string -> index\n    private String[] keys;           // index  -> string\n    private Digraph graph;           // the underlying digraph\n\n    \n    public SymbolDigraph(String filename, String delimiter) {\n        st = new ST<String, Integer>();\n\n        In in = new In(filename);\n        while (in.hasNextLine()) {\n            String[] a = in.readLine().split(delimiter);\n            for (int i = 0; i < a.length; i++) {\n                if (!st.contains(a[i]))\n                    st.put(a[i], st.size());\n            }\n        }\n\n        keys = new String[st.size()];\n        for (String name : st.keys()) {\n            keys[st.get(name)] = name;\n        }\n\n        graph = new Digraph(st.size());\n        in = new In(filename);\n        while (in.hasNextLine()) {\n            String[] a = in.readLine().split(delimiter);\n            int v = st.get(a[0]);\n            for (int i = 1; i < a.length; i++) {\n                int w = st.get(a[i]);\n                graph.addEdge(v, w);\n            }\n        }\n    }\n\n    \n    public boolean contains(String s) {\n        return st.contains(s);\n    }\n\n    \n    @Deprecated\n    public int index(String s) {\n        return st.get(s);\n    }\n\n    \n    public int indexOf(String s) {\n        return st.get(s);\n    }\n\n    \n    @Deprecated\n    public String name(int v) {\n        validateVertex(v);\n        return keys[v];\n    }\n\n    \n    public String nameOf(int v) {\n        validateVertex(v);\n        return keys[v];\n    }\n\n    \n    @Deprecated\n    public Digraph G() {\n        return graph;\n    }\n\n    \n    public Digraph digraph() {\n        return graph;\n    }\n\n    private void validateVertex(int v) {\n        int V = graph.V();\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        String filename  = args[0];\n        String delimiter = args[1];\n        SymbolDigraph sg = new SymbolDigraph(filename, delimiter);\n        Digraph graph = sg.digraph();\n        while (!StdIn.isEmpty()) {\n            String t = StdIn.readLine();\n            for (int v : graph.adj(sg.index(t))) {\n                StdOut.println(\"   \" + sg.name(v));\n            }\n        }\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Arbitrage {\n\n    private Arbitrage() { }\n\n    \n    public static void main(String[] args) {\n\n        int V = StdIn.readInt();\n        String[] name = new String[V];\n\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);\n        for (int v = 0; v < V; v++) {\n            name[v] = StdIn.readString();\n            for (int w = 0; w < V; w++) {\n                double rate = StdIn.readDouble();\n                DirectedEdge e = new DirectedEdge(v, w, -Math.log(rate));\n                G.addEdge(e);\n            }\n        }\n\n        BellmanFordSP spt = new BellmanFordSP(G, 0);\n        if (spt.hasNegativeCycle()) {\n            double stake = 1000.0;\n            for (DirectedEdge e : spt.negativeCycle()) {\n                StdOut.printf(\"%10.5f %s \", stake, name[e.from()]);\n                stake *= Math.exp(-e.weight());\n                StdOut.printf(\"= %10.5f %s\\n\", stake, name[e.to()]);\n            }\n        }\n        else {\n            StdOut.println(\"No arbitrage opportunity\");\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\n\npublic class GrahamScan {\n    private Stack<Point2D> hull = new Stack<Point2D>();\n\n    \n    public GrahamScan(Point2D[] points) {\n        if (points == null) throw new IllegalArgumentException(\"argument is null\");\n        if (points.length == 0) throw new IllegalArgumentException(\"array is of length 0\");\n\n        int n = points.length;\n        Point2D[] a = new Point2D[n];\n        for (int i = 0; i < n; i++) {\n            if (points[i] == null)\n                throw new IllegalArgumentException(\"points[\" + i + \"] is null\");\n            a[i] = points[i];\n        }\n\n        Arrays.sort(a);\n\n        Arrays.sort(a, 1, n, a[0].polarOrder());\n\n        hull.push(a[0]);       // a[0] is first extreme point\n\n        int k1;\n        for (k1 = 1; k1 < n; k1++)\n            if (!a[0].equals(a[k1])) break;\n        if (k1 == n) return;        // all points equal\n\n        int k2;\n        for (k2 = k1+1; k2 < n; k2++)\n            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;\n        hull.push(a[k2-1]);    // a[k2-1] is second extreme point\n\n        for (int i = k2; i < n; i++) {\n            Point2D top = hull.pop();\n            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {\n                top = hull.pop();\n            }\n            hull.push(top);\n            hull.push(a[i]);\n        }\n\n        assert isConvex();\n    }\n\n    \n    public Iterable<Point2D> hull() {\n        Stack<Point2D> s = new Stack<Point2D>();\n        for (Point2D p : hull) s.push(p);\n        return s;\n    }\n\n    private boolean isConvex() {\n        int n = hull.size();\n        if (n <= 2) return true;\n\n        Point2D[] points = new Point2D[n];\n        int k = 0;\n        for (Point2D p : hull()) {\n            points[k++] = p;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (Point2D.ccw(points[i], points[(i+1) % n], points[(i+2) % n]) <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n   \n    public static void main(String[] args) {\n        int n = StdIn.readInt();\n        Point2D[] points = new Point2D[n];\n        for (int i = 0; i < n; i++) {\n            int x = StdIn.readInt();\n            int y = StdIn.readInt();\n            points[i] = new Point2D(x, y);\n        }\n        GrahamScan graham = new GrahamScan(points);\n        for (Point2D p : graham.hull())\n            StdOut.println(p);\n    }\n\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\n\npublic final class RectHV {\n    private final double xmin, ymin;   // minimum x- and y-coordinates\n    private final double xmax, ymax;   // maximum x- and y-coordinates\n\n    \n    public RectHV(double xmin, double ymin, double xmax, double ymax) {\n        this.xmin = xmin;\n        this.ymin = ymin;\n        this.xmax = xmax;\n        this.ymax = ymax;\n        if (Double.isNaN(xmin) || Double.isNaN(xmax)) {\n            throw new IllegalArgumentException(\"x-coordinate is NaN: \" + toString());\n        }\n        if (Double.isNaN(ymin) || Double.isNaN(ymax)) {\n            throw new IllegalArgumentException(\"y-coordinate is NaN: \" + toString());\n        }\n        if (xmax < xmin) {\n            throw new IllegalArgumentException(\"xmax < xmin: \" + toString());\n        }\n        if (ymax < ymin) {\n            throw new IllegalArgumentException(\"ymax < ymin: \" + toString());\n        }\n    }\n\n    \n    public double xmin() {\n        return xmin;\n    }\n\n    \n    public double xmax() {\n        return xmax;\n    }\n\n    \n    public double ymin() {\n        return ymin;\n    }\n\n    \n    public double ymax() {\n        return ymax;\n    }\n\n    \n    public double width() {\n        return xmax - xmin;\n    }\n\n    \n    public double height() {\n        return ymax - ymin;\n    }\n\n    \n    public boolean intersects(RectHV that) {\n        return this.xmax >= that.xmin && this.ymax >= that.ymin\n            && that.xmax >= this.xmin && that.ymax >= this.ymin;\n    }\n\n    \n    public boolean contains(Point2D p) {\n        return (p.x() >= xmin) && (p.x() <= xmax)\n            && (p.y() >= ymin) && (p.y() <= ymax);\n    }\n\n    \n    public double distanceTo(Point2D p) {\n        return Math.sqrt(this.distanceSquaredTo(p));\n    }\n\n    \n    public double distanceSquaredTo(Point2D p) {\n        double dx = 0.0, dy = 0.0;\n        if      (p.x() < xmin) dx = p.x() - xmin;\n        else if (p.x() > xmax) dx = p.x() - xmax;\n        if      (p.y() < ymin) dy = p.y() - ymin;\n        else if (p.y() > ymax) dy = p.y() - ymax;\n        return dx*dx + dy*dy;\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (other == this) return true;\n        if (other == null) return false;\n        if (other.getClass() != this.getClass()) return false;\n        RectHV that = (RectHV) other;\n        if (this.xmin != that.xmin) return false;\n        if (this.ymin != that.ymin) return false;\n        if (this.xmax != that.xmax) return false;\n        if (this.ymax != that.ymax) return false;\n        return true;\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int hash1 = ((Double) xmin).hashCode();\n        int hash2 = ((Double) ymin).hashCode();\n        int hash3 = ((Double) xmax).hashCode();\n        int hash4 = ((Double) ymax).hashCode();\n        return 31*(31*(31*hash1 + hash2) + hash3) + hash4;\n    }\n\n    \n    @Override\n    public String toString() {\n        return \"[\" + xmin + \", \" + xmax + \"] x [\" + ymin + \", \" + ymax + \"]\";\n    }\n\n    \n    public void draw() {\n        StdDraw.line(xmin, ymin, xmax, ymin);\n        StdDraw.line(xmax, ymin, xmax, ymax);\n        StdDraw.line(xmax, ymax, xmin, ymax);\n        StdDraw.line(xmin, ymax, xmin, ymin);\n    }\n\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class ResizingArrayStack<Item> implements Iterable<Item> {\n    private Item[] a;         // array of items\n    private int n;            // number of elements on stack\n\n\n    \n    public ResizingArrayStack() {\n        a = (Item[]) new Object[2];\n        n = 0;\n    }\n\n    \n    public boolean isEmpty() {\n        return n == 0;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n\n    private void resize(int capacity) {\n        assert capacity >= n;\n\n        Item[] temp = (Item[]) new Object[capacity];\n        for (int i = 0; i < n; i++) {\n            temp[i] = a[i];\n        }\n        a = temp;\n\n    }\n\n\n\n    \n    public void push(Item item) {\n        if (n == a.length) resize(2*a.length);    // double size of array if necessary\n        a[n++] = item;                            // add item\n    }\n\n    \n    public Item pop() {\n        if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\");\n        Item item = a[n-1];\n        a[n-1] = null;                              // to avoid loitering\n        n--;\n        if (n > 0 && n == a.length/4) resize(a.length/2);\n        return item;\n    }\n\n\n    \n    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\");\n        return a[n-1];\n    }\n\n    \n    public Iterator<Item> iterator() {\n        return new ReverseArrayIterator();\n    }\n\n    private class ReverseArrayIterator implements Iterator<Item> {\n        private int i;\n\n        public ReverseArrayIterator() {\n            i = n-1;\n        }\n\n        public boolean hasNext() {\n            return i >= 0;\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            return a[i--];\n        }\n    }\n\n\n    \n    public static void main(String[] args) {\n        ResizingArrayStack<String> stack = new ResizingArrayStack<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\")) stack.push(item);\n            else if (!stack.isEmpty()) StdOut.print(stack.pop() + \" \");\n        }\n        StdOut.println(\"(\" + stack.size() + \" left on stack)\");\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class Particle {\n    private static final double INFINITY = Double.POSITIVE_INFINITY;\n\n    private double rx, ry;        // position\n    private double vx, vy;        // velocity\n    private int count;            // number of collisions so far\n    private final double radius;  // radius\n    private final double mass;    // mass\n    private final Color color;    // color\n\n\n    \n    public Particle(double rx, double ry, double vx, double vy, double radius, double mass, Color color) {\n        this.vx = vx;\n        this.vy = vy;\n        this.rx = rx;\n        this.ry = ry;\n        this.radius = radius;\n        this.mass   = mass;\n        this.color  = color;\n    }\n         \n    \n    public Particle() {\n        rx     = StdRandom.uniform(0.0, 1.0);\n        ry     = StdRandom.uniform(0.0, 1.0);\n        vx     = StdRandom.uniform(-0.005, 0.005);\n        vy     = StdRandom.uniform(-0.005, 0.005);\n        radius = 0.02;\n        mass   = 0.5;\n        color  = Color.BLACK;\n    }\n\n    \n    public void move(double dt) {\n        rx += vx * dt;\n        ry += vy * dt;\n    }\n\n    \n    public void draw() {\n        StdDraw.setPenColor(color);\n        StdDraw.filledCircle(rx, ry, radius);\n    }\n\n    \n    public int count() {\n        return count;\n    }\n\n    \n    public double timeToHit(Particle that) {\n        if (this == that) return INFINITY;\n        double dx  = that.rx - this.rx;\n        double dy  = that.ry - this.ry;\n        double dvx = that.vx - this.vx;\n        double dvy = that.vy - this.vy;\n        double dvdr = dx*dvx + dy*dvy;\n        if (dvdr > 0) return INFINITY;\n        double dvdv = dvx*dvx + dvy*dvy;\n        if (dvdv == 0) return INFINITY;\n        double drdr = dx*dx + dy*dy;\n        double sigma = this.radius + that.radius;\n        double d = (dvdr*dvdr) - dvdv * (drdr - sigma*sigma);\n        if (d < 0) return INFINITY;\n        return -(dvdr + Math.sqrt(d)) / dvdv;\n    }\n\n    \n    public double timeToHitVerticalWall() {\n        if      (vx > 0) return (1.0 - rx - radius) / vx;\n        else if (vx < 0) return (radius - rx) / vx;  \n        else             return INFINITY;\n    }\n\n    \n    public double timeToHitHorizontalWall() {\n        if      (vy > 0) return (1.0 - ry - radius) / vy;\n        else if (vy < 0) return (radius - ry) / vy;\n        else             return INFINITY;\n    }\n\n    \n    public void bounceOff(Particle that) {\n        double dx  = that.rx - this.rx;\n        double dy  = that.ry - this.ry;\n        double dvx = that.vx - this.vx;\n        double dvy = that.vy - this.vy;\n        double dvdr = dx*dvx + dy*dvy;             // dv dot dr\n        double dist = this.radius + that.radius;   // distance between particle centers at collison\n\n        double magnitude = 2 * this.mass * that.mass * dvdr / ((this.mass + that.mass) * dist);\n\n        double fx = magnitude * dx / dist;\n        double fy = magnitude * dy / dist;\n\n        this.vx += fx / this.mass;\n        this.vy += fy / this.mass;\n        that.vx -= fx / that.mass;\n        that.vy -= fy / that.mass;\n\n        this.count++;\n        that.count++;\n    }\n\n    \n    public void bounceOffVerticalWall() {\n        vx = -vx;\n        count++;\n    }\n\n    \n    public void bounceOffHorizontalWall() {\n        vy = -vy;\n        count++;\n    }\n\n    \n    public double kineticEnergy() {\n        return 0.5 * mass * (vx*vx + vy*vy);\n    }\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\n\npublic class Bipartite {\n    private boolean isBipartite;   // is the graph bipartite?\n    private boolean[] color;       // color[v] gives vertices on one side of bipartition\n    private boolean[] marked;      // marked[v] = true iff v has been visited in DFS\n    private int[] edgeTo;          // edgeTo[v] = last edge on path to v\n    private Stack<Integer> cycle;  // odd-length cycle\n\n    \n    public Bipartite(Graph G) {\n        isBipartite = true;\n        color  = new boolean[G.V()];\n        marked = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v]) {\n                dfs(G, v);\n            }\n        }\n        assert check(G);\n    }\n\n    private void dfs(Graph G, int v) { \n        marked[v] = true;\n        for (int w : G.adj(v)) {\n\n            if (cycle != null) return;\n\n            if (!marked[w]) {\n                edgeTo[w] = v;\n                color[w] = !color[v];\n                dfs(G, w);\n            } \n\n            else if (color[w] == color[v]) {\n                isBipartite = false;\n                cycle = new Stack<Integer>();\n                cycle.push(w);  // don't need this unless you want to include start vertex twice\n                for (int x = v; x != w; x = edgeTo[x]) {\n                    cycle.push(x);\n                }\n                cycle.push(w);\n            }\n        }\n    }\n\n    \n    public boolean isBipartite() {\n        return isBipartite;\n    }\n \n    \n    public boolean color(int v) {\n        validateVertex(v);\n        if (!isBipartite)\n            throw new UnsupportedOperationException(\"graph is not bipartite\");\n        return color[v];\n    }\n\n    \n    public Iterable<Integer> oddCycle() {\n        return cycle; \n    }\n\n    private boolean check(Graph G) {\n        if (isBipartite) {\n            for (int v = 0; v < G.V(); v++) {\n                for (int w : G.adj(v)) {\n                    if (color[v] == color[w]) {\n                        System.err.printf(\"edge %d-%d with %d and %d in same side of bipartition\\n\", v, w, v, w);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        else {\n            int first = -1, last = -1;\n            for (int v : oddCycle()) {\n                if (first == -1) first = v;\n                last = v;\n            }\n            if (first != last) {\n                System.err.printf(\"cycle begins with %d and ends with %d\\n\", first, last);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        int V1 = Integer.parseInt(args[0]);\n        int V2 = Integer.parseInt(args[1]);\n        int E  = Integer.parseInt(args[2]);\n        int F  = Integer.parseInt(args[3]);\n\n        Graph G = GraphGenerator.bipartite(V1, V2, E);\n        for (int i = 0; i < F; i++) {\n            int v = StdRandom.uniform(V1 + V2);\n            int w = StdRandom.uniform(V1 + V2);\n            G.addEdge(v, w);\n        }\n\n        StdOut.println(G);\n\n\n        Bipartite b = new Bipartite(G);\n        if (b.isBipartite()) {\n            StdOut.println(\"Graph is bipartite\");\n            for (int v = 0; v < G.V(); v++) {\n                StdOut.println(v + \": \" + b.color(v));\n            }\n        }\n        else {\n            StdOut.print(\"Graph has an odd-length cycle: \");\n            for (int x : b.oddCycle()) {\n                StdOut.print(x + \" \");\n            }\n            StdOut.println();\n        }\n    }\n\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class WeightedQuickUnionUF {\n    private int[] parent;   // parent[i] = parent of i\n    private int[] size;     // size[i] = number of sites in subtree rooted at i\n    private int count;      // number of components\n\n    \n    public WeightedQuickUnionUF(int n) {\n        count = n;\n        parent = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    \n    public int count() {\n        return count;\n    }\n  \n    \n    public int find(int p) {\n        validate(p);\n        while (p != parent[p])\n            p = parent[p];\n        return p;\n    }\n\n    private void validate(int p) {\n        int n = parent.length;\n        if (p < 0 || p >= n) {\n            throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1));  \n        }\n    }\n\n    \n    public boolean connected(int p, int q) {\n        return find(p) == find(q);\n    }\n\n    \n    public void union(int p, int q) {\n        int rootP = find(p);\n        int rootQ = find(q);\n        if (rootP == rootQ) return;\n\n        if (size[rootP] < size[rootQ]) {\n            parent[rootP] = rootQ;\n            size[rootQ] += size[rootP];\n        }\n        else {\n            parent[rootQ] = rootP;\n            size[rootP] += size[rootQ];\n        }\n        count--;\n    }\n\n\n    \n    public static void main(String[] args) {\n        int n = StdIn.readInt();\n        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(n);\n        while (!StdIn.isEmpty()) {\n            int p = StdIn.readInt();\n            int q = StdIn.readInt();\n            if (uf.connected(p, q)) continue;\n            uf.union(p, q);\n            StdOut.println(p + \" \" + q);\n        }\n        StdOut.println(uf.count() + \" components\");\n    }\n\n}\n\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class Interval1D {\n\n    \n    public static final Comparator<Interval1D> MIN_ENDPOINT_ORDER  = new MinEndpointComparator();\n\n    \n    public static final Comparator<Interval1D> MAX_ENDPOINT_ORDER = new MaxEndpointComparator();\n\n    \n    public static final Comparator<Interval1D> LENGTH_ORDER = new LengthComparator();\n\n    private final double min;\n    private final double max;\n\n    \n    public Interval1D(double min, double max) {\n        if (Double.isInfinite(min) || Double.isInfinite(max))\n            throw new IllegalArgumentException(\"Endpoints must be finite\");\n        if (Double.isNaN(min) || Double.isNaN(max))\n            throw new IllegalArgumentException(\"Endpoints cannot be NaN\");\n\n        if (min == 0.0) min = 0.0;\n        if (max == 0.0) max = 0.0;\n\n        if (min <= max) {\n            this.min = min;\n            this.max = max;\n        }\n        else throw new IllegalArgumentException(\"Illegal interval\");\n    }\n\n    \n    @Deprecated\n    public double left() { \n        return min;\n    }\n\n    \n    @Deprecated\n    public double right() { \n        return max;\n    }\n\n    \n    public double min() { \n        return min;\n    }\n\n    \n    public double max() { \n        return max;\n    }\n\n    \n    public boolean intersects(Interval1D that) {\n        if (this.max < that.min) return false;\n        if (that.max < this.min) return false;\n        return true;\n    }\n\n    \n    public boolean contains(double x) {\n        return (min <= x) && (x <= max);\n    }\n\n    \n    public double length() {\n        return max - min;\n    }\n\n    \n    public String toString() {\n        return \"[\" + min + \", \" + max + \"]\";\n    }\n\n    \n    public boolean equals(Object other) {\n        if (other == this) return true;\n        if (other == null) return false;\n        if (other.getClass() != this.getClass()) return false;\n        Interval1D that = (Interval1D) other;\n        return this.min == that.min && this.max == that.max;\n    }\n\n    \n    public int hashCode() {\n        int hash1 = ((Double) min).hashCode();\n        int hash2 = ((Double) max).hashCode();\n        return 31*hash1 + hash2;\n    }\n\n    private static class MinEndpointComparator implements Comparator<Interval1D> {\n        public int compare(Interval1D a, Interval1D b) {\n            if      (a.min < b.min) return -1;\n            else if (a.min > b.min) return +1;\n            else if (a.max < b.max) return -1;\n            else if (a.max > b.max) return +1;\n            else                    return  0;\n        }\n    }\n\n    private static class MaxEndpointComparator implements Comparator<Interval1D> {\n        public int compare(Interval1D a, Interval1D b) {\n            if      (a.max < b.max) return -1;\n            else if (a.max > b.max) return +1;\n            else if (a.min < b.min) return -1;\n            else if (a.min > b.min) return +1;\n            else                    return  0;\n        }\n    }\n\n    private static class LengthComparator implements Comparator<Interval1D> {\n        public int compare(Interval1D a, Interval1D b) {\n            double alen = a.length();\n            double blen = b.length();\n            if      (alen < blen) return -1;\n            else if (alen > blen) return +1;\n            else                  return  0;\n        }\n    }\n\n\n\n\n    \n    public static void main(String[] args) {\n        Interval1D[] intervals = new Interval1D[4];\n        intervals[0] = new Interval1D(15.0, 33.0);\n        intervals[1] = new Interval1D(45.0, 60.0);\n        intervals[2] = new Interval1D(20.0, 70.0);\n        intervals[3] = new Interval1D(46.0, 55.0);\n\n        StdOut.println(\"Unsorted\");\n        for (int i = 0; i < intervals.length; i++)\n            StdOut.println(intervals[i]);\n        StdOut.println();\n        \n        StdOut.println(\"Sort by min endpoint\");\n        Arrays.sort(intervals, Interval1D.MIN_ENDPOINT_ORDER);\n        for (int i = 0; i < intervals.length; i++)\n            StdOut.println(intervals[i]);\n        StdOut.println();\n\n        StdOut.println(\"Sort by max endpoint\");\n        Arrays.sort(intervals, Interval1D.MAX_ENDPOINT_ORDER);\n        for (int i = 0; i < intervals.length; i++)\n            StdOut.println(intervals[i]);\n        StdOut.println();\n\n        StdOut.println(\"Sort by length\");\n        Arrays.sort(intervals, Interval1D.LENGTH_ORDER);\n        for (int i = 0; i < intervals.length; i++)\n            StdOut.println(intervals[i]);\n        StdOut.println();\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class FileIndex { \n\n    private FileIndex() { }\n\n    public static void main(String[] args) {\n\n        ST<String, SET<File>> st = new ST<String, SET<File>>();\n\n        StdOut.println(\"Indexing files\");\n        for (String filename : args) {\n            StdOut.println(\"  \" + filename);\n            File file = new File(filename);\n            In in = new In(file);\n            while (!in.isEmpty()) {\n                String word = in.readString();\n                if (!st.contains(word)) st.put(word, new SET<File>());\n                SET<File> set = st.get(word);\n                set.add(file);\n            }\n        }\n\n\n        while (!StdIn.isEmpty()) {\n            String query = StdIn.readString();\n            if (st.contains(query)) {\n                SET<File> set = st.get(query);\n                for (File file : set) {\n                    StdOut.println(\"  \" + file.getName());\n                }\n            }\n        }\n\n    }\n\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\n\n\npublic class PictureDump {\n\n    private PictureDump() { }\n\n    \n    public static void main(String[] args) {\n        int width = Integer.parseInt(args[0]);\n        int height = Integer.parseInt(args[1]);\n        Picture picture = new Picture(width, height);\n        for (int row = 0; row < height; row++) {\n            for (int col = 0; col < width; col++) {\n                if (!BinaryStdIn.isEmpty()) {\n                    boolean bit = BinaryStdIn.readBoolean();\n                    if (bit) picture.set(col, row, Color.BLACK);\n                    else     picture.set(col, row, Color.WHITE);\n                }\n                else {\n                    picture.set(col, row, Color.RED);\n                }\n            }\n        }\n        picture.show();\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\n\npublic class ResizingArrayQueue<Item> implements Iterable<Item> {\n    private Item[] q;       // queue elements\n    private int n;          // number of elements on queue\n    private int first;      // index of first element of queue\n    private int last;       // index of next available slot\n\n\n    \n    public ResizingArrayQueue() {\n        q = (Item[]) new Object[2];\n        n = 0;\n        first = 0;\n        last = 0;\n    }\n\n    \n    public boolean isEmpty() {\n        return n == 0;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    private void resize(int capacity) {\n        assert capacity >= n;\n        Item[] temp = (Item[]) new Object[capacity];\n        for (int i = 0; i < n; i++) {\n            temp[i] = q[(first + i) % q.length];\n        }\n        q = temp;\n        first = 0;\n        last  = n;\n    }\n\n    \n    public void enqueue(Item item) {\n        if (n == q.length) resize(2*q.length);   // double size of array if necessary\n        q[last++] = item;                        // add item\n        if (last == q.length) last = 0;          // wrap-around\n        n++;\n    }\n\n    \n    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        Item item = q[first];\n        q[first] = null;                            // to avoid loitering\n        n--;\n        first++;\n        if (first == q.length) first = 0;           // wrap-around\n        if (n > 0 && n == q.length/4) resize(q.length/2); \n        return item;\n    }\n\n    \n    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\");\n        return q[first];\n    }\n\n\n    \n    public Iterator<Item> iterator() {\n        return new ArrayIterator();\n    }\n\n    private class ArrayIterator implements Iterator<Item> {\n        private int i = 0;\n        public boolean hasNext()  { return i < n;                               }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = q[(i + first) % q.length];\n            i++;\n            return item;\n        }\n    }\n\n   \n    public static void main(String[] args) {\n        ResizingArrayQueue<String> queue = new ResizingArrayQueue<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\")) queue.enqueue(item);\n            else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + \" \");\n        }\n        StdOut.println(\"(\" + queue.size() + \" left on queue)\");\n    }\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class Average { \n\n    private Average() { }\n\n    \n    public static void main(String[] args) { \n        int count = 0;       // number input values\n        double sum = 0.0;    // sum of input values\n\n        while (!StdIn.isEmpty()) {\n            double value = StdIn.readDouble();\n            sum += value;\n            count++;\n        }\n\n        double average = sum / count;\n\n        StdOut.println(\"Average is \" + average);\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class TrieSET implements Iterable<String> {\n    private static final int R = 256;        // extended ASCII\n\n    private Node root;      // root of trie\n    private int n;          // number of keys in trie\n\n    private static class Node {\n        private Node[] next = new Node[R];\n        private boolean isString;\n    }\n\n    \n    public TrieSET() {\n    }\n\n    \n    public boolean contains(String key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\");\n        Node x = get(root, key, 0);\n        if (x == null) return false;\n        return x.isString;\n    }\n\n    private Node get(Node x, String key, int d) {\n        if (x == null) return null;\n        if (d == key.length()) return x;\n        char c = key.charAt(d);\n        return get(x.next[c], key, d+1);\n    }\n\n    \n    public void add(String key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to add() is null\");\n        root = add(root, key, 0);\n    }\n\n    private Node add(Node x, String key, int d) {\n        if (x == null) x = new Node();\n        if (d == key.length()) {\n            if (!x.isString) n++;\n            x.isString = true;\n        }\n        else {\n            char c = key.charAt(d);\n            x.next[c] = add(x.next[c], key, d+1);\n        }\n        return x;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    \n    public Iterator<String> iterator() {\n        return keysWithPrefix(\"\").iterator();\n    }\n\n    \n    public Iterable<String> keysWithPrefix(String prefix) {\n        Queue<String> results = new Queue<String>();\n        Node x = get(root, prefix, 0);\n        collect(x, new StringBuilder(prefix), results);\n        return results;\n    }\n\n    private void collect(Node x, StringBuilder prefix, Queue<String> results) {\n        if (x == null) return;\n        if (x.isString) results.enqueue(prefix.toString());\n        for (char c = 0; c < R; c++) {\n            prefix.append(c);\n            collect(x.next[c], prefix, results);\n            prefix.deleteCharAt(prefix.length() - 1);\n        }\n    }\n\n      \n    public Iterable<String> keysThatMatch(String pattern) {\n        Queue<String> results = new Queue<String>();\n        StringBuilder prefix = new StringBuilder();\n        collect(root, prefix, pattern, results);\n        return results;\n    }\n        \n    private void collect(Node x, StringBuilder prefix, String pattern, Queue<String> results) {\n        if (x == null) return;\n        int d = prefix.length();\n        if (d == pattern.length() && x.isString)\n            results.enqueue(prefix.toString());\n        if (d == pattern.length())\n            return;\n        char c = pattern.charAt(d);\n        if (c == '.') {\n            for (char ch = 0; ch < R; ch++) {\n                prefix.append(ch);\n                collect(x.next[ch], prefix, pattern, results);\n                prefix.deleteCharAt(prefix.length() - 1);\n            }\n        }\n        else {\n            prefix.append(c);\n            collect(x.next[c], prefix, pattern, results);\n            prefix.deleteCharAt(prefix.length() - 1);\n        }\n    }\n\n    \n    public String longestPrefixOf(String query) {\n        if (query == null) throw new IllegalArgumentException(\"argument to longestPrefixOf() is null\");\n        int length = longestPrefixOf(root, query, 0, -1);\n        if (length == -1) return null;\n        return query.substring(0, length);\n    }\n\n    private int longestPrefixOf(Node x, String query, int d, int length) {\n        if (x == null) return length;\n        if (x.isString) length = d;\n        if (d == query.length()) return length;\n        char c = query.charAt(d);\n        return longestPrefixOf(x.next[c], query, d+1, length);\n    }\n\n    \n    public void delete(String key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\");\n        root = delete(root, key, 0);\n    }\n\n    private Node delete(Node x, String key, int d) {\n        if (x == null) return null;\n        if (d == key.length()) {\n            if (x.isString) n--;\n            x.isString = false;\n        }\n        else {\n            char c = key.charAt(d);\n            x.next[c] = delete(x.next[c], key, d+1);\n        }\n\n        if (x.isString) return x;\n        for (int c = 0; c < R; c++)\n            if (x.next[c] != null)\n                return x;\n        return null;\n    }\n\n\n    \n    public static void main(String[] args) {\n        TrieSET set = new TrieSET();\n        while (!StdIn.isEmpty()) {\n            String key = StdIn.readString();\n            set.add(key);\n        }\n\n        if (set.size() < 100) {\n            StdOut.println(\"keys(\\\"\\\"):\");\n            for (String key : set) {\n                StdOut.println(key);\n            }\n            StdOut.println();\n        }\n\n        StdOut.println(\"longestPrefixOf(\\\"shellsort\\\"):\");\n        StdOut.println(set.longestPrefixOf(\"shellsort\"));\n        StdOut.println();\n\n        StdOut.println(\"longestPrefixOf(\\\"xshellsort\\\"):\");\n        StdOut.println(set.longestPrefixOf(\"xshellsort\"));\n        StdOut.println();\n\n        StdOut.println(\"keysWithPrefix(\\\"shor\\\"):\");\n        for (String s : set.keysWithPrefix(\"shor\"))\n            StdOut.println(s);\n        StdOut.println();\n\n        StdOut.println(\"keysWithPrefix(\\\"shortening\\\"):\");\n        for (String s : set.keysWithPrefix(\"shortening\"))\n            StdOut.println(s);\n        StdOut.println();\n\n        StdOut.println(\"keysThatMatch(\\\".he.l.\\\"):\");\n        for (String s : set.keysThatMatch(\".he.l.\"))\n            StdOut.println(s);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class Genome {\n\n    private Genome() { }\n\n    \n    public static void compress() { \n        Alphabet DNA = Alphabet.DNA;\n        String s = BinaryStdIn.readString();\n        int n = s.length();\n        BinaryStdOut.write(n);\n\n        for (int i = 0; i < n; i++) {\n            int d = DNA.toIndex(s.charAt(i));\n            BinaryStdOut.write(d, 2);\n        }\n        BinaryStdOut.close();\n    } \n\n    \n    public static void expand() {\n        Alphabet DNA = Alphabet.DNA;\n        int n = BinaryStdIn.readInt();\n        for (int i = 0; i < n; i++) {\n            char c = BinaryStdIn.readChar(2);\n            BinaryStdOut.write(DNA.toChar(c), 8);\n        }\n        BinaryStdOut.close();\n    }\n\n\n    \n    public static void main(String[] args) {\n        if      (args[0].equals(\"-\")) compress();\n        else if (args[0].equals(\"+\")) expand();\n        else throw new IllegalArgumentException(\"Illegal command line argument\");\n    }\n\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class TST<Value> {\n    private int n;              // size\n    private Node<Value> root;   // root of TST\n\n    private static class Node<Value> {\n        private char c;                        // character\n        private Node<Value> left, mid, right;  // left, middle, and right subtries\n        private Value val;                     // value associated with string\n    }\n\n    \n    public TST() {\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public boolean contains(String key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"argument to contains() is null\");\n        }\n        return get(key) != null;\n    }\n\n    \n    public Value get(String key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"calls get() with null argument\");\n        }\n        if (key.length() == 0) throw new IllegalArgumentException(\"key must have length >= 1\");\n        Node<Value> x = get(root, key, 0);\n        if (x == null) return null;\n        return x.val;\n    }\n\n    private Node<Value> get(Node<Value> x, String key, int d) {\n        if (x == null) return null;\n        if (key.length() == 0) throw new IllegalArgumentException(\"key must have length >= 1\");\n        char c = key.charAt(d);\n        if      (c < x.c)              return get(x.left,  key, d);\n        else if (c > x.c)              return get(x.right, key, d);\n        else if (d < key.length() - 1) return get(x.mid,   key, d+1);\n        else                           return x;\n    }\n\n    \n    public void put(String key, Value val) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"calls put() with null key\");\n        }\n        if (!contains(key)) n++;\n        else if(val == null) n--;       // delete existing key\n        root = put(root, key, val, 0);\n    }\n\n    private Node<Value> put(Node<Value> x, String key, Value val, int d) {\n        char c = key.charAt(d);\n        if (x == null) {\n            x = new Node<Value>();\n            x.c = c;\n        }\n        if      (c < x.c)               x.left  = put(x.left,  key, val, d);\n        else if (c > x.c)               x.right = put(x.right, key, val, d);\n        else if (d < key.length() - 1)  x.mid   = put(x.mid,   key, val, d+1);\n        else                            x.val   = val;\n        return x;\n    }\n\n    \n    public String longestPrefixOf(String query) {\n        if (query == null) {\n            throw new IllegalArgumentException(\"calls longestPrefixOf() with null argument\");\n        }\n        if (query.length() == 0) return null;\n        int length = 0;\n        Node<Value> x = root;\n        int i = 0;\n        while (x != null && i < query.length()) {\n            char c = query.charAt(i);\n            if      (c < x.c) x = x.left;\n            else if (c > x.c) x = x.right;\n            else {\n                i++;\n                if (x.val != null) length = i;\n                x = x.mid;\n            }\n        }\n        return query.substring(0, length);\n    }\n\n    \n    public Iterable<String> keys() {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), queue);\n        return queue;\n    }\n\n    \n    public Iterable<String> keysWithPrefix(String prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException(\"calls keysWithPrefix() with null argument\");\n        }\n        Queue<String> queue = new Queue<String>();\n        Node<Value> x = get(root, prefix, 0);\n        if (x == null) return queue;\n        if (x.val != null) queue.enqueue(prefix);\n        collect(x.mid, new StringBuilder(prefix), queue);\n        return queue;\n    }\n\n    private void collect(Node<Value> x, StringBuilder prefix, Queue<String> queue) {\n        if (x == null) return;\n        collect(x.left,  prefix, queue);\n        if (x.val != null) queue.enqueue(prefix.toString() + x.c);\n        collect(x.mid,   prefix.append(x.c), queue);\n        prefix.deleteCharAt(prefix.length() - 1);\n        collect(x.right, prefix, queue);\n    }\n\n\n    \n    public Iterable<String> keysThatMatch(String pattern) {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), 0, pattern, queue);\n        return queue;\n    }\n \n    private void collect(Node<Value> x, StringBuilder prefix, int i, String pattern, Queue<String> queue) {\n        if (x == null) return;\n        char c = pattern.charAt(i);\n        if (c == '.' || c < x.c) collect(x.left, prefix, i, pattern, queue);\n        if (c == '.' || c == x.c) {\n            if (i == pattern.length() - 1 && x.val != null) queue.enqueue(prefix.toString() + x.c);\n            if (i < pattern.length() - 1) {\n                collect(x.mid, prefix.append(x.c), i+1, pattern, queue);\n                prefix.deleteCharAt(prefix.length() - 1);\n            }\n        }\n        if (c == '.' || c > x.c) collect(x.right, prefix, i, pattern, queue);\n    }\n\n\n    \n    public static void main(String[] args) {\n\n        TST<Integer> st = new TST<Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        if (st.size() < 100) {\n            StdOut.println(\"keys(\\\"\\\"):\");\n            for (String key : st.keys()) {\n                StdOut.println(key + \" \" + st.get(key));\n            }\n            StdOut.println();\n        }\n\n        StdOut.println(\"longestPrefixOf(\\\"shellsort\\\"):\");\n        StdOut.println(st.longestPrefixOf(\"shellsort\"));\n        StdOut.println();\n\n        StdOut.println(\"longestPrefixOf(\\\"shell\\\"):\");\n        StdOut.println(st.longestPrefixOf(\"shell\"));\n        StdOut.println();\n\n        StdOut.println(\"keysWithPrefix(\\\"shor\\\"):\");\n        for (String s : st.keysWithPrefix(\"shor\"))\n            StdOut.println(s);\n        StdOut.println();\n\n        StdOut.println(\"keysThatMatch(\\\".he.l.\\\"):\");\n        for (String s : st.keysThatMatch(\".he.l.\"))\n            StdOut.println(s);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class Vector { \n\n    private int d;               // dimension of the vector\n    private double[] data;       // array of vector's components\n\n\n    \n    public Vector(int d) {\n        this.d = d;\n        data = new double[d];\n    }\n\n    \n    public Vector(double... a) {\n        d = a.length;\n\n        data = new double[d];\n        for (int i = 0; i < d; i++)\n            data[i] = a[i];\n    }\n\n    \n    @Deprecated\n    public int length() {\n        return d;\n    }\n\n    \n    public int dimension() {\n        return d;\n    }\n\n    \n    public double dot(Vector that) {\n        if (this.d != that.d) throw new IllegalArgumentException(\"Dimensions don't agree\");\n        double sum = 0.0;\n        for (int i = 0; i < d; i++)\n            sum = sum + (this.data[i] * that.data[i]);\n        return sum;\n    }\n\n    \n    public double magnitude() {\n        return Math.sqrt(this.dot(this));\n    }\n\n    \n    public double distanceTo(Vector that) {\n        if (this.d != that.d) throw new IllegalArgumentException(\"Dimensions don't agree\");\n        return this.minus(that).magnitude();\n    }\n\n    \n    public Vector plus(Vector that) {\n        if (this.d != that.d) throw new IllegalArgumentException(\"Dimensions don't agree\");\n        Vector c = new Vector(d);\n        for (int i = 0; i < d; i++)\n            c.data[i] = this.data[i] + that.data[i];\n        return c;\n    }\n\n    \n    public Vector minus(Vector that) {\n        if (this.d != that.d) throw new IllegalArgumentException(\"Dimensions don't agree\");\n        Vector c = new Vector(d);\n        for (int i = 0; i < d; i++)\n            c.data[i] = this.data[i] - that.data[i];\n        return c;\n    }\n\n    \n    public double cartesian(int i) {\n        return data[i];\n    }\n\n    \n    @Deprecated\n    public Vector times(double alpha) {\n        Vector c = new Vector(d);\n        for (int i = 0; i < d; i++)\n            c.data[i] = alpha * data[i];\n        return c;\n    }\n\n    \n    public Vector scale(double alpha) {\n        Vector c = new Vector(d);\n        for (int i = 0; i < d; i++)\n            c.data[i] = alpha * data[i];\n        return c;\n    }\n\n    \n    public Vector direction() {\n        if (this.magnitude() == 0.0) throw new ArithmeticException(\"Zero-vector has no direction\");\n        return this.times(1.0 / this.magnitude());\n    }\n\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < d; i++)\n            s.append(data[i] + \" \");\n        return s.toString();\n    }\n\n    \n    public static void main(String[] args) {\n        double[] xdata = { 1.0, 2.0, 3.0, 4.0 };\n        double[] ydata = { 5.0, 2.0, 4.0, 1.0 };\n        Vector x = new Vector(xdata);\n        Vector y = new Vector(ydata);\n\n        StdOut.println(\"   x       = \" + x);\n        StdOut.println(\"   y       = \" + y);\n\n        Vector z = x.plus(y);\n        StdOut.println(\"   z       = \" + z);\n\n        z = z.times(10.0);\n        StdOut.println(\" 10z       = \" + z);\n\n        StdOut.println(\"  |x|      = \" + x.magnitude());\n        StdOut.println(\" <x, y>    = \" + x.dot(y));\n        StdOut.println(\"dist(x, y) = \" + x.distanceTo(y));\n        StdOut.println(\"dir(x)     = \" + x.direction());\n\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class MergeBU {\n\n    private MergeBU() { }\n\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k]; \n        }\n\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)              a[k] = aux[j++];  // this copying is unneccessary\n            else if (j > hi)               a[k] = aux[i++];\n            else if (less(aux[j], aux[i])) a[k] = aux[j++];\n            else                           a[k] = aux[i++];\n        }\n\n    }\n\n    \n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        Comparable[] aux = new Comparable[n];\n        for (int len = 1; len < n; len *= 2) {\n            for (int lo = 0; lo < n-len; lo += len+len) {\n                int mid  = lo+len-1;\n                int hi = Math.min(lo+len+len-1, n-1);\n                merge(a, aux, lo, mid, hi);\n            }\n        }\n        assert isSorted(a);\n    }\n\n  \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        for (int i = 1; i < a.length; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        MergeBU.sort(a);\n        show(a);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class TarjanSCC {\n\n    private boolean[] marked;        // marked[v] = has v been visited?\n    private int[] id;                // id[v] = id of strong component containing v\n    private int[] low;               // low[v] = low number of v\n    private int pre;                 // preorder number counter\n    private int count;               // number of strongly-connected components\n    private Stack<Integer> stack;\n\n\n    \n    public TarjanSCC(Digraph G) {\n        marked = new boolean[G.V()];\n        stack = new Stack<Integer>();\n        id = new int[G.V()]; \n        low = new int[G.V()];\n        for (int v = 0; v < G.V(); v++) {\n            if (!marked[v]) dfs(G, v);\n        }\n\n        assert check(G);\n    }\n\n    private void dfs(Digraph G, int v) { \n        marked[v] = true;\n        low[v] = pre++;\n        int min = low[v];\n        stack.push(v);\n        for (int w : G.adj(v)) {\n            if (!marked[w]) dfs(G, w);\n            if (low[w] < min) min = low[w];\n        }\n        if (min < low[v]) {\n            low[v] = min;\n            return;\n        }\n        int w;\n        do {\n            w = stack.pop();\n            id[w] = count;\n            low[w] = G.V();\n        } while (w != v);\n        count++;\n    }\n\n\n    \n    public int count() {\n        return count;\n    }\n\n\n    \n    public boolean stronglyConnected(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return id[v] == id[w];\n    }\n\n    \n    public int id(int v) {\n        validateVertex(v);\n        return id[v];\n    }\n\n    private boolean check(Digraph G) {\n        TransitiveClosure tc = new TransitiveClosure(G);\n        for (int v = 0; v < G.V(); v++) {\n            for (int w = 0; w < G.V(); w++) {\n                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n        TarjanSCC scc = new TarjanSCC(G);\n\n        int m = scc.count();\n        StdOut.println(m + \" components\");\n\n        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];\n        for (int i = 0; i < m; i++) {\n            components[i] = new Queue<Integer>();\n        }\n        for (int v = 0; v < G.V(); v++) {\n            components[scc.id(v)].enqueue(v);\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int v : components[i]) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class FloydWarshall {\n    private boolean hasNegativeCycle;  // is there a negative cycle?\n    private double[][] distTo;         // distTo[v][w] = length of shortest v->w path\n    private DirectedEdge[][] edgeTo;   // edgeTo[v][w] = last edge on shortest v->w path\n\n    \n    public FloydWarshall(AdjMatrixEdgeWeightedDigraph G) {\n        int V = G.V();\n        distTo = new double[V][V];\n        edgeTo = new DirectedEdge[V][V];\n\n        for (int v = 0; v < V; v++) {\n            for (int w = 0; w < V; w++) {\n                distTo[v][w] = Double.POSITIVE_INFINITY;\n            }\n        }\n\n        for (int v = 0; v < G.V(); v++) {\n            for (DirectedEdge e : G.adj(v)) {\n                distTo[e.from()][e.to()] = e.weight();\n                edgeTo[e.from()][e.to()] = e;\n            }\n            if (distTo[v][v] >= 0.0) {\n                distTo[v][v] = 0.0;\n                edgeTo[v][v] = null;\n            }\n        }\n\n        for (int i = 0; i < V; i++) {\n            for (int v = 0; v < V; v++) {\n                if (edgeTo[v][i] == null) continue;  // optimization\n                for (int w = 0; w < V; w++) {\n                    if (distTo[v][w] > distTo[v][i] + distTo[i][w]) {\n                        distTo[v][w] = distTo[v][i] + distTo[i][w];\n                        edgeTo[v][w] = edgeTo[i][w];\n                    }\n                }\n                if (distTo[v][v] < 0.0) {\n                    hasNegativeCycle = true;\n                    return;\n                }\n            }\n        }\n        assert check(G);\n    }\n\n    \n    public boolean hasNegativeCycle() {\n        return hasNegativeCycle;\n    }\n\n    \n    public Iterable<DirectedEdge> negativeCycle() {\n        for (int v = 0; v < distTo.length; v++) {\n            if (distTo[v][v] < 0.0) {\n                int V = edgeTo.length;\n                EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);\n                for (int w = 0; w < V; w++)\n                    if (edgeTo[v][w] != null)\n                        spt.addEdge(edgeTo[v][w]);\n                EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);\n                assert finder.hasCycle();\n                return finder.cycle();\n            }\n        }\n        return null;\n    }\n\n    \n    public boolean hasPath(int s, int t) {\n        validateVertex(s);\n        validateVertex(t);\n        return distTo[s][t] < Double.POSITIVE_INFINITY;\n    }\n\n    \n    public double dist(int s, int t) {\n        validateVertex(s);\n        validateVertex(t);\n        if (hasNegativeCycle())\n            throw new UnsupportedOperationException(\"Negative cost cycle exists\");\n        return distTo[s][t];\n    }\n\n    \n    public Iterable<DirectedEdge> path(int s, int t) {\n        validateVertex(s);\n        validateVertex(t);\n        if (hasNegativeCycle())\n            throw new UnsupportedOperationException(\"Negative cost cycle exists\");\n        if (!hasPath(s, t)) return null;\n        Stack<DirectedEdge> path = new Stack<DirectedEdge>();\n        for (DirectedEdge e = edgeTo[s][t]; e != null; e = edgeTo[s][e.from()]) {\n            path.push(e);\n        }\n        return path;\n    }\n\n    private boolean check(AdjMatrixEdgeWeightedDigraph G) {\n\n        if (!hasNegativeCycle()) {\n            for (int v = 0; v < G.V(); v++) {\n                for (DirectedEdge e : G.adj(v)) {\n                    int w = e.to();\n                    for (int i = 0; i < G.V(); i++) {\n                        if (distTo[i][w] > distTo[i][v] + e.weight()) {\n                            System.err.println(\"edge \" + e + \" is eligible\");\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = distTo.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n        AdjMatrixEdgeWeightedDigraph G = new AdjMatrixEdgeWeightedDigraph(V);\n        for (int i = 0; i < E; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = Math.round(100 * (StdRandom.uniform() - 0.15)) / 100.0;\n            if (v == w) G.addEdge(new DirectedEdge(v, w, Math.abs(weight)));\n            else G.addEdge(new DirectedEdge(v, w, weight));\n        }\n\n        StdOut.println(G);\n\n        FloydWarshall spt = new FloydWarshall(G);\n\n        StdOut.printf(\"  \");\n        for (int v = 0; v < G.V(); v++) {\n            StdOut.printf(\"%6d \", v);\n        }\n        StdOut.println();\n        for (int v = 0; v < G.V(); v++) {\n            StdOut.printf(\"%3d: \", v);\n            for (int w = 0; w < G.V(); w++) {\n                if (spt.hasPath(v, w)) StdOut.printf(\"%6.2f \", spt.dist(v, w));\n                else StdOut.printf(\"  Inf \");\n            }\n            StdOut.println();\n        }\n\n        if (spt.hasNegativeCycle()) {\n            StdOut.println(\"Negative cost cycle:\");\n            for (DirectedEdge e : spt.negativeCycle())\n                StdOut.println(e);\n            StdOut.println();\n        }\n\n        else {\n            for (int v = 0; v < G.V(); v++) {\n                for (int w = 0; w < G.V(); w++) {\n                    if (spt.hasPath(v, w)) {\n                        StdOut.printf(\"%d to %d (%5.2f)  \", v, w, spt.dist(v, w));\n                        for (DirectedEdge e : spt.path(v, w))\n                            StdOut.print(e + \"  \");\n                        StdOut.println();\n                    }\n                    else {\n                        StdOut.printf(\"%d to %d no path\\n\", v, w);\n                    }\n                }\n            }\n        }\n\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class Bag<Item> implements Iterable<Item> {\n    private Node<Item> first;    // beginning of bag\n    private int n;               // number of elements in bag\n\n    private static class Node<Item> {\n        private Item item;\n        private Node<Item> next;\n    }\n\n    \n    public Bag() {\n        first = null;\n        n = 0;\n    }\n\n    \n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public void add(Item item) {\n        Node<Item> oldfirst = first;\n        first = new Node<Item>();\n        first.item = item;\n        first.next = oldfirst;\n        n++;\n    }\n\n\n    \n    public Iterator<Item> iterator()  {\n        return new ListIterator(first);  \n    }\n\n    private class ListIterator implements Iterator<Item> {\n        private Node<Item> current;\n\n        public ListIterator(Node<Item> first) {\n            current = first;\n        }\n\n        public boolean hasNext()  { return current != null;                     }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Item next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            Item item = current.item;\n            current = current.next; \n            return item;\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        Bag<String> bag = new Bag<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            bag.add(item);\n        }\n\n        StdOut.println(\"size of bag = \" + bag.size());\n        for (String s : bag) {\n            StdOut.println(s);\n        }\n    }\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class EulerianCycle {\n    private Stack<Integer> cycle = new Stack<Integer>();  // Eulerian cycle; null if no such cycle\n\n    private static class Edge {\n        private final int v;\n        private final int w;\n        private boolean isUsed;\n\n        public Edge(int v, int w) {\n            this.v = v;\n            this.w = w;\n            isUsed = false;\n        }\n\n        public int other(int vertex) {\n            if      (vertex == v) return w;\n            else if (vertex == w) return v;\n            else throw new IllegalArgumentException(\"Illegal endpoint\");\n        }\n    }\n\n    \n    public EulerianCycle(Graph G) {\n\n        if (G.E() == 0) return;\n\n        for (int v = 0; v < G.V(); v++) \n            if (G.degree(v) % 2 != 0)\n                return;\n\n        Queue<Edge>[] adj = (Queue<Edge>[]) new Queue[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            adj[v] = new Queue<Edge>();\n\n        for (int v = 0; v < G.V(); v++) {\n            int selfLoops = 0;\n            for (int w : G.adj(v)) {\n                if (v == w) {\n                    if (selfLoops % 2 == 0) {\n                        Edge e = new Edge(v, w);\n                        adj[v].enqueue(e);\n                        adj[w].enqueue(e);\n                    }\n                    selfLoops++;\n                }\n                else if (v < w) {\n                    Edge e = new Edge(v, w);\n                    adj[v].enqueue(e);\n                    adj[w].enqueue(e);\n                }\n            }\n        }\n\n        int s = nonIsolatedVertex(G);\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(s);\n\n        cycle = new Stack<Integer>();\n        while (!stack.isEmpty()) {\n            int v = stack.pop();\n            while (!adj[v].isEmpty()) {\n                Edge edge = adj[v].dequeue();\n                if (edge.isUsed) continue;\n                edge.isUsed = true;\n                stack.push(v);\n                v = edge.other(v);\n            }\n            cycle.push(v);\n        }\n\n        if (cycle.size() != G.E() + 1)\n            cycle = null;\n\n        assert certifySolution(G);\n    }\n\n    \n    public Iterable<Integer> cycle() {\n        return cycle;\n    }\n\n    \n    public boolean hasEulerianCycle() {\n        return cycle != null;\n    }\n\n    private static int nonIsolatedVertex(Graph G) {\n        for (int v = 0; v < G.V(); v++)\n            if (G.degree(v) > 0)\n                return v;\n        return -1;\n    }\n\n    \n\n    private static boolean satisfiesNecessaryAndSufficientConditions(Graph G) {\n\n        if (G.E() == 0) return false;\n\n        for (int v = 0; v < G.V(); v++)\n            if (G.degree(v) % 2 != 0)\n                return false;\n\n        int s = nonIsolatedVertex(G);\n        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\n        for (int v = 0; v < G.V(); v++)\n            if (G.degree(v) > 0 && !bfs.hasPathTo(v))\n                return false;\n\n        return true;\n    }\n\n    private boolean certifySolution(Graph G) {\n\n        if (hasEulerianCycle() == (cycle() == null)) return false;\n\n        if (hasEulerianCycle() != satisfiesNecessaryAndSufficientConditions(G)) return false;\n\n        if (cycle == null) return true;\n\n        if (cycle.size() != G.E() + 1) return false;\n\n\n        int first = -1, last = -1;\n        for (int v : cycle()) {\n            if (first == -1) first = v;\n            last = v;\n        }\n        if (first != last) return false;\n\n        return true;\n    }\n\n    private static void unitTest(Graph G, String description) {\n        StdOut.println(description);\n        StdOut.println(\"-------------------------------------\");\n        StdOut.print(G);\n\n        EulerianCycle euler = new EulerianCycle(G);\n\n        StdOut.print(\"Eulerian cycle: \");\n        if (euler.hasEulerianCycle()) {\n            for (int v : euler.cycle()) {\n                StdOut.print(v + \" \");\n            }\n            StdOut.println();\n        }\n        else {\n            StdOut.println(\"none\");\n        }\n        StdOut.println();\n    }\n\n\n    \n    public static void main(String[] args) {\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n\n        Graph G1 = GraphGenerator.eulerianCycle(V, E);\n        unitTest(G1, \"Eulerian cycle\");\n\n        Graph G2 = GraphGenerator.eulerianPath(V, E);\n        unitTest(G2, \"Eulerian path\");\n\n        Graph G3 = new Graph(V);\n        unitTest(G3, \"empty graph\");\n\n        Graph G4 = new Graph(V);\n        int v4 = StdRandom.uniform(V);\n        G4.addEdge(v4, v4);\n        unitTest(G4, \"single self loop\");\n\n        Graph H1 = GraphGenerator.eulerianCycle(V/2, E/2);\n        Graph H2 = GraphGenerator.eulerianCycle(V - V/2, E - E/2);\n        int[] perm = new int[V];\n        for (int i = 0; i < V; i++)\n            perm[i] = i;\n        StdRandom.shuffle(perm);\n        Graph G5 = new Graph(V);\n        for (int v = 0; v < H1.V(); v++)\n            for (int w : H1.adj(v))\n                G5.addEdge(perm[v], perm[w]);\n        for (int v = 0; v < H2.V(); v++)\n            for (int w : H2.adj(v))\n                G5.addEdge(perm[V/2 + v], perm[V/2 + w]);\n        unitTest(G5, \"Union of two disjoint cycles\");\n\n        Graph G6 = GraphGenerator.simple(V, E);\n        unitTest(G6, \"simple graph\");\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class RandomSeq { \n\n    private RandomSeq() { }\n\n\n    \n    public static void main(String[] args) {\n\n        int n = Integer.parseInt(args[0]);\n\n        if (args.length == 1) {\n            for (int i = 0; i < n; i++) {\n                double x = StdRandom.uniform();\n                StdOut.println(x);\n            }\n        }\n\n        else if (args.length == 3) {\n            double lo = Double.parseDouble(args[1]);\n            double hi = Double.parseDouble(args[2]);\n\n            for (int i = 0; i < n; i++) {\n                double x = StdRandom.uniform(lo, hi);\n                StdOut.printf(\"%.2f\\n\", x);\n            }\n        }\n\n        else {\n            throw new IllegalArgumentException(\"Invalid number of arguments\");\n        }\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class FFT {\n\n    private static final Complex ZERO = new Complex(0, 0);\n\n    private FFT() { }\n\n    \n    public static Complex[] fft(Complex[] x) {\n        int n = x.length;\n\n        if (n == 1) {\n            return new Complex[] { x[0] };\n        }\n\n        if (n % 2 != 0) {\n            throw new IllegalArgumentException(\"n is not a power of 2\");\n        }\n\n        Complex[] even = new Complex[n/2];\n        for (int k = 0; k < n/2; k++) {\n            even[k] = x[2*k];\n        }\n        Complex[] q = fft(even);\n\n        Complex[] odd  = even;  // reuse the array\n        for (int k = 0; k < n/2; k++) {\n            odd[k] = x[2*k + 1];\n        }\n        Complex[] r = fft(odd);\n\n        Complex[] y = new Complex[n];\n        for (int k = 0; k < n/2; k++) {\n            double kth = -2 * k * Math.PI / n;\n            Complex wk = new Complex(Math.cos(kth), Math.sin(kth));\n            y[k]       = q[k].plus(wk.times(r[k]));\n            y[k + n/2] = q[k].minus(wk.times(r[k]));\n        }\n        return y;\n    }\n\n\n    \n    public static Complex[] ifft(Complex[] x) {\n        int n = x.length;\n        Complex[] y = new Complex[n];\n\n        for (int i = 0; i < n; i++) {\n            y[i] = x[i].conjugate();\n        }\n\n        y = fft(y);\n\n        for (int i = 0; i < n; i++) {\n            y[i] = y[i].conjugate();\n        }\n\n        for (int i = 0; i < n; i++) {\n            y[i] = y[i].scale(1.0 / n);\n        }\n\n        return y;\n\n    }\n\n    \n    public static Complex[] cconvolve(Complex[] x, Complex[] y) {\n\n        if (x.length != y.length) {\n            throw new IllegalArgumentException(\"Dimensions don't agree\");\n        }\n\n        int n = x.length;\n\n        Complex[] a = fft(x);\n        Complex[] b = fft(y);\n\n        Complex[] c = new Complex[n];\n        for (int i = 0; i < n; i++) {\n            c[i] = a[i].times(b[i]);\n        }\n\n        return ifft(c);\n    }\n\n    \n    public static Complex[] convolve(Complex[] x, Complex[] y) {\n        Complex[] a = new Complex[2*x.length];\n        for (int i = 0; i < x.length; i++)\n            a[i] = x[i];\n        for (int i = x.length; i < 2*x.length; i++)\n            a[i] = ZERO;\n\n        Complex[] b = new Complex[2*y.length];\n        for (int i = 0; i < y.length; i++)\n            b[i] = y[i];\n        for (int i = y.length; i < 2*y.length; i++)\n            b[i] = ZERO;\n\n        return cconvolve(a, b);\n    }\n\n    private static void show(Complex[] x, String title) {\n        StdOut.println(title);\n        StdOut.println(\"-------------------\");\n        for (int i = 0; i < x.length; i++) {\n            StdOut.println(x[i]);\n        }\n        StdOut.println();\n    }\n\n\n   \n\n    \n    public static void main(String[] args) { \n        int n = Integer.parseInt(args[0]);\n        Complex[] x = new Complex[n];\n\n        for (int i = 0; i < n; i++) {\n            x[i] = new Complex(i, 0);\n            x[i] = new Complex(StdRandom.uniform(-1.0, 1.0), 0);\n        }\n        show(x, \"x\");\n\n        Complex[] y = fft(x);\n        show(y, \"y = fft(x)\");\n\n        Complex[] z = ifft(y);\n        show(z, \"z = ifft(y)\");\n\n        Complex[] c = cconvolve(x, x);\n        show(c, \"c = cconvolve(x, x)\");\n\n        Complex[] d = convolve(x, x);\n        show(d, \"d = convolve(x, x)\");\n    }\n\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\npublic class Date implements Comparable<Date> {\n    private static final int[] DAYS = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n    private final int month;   // month (between 1 and 12)\n    private final int day;     // day   (between 1 and DAYS[month]\n    private final int year;    // year\n\n   \n    public Date(int month, int day, int year) {\n        if (!isValid(month, day, year)) throw new IllegalArgumentException(\"Invalid date\");\n        this.month = month;\n        this.day   = day;\n        this.year  = year;\n    }\n\n    \n    public Date(String date) {\n        String[] fields = date.split(\"/\");\n        if (fields.length != 3) {\n            throw new IllegalArgumentException(\"Invalid date\");\n        }\n        month = Integer.parseInt(fields[0]);\n        day   = Integer.parseInt(fields[1]);\n        year  = Integer.parseInt(fields[2]);\n        if (!isValid(month, day, year)) throw new IllegalArgumentException(\"Invalid date\");\n    }\n\n    \n    public int month() {\n        return month;\n    }\n\n    \n    public int day() {\n        return day;\n    }\n\n    \n    public int year() {\n        return year;\n    }\n\n\n    private static boolean isValid(int m, int d, int y) {\n        if (m < 1 || m > 12)      return false;\n        if (d < 1 || d > DAYS[m]) return false;\n        if (m == 2 && d == 29 && !isLeapYear(y)) return false;\n        return true;\n    }\n\n    private static boolean isLeapYear(int y) {\n        if (y % 400 == 0) return true;\n        if (y % 100 == 0) return false;\n        return y % 4 == 0;\n    }\n\n    \n    public Date next() {\n        if (isValid(month, day + 1, year))    return new Date(month, day + 1, year);\n        else if (isValid(month + 1, 1, year)) return new Date(month + 1, 1, year);\n        else                                  return new Date(1, 1, year + 1);\n    }\n\n    \n    public boolean isAfter(Date that) {\n        return compareTo(that) > 0;\n    }\n\n    \n    public boolean isBefore(Date that) {\n        return compareTo(that) < 0;\n    }\n\n    \n    @Override\n    public int compareTo(Date that) {\n        if (this.year  < that.year)  return -1;\n        if (this.year  > that.year)  return +1;\n        if (this.month < that.month) return -1;\n        if (this.month > that.month) return +1;\n        if (this.day   < that.day)   return -1;\n        if (this.day   > that.day)   return +1;\n        return 0;\n    }\n\n    \n    @Override\n    public String toString() {\n        return month + \"/\" + day + \"/\" + year;\n    }\n\n    \n    @Override\n    public boolean equals(Object other) {\n        if (other == this) return true;\n        if (other == null) return false;\n        if (other.getClass() != this.getClass()) return false;\n        Date that = (Date) other;\n        return (this.month == that.month) && (this.day == that.day) && (this.year == that.year);\n    }\n\n    \n    @Override\n    public int hashCode() {\n        int hash = 17;\n        hash = 31*hash + month;\n        hash = 31*hash + day;\n        hash = 31*hash + year;\n        return hash;\n    }\n\n    \n    public static void main(String[] args) {\n        Date today = new Date(2, 25, 2004);\n        StdOut.println(today);\n        for (int i = 0; i < 10; i++) {\n            today = today.next();\n            StdOut.println(today);\n        }\n\n        StdOut.println(today.isAfter(today.next()));\n        StdOut.println(today.isAfter(today));\n        StdOut.println(today.next().isAfter(today));\n\n\n        Date birthday = new Date(10, 16, 1971);\n        StdOut.println(birthday);\n        for (int i = 0; i < 10; i++) {\n            birthday = birthday.next();\n            StdOut.println(birthday);\n        }\n    }\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class SeparateChainingHashST<Key, Value> {\n    private static final int INIT_CAPACITY = 4;\n\n    private int n;                                // number of key-value pairs\n    private int m;                                // hash table size\n    private SequentialSearchST<Key, Value>[] st;  // array of linked-list symbol tables\n\n\n    \n    public SeparateChainingHashST() {\n        this(INIT_CAPACITY);\n    } \n\n    \n    public SeparateChainingHashST(int m) {\n        this.m = m;\n        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[m];\n        for (int i = 0; i < m; i++)\n            st[i] = new SequentialSearchST<Key, Value>();\n    } \n\n    private void resize(int chains) {\n        SeparateChainingHashST<Key, Value> temp = new SeparateChainingHashST<Key, Value>(chains);\n        for (int i = 0; i < m; i++) {\n            for (Key key : st[i].keys()) {\n                temp.put(key, st[i].get(key));\n            }\n        }\n        this.m  = temp.m;\n        this.n  = temp.n;\n        this.st = temp.st;\n    }\n\n    private int hash(Key key) {\n        return (key.hashCode() & 0x7fffffff) % m;\n    } \n\n    \n    public int size() {\n        return n;\n    } \n\n    \n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    \n    public boolean contains(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    } \n\n    \n    public Value get(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to get() is null\");\n        int i = hash(key);\n        return st[i].get(key);\n    } \n\n    \n    public void put(Key key, Value val) {\n        if (key == null) throw new IllegalArgumentException(\"first argument to put() is null\");\n        if (val == null) {\n            delete(key);\n            return;\n        }\n\n        if (n >= 10*m) resize(2*m);\n\n        int i = hash(key);\n        if (!st[i].contains(key)) n++;\n        st[i].put(key, val);\n    } \n\n    \n    public void delete(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\");\n\n        int i = hash(key);\n        if (st[i].contains(key)) n--;\n        st[i].delete(key);\n\n        if (m > INIT_CAPACITY && n <= 2*m) resize(m/2);\n    } \n\n    public Iterable<Key> keys() {\n        Queue<Key> queue = new Queue<Key>();\n        for (int i = 0; i < m; i++) {\n            for (Key key : st[i].keys())\n                queue.enqueue(key);\n        }\n        return queue;\n    } \n\n\n    \n    public static void main(String[] args) { \n        SeparateChainingHashST<String, Integer> st = new SeparateChainingHashST<String, Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        for (String s : st.keys()) \n            StdOut.println(s + \" \" + st.get(s)); \n\n    }\n\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class LongestRepeatedSubstring {\n\n    private LongestRepeatedSubstring() { }\n\n    \n\n    \n    public static String lrs(String text) {\n        int n = text.length();\n        SuffixArray sa = new SuffixArray(text);\n        String lrs = \"\";\n        for (int i = 1; i < n; i++) {\n            int length = sa.lcp(i);\n            if (length > lrs.length()) {\n                lrs = text.substring(sa.index(i), sa.index(i) + length);\n            }\n        }\n        return lrs;\n    }\n\n    \n    public static void main(String[] args) {\n        String text = StdIn.readAll().replaceAll(\"\\\\s+\", \" \");\n        StdOut.println(\"'\" + lrs(text) + \"'\");\n    }\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class SuffixArrayX {\n    private static final int CUTOFF =  5;   // cutoff to insertion sort (any value between 0 and 12)\n\n    private final char[] text;\n    private final int[] index;   // index[i] = j means text.substring(j) is ith largest suffix\n    private final int n;         // number of characters in text\n\n    \n    public SuffixArrayX(String text) {\n        n = text.length();\n        text = text + '\\0';\n        this.text = text.toCharArray();\n        this.index = new int[n];\n        for (int i = 0; i < n; i++)\n            index[i] = i;\n\n        sort(0, n-1, 0);\n    }\n\n    private void sort(int lo, int hi, int d) { \n\n        if (hi <= lo + CUTOFF) {\n            insertion(lo, hi, d);\n            return;\n        }\n\n        int lt = lo, gt = hi;\n        char v = text[index[lo] + d];\n        int i = lo + 1;\n        while (i <= gt) {\n            char t = text[index[i] + d];\n            if      (t < v) exch(lt++, i++);\n            else if (t > v) exch(i, gt--);\n            else            i++;\n        }\n\n        sort(lo, lt-1, d);\n        if (v > 0) sort(lt, gt, d+1);\n        sort(gt+1, hi, d);\n    }\n\n    private void insertion(int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(index[j], index[j-1], d); j--)\n                exch(j, j-1);\n    }\n\n    private boolean less(int i, int j, int d) {\n        if (i == j) return false;\n        i = i + d;\n        j = j + d;\n        while (i < n && j < n) {\n            if (text[i] < text[j]) return true;\n            if (text[i] > text[j]) return false;\n            i++;\n            j++;\n        }\n        return i > j;\n    }\n\n    private void exch(int i, int j) {\n        int swap = index[i];\n        index[i] = index[j];\n        index[j] = swap;\n    }\n\n    \n    public int length() {\n        return n;\n    }\n\n\n    \n    public int index(int i) {\n        if (i < 0 || i >= n) throw new IllegalArgumentException();\n        return index[i];\n    }\n\n    \n    public int lcp(int i) {\n        if (i < 1 || i >= n) throw new IllegalArgumentException();\n        return lcp(index[i], index[i-1]);\n    }\n\n    private int lcp(int i, int j) {\n        int length = 0;\n        while (i < n && j < n) {\n            if (text[i] != text[j]) return length;\n            i++;\n            j++;\n            length++;\n        }\n        return length;\n    }\n\n    \n    public String select(int i) {\n        if (i < 0 || i >= n) throw new IllegalArgumentException();\n        return new String(text, index[i], n - index[i]);\n    }\n\n    \n    public int rank(String query) {\n        int lo = 0, hi = n - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            int cmp = compare(query, index[mid]);\n            if      (cmp < 0) hi = mid - 1;\n            else if (cmp > 0) lo = mid + 1;\n            else return mid;\n        }\n        return lo;\n    } \n\n    private int compare(String query, int i) {\n        int m = query.length();\n        int j = 0;\n        while (i < n && j < m) {\n            if (query.charAt(j) != text[i]) return query.charAt(j) - text[i];\n            i++;\n            j++;\n\n        }\n        if (i < n) return -1;\n        if (j < m) return +1;\n        return 0;\n    }\n\n\n    \n    public static void main(String[] args) {\n        String s = StdIn.readAll().replaceAll(\"\\n\", \" \").trim();\n        SuffixArrayX suffix1 = new SuffixArrayX(s);\n        SuffixArray suffix2 = new SuffixArray(s);\n        boolean check = true;\n        for (int i = 0; check && i < s.length(); i++) {\n            if (suffix1.index(i) != suffix2.index(i)) {\n                StdOut.println(\"suffix1(\" + i + \") = \" + suffix1.index(i));\n                StdOut.println(\"suffix2(\" + i + \") = \" + suffix2.index(i));\n                String ith = \"\\\"\" + s.substring(suffix1.index(i), Math.min(suffix1.index(i) + 50, s.length())) + \"\\\"\";\n                String jth = \"\\\"\" + s.substring(suffix2.index(i), Math.min(suffix2.index(i) + 50, s.length())) + \"\\\"\";\n                StdOut.println(ith);\n                StdOut.println(jth);\n                check = false;\n            }\n        }\n\n        StdOut.println(\"  i ind lcp rnk  select\");\n        StdOut.println(\"---------------------------\");\n\n        for (int i = 0; i < s.length(); i++) {\n            int index = suffix2.index(i);\n            String ith = \"\\\"\" + s.substring(index, Math.min(index + 50, s.length())) + \"\\\"\";\n            int rank = suffix2.rank(s.substring(index));\n            assert s.substring(index).equals(suffix2.select(i));\n            if (i == 0) {\n                StdOut.printf(\"%3d %3d %3s %3d  %s\\n\", i, index, \"-\", rank, ith);\n            }\n            else {\n                int lcp  = suffix2.lcp(i);\n                StdOut.printf(\"%3d %3d %3d %3d  %s\\n\", i, index, lcp, rank, ith);\n            }\n        }\n    }\n\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class LookupCSV {\n\n    private LookupCSV() { }\n\n    public static void main(String[] args) {\n        int keyField = Integer.parseInt(args[1]);\n        int valField = Integer.parseInt(args[2]);\n\n        ST<String, String> st = new ST<String, String>();\n\n        In in = new In(args[0]);\n        while (in.hasNextLine()) {\n            String line = in.readLine();\n            String[] tokens = line.split(\",\");\n            String key = tokens[keyField];\n            String val = tokens[valField];\n            st.put(key, val);\n        }\n\n        while (!StdIn.isEmpty()) {\n            String s = StdIn.readString();\n            if (st.contains(s)) StdOut.println(st.get(s));\n            else                StdOut.println(\"Not found\");\n        }\n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class LookupIndex { \n\n    private LookupIndex() { }\n\n    public static void main(String[] args) {\n        String filename  = args[0];\n        String separator = args[1];\n        In in = new In(filename);\n\n        ST<String, Queue<String>> st = new ST<String, Queue<String>>();\n        ST<String, Queue<String>> ts = new ST<String, Queue<String>>();\n\n        while (in.hasNextLine()) {\n            String line = in.readLine();\n            String[] fields = line.split(separator);\n            String key = fields[0];\n            for (int i = 1; i < fields.length; i++) {\n                String val = fields[i];\n                if (!st.contains(key)) st.put(key, new Queue<String>());\n                if (!ts.contains(val)) ts.put(val, new Queue<String>());\n                st.get(key).enqueue(val);\n                ts.get(val).enqueue(key);\n            }\n        }\n\n        StdOut.println(\"Done indexing\");\n\n        while (!StdIn.isEmpty()) {\n            String query = StdIn.readLine();\n            if (st.contains(query)) \n                for (String vals : st.get(query))\n                    StdOut.println(\"  \" + vals);\n            if (ts.contains(query)) \n                for (String keys : ts.get(query))\n                    StdOut.println(\"  \" + keys);\n        }\n\n    }\n\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class Edge implements Comparable<Edge> { \n\n    private final int v;\n    private final int w;\n    private final double weight;\n\n    \n    public Edge(int v, int w, double weight) {\n        if (v < 0) throw new IllegalArgumentException(\"vertex index must be a nonnegative integer\");\n        if (w < 0) throw new IllegalArgumentException(\"vertex index must be a nonnegative integer\");\n        if (Double.isNaN(weight)) throw new IllegalArgumentException(\"Weight is NaN\");\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n\n    \n    public double weight() {\n        return weight;\n    }\n\n    \n    public int either() {\n        return v;\n    }\n\n    \n    public int other(int vertex) {\n        if      (vertex == v) return w;\n        else if (vertex == w) return v;\n        else throw new IllegalArgumentException(\"Illegal endpoint\");\n    }\n\n    \n    @Override\n    public int compareTo(Edge that) {\n        return Double.compare(this.weight, that.weight);\n    }\n\n    \n    public String toString() {\n        return String.format(\"%d-%d %.5f\", v, w, weight);\n    }\n\n    \n    public static void main(String[] args) {\n        Edge e = new Edge(12, 34, 5.67);\n        StdOut.println(e);\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class EdgeWeightedDigraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;                // number of vertices in this digraph\n    private int E;                      // number of edges in this digraph\n    private Bag<DirectedEdge>[] adj;    // adj[v] = adjacency list for vertex v\n    private int[] indegree;             // indegree[v] = indegree of vertex v\n    \n    \n    public EdgeWeightedDigraph(int V) {\n        if (V < 0) throw new IllegalArgumentException(\"Number of vertices in a Digraph must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        this.indegree = new int[V];\n        adj = (Bag<DirectedEdge>[]) new Bag[V];\n        for (int v = 0; v < V; v++)\n            adj[v] = new Bag<DirectedEdge>();\n    }\n\n    \n    public EdgeWeightedDigraph(int V, int E) {\n        this(V);\n        if (E < 0) throw new IllegalArgumentException(\"Number of edges in a Digraph must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = 0.01 * StdRandom.uniform(100);\n            DirectedEdge e = new DirectedEdge(v, w, weight);\n            addEdge(e);\n        }\n    }\n\n    \n    public EdgeWeightedDigraph(In in) {\n        this(in.readInt());\n        int E = in.readInt();\n        if (E < 0) throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = in.readInt();\n            int w = in.readInt();\n            validateVertex(v);\n            validateVertex(w);\n            double weight = in.readDouble();\n            addEdge(new DirectedEdge(v, w, weight));\n        }\n    }\n\n    \n    public EdgeWeightedDigraph(EdgeWeightedDigraph G) {\n        this(G.V());\n        this.E = G.E();\n        for (int v = 0; v < G.V(); v++)\n            this.indegree[v] = G.indegree(v);\n        for (int v = 0; v < G.V(); v++) {\n            Stack<DirectedEdge> reverse = new Stack<DirectedEdge>();\n            for (DirectedEdge e : G.adj[v]) {\n                reverse.push(e);\n            }\n            for (DirectedEdge e : reverse) {\n                adj[v].add(e);\n            }\n        }\n    }\n\n    \n    public int V() {\n        return V;\n    }\n\n    \n    public int E() {\n        return E;\n    }\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public void addEdge(DirectedEdge e) {\n        int v = e.from();\n        int w = e.to();\n        validateVertex(v);\n        validateVertex(w);\n        adj[v].add(e);\n        indegree[w]++;\n        E++;\n    }\n\n\n    \n    public Iterable<DirectedEdge> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    \n    public int outdegree(int v) {\n        validateVertex(v);\n        return adj[v].size();\n    }\n\n    \n    public int indegree(int v) {\n        validateVertex(v);\n        return indegree[v];\n    }\n\n    \n    public Iterable<DirectedEdge> edges() {\n        Bag<DirectedEdge> list = new Bag<DirectedEdge>();\n        for (int v = 0; v < V; v++) {\n            for (DirectedEdge e : adj(v)) {\n                list.add(e);\n            }\n        }\n        return list;\n    } \n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" \" + E + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(v + \": \");\n            for (DirectedEdge e : adj[v]) {\n                s.append(e + \"  \");\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);\n        StdOut.println(G);\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\npublic class DirectedDFS {\n    private boolean[] marked;  // marked[v] = true iff v is reachable from source(s)\n    private int count;         // number of vertices reachable from source(s)\n\n    \n    public DirectedDFS(Digraph G, int s) {\n        marked = new boolean[G.V()];\n        validateVertex(s);\n        dfs(G, s);\n    }\n\n    \n    public DirectedDFS(Digraph G, Iterable<Integer> sources) {\n        marked = new boolean[G.V()];\n        validateVertices(sources);\n        for (int v : sources) {\n            if (!marked[v]) dfs(G, v);\n        }\n    }\n\n    private void dfs(Digraph G, int v) { \n        count++;\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w]) dfs(G, w);\n        }\n    }\n\n    \n    public boolean marked(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    \n    public int count() {\n        return count;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    private void validateVertices(Iterable<Integer> vertices) {\n        if (vertices == null) {\n            throw new IllegalArgumentException(\"argument is null\");\n        }\n        int V = marked.length;\n        for (int v : vertices) {\n            if (v < 0 || v >= V) {\n                throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n            }\n        }\n    }\n\n\n    \n    public static void main(String[] args) {\n\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n\n        Bag<Integer> sources = new Bag<Integer>();\n        for (int i = 1; i < args.length; i++) {\n            int s = Integer.parseInt(args[i]);\n            sources.add(s);\n        }\n\n        DirectedDFS dfs = new DirectedDFS(G, sources);\n\n        for (int v = 0; v < G.V(); v++) {\n            if (dfs.marked(v)) StdOut.print(v + \" \");\n        }\n        StdOut.println();\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class BinaryInsertion {\n\n    private BinaryInsertion() { }\n\n    \n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        for (int i = 1; i < n; i++) {\n\n            Comparable v = a[i];\n            int lo = 0, hi = i;\n            while (lo < hi) {\n                int mid = lo + (hi - lo) / 2; \n                if (less(v, a[mid])) hi = mid;\n                else                 lo = mid + 1;\n            }\n\n            for (int j = i; j > lo; --j)\n                a[j] = a[j-1];\n            a[lo] = v;\n        }\n        assert isSorted(a);\n    }\n\n\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n   \n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo+1; i <= hi; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        BinaryInsertion.sort(a);\n        show(a);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\n\n\npublic class UF {\n\n    private int[] parent;  // parent[i] = parent of i\n    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)\n    private int count;     // number of components\n\n    \n    public UF(int n) {\n        if (n < 0) throw new IllegalArgumentException();\n        count = n;\n        parent = new int[n];\n        rank = new byte[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    \n    public int find(int p) {\n        validate(p);\n        while (p != parent[p]) {\n            parent[p] = parent[parent[p]];    // path compression by halving\n            p = parent[p];\n        }\n        return p;\n    }\n\n    \n    public int count() {\n        return count;\n    }\n  \n    \n    public boolean connected(int p, int q) {\n        return find(p) == find(q);\n    }\n  \n    \n    public void union(int p, int q) {\n        int rootP = find(p);\n        int rootQ = find(q);\n        if (rootP == rootQ) return;\n\n        if      (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;\n        else if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;\n        else {\n            parent[rootQ] = rootP;\n            rank[rootP]++;\n        }\n        count--;\n    }\n\n    private void validate(int p) {\n        int n = parent.length;\n        if (p < 0 || p >= n) {\n            throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1));  \n        }\n    }\n\n    \n    public static void main(String[] args) {\n        int n = StdIn.readInt();\n        UF uf = new UF(n);\n        while (!StdIn.isEmpty()) {\n            int p = StdIn.readInt();\n            int q = StdIn.readInt();\n            if (uf.connected(p, q)) continue;\n            uf.union(p, q);\n            StdOut.println(p + \" \" + q);\n        }\n        StdOut.println(uf.count() + \" components\");\n    }\n}\n\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class Whitelist {\n\n    private Whitelist() { }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        int[] white = in.readAllInts();\n        StaticSETofInts set = new StaticSETofInts(white);\n\n        while (!StdIn.isEmpty()) {\n            int key = StdIn.readInt();\n            if (!set.contains(key))\n                StdOut.println(key);\n        }\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\n\npublic class ClosestPair {\n\n    private Point2D best1, best2;\n    private double bestDistance = Double.POSITIVE_INFINITY;\n\n    \n    public ClosestPair(Point2D[] points) {\n        if (points == null) throw new IllegalArgumentException(\"constructor argument is null\");\n        for (int i = 0; i < points.length; i++) {\n            if (points[i] == null) throw new IllegalArgumentException(\"array element \" + i + \" is null\");\n        }\n\n        int n = points.length;\n        if (n <= 1) return;\n\n        Point2D[] pointsByX = new Point2D[n];\n        for (int i = 0; i < n; i++)\n            pointsByX[i] = points[i];\n        Arrays.sort(pointsByX, Point2D.X_ORDER);\n\n        for (int i = 0; i < n-1; i++) {\n            if (pointsByX[i].equals(pointsByX[i+1])) {\n                bestDistance = 0.0;\n                best1 = pointsByX[i];\n                best2 = pointsByX[i+1];\n                return;\n            }\n        }\n\n        Point2D[] pointsByY = new Point2D[n];\n        for (int i = 0; i < n; i++)\n            pointsByY[i] = pointsByX[i];\n\n        Point2D[] aux = new Point2D[n];\n\n        closest(pointsByX, pointsByY, aux, 0, n-1);\n    }\n\n    private double closest(Point2D[] pointsByX, Point2D[] pointsByY, Point2D[] aux, int lo, int hi) {\n        if (hi <= lo) return Double.POSITIVE_INFINITY;\n\n        int mid = lo + (hi - lo) / 2;\n        Point2D median = pointsByX[mid];\n\n        double delta1 = closest(pointsByX, pointsByY, aux, lo, mid);\n        double delta2 = closest(pointsByX, pointsByY, aux, mid+1, hi);\n        double delta = Math.min(delta1, delta2);\n\n        merge(pointsByY, aux, lo, mid, hi);\n\n        int m = 0;\n        for (int i = lo; i <= hi; i++) {\n            if (Math.abs(pointsByY[i].x() - median.x()) < delta)\n                aux[m++] = pointsByY[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = i+1; (j < m) && (aux[j].y() - aux[i].y() < delta); j++) {\n                double distance = aux[i].distanceTo(aux[j]);\n                if (distance < delta) {\n                    delta = distance;\n                    if (distance < bestDistance) {\n                        bestDistance = delta;\n                        best1 = aux[i];\n                        best2 = aux[j];\n                    }\n                }\n            }\n        }\n        return delta;\n    }\n\n    \n    public Point2D either() {\n        return best1;\n    }\n\n    \n    public Point2D other() {\n        return best2;\n    }\n\n    \n    public double distance() {\n        return bestDistance;\n    }\n\n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n    \n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) {\n            if      (i > mid)              a[k] = aux[j++];\n            else if (j > hi)               a[k] = aux[i++];\n            else if (less(aux[j], aux[i])) a[k] = aux[j++];\n            else                           a[k] = aux[i++];\n        }\n    }\n\n\n\n   \n    public static void main(String[] args) {\n        int n = StdIn.readInt();\n        Point2D[] points = new Point2D[n];\n        for (int i = 0; i < n; i++) {\n            double x = StdIn.readDouble();\n            double y = StdIn.readDouble();\n            points[i] = new Point2D(x, y);\n        }\n        ClosestPair closest = new ClosestPair(points);\n        StdOut.println(closest.distance() + \" from \" + closest.either() + \" to \" + closest.other());\n    }\n\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\n\n\npublic class MaxPQ<Key> implements Iterable<Key> {\n    private Key[] pq;                    // store items at indices 1 to n\n    private int n;                       // number of items on priority queue\n    private Comparator<Key> comparator;  // optional comparator\n\n    \n    public MaxPQ(int initCapacity) {\n        pq = (Key[]) new Object[initCapacity + 1];\n        n = 0;\n    }\n\n    \n    public MaxPQ() {\n        this(1);\n    }\n\n    \n    public MaxPQ(int initCapacity, Comparator<Key> comparator) {\n        this.comparator = comparator;\n        pq = (Key[]) new Object[initCapacity + 1];\n        n = 0;\n    }\n\n    \n    public MaxPQ(Comparator<Key> comparator) {\n        this(1, comparator);\n    }\n\n    \n    public MaxPQ(Key[] keys) {\n        n = keys.length;\n        pq = (Key[]) new Object[keys.length + 1];\n        for (int i = 0; i < n; i++)\n            pq[i+1] = keys[i];\n        for (int k = n/2; k >= 1; k--)\n            sink(k);\n        assert isMaxHeap();\n    }\n      \n\n\n    \n    public boolean isEmpty() {\n        return n == 0;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public Key max() {\n        if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\");\n        return pq[1];\n    }\n\n    private void resize(int capacity) {\n        assert capacity > n;\n        Key[] temp = (Key[]) new Object[capacity];\n        for (int i = 1; i <= n; i++) {\n            temp[i] = pq[i];\n        }\n        pq = temp;\n    }\n\n\n    \n    public void insert(Key x) {\n\n        if (n == pq.length - 1) resize(2 * pq.length);\n\n        pq[++n] = x;\n        swim(n);\n        assert isMaxHeap();\n    }\n\n    \n    public Key delMax() {\n        if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\");\n        Key max = pq[1];\n        exch(1, n--);\n        sink(1);\n        pq[n+1] = null;     // to avoid loiteing and help with garbage collection\n        if ((n > 0) && (n == (pq.length - 1) / 4)) resize(pq.length / 2);\n        assert isMaxHeap();\n        return max;\n    }\n\n\n   \n\n    private void swim(int k) {\n        while (k > 1 && less(k/2, k)) {\n            exch(k, k/2);\n            k = k/2;\n        }\n    }\n\n    private void sink(int k) {\n        while (2*k <= n) {\n            int j = 2*k;\n            if (j < n && less(j, j+1)) j++;\n            if (!less(k, j)) break;\n            exch(k, j);\n            k = j;\n        }\n    }\n\n   \n    private boolean less(int i, int j) {\n        if (comparator == null) {\n            return ((Comparable<Key>) pq[i]).compareTo(pq[j]) < 0;\n        }\n        else {\n            return comparator.compare(pq[i], pq[j]) < 0;\n        }\n    }\n\n    private void exch(int i, int j) {\n        Key swap = pq[i];\n        pq[i] = pq[j];\n        pq[j] = swap;\n    }\n\n    private boolean isMaxHeap() {\n        return isMaxHeap(1);\n    }\n\n    private boolean isMaxHeap(int k) {\n        if (k > n) return true;\n        int left = 2*k;\n        int right = 2*k + 1;\n        if (left  <= n && less(k, left))  return false;\n        if (right <= n && less(k, right)) return false;\n        return isMaxHeap(left) && isMaxHeap(right);\n    }\n\n\n   \n\n    \n    public Iterator<Key> iterator() {\n        return new HeapIterator();\n    }\n\n    private class HeapIterator implements Iterator<Key> {\n\n        private MaxPQ<Key> copy;\n\n        public HeapIterator() {\n            if (comparator == null) copy = new MaxPQ<Key>(size());\n            else                    copy = new MaxPQ<Key>(size(), comparator);\n            for (int i = 1; i <= n; i++)\n                copy.insert(pq[i]);\n        }\n\n        public boolean hasNext()  { return !copy.isEmpty();                     }\n        public void remove()      { throw new UnsupportedOperationException();  }\n\n        public Key next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            return copy.delMax();\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        MaxPQ<String> pq = new MaxPQ<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"-\")) pq.insert(item);\n            else if (!pq.isEmpty()) StdOut.print(pq.delMax() + \" \");\n        }\n        StdOut.println(\"(\" + pq.size() + \" left on pq)\");\n    }\n\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\npublic class ThreeSum {\n\n    private ThreeSum() { }\n\n    \n    public static void printAll(int[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (a[i] + a[j] + a[k] == 0) {\n                        StdOut.println(a[i] + \" \" + a[j] + \" \" + a[k]);\n                    }\n                }\n            }\n        }\n    } \n\n    \n    public static int count(int[] a) {\n        int n = a.length;\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (a[i] + a[j] + a[k] == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    } \n\n    \n    public static void main(String[] args)  { \n        In in = new In(args[0]);\n        int[] a = in.readAllInts();\n\n        Stopwatch timer = new Stopwatch();\n        int count = count(a);\n        StdOut.println(\"elapsed time = \" + timer.elapsedTime());\n        StdOut.println(count);\n    } \n} \n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class AcyclicLP {\n    private double[] distTo;          // distTo[v] = distance  of longest s->v path\n    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on longest s->v path\n\n    \n    public AcyclicLP(EdgeWeightedDigraph G, int s) {\n        distTo = new double[G.V()];\n        edgeTo = new DirectedEdge[G.V()];\n\n        validateVertex(s);\n\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = Double.NEGATIVE_INFINITY;\n        distTo[s] = 0.0;\n\n        Topological topological = new Topological(G);\n        if (!topological.hasOrder())\n            throw new IllegalArgumentException(\"Digraph is not acyclic.\");\n        for (int v : topological.order()) {\n            for (DirectedEdge e : G.adj(v))\n                relax(e);\n        }\n    }\n\n    private void relax(DirectedEdge e) {\n        int v = e.from(), w = e.to();\n        if (distTo[w] < distTo[v] + e.weight()) {\n            distTo[w] = distTo[v] + e.weight();\n            edgeTo[w] = e;\n        }       \n    }\n\n    \n    public double distTo(int v) {\n        validateVertex(v);\n        return distTo[v];\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return distTo[v] > Double.NEGATIVE_INFINITY;\n    }\n\n    \n    public Iterable<DirectedEdge> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v)) return null;\n        Stack<DirectedEdge> path = new Stack<DirectedEdge>();\n        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {\n            path.push(e);\n        }\n        return path;\n    }\n\n    private void validateVertex(int v) {\n        int V = distTo.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        int s = Integer.parseInt(args[1]);\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);\n\n        AcyclicLP lp = new AcyclicLP(G, s);\n\n        for (int v = 0; v < G.V(); v++) {\n            if (lp.hasPathTo(v)) {\n                StdOut.printf(\"%d to %d (%.2f)  \", s, v, lp.distTo(v));\n                for (DirectedEdge e : lp.pathTo(v)) {\n                    StdOut.print(e + \"   \");\n                }\n                StdOut.println();\n            }\n            else {\n                StdOut.printf(\"%d to %d         no path\\n\", s, v);\n            }\n        }\n    }\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class Knuth { \n\n    private Knuth() { }\n\n    \n    public static void shuffle(Object[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int r = (int) (Math.random() * (i + 1));\n            Object swap = a[r];\n            a[r] = a[i];\n            a[i] = swap;\n        }\n    }\n\n    \n    public static void shuffleAlternate(Object[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            Object swap = a[r];\n            a[r] = a[i];\n            a[i] = swap;\n        }\n    }\n\n    \n    public static void main(String[] args) {\n\n        String[] a = StdIn.readAllStrings();\n\n        Knuth.shuffle(a);\n\n        for (int i = 0; i < a.length; i++)\n            StdOut.println(a[i]);\n    }\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class GREP {\n\n    private GREP() { }\n\n    \n    public static void main(String[] args) { \n        String regexp = \"(.*\" + args[0] + \".*)\";\n        NFA nfa = new NFA(regexp);\n        while (StdIn.hasNextLine()) { \n            String line = StdIn.readLine();\n            if (nfa.recognizes(line)) {\n                StdOut.println(line);\n            }\n        }\n    } \n} \n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\n\npublic class Selection {\n\n    private Selection() { }\n\n    \n    public static void sort(Comparable[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int min = i;\n            for (int j = i+1; j < n; j++) {\n                if (less(a[j], a[min])) min = j;\n            }\n            exch(a, i, min);\n            assert isSorted(a, 0, i);\n        }\n        assert isSorted(a);\n    }\n\n    \n    public static void sort(Object[] a, Comparator comparator) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int min = i;\n            for (int j = i+1; j < n; j++) {\n                if (less(comparator, a[j], a[min])) min = j;\n            }\n            exch(a, i, min);\n            assert isSorted(a, comparator, 0, i);\n        }\n        assert isSorted(a, comparator);\n    }\n\n\n   \n    \n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n\n    private static boolean less(Comparator comparator, Object v, Object w) {\n        return comparator.compare(v, w) < 0;\n    }\n        \n        \n    private static void exch(Object[] a, int i, int j) {\n        Object swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n\n\n   \n\n    private static boolean isSorted(Comparable[] a) {\n        return isSorted(a, 0, a.length - 1);\n    }\n        \n    private static boolean isSorted(Comparable[] a, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++)\n            if (less(a[i], a[i-1])) return false;\n        return true;\n    }\n\n    private static boolean isSorted(Object[] a, Comparator comparator) {\n        return isSorted(a, comparator, 0, a.length - 1);\n    }\n\n    private static boolean isSorted(Object[] a, Comparator comparator, int lo, int hi) {\n        for (int i = lo + 1; i <= hi; i++)\n            if (less(comparator, a[i], a[i-1])) return false;\n        return true;\n    }\n\n\n\n    private static void show(Comparable[] a) {\n        for (int i = 0; i < a.length; i++) {\n            StdOut.println(a[i]);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        String[] a = StdIn.readAllStrings();\n        Selection.sort(a);\n        show(a);\n    }\n}\n\n\n", "nl": "2_SORTING"}
{"code": "\n\n\n\n\npublic class AdjMatrixEdgeWeightedDigraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;\n    private int E;\n    private DirectedEdge[][] adj;\n    \n    \n    public AdjMatrixEdgeWeightedDigraph(int V) {\n        if (V < 0) throw new IllegalArgumentException(\"number of vertices must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        this.adj = new DirectedEdge[V][V];\n    }\n\n    \n    public AdjMatrixEdgeWeightedDigraph(int V, int E) {\n        this(V);\n        if (E < 0) throw new IllegalArgumentException(\"number of edges must be nonnegative\");\n        if (E > V*V) throw new IllegalArgumentException(\"too many edges\");\n\n        while (this.E != E) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double weight = Math.round(100 * StdRandom.uniform()) / 100.0;\n            addEdge(new DirectedEdge(v, w, weight));\n        }\n    }\n\n    \n    public int V() {\n        return V;\n    }\n\n    \n    public int E() {\n        return E;\n    }\n\n    \n    public void addEdge(DirectedEdge e) {\n        int v = e.from();\n        int w = e.to();\n        validateVertex(v);\n        validateVertex(w);\n        if (adj[v][w] == null) {\n            E++;\n            adj[v][w] = e;\n        }\n    }\n\n    \n    public Iterable<DirectedEdge> adj(int v) {\n        validateVertex(v);\n        return new AdjIterator(v);\n    }\n\n    private class AdjIterator implements Iterator<DirectedEdge>, Iterable<DirectedEdge> {\n        private int v;\n        private int w = 0;\n\n        public AdjIterator(int v) {\n            this.v = v;\n        }\n\n        public Iterator<DirectedEdge> iterator() {\n            return this;\n        }\n\n        public boolean hasNext() {\n            while (w < V) {\n                if (adj[v][w] != null) return true;\n                w++;\n            }\n            return false;\n        }\n\n        public DirectedEdge next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return adj[v][w++];\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" \" + E + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(v + \": \");\n            for (DirectedEdge e : adj(v)) {\n                s.append(e + \"  \");\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n\n    \n    public static void main(String[] args) {\n        int V = Integer.parseInt(args[0]);\n        int E = Integer.parseInt(args[1]);\n        AdjMatrixEdgeWeightedDigraph G = new AdjMatrixEdgeWeightedDigraph(V, E);\n        StdOut.println(G);\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class Count {\n\n    private Count() { }\n\n    \n    public static void main(String[] args) {\n        Alphabet alphabet = new Alphabet(args[0]);\n        final int R = alphabet.radix();\n        int[] count = new int[R];\n        while (StdIn.hasNextChar()) {\n            char c = StdIn.readChar();\n            if (alphabet.contains(c))\n                count[alphabet.toIndex(c)]++;\n        }\n        for (int c = 0; c < R; c++)\n            StdOut.println(alphabet.toChar(c) + \" \" + count[c]);\n    }\n}\n\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class GlobalMincut {\n    private static final double FLOATING_POINT_EPSILON = 1E-11;\n\n    private double weight = Double.POSITIVE_INFINITY;\n\n    private boolean[] cut;\n\n    private int V;\n\n    \n    private class CutPhase {\n        private double weight; // the weight of the minimum s-t cut\n        private int s;         // the vertex s\n        private int t;         // the vertex t\n\n        public CutPhase(double weight, int s, int t) {\n            this.weight = weight;\n            this.s = s;\n            this.t = t;\n        }\n    }\n\n    \n    public GlobalMincut(EdgeWeightedGraph G) {\n        V = G.V();\n        validate(G);\n        minCut(G, 0);\n        assert check(G);\n    }\n\n    \n    private void validate(EdgeWeightedGraph G) {\n        if (G.V() < 2) throw new IllegalArgumentException(\"number of vertices of G is less than 2\");\n        for (Edge e : G.edges()) {\n            if (e.weight() < 0) throw new IllegalArgumentException(\"edge \" + e + \" has negative weight\");\n        }\n    }\n\n    \n    public double weight() {\n        return weight;\n    }\n\n    \n    public boolean cut(int v) {\n        validateVertex(v);\n        return cut[v];\n    }\n\n    \n    private void makeCut(int t, UF uf) {\n        for (int v = 0; v < cut.length; v++) {\n            cut[v] = uf.connected(v, t);\n        }\n    }\n\n    \n    private void minCut(EdgeWeightedGraph G, int a) {\n        UF uf = new UF(G.V());\n        boolean[] marked = new boolean[G.V()];\n        cut = new boolean[G.V()];\n        CutPhase cp = new CutPhase(0.0, a, a);\n        for (int v = G.V(); v > 1; v--) {\n            cp = minCutPhase(G, marked, cp);\n            if (cp.weight < weight) {\n                weight = cp.weight;\n                makeCut(cp.t, uf);\n            }\n            G = contractEdge(G, cp.s, cp.t);\n            marked[cp.t] = true;\n            uf.union(cp.s, cp.t);\n        }\n    }\n\n    \n    private CutPhase minCutPhase(EdgeWeightedGraph G, boolean[] marked, CutPhase cp) {\n        IndexMaxPQ<Double> pq = new IndexMaxPQ<Double>(G.V());\n        for (int v = 0; v < G.V(); v++) {\n            if (v != cp.s && !marked[v]) pq.insert(v, 0.0);\n        }\n        pq.insert(cp.s, Double.POSITIVE_INFINITY);\n        while (!pq.isEmpty()) {\n            int v = pq.delMax();\n            cp.s = cp.t;\n            cp.t = v;\n            for (Edge e : G.adj(v)) {\n                int w = e.other(v);\n                if (pq.contains(w)) pq.increaseKey(w, pq.keyOf(w) + e.weight());\n            }\n        }\n        cp.weight = 0.0;\n        for (Edge e : G.adj(cp.t)) {\n            cp.weight += e.weight();\n        }\n        return cp;\n    }\n\n    \n    private EdgeWeightedGraph contractEdge(EdgeWeightedGraph G, int s, int t) {\n        EdgeWeightedGraph H = new EdgeWeightedGraph(G.V());\n        for (int v = 0; v < G.V(); v++) {\n            for (Edge e : G.adj(v)) {\n                int w = e.other(v);\n                if (v == s && w == t || v == t && w == s) continue;\n                if (v < w) {\n                    if (w == t)      H.addEdge(new Edge(v, s, e.weight()));\n                    else if (v == t) H.addEdge(new Edge(w, s, e.weight()));\n                    else             H.addEdge(new Edge(v, w, e.weight()));\n                }\n            }\n        }\n        return H;\n    }\n\n    \n    private boolean check(EdgeWeightedGraph G) {\n\n        double value = Double.POSITIVE_INFINITY;\n        for (int s = 0, t = 1; t < G.V(); t++) {\n            FlowNetwork F = new FlowNetwork(G.V());\n            for (Edge e : G.edges()) {\n                int v = e.either(), w = e.other(v);\n                F.addEdge(new FlowEdge(v, w, e.weight()));\n                F.addEdge(new FlowEdge(w, v, e.weight()));\n            }\n            FordFulkerson maxflow = new FordFulkerson(F, s, t);\n            value = Math.min(value, maxflow.value());\n        }\n        if (Math.abs(weight - value) > FLOATING_POINT_EPSILON) {\n            System.err.println(\"Min cut weight = \" + weight + \" , max flow value = \" + value);\n            return false;\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedGraph G = new EdgeWeightedGraph(in);\n        GlobalMincut mc = new GlobalMincut(G);\n        StdOut.print(\"Min cut: \");\n        for (int v = 0; v < G.V(); v++) {\n            if (mc.cut(v)) StdOut.print(v + \" \");\n        }\n        StdOut.println();\n        StdOut.println(\"Min cut weight = \" + mc.weight());\n    }\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class QuickUnionUF {\n    private int[] parent;  // parent[i] = parent of i\n    private int count;     // number of components\n\n    \n    public QuickUnionUF(int n) {\n        parent = new int[n];\n        count = n;\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    \n    public int count() {\n        return count;\n    }\n  \n    \n    public int find(int p) {\n        validate(p);\n        while (p != parent[p])\n            p = parent[p];\n        return p;\n    }\n\n    private void validate(int p) {\n        int n = parent.length;\n        if (p < 0 || p >= n) {\n            throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1));\n        }\n    }\n\n    \n    public boolean connected(int p, int q) {\n        return find(p) == find(q);\n    }\n\n  \n    \n    public void union(int p, int q) {\n        int rootP = find(p);\n        int rootQ = find(q);\n        if (rootP == rootQ) return;\n        parent[rootP] = rootQ; \n        count--;\n    }\n\n    \n    public static void main(String[] args) {\n        int n = StdIn.readInt();\n        QuickUnionUF uf = new QuickUnionUF(n);\n        while (!StdIn.isEmpty()) {\n            int p = StdIn.readInt();\n            int q = StdIn.readInt();\n            if (uf.connected(p, q)) continue;\n            uf.union(p, q);\n            StdOut.println(p + \" \" + q);\n        }\n        StdOut.println(uf.count() + \" components\");\n    }\n\n\n}\n\n\n", "nl": "1_FUNDAMENTALS"}
{"code": "\n\n\n\npublic class LinearProbingHashST<Key, Value> {\n    private static final int INIT_CAPACITY = 4;\n\n    private int n;           // number of key-value pairs in the symbol table\n    private int m;           // size of linear probing table\n    private Key[] keys;      // the keys\n    private Value[] vals;    // the values\n\n\n    \n    public LinearProbingHashST() {\n        this(INIT_CAPACITY);\n    }\n\n    \n    public LinearProbingHashST(int capacity) {\n        m = capacity;\n        n = 0;\n        keys = (Key[])   new Object[m];\n        vals = (Value[]) new Object[m];\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    \n    public boolean contains(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    private int hash(Key key) {\n        return (key.hashCode() & 0x7fffffff) % m;\n    }\n\n    private void resize(int capacity) {\n        LinearProbingHashST<Key, Value> temp = new LinearProbingHashST<Key, Value>(capacity);\n        for (int i = 0; i < m; i++) {\n            if (keys[i] != null) {\n                temp.put(keys[i], vals[i]);\n            }\n        }\n        keys = temp.keys;\n        vals = temp.vals;\n        m    = temp.m;\n    }\n\n    \n    public void put(Key key, Value val) {\n        if (key == null) throw new IllegalArgumentException(\"first argument to put() is null\");\n\n        if (val == null) {\n            delete(key);\n            return;\n        }\n\n        if (n >= m/2) resize(2*m);\n\n        int i;\n        for (i = hash(key); keys[i] != null; i = (i + 1) % m) {\n            if (keys[i].equals(key)) {\n                vals[i] = val;\n                return;\n            }\n        }\n        keys[i] = key;\n        vals[i] = val;\n        n++;\n    }\n\n    \n    public Value get(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to get() is null\");\n        for (int i = hash(key); keys[i] != null; i = (i + 1) % m)\n            if (keys[i].equals(key))\n                return vals[i];\n        return null;\n    }\n\n    \n    public void delete(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\");\n        if (!contains(key)) return;\n\n        int i = hash(key);\n        while (!key.equals(keys[i])) {\n            i = (i + 1) % m;\n        }\n\n        keys[i] = null;\n        vals[i] = null;\n\n        i = (i + 1) % m;\n        while (keys[i] != null) {\n            Key   keyToRehash = keys[i];\n            Value valToRehash = vals[i];\n            keys[i] = null;\n            vals[i] = null;\n            n--;\n            put(keyToRehash, valToRehash);\n            i = (i + 1) % m;\n        }\n\n        n--;\n\n        if (n > 0 && n <= m/8) resize(m/2);\n\n        assert check();\n    }\n\n    \n    public Iterable<Key> keys() {\n        Queue<Key> queue = new Queue<Key>();\n        for (int i = 0; i < m; i++)\n            if (keys[i] != null) queue.enqueue(keys[i]);\n        return queue;\n    }\n\n    private boolean check() {\n\n        if (m < 2*n) {\n            System.err.println(\"Hash table size m = \" + m + \"; array size n = \" + n);\n            return false;\n        }\n\n        for (int i = 0; i < m; i++) {\n            if (keys[i] == null) continue;\n            else if (get(keys[i]) != vals[i]) {\n                System.err.println(\"get[\" + keys[i] + \"] = \" + get(keys[i]) + \"; vals[i] = \" + vals[i]);\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    \n    public static void main(String[] args) { \n        LinearProbingHashST<String, Integer> st = new LinearProbingHashST<String, Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        for (String s : st.keys()) \n            StdOut.println(s + \" \" + st.get(s)); \n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class Topological {\n    private Iterable<Integer> order;  // topological order\n    private int[] rank;               // rank[v] = rank of vertex v in order\n\n    \n    public Topological(Digraph G) {\n        DirectedCycle finder = new DirectedCycle(G);\n        if (!finder.hasCycle()) {\n            DepthFirstOrder dfs = new DepthFirstOrder(G);\n            order = dfs.reversePost();\n            rank = new int[G.V()];\n            int i = 0;\n            for (int v : order)\n                rank[v] = i++;\n        }\n    }\n\n    \n    public Topological(EdgeWeightedDigraph G) {\n        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(G);\n        if (!finder.hasCycle()) {\n            DepthFirstOrder dfs = new DepthFirstOrder(G);\n            order = dfs.reversePost();\n        }\n    }\n\n    \n    public Iterable<Integer> order() {\n        return order;\n    }\n\n    \n    public boolean hasOrder() {\n        return order != null;\n    }\n\n    \n    @Deprecated\n    public boolean isDAG() {\n        return hasOrder();\n    }\n\n    \n    public int rank(int v) {\n        validateVertex(v);\n        if (hasOrder()) return rank[v];\n        else            return -1;\n    }\n\n    private void validateVertex(int v) {\n        int V = rank.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        String filename  = args[0];\n        String delimiter = args[1];\n        SymbolDigraph sg = new SymbolDigraph(filename, delimiter);\n        Topological topological = new Topological(sg.digraph());\n        for (int v : topological.order()) {\n            StdOut.println(sg.nameOf(v));\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class DijkstraUndirectedSP {\n    private double[] distTo;          // distTo[v] = distance  of shortest s->v path\n    private Edge[] edgeTo;            // edgeTo[v] = last edge on shortest s->v path\n    private IndexMinPQ<Double> pq;    // priority queue of vertices\n\n    \n    public DijkstraUndirectedSP(EdgeWeightedGraph G, int s) {\n        for (Edge e : G.edges()) {\n            if (e.weight() < 0)\n                throw new IllegalArgumentException(\"edge \" + e + \" has negative weight\");\n        }\n\n        distTo = new double[G.V()];\n        edgeTo = new Edge[G.V()];\n\n        validateVertex(s);\n\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = Double.POSITIVE_INFINITY;\n        distTo[s] = 0.0;\n\n        pq = new IndexMinPQ<Double>(G.V());\n        pq.insert(s, distTo[s]);\n        while (!pq.isEmpty()) {\n            int v = pq.delMin();\n            for (Edge e : G.adj(v))\n                relax(e, v);\n        }\n\n        assert check(G, s);\n    }\n\n    private void relax(Edge e, int v) {\n        int w = e.other(v);\n        if (distTo[w] > distTo[v] + e.weight()) {\n            distTo[w] = distTo[v] + e.weight();\n            edgeTo[w] = e;\n            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);\n            else                pq.insert(w, distTo[w]);\n        }\n    }\n\n    \n    public double distTo(int v) {\n        validateVertex(v);\n        return distTo[v];\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return distTo[v] < Double.POSITIVE_INFINITY;\n    }\n\n    \n    public Iterable<Edge> pathTo(int v) {\n        validateVertex(v);\n        if (!hasPathTo(v)) return null;\n        Stack<Edge> path = new Stack<Edge>();\n        int x = v;\n        for (Edge e = edgeTo[v]; e != null; e = edgeTo[x]) {\n            path.push(e);\n            x = e.other(x);\n        }\n        return path;\n    }\n\n\n    private boolean check(EdgeWeightedGraph G, int s) {\n\n        for (Edge e : G.edges()) {\n            if (e.weight() < 0) {\n                System.err.println(\"negative edge weight detected\");\n                return false;\n            }\n        }\n\n        if (distTo[s] != 0.0 || edgeTo[s] != null) {\n            System.err.println(\"distTo[s] and edgeTo[s] inconsistent\");\n            return false;\n        }\n        for (int v = 0; v < G.V(); v++) {\n            if (v == s) continue;\n            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {\n                System.err.println(\"distTo[] and edgeTo[] inconsistent\");\n                return false;\n            }\n        }\n\n        for (int v = 0; v < G.V(); v++) {\n            for (Edge e : G.adj(v)) {\n                int w = e.other(v);\n                if (distTo[v] + e.weight() < distTo[w]) {\n                    System.err.println(\"edge \" + e + \" not relaxed\");\n                    return false;\n                }\n            }\n        }\n\n        for (int w = 0; w < G.V(); w++) {\n            if (edgeTo[w] == null) continue;\n            Edge e = edgeTo[w];\n            if (w != e.either() && w != e.other(e.either())) return false;\n            int v = e.other(w);\n            if (distTo[v] + e.weight() != distTo[w]) {\n                System.err.println(\"edge \" + e + \" on shortest path not tight\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void validateVertex(int v) {\n        int V = distTo.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        EdgeWeightedGraph G = new EdgeWeightedGraph(in);\n        int s = Integer.parseInt(args[1]);\n\n        DijkstraUndirectedSP sp = new DijkstraUndirectedSP(G, s);\n\n\n        for (int t = 0; t < G.V(); t++) {\n            if (sp.hasPathTo(t)) {\n                StdOut.printf(\"%d to %d (%.2f)  \", s, t, sp.distTo(t));\n                for (Edge e : sp.pathTo(t)) {\n                    StdOut.print(e + \"   \");\n                }\n                StdOut.println();\n            }\n            else {\n                StdOut.printf(\"%d to %d         no path\\n\", s, t);\n            }\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class FlowNetwork {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private final int V;\n    private int E;\n    private Bag<FlowEdge>[] adj;\n    \n    \n    public FlowNetwork(int V) {\n        if (V < 0) throw new IllegalArgumentException(\"Number of vertices in a Graph must be nonnegative\");\n        this.V = V;\n        this.E = 0;\n        adj = (Bag<FlowEdge>[]) new Bag[V];\n        for (int v = 0; v < V; v++)\n            adj[v] = new Bag<FlowEdge>();\n    }\n\n    \n    public FlowNetwork(int V, int E) {\n        this(V);\n        if (E < 0) throw new IllegalArgumentException(\"Number of edges must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = StdRandom.uniform(V);\n            int w = StdRandom.uniform(V);\n            double capacity = StdRandom.uniform(100);\n            addEdge(new FlowEdge(v, w, capacity));\n        }\n    }\n\n    \n    public FlowNetwork(In in) {\n        this(in.readInt());\n        int E = in.readInt();\n        if (E < 0) throw new IllegalArgumentException(\"number of edges must be nonnegative\");\n        for (int i = 0; i < E; i++) {\n            int v = in.readInt();\n            int w = in.readInt();\n            validateVertex(v);\n            validateVertex(w);\n            double capacity = in.readDouble();\n            addEdge(new FlowEdge(v, w, capacity));\n        }\n    }\n\n\n    \n    public int V() {\n        return V;\n    }\n\n    \n    public int E() {\n        return E;\n    }\n\n    private void validateVertex(int v) {\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public void addEdge(FlowEdge e) {\n        int v = e.from();\n        int w = e.to();\n        validateVertex(v);\n        validateVertex(w);\n        adj[v].add(e);\n        adj[w].add(e);\n        E++;\n    }\n\n    \n    public Iterable<FlowEdge> adj(int v) {\n        validateVertex(v);\n        return adj[v];\n    }\n\n    public Iterable<FlowEdge> edges() {\n        Bag<FlowEdge> list = new Bag<FlowEdge>();\n        for (int v = 0; v < V; v++)\n            for (FlowEdge e : adj(v)) {\n                if (e.to() != v)\n                    list.add(e);\n            }\n        return list;\n    }\n\n\n    \n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(V + \" \" + E + NEWLINE);\n        for (int v = 0; v < V; v++) {\n            s.append(v + \":  \");\n            for (FlowEdge e : adj[v]) {\n                if (e.to() != v) s.append(e + \"  \");\n            }\n            s.append(NEWLINE);\n        }\n        return s.toString();\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        FlowNetwork G = new FlowNetwork(in);\n        StdOut.println(G);\n    }\n\n}\n\n\n", "nl": "6_CONTEXT"}
{"code": "\n\n\n\npublic class FarthestPair {\n\n    private Point2D best1, best2;\n    private double bestDistanceSquared = Double.NEGATIVE_INFINITY;\n\n    \n    public FarthestPair(Point2D[] points) {\n        if (points == null) throw new IllegalArgumentException(\"constructor argument is null\");\n        for (int i = 0; i < points.length; i++) {\n            if (points[i] == null) throw new IllegalArgumentException(\"array element \" + i + \" is null\");\n        }\n\n        GrahamScan graham = new GrahamScan(points);\n\n        if (points.length <= 1) return;\n\n        int m = 0;\n        for (Point2D p : graham.hull())\n            m++;\n\n        Point2D[] hull = new Point2D[m+1];\n        m = 1;\n        for (Point2D p : graham.hull()) {\n            hull[m++] = p;\n        }\n        m--;\n\n        if (m == 1) return;\n\n        if (m == 2) {\n            best1 = hull[1];\n            best2 = hull[2];\n            bestDistanceSquared = best1.distanceSquaredTo(best2);\n            return;\n        }\n\n        int k = 2;\n        while (Point2D.area2(hull[m], hull[1], hull[k+1]) > Point2D.area2(hull[m], hull[1], hull[k])) {\n            k++;\n        }\n\n        int j = k;\n        for (int i = 1; i <= k && j <= m; i++) {\n            if (hull[i].distanceSquaredTo(hull[j]) > bestDistanceSquared) {\n                best1 = hull[i];\n                best2 = hull[j];\n                bestDistanceSquared = hull[i].distanceSquaredTo(hull[j]);\n            }\n            while ((j < m) && Point2D.area2(hull[i], hull[i+1], hull[j+1]) > Point2D.area2(hull[i], hull[i+1], hull[j])) {\n                j++;\n                double distanceSquared = hull[i].distanceSquaredTo(hull[j]);\n                if (distanceSquared > bestDistanceSquared) {\n                    best1 = hull[i];\n                    best2 = hull[j];\n                    bestDistanceSquared = hull[i].distanceSquaredTo(hull[j]);\n                }\n            }\n        }\n    }\n\n    \n    public Point2D either() {\n        return best1;\n    }\n\n    \n    public Point2D other() {\n        return best2;\n    }\n\n    \n    public double distance() {\n        return Math.sqrt(bestDistanceSquared);\n    }\n\n   \n    public static void main(String[] args) {\n        int n = StdIn.readInt();\n        Point2D[] points = new Point2D[n];\n        for (int i = 0; i < n; i++) {\n            int x = StdIn.readInt();\n            int y = StdIn.readInt();\n            points[i] = new Point2D(x, y);\n        }\n        FarthestPair farthest = new FarthestPair(points);\n        StdOut.println(farthest.distance() + \" from \" + farthest.either() + \" to \" + farthest.other());\n    }\n\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\npublic class TrieST<Value> {\n    private static final int R = 256;        // extended ASCII\n\n\n    private Node root;      // root of trie\n    private int n;          // number of keys in trie\n\n    private static class Node {\n        private Object val;\n        private Node[] next = new Node[R];\n    }\n\n   \n    public TrieST() {\n    }\n\n\n    \n    public Value get(String key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to get() is null\");\n        Node x = get(root, key, 0);\n        if (x == null) return null;\n        return (Value) x.val;\n    }\n\n    \n    public boolean contains(String key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to contains() is null\");\n        return get(key) != null;\n    }\n\n    private Node get(Node x, String key, int d) {\n        if (x == null) return null;\n        if (d == key.length()) return x;\n        char c = key.charAt(d);\n        return get(x.next[c], key, d+1);\n    }\n\n    \n    public void put(String key, Value val) {\n        if (key == null) throw new IllegalArgumentException(\"first argument to put() is null\");\n        if (val == null) delete(key);\n        else root = put(root, key, val, 0);\n    }\n\n    private Node put(Node x, String key, Value val, int d) {\n        if (x == null) x = new Node();\n        if (d == key.length()) {\n            if (x.val == null) n++;\n            x.val = val;\n            return x;\n        }\n        char c = key.charAt(d);\n        x.next[c] = put(x.next[c], key, val, d+1);\n        return x;\n    }\n\n    \n    public int size() {\n        return n;\n    }\n\n    \n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    \n    public Iterable<String> keys() {\n        return keysWithPrefix(\"\");\n    }\n\n    \n    public Iterable<String> keysWithPrefix(String prefix) {\n        Queue<String> results = new Queue<String>();\n        Node x = get(root, prefix, 0);\n        collect(x, new StringBuilder(prefix), results);\n        return results;\n    }\n\n    private void collect(Node x, StringBuilder prefix, Queue<String> results) {\n        if (x == null) return;\n        if (x.val != null) results.enqueue(prefix.toString());\n        for (char c = 0; c < R; c++) {\n            prefix.append(c);\n            collect(x.next[c], prefix, results);\n            prefix.deleteCharAt(prefix.length() - 1);\n        }\n    }\n\n    \n    public Iterable<String> keysThatMatch(String pattern) {\n        Queue<String> results = new Queue<String>();\n        collect(root, new StringBuilder(), pattern, results);\n        return results;\n    }\n\n    private void collect(Node x, StringBuilder prefix, String pattern, Queue<String> results) {\n        if (x == null) return;\n        int d = prefix.length();\n        if (d == pattern.length() && x.val != null)\n            results.enqueue(prefix.toString());\n        if (d == pattern.length())\n            return;\n        char c = pattern.charAt(d);\n        if (c == '.') {\n            for (char ch = 0; ch < R; ch++) {\n                prefix.append(ch);\n                collect(x.next[ch], prefix, pattern, results);\n                prefix.deleteCharAt(prefix.length() - 1);\n            }\n        }\n        else {\n            prefix.append(c);\n            collect(x.next[c], prefix, pattern, results);\n            prefix.deleteCharAt(prefix.length() - 1);\n        }\n    }\n\n    \n    public String longestPrefixOf(String query) {\n        if (query == null) throw new IllegalArgumentException(\"argument to longestPrefixOf() is null\");\n        int length = longestPrefixOf(root, query, 0, -1);\n        if (length == -1) return null;\n        else return query.substring(0, length);\n    }\n\n    private int longestPrefixOf(Node x, String query, int d, int length) {\n        if (x == null) return length;\n        if (x.val != null) length = d;\n        if (d == query.length()) return length;\n        char c = query.charAt(d);\n        return longestPrefixOf(x.next[c], query, d+1, length);\n    }\n\n    \n    public void delete(String key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to delete() is null\");\n        root = delete(root, key, 0);\n    }\n\n    private Node delete(Node x, String key, int d) {\n        if (x == null) return null;\n        if (d == key.length()) {\n            if (x.val != null) n--;\n            x.val = null;\n        }\n        else {\n            char c = key.charAt(d);\n            x.next[c] = delete(x.next[c], key, d+1);\n        }\n\n        if (x.val != null) return x;\n        for (int c = 0; c < R; c++)\n            if (x.next[c] != null)\n                return x;\n        return null;\n    }\n\n    \n    public static void main(String[] args) {\n\n        TrieST<Integer> st = new TrieST<Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        if (st.size() < 100) {\n            StdOut.println(\"keys(\\\"\\\"):\");\n            for (String key : st.keys()) {\n                StdOut.println(key + \" \" + st.get(key));\n            }\n            StdOut.println();\n        }\n\n        StdOut.println(\"longestPrefixOf(\\\"shellsort\\\"):\");\n        StdOut.println(st.longestPrefixOf(\"shellsort\"));\n        StdOut.println();\n\n        StdOut.println(\"longestPrefixOf(\\\"quicksort\\\"):\");\n        StdOut.println(st.longestPrefixOf(\"quicksort\"));\n        StdOut.println();\n\n        StdOut.println(\"keysWithPrefix(\\\"shor\\\"):\");\n        for (String s : st.keysWithPrefix(\"shor\"))\n            StdOut.println(s);\n        StdOut.println();\n\n        StdOut.println(\"keysThatMatch(\\\".he.l.\\\"):\");\n        for (String s : st.keysThatMatch(\".he.l.\"))\n            StdOut.println(s);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class BinaryDump {\n\n    private BinaryDump() { }\n\n    \n    public static void main(String[] args) {\n        int bitsPerLine = 16;\n        if (args.length == 1) {\n            bitsPerLine = Integer.parseInt(args[0]);\n        }\n\n        int count;\n        for (count = 0; !BinaryStdIn.isEmpty(); count++) {\n            if (bitsPerLine == 0) {\n                BinaryStdIn.readBoolean();\n                continue;\n            }\n            else if (count != 0 && count % bitsPerLine == 0) StdOut.println();\n            if (BinaryStdIn.readBoolean()) StdOut.print(1);\n            else                           StdOut.print(0);\n        }\n        if (bitsPerLine != 0) StdOut.println();\n        StdOut.println(count + \" bits\");\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\npublic class TransitiveClosure {\n    private DirectedDFS[] tc;  // tc[v] = reachable from v\n\n    \n    public TransitiveClosure(Digraph G) {\n        tc = new DirectedDFS[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            tc[v] = new DirectedDFS(G, v);\n    }\n\n    \n    public boolean reachable(int v, int w) {\n        validateVertex(v);\n        validateVertex(w);\n        return tc[v].marked(w);\n    }\n\n    private void validateVertex(int v) {\n        int V = tc.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n\n        TransitiveClosure tc = new TransitiveClosure(G);\n\n        StdOut.print(\"     \");\n        for (int v = 0; v < G.V(); v++)\n            StdOut.printf(\"%3d\", v);\n        StdOut.println();\n        StdOut.println(\"--------------------------------------------\");\n\n        for (int v = 0; v < G.V(); v++) {\n            StdOut.printf(\"%3d: \", v);\n            for (int w = 0; w < G.V(); w++) {\n                if (tc.reachable(v, w)) StdOut.printf(\"  T\");\n                else                    StdOut.printf(\"   \");\n            }\n            StdOut.println();\n        }\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\npublic class FrequencyCounter {\n\n    private FrequencyCounter() { }\n\n    \n    public static void main(String[] args) {\n        int distinct = 0, words = 0;\n        int minlen = Integer.parseInt(args[0]);\n        ST<String, Integer> st = new ST<String, Integer>();\n\n        while (!StdIn.isEmpty()) {\n            String key = StdIn.readString();\n            if (key.length() < minlen) continue;\n            words++;\n            if (st.contains(key)) {\n                st.put(key, st.get(key) + 1);\n            }\n            else {\n                st.put(key, 1);\n                distinct++;\n            }\n        }\n\n        String max = \"\";\n        st.put(max, 0);\n        for (String word : st.keys()) {\n            if (st.get(word) > st.get(max))\n                max = word;\n        }\n\n        StdOut.println(max + \" \" + st.get(max));\n        StdOut.println(\"distinct = \" + distinct);\n        StdOut.println(\"words    = \" + words);\n    }\n}\n\n\n", "nl": "3_SEARCHING"}
{"code": "\n\n\n\npublic class Quick3string {\n    private static final int CUTOFF =  15;   // cutoff to insertion sort\n\n    private Quick3string() { } \n\n    \n    public static void sort(String[] a) {\n        StdRandom.shuffle(a);\n        sort(a, 0, a.length-1, 0);\n        assert isSorted(a);\n    }\n\n    private static int charAt(String s, int d) { \n        assert d >= 0 && d <= s.length();\n        if (d == s.length()) return -1;\n        return s.charAt(d);\n    }\n\n\n    private static void sort(String[] a, int lo, int hi, int d) { \n\n        if (hi <= lo + CUTOFF) {\n            insertion(a, lo, hi, d);\n            return;\n        }\n\n        int lt = lo, gt = hi;\n        int v = charAt(a[lo], d);\n        int i = lo + 1;\n        while (i <= gt) {\n            int t = charAt(a[i], d);\n            if      (t < v) exch(a, lt++, i++);\n            else if (t > v) exch(a, i, gt--);\n            else              i++;\n        }\n\n        sort(a, lo, lt-1, d);\n        if (v >= 0) sort(a, lt, gt, d+1);\n        sort(a, gt+1, hi, d);\n    }\n\n    private static void insertion(String[] a, int lo, int hi, int d) {\n        for (int i = lo; i <= hi; i++)\n            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)\n                exch(a, j, j-1);\n    }\n\n    private static void exch(String[] a, int i, int j) {\n        String temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n\n    private static boolean less(String v, String w, int d) {\n        assert v.substring(0, d).equals(w.substring(0, d));\n        for (int i = d; i < Math.min(v.length(), w.length()); i++) {\n            if (v.charAt(i) < w.charAt(i)) return true;\n            if (v.charAt(i) > w.charAt(i)) return false;\n        }\n        return v.length() < w.length();\n    }\n\n    private static boolean isSorted(String[] a) {\n        for (int i = 1; i < a.length; i++)\n            if (a[i].compareTo(a[i-1]) < 0) return false;\n        return true;\n    }\n\n\n    \n    public static void main(String[] args) {\n\n        String[] a = StdIn.readAllStrings();\n        int n = a.length;\n\n        sort(a);\n\n        for (int i = 0; i < n; i++)\n            StdOut.println(a[i]);\n    }\n}\n\n\n", "nl": "5_STRINGS"}
{"code": "\n\n\n\n\npublic class MultiwayMinPQ<Key> implements Iterable<Key> {\n\tprivate final int d; \t\t\t\t//Dimension of the heap\n\tprivate int n;\t\t\t\t\t\t//Number of keys currently in the heap\n\tprivate int order;\t\t\t\t\t//Number of levels of the tree\n\tprivate Key[] keys;\t\t\t\t\t//Array of keys\n\tprivate final Comparator<Key> comp;\t//Comparator over the keys\n\t\n\t\n    \n\tpublic MultiwayMinPQ(int d) {\n\t\tif (d < 2) throw new IllegalArgumentException(\"Dimension should be 2 or over\");\n\t\tthis.d = d;\n\t\torder = 1;\n\t\tkeys = (Key[]) new Comparable[d << 1];\n\t\tcomp = new MyComparator();\n\t}\n\t\n    \n\tpublic MultiwayMinPQ(Comparator<Key> comparator, int d) {\n\t\tif (d < 2) throw new IllegalArgumentException(\"Dimension should be 2 or over\");\n\t\tthis.d = d;\n\t\torder = 1;\n\t\tkeys = (Key[]) new Comparable[d << 1];\n\t\tcomp = comparator;\n\t}\n\t\n    \n\tpublic MultiwayMinPQ(Key[] a, int d) {\n\t\tif (d < 2) throw new IllegalArgumentException(\"Dimension should be 2 or over\");\n\t\tthis.d = d;\n\t\torder = 1;\n\t\tkeys = (Key[]) new Comparable[d << 1];\n\t\tcomp = new MyComparator();\n\t\tfor (Key key : a) insert(key);\n\t}\n\t\n    \n\tpublic MultiwayMinPQ(Comparator<Key> comparator, Key[] a, int d) {\n\t\tif (d < 2) throw new IllegalArgumentException(\"Dimension should be 2 or over\");\n\t\tthis.d = d;\n\t\torder = 1;\n\t\tkeys = (Key[]) new Comparable[d << 1];\n\t\tcomp = comparator;\n\t\tfor (Key key : a) insert(key);\n\t}\n\n        \n\tpublic boolean isEmpty() {\n\t\treturn n == 0;\n\t}\n\n\t\n\tpublic int size() {\n\t\treturn n;\n\t}\n\n\t\n\tpublic void insert(Key key) {\n\t\tkeys[n+d] = key;\n\t\tswim(n++);\n\t\tif (n == keys.length-d) {\n\t\t\tresize(getN(order+1)+d);\n\t\t\torder++;\n\t\t}\n\t}\n\n\t\n\tpublic Key minKey() {\n\t\tif (isEmpty()) throw new NoSuchElementException(\"Priority queue is empty\");\n\t\treturn keys[d];\n\t}\n\n\t\n\tpublic Key delMin() {\n\t\tif (isEmpty()) throw new NoSuchElementException(\"Priority queue is empty\");\n\t\texch(0, --n);\n\t\tsink(0);\n\t\tKey min = keys[n+d];\n\t\tkeys[n+d] = null;\n\t\tint number = getN(order-2);\n\t\tif(order > 1 && n == number)  {\n\t\t\tresize(number+(int)Math.pow(d, order-1)+d);\n\t\t\torder--;\n\t\t}\n\t\treturn min;\n\t}\n\t\n\t\n\t\n\tprivate boolean greater(int x, int y) {\n\t\tint i = x+d, j = y+d;\n\t\tif (keys[i] == null) return false;\n\t\tif (keys[j] == null) return true;\n\t\treturn comp.compare(keys[i], keys[j]) > 0;\n\t}\n\t\n\tprivate void exch(int x, int y) {\n\t\tint i = x+d, j = y+d;\n\t\tKey swap = keys[i];\n\t\tkeys[i] = keys[j];\n\t\tkeys[j] = swap;\n\t}\n\t\n\tprivate int getN(int order) {\n\t\treturn (1-((int)Math.pow(d, order+1)))/(1-d);\n\t}\n\t\n\t\n\t\n\tprivate void swim(int i) {\n\t\tif (i > 0 && greater((i-1)/d, i)) {\n\t\t\texch(i, (i-1)/d);\n\t\t\tswim((i-1)/d);\n\t\t}\n\t}\n\t\n\tprivate void sink(int i) {\n\t\tint child = d*i+1;\n\t\tif (child >= n) return;\n\t\tint min = minChild(i);\n\t\twhile (min < n && greater(i, min)) {\n\t\t\texch(i, min);\n\t\t\ti = min;\n\t\t\tmin = minChild(i);\n\t\t}\n\t}\n\t\n\t\n\t\n\tprivate int minChild(int i) {\n\t\tint loBound = d*i+1, hiBound = d*i+d;\n\t\tint min = loBound;\n\t\tfor (int cur = loBound; cur <= hiBound; cur++) {\n\t\t\tif (cur < n && greater(min, cur)) min = cur;\n\t\t}\n\t\treturn min;\n\t}\n\t\n\t\n\t\n\tprivate void resize(int N) {\n\t\tKey[] array = (Key[]) new Comparable[N];\n\t\tfor (int i = 0; i < Math.min(keys.length, array.length); i++) {\n\t\t\tarray[i] = keys[i];\n\t\t\tkeys[i] = null;\n\t\t}\n\t\tkeys = array;\n\t}\n\t\n\t\n\t\n\t\n\t\n\tpublic Iterator<Key> iterator() {\n\t\treturn new MyIterator();\n\t}\n\t\n\tprivate class MyIterator implements Iterator<Key> {\n\t\tMultiwayMinPQ<Key> data;\n\t\t\n\t\tpublic MyIterator() {\n\t\t\tdata = new MultiwayMinPQ<Key>(comp, d);\n\t\t\tdata.keys = (Key[]) new Comparable[keys.length];\n\t\t\tdata.n = n;\n\t\t\tfor (int i = 0; i < keys.length; i++) {\n\t\t\t\tdata.keys[i] = keys[i];\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\treturn !data.isEmpty();\n\t\t}\n\t\t\n\t\tpublic Key next() {\n                        if (!hasNext()) throw new NoSuchElementException();\n\t\t\treturn data.delMin();\n\t\t}\n\t\t\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\t\n\t\n\t\n\tprivate class MyComparator implements Comparator<Key> {\n\t\t@Override\n\t\tpublic int compare(Key key1, Key key2) {\n\t\t\treturn ((Comparable<Key>) key1).compareTo(key2);\n\t\t}\n\t}\n\t\n}\n\n\n", "nl": "9_BEYOND"}
{"code": "\n\n\n\npublic class BreadthFirstDirectedPaths {\n    private static final int INFINITY = Integer.MAX_VALUE;\n    private boolean[] marked;  // marked[v] = is there an s->v path?\n    private int[] edgeTo;      // edgeTo[v] = last edge on shortest s->v path\n    private int[] distTo;      // distTo[v] = length of shortest s->v path\n\n    \n    public BreadthFirstDirectedPaths(Digraph G, int s) {\n        marked = new boolean[G.V()];\n        distTo = new int[G.V()];\n        edgeTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = INFINITY;\n        validateVertex(s);\n        bfs(G, s);\n    }\n\n    \n    public BreadthFirstDirectedPaths(Digraph G, Iterable<Integer> sources) {\n        marked = new boolean[G.V()];\n        distTo = new int[G.V()];\n        edgeTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            distTo[v] = INFINITY;\n        validateVertices(sources);\n        bfs(G, sources);\n    }\n\n    private void bfs(Digraph G, int s) {\n        Queue<Integer> q = new Queue<Integer>();\n        marked[s] = true;\n        distTo[s] = 0;\n        q.enqueue(s);\n        while (!q.isEmpty()) {\n            int v = q.dequeue();\n            for (int w : G.adj(v)) {\n                if (!marked[w]) {\n                    edgeTo[w] = v;\n                    distTo[w] = distTo[v] + 1;\n                    marked[w] = true;\n                    q.enqueue(w);\n                }\n            }\n        }\n    }\n\n    private void bfs(Digraph G, Iterable<Integer> sources) {\n        Queue<Integer> q = new Queue<Integer>();\n        for (int s : sources) {\n            marked[s] = true;\n            distTo[s] = 0;\n            q.enqueue(s);\n        }\n        while (!q.isEmpty()) {\n            int v = q.dequeue();\n            for (int w : G.adj(v)) {\n                if (!marked[w]) {\n                    edgeTo[w] = v;\n                    distTo[w] = distTo[v] + 1;\n                    marked[w] = true;\n                    q.enqueue(w);\n                }\n            }\n        }\n    }\n\n    \n    public boolean hasPathTo(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    \n    public int distTo(int v) {\n        validateVertex(v);\n        return distTo[v];\n    }\n\n    \n    public Iterable<Integer> pathTo(int v) {\n        validateVertex(v);\n\n        if (!hasPathTo(v)) return null;\n        Stack<Integer> path = new Stack<Integer>();\n        int x;\n        for (x = v; distTo[x] != 0; x = edgeTo[x])\n            path.push(x);\n        path.push(x);\n        return path;\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    private void validateVertices(Iterable<Integer> vertices) {\n        if (vertices == null) {\n            throw new IllegalArgumentException(\"argument is null\");\n        }\n        int V = marked.length;\n        for (int v : vertices) {\n            if (v < 0 || v >= V) {\n                throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n            }\n        }\n    }\n\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n\n        int s = Integer.parseInt(args[1]);\n        BreadthFirstDirectedPaths bfs = new BreadthFirstDirectedPaths(G, s);\n\n        for (int v = 0; v < G.V(); v++) {\n            if (bfs.hasPathTo(v)) {\n                StdOut.printf(\"%d to %d (%d):  \", s, v, bfs.distTo(v));\n                for (int x : bfs.pathTo(v)) {\n                    if (x == s) StdOut.print(x);\n                    else        StdOut.print(\"->\" + x);\n                }\n                StdOut.println();\n            }\n\n            else {\n                StdOut.printf(\"%d to %d (-):  not connected\\n\", s, v);\n            }\n\n        }\n    }\n\n\n}\n\n\n", "nl": "4_GRAPHS"}
{"code": "\n\n\n\n\npublic class NonrecursiveDirectedDFS {\n    private boolean[] marked;  // marked[v] = is there an s->v path?\n    \n    public NonrecursiveDirectedDFS(Digraph G, int s) {\n        marked = new boolean[G.V()];\n        validateVertex(s);\n\n        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];\n        for (int v = 0; v < G.V(); v++)\n            adj[v] = G.adj(v).iterator();\n\n        Stack<Integer> stack = new Stack<Integer>();\n        marked[s] = true;\n        stack.push(s);\n        while (!stack.isEmpty()) {\n            int v = stack.peek();\n            if (adj[v].hasNext()) {\n                int w = adj[v].next();\n                if (!marked[w]) {\n                    marked[w] = true;\n                    stack.push(w);\n                }\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n\n    \n    public boolean marked(int v) {\n        validateVertex(v);\n        return marked[v];\n    }\n\n    private void validateVertex(int v) {\n        int V = marked.length;\n        if (v < 0 || v >= V)\n            throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V-1));\n    }\n\n    \n    public static void main(String[] args) {\n        In in = new In(args[0]);\n        Digraph G = new Digraph(in);\n        int s = Integer.parseInt(args[1]);\n        NonrecursiveDirectedDFS dfs = new NonrecursiveDirectedDFS(G, s);\n        for (int v = 0; v < G.V(); v++)\n            if (dfs.marked(v))\n                StdOut.print(v + \" \");\n        StdOut.println();\n    }\n\n}\n\n\n", "nl": "4_GRAPHS"}

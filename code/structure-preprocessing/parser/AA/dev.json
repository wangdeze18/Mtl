{"code": "public class LinkedListCycle2 {\n\tpublic boolean hasCycle(ListNode head) {\n\t\tSet<ListNode> nodesSeen = new HashSet<>();\n\t\twhile (head != null) {\n\t\t\tif (nodesSeen.contains(head)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tnodesSeen.add(head);\n\t\t\t}\n\t\t\thead = head.next;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MedianofTwoSortedArrays2 {\n\tpublic double findMedianSortedArrays(int A[], int B[]) {\n        int k = A.length + B.length;\n        return k % 2 == 0 ?  (findK(A, 0, A.length - 1, B, 0, B.length - 1, k/2 + 1) + \n        findK(A, 0, A.length - 1, B, 0, B.length - 1, k/2)) / 2\n        : findK(A, 0, A.length - 1, B, 0, B.length - 1, k/2 + 1);\n    }\n \n    public double findK(int a[], int s1, int e1, int b[], int s2, int e2, int k) {\n        int m = e1 - s1 + 1;\n        int n = e2 - s2 + 1;\n        if (m > n) return findK(b, s2, e2, a, s1, e1, k); \n        if (s1 > e1) return b[s2 + k - 1]; \n        if (s2 > e2) return a[s1 + k - 1];\n        if (k == 1) return Math.min(a[s1], b[s2]);\n        int midA = Math.min(k/2, m), midB = k - midA; \n  \n        if (a[s1 + midA - 1] < b[s2 + midB - 1]) \n            return findK(a, s1 + midA, e1, b, s2, e2, k - midA);\n        else if (a[s1 + midA - 1] > b[s2 + midB - 1]) \n            return findK(a, s1, e1, b, s2 + midB, e2, k - midB);\n        else\n            return a[s1 + midA - 1];\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<Integer> preorderTraversal_1(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if(root == null) return res;\n        res.add(root.val);\n        List<Integer> left = preorderTraversal(root.left);\n        List<Integer> right = preorderTraversal(root.right);\n        res.addAll(left);\n        res.addAll(right);\n        return res;\n    }\n    public void preorderTraversalRe(TreeNode root, List<Integer> res) {\n        if (root == null) return;\n        res.add(root.val);\n        preorderTraversalRe(root.left, res);\n        preorderTraversalRe(root.right, res);\n    }\n    public List<Integer> preorderTraversal_2(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if(root == null) return res;\n        preorderTraversalRe(root, res);\n        return res;\n    }\n    public List<Integer> preorderTraversal_3(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if(root == null) return res;\n        Stack<TreeNode> stk = new Stack<TreeNode>();\n        stk.push(root);\n        while (stk.isEmpty() == false) {\n            TreeNode cur = stk.pop();\n            res.add(cur.val);\n            if (cur.right != null) stk.push(cur.right);\n            if (cur.left != null) stk.push(cur.left);\n        }\n        return res;\n    }\n    public List<Integer> preorderTraversal_4(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if(root == null) return res;\n        Stack<TreeNode> stk = new Stack<TreeNode>();\n        TreeNode cur = root;\n        while (stk.isEmpty() == false || cur != null) {\n            if (cur != null) {\n                stk.push(cur);\n                res.add(cur.val);\n                cur = cur.left;\n            } else {\n                cur = stk.pop();\n                cur = cur.right;\n            }\n        }\n        return res;\n    }\n    public List<Integer> preorderTraversal_5(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if(root == null) return res;\n        TreeNode cur = root;\n        while (cur) {\n            if (cur.left == null) {\n                res.add(cur.val);\n                cur = cur.right;\n            } else {\n                TreeNode node = cur.left;\n                while (node.right != null && node.right != cur)\n                    node = node.right;\n                if (node == null) {\n                    node.right = cur;\n                    res.add(cur.val);\n                    cur = cur.left;\n                } else {\n                    node.right = null;\n                    cur = cur.right;\n                }\n            }\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class CombinationSum3 {\n\n  public static void main(String[] args) {\n    CombinationSum3 cs = new CombinationSum3();\n    System.out.println(cs.combinationSum3(3, 7));\n    System.out.println(cs.combinationSum3(3, 9));\n  }\n\n  public List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> ans = new ArrayList<>();\n    backtrack(ans, new ArrayList<>(), k, 1, n);\n    return ans;\n  }\n\n  private void backtrack(List<List<Integer>> ans, List<Integer> comb, int k, int start, int n) {\n    if (comb.size() > k) return; // no need to search in k+1 numbers\n\n    if (comb.size() == k && n == 0) { // combination found\n      List<Integer> res = new ArrayList<>(comb); // make a copy of the list\n      ans.add(res);\n      return;\n    }\n\n    for (int i = start; i <= 9; i++) {\n      if (n - i >= 0) { // n < i can be skipped\n        comb.add(i);\n        backtrack(ans, comb, k, i + 1, n - i);\n        comb.remove(comb.size() - 1);\n      }\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class SymmetricTree {\n\n  static class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n\n  \n  public static void main(String[] args) throws Exception {\n    TreeNode node = new TreeNode(3);\n    node.left = new TreeNode(4);\n    node.right = new TreeNode(5);\n    System.out.println(new SymmetricTree().isSymmetric(node));\n  }\n\n  public boolean isSymmetric(TreeNode root) {\n    if (root == null) return true;\n    return dfs(root.left, root.right);\n  }\n\n  private boolean dfs(TreeNode left, TreeNode right) {\n    if (left == null && right == null) return true;\n    else if (left == null || right == null) return false;\n    return dfs(left.left, right.right) && left.val == right.val && dfs(left.right, right.left);\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class CombinationSum \n{\n\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) \n    {\n\t\tList<List<Integer>> allCombs = new LinkedList<>();\n\t\tLinkedList<Integer> oneComb = new LinkedList<>();\n\t\t\n\t\tgenerateCombs( allCombs, oneComb, candidates, 0, target );\n\t\t\n\t\treturn allCombs;\n    }\n\t\n\tprivate void generateCombs( List<List<Integer>> allCombs, LinkedList<Integer> oneComb, int[] nums, int startPos, int targetSum )\n\t{\n\t\tif ( targetSum < 0 \n\t\t\t\t|| startPos >= nums.length )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ( targetSum == 0 )\n\t\t{\n\t\t\tallCombs.add( new LinkedList<>( oneComb ) );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor ( int i = startPos; i < nums.length; i++ )\n\t\t{\n\t\t\toneComb.addLast( nums[i] );\n\t\t\tgenerateCombs( allCombs, oneComb, nums, i, targetSum - nums[i] );\n\t\t\toneComb.removeLast( );\n\t\t}\n\t}\n}", "nl": "FreemanZhang"}
{"code": "public class Combinations2 {\n\n}\n", "nl": "gaohannk"}
{"code": "public class rotateImage\n{\n    public void rotate( int[][] matrix )\n    {\n\t\tint n = matrix.length;\n\t\tfor ( int i = 0; i < n / 2; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < Math.ceil( ( ( double ) n ) / 2. ); j++ )\n\t\t\t{\n\t\t\t\tint temp = matrix[i][j];\n\t\t\t\tmatrix[i][j] = matrix[n - 1 - j][i];\n\t\t\t\tmatrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\n\t\t\t\tmatrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\n\t\t\t\tmatrix[j][n - 1 - i] = temp;\n\t\t\t}\n\t\t}\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class WordBreak {\n\n    \n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> words = new HashSet<>(wordDict);\n        boolean[] breakable = new boolean[s.length() + 1];\n        breakable[0] = true;\n        for (int i = 1; i < breakable.length; i++) {\n            for (int j = i; j >= 0; j--) {\n                if (breakable[j] && words.contains(s.substring(j, i))) {\n                    breakable[i] = true;\n                    break; // Pruning. Found one is enough.\n                }\n            }\n        }\n        return breakable[s.length()];\n    }\n\n    \n    public boolean wordBreak2(String s, List<String> wordDict) {\n        return wordBreak(s, new HashSet<>(wordDict), new HashSet<String>());\n    }\n\n    private boolean wordBreak(String s, Set<String> words, Set<String> unbreakable) {\n        if (words.contains(s)) return true;\n        if (unbreakable.contains(s)) return false;\n        for (int i = 1; i <= s.length(); i++) {\n            String pre = s.substring(0, i);\n            if (words.contains(pre)) {\n                if (i == s.length()) {\n                    words.add(s);\n                    return true;\n                }\n                if (wordBreak(s.substring(i), words, unbreakable)) {\n                    words.add(s.substring(i));\n                    return true;\n                }\n            } else {\n                unbreakable.add(pre);\n            }\n        }\n        return false;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int numDecodings(String s) {\n        if (s.length() == 0 || s.charAt(0) == '0') return 0;\n        int N = s.length();\n        int f0 = 1, f1 = 1;\n        for (int i = 1; i < N; ++i) {\n            if (s.charAt(i) == '0') f1 = 0;\n            int num = s.charAt(i) - '0' + (s.charAt(i-1) - '0') * 10;\n            if (num < 10 || num > 26) {\n                f0 = 0;\n            }\n            int tmp = f1;\n            f1 = f1 + f0;\n            f0 = tmp;\n        }\n        return f1;\n    }\n}", "nl": "leetcoders"}
{"code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return \"\";\n        }\n        \n        Arrays.sort(strs);\n        String head = strs[0];\n        String tail = strs[strs.length - 1];\n        \n        int size = head.length() < tail.length() ? head.length() : tail.length();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < size; i++) {\n            if (head.charAt(i) != tail.charAt(i)) {\n                break;\n            }\n            sb.append(head.charAt(i));\n        }\n        return sb.toString();\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n        int n = prices.length;\n        int[] dp = new int[n + 1]; // min value up to first i items\n        dp[0] = Integer.MAX_VALUE;\n        int profit = 0;\n        for (int i = 1; i <= n; i++) {\n            dp[i] = Math.min(dp[i - 1], prices[i - 1]);\n            profit = Math.max(profit, prices[i - 1] - dp[i]);\n        }\n        return profit;\n    }\n}", "nl": "awangdev"}
{"code": "public class TrappingRainWater4 {\n    public int trap(int[] A) {\n        int ans = 0, current = 0;\n        Stack<Integer> st = new Stack<>();\n        while (current < A.length) {\n            while (!st.empty() && A[current] > A[st.peek()]) {\n                int top = st.pop();\n                if (st.empty())\n                    break;\n                int distance = current - st.peek() - 1;\n                int bounded_height = Math.min(A[current], A[st.peek()]) - A[top];\n                ans += distance * bounded_height;\n            }\n            st.push(current++);\n        }\n        return ans;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class L080_Remove_Duplicates_from_Sorted_Array_II {\n\n\tpublic int removeDuplicates(int[] nums) {\n\n\t\tint cur = 2;\n\t\tfor (int i = cur; i < nums.length; i++) {\n\t\t\tif (!(nums[i] == nums[cur - 1] && nums[i] == nums[cur - 2])) {\n\t\t\t\tnums[cur++] = nums[i];\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(cur, nums.length);\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class SymmetricTree\n{\n\tpublic boolean isSymmetricIterative( TreeNode root )\n\t{\n\t\tif ( root == null ) return true;\n\t\tQueue<TreeNode> leftFirst = new LinkedList<>();\n\t\tQueue<TreeNode> rightFirst = new LinkedList<>();\n\t\tleftFirst.add( root );\n\t\trightFirst.add( root );\n\t\twhile ( !leftFirst.isEmpty() && !rightFirst.isEmpty() )\n\t\t{\n\t\t\tTreeNode left = leftFirst.poll();\n\t\t\tTreeNode right = rightFirst.poll();\n\t\t\tif ( left == null && right != null \n\t\t\t\t\t|| left != null && right == null )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( left != null && right != null )\n\t\t\t{\n\t\t\t\tif ( left.val != right.val )\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tleftFirst.add( left.left );\n\t\t\t\tleftFirst.add( left.right );\n\t\t\t\trightFirst.add( right.right );\n\t\t\t\trightFirst.add( right.left );\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n    public boolean isSymmetric( TreeNode root )\n    {\n    \tif ( root == null )\n    \t{\n    \t\treturn true;\n    \t}\n    \t\n    \treturn isSymmetricRecurse( root.left, root.right );\n    }\n    \n    private boolean isSymmetricRecurse( TreeNode left, TreeNode right )\n    {\n    \tif ( left == null || right == null )\n    \t{\n    \t\treturn left == right;\n    \t}\n    \treturn left.val == right.val && isSymmetricRecurse( left.left, right.right ) && isSymmetricRecurse( left.right, right.left );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class L062_Unique_Paths {\n\n\tpublic int uniquePaths(int m, int n) {\n\n\t\tif (m <= 0 || n <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint[][] dp = new int[m][n];\n\n\t\tfor (int y = 1; y < n; y++) {\n\t\t\tdp[0][y] = 1;\n\t\t}\n\n\t\tfor (int x = 1; x < m; x++) {\n\t\t\tdp[x][0] = 1;\n\t\t}\n\n\t\tfor (int y = 1; y < n; y++) {\n\t\t\tfor (int x = 1; x < m; x++) {\n\t\t\t\tdp[x][y] = dp[x - 1][y] + dp[x][y - 1];\n\t\t\t}\n\t\t}\n\n\t\treturn dp[m - 1][n - 1];\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n        ArrayList<Interval> res = new ArrayList<Interval>();        \n        Interval pre= new Interval(newInterval.start,newInterval.end);\n        \n        boolean inserted = false;\n        int i=0;\n        while(i<intervals.size() || !inserted){\n            if(i<intervals.size()){\n                Interval current= intervals.get(i);\n                if(inserted)\n                    res.add(current);\n                else if(current.end<pre.start)\n                    res.add(current);\n                else if(isOverlap(current,pre)){\n                    pre.start = Math.min(current.start,pre.start);\n                    pre.end = Math.max(current.end,pre.end);\n                }\n                 else{\n                     res.add(pre);\n                     res.add(current);\n                     inserted=true;\n                 }\n            }else{\n                res.add(pre);\n                inserted=true;\n            }\n                \n            i++;\n                \n        }     \n        return res;\n\n\n    }\n    public boolean isOverlap(Interval a, Interval b){\n    \treturn !(b.start>a.end || a.start> b.end);\n    }\n}\t", "nl": "azheanda"}
{"code": "public class MultiplyStrings {\n\tpublic String multiply(String num1, String num2) {\n\n\t\tif ((num1.equals(\"\")) || (num2.equals(\"\")) || (!num1.matches(\"[0-9]+\"))\n\t\t\t\t|| (!num2.matches(\"[0-9]+\")))\n\t\t\treturn \"\";\n\t\t\n\t\tint[] output = new int[num1.length() + num2.length()];\n\t\t\n\t\tfor (int i = num1.length() - 1; i >= 0; i--) {\n\t\t\t\n\t\t\tint carryM = 0;\n\t\t\tint carryS = 0;\n\t\t\t\n\t\t\tfor (int j = num2.length() - 1; j >= 0; j--) {\n\t\t\t\tint m1 = Integer.parseInt(num1.substring(i, i + 1));\n\t\t\t\tint m2 = Integer.parseInt(num2.substring(j, j + 1));\n\t\t\t\tint mult = (m1 * m2) + carryM;\n\t\t\t\tcarryM = mult / 10;\n\t\t\t\tint rest = mult % 10;\n\n\t\t\t\tint inc = output[j + i + 1] + rest + carryS;\n\t\t\t\toutput[j + i + 1] = inc % 10;\n\t\t\t\tcarryS = inc / 10;\n\t\t\t}\n\t\t\toutput[i] = carryM + carryS;\n\t\t}\n\t\t\n\t\tStringBuilder out = new StringBuilder();\n\t\tboolean firstZeros = true;\n\t\tfor (int i = 0; i < output.length; i++) {\n\t\t\tif ((output[i] == 0) && (i != output.length - 1)) {\n\t\t\t\tif (!firstZeros)\n\t\t\t\t\tout.append(output[i]);\n\t\t\t} else {\n\t\t\t\tout.append(output[i]);\n\t\t\t\tfirstZeros = false;\n\t\t\t}\n\t\t}\n\n\t\treturn out.toString();\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L153_Find_Minimum_in_Rotated_Sorted_Array {\n\n\tpublic int findMin(int[] nums) {\n\n\t\tif (nums.length == 1) {\n\t\t\treturn nums[0];\n\t\t}\n\n\t\tif (nums.length == 2) {\n\t\t\treturn Math.min(nums[0], nums[1]);\n\t\t}\n\n\t\tint s = 0, e = nums.length - 1;\n\n\t\tint m = (s + e) / 2;\n\n\t\tif (nums[s] < nums[e]) {\n\t\t\treturn nums[s];\n\t\t}\n\n\t\tif (nums[m] > nums[s]) {\n\t\t\treturn findMin(Arrays.copyOfRange(nums, m + 1, e + 1));\n\t\t}\n\n\t\treturn findMin(Arrays.copyOfRange(nums, s, m + 1));\n\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class GasStation {\n\tpublic int canCompleteCircuit(int[] gas, int[] cost) {\n\t\tif(gas==null||gas.length<=1)\n\t\t\treturn 0;\n\t\tfor (int i = 0; i < gas.length; i++) {\n\t\t\tint start = i;\n\t\t\tint end=i-1;\n\t\t\tif(i==0)\n\t\t\t\tend=gas.length-1;\n\t\t\tint totalgas = 0;\n\t\t\tint totalcost = 0;\n\t\t\twhile (start != end) {\n\t\t\t\ttotalgas += gas[start];\n\t\t\t\ttotalcost += cost[start];\n\t\t\t\tif (totalgas < totalcost)\n\t\t\t\t\tbreak;\n\t\t\t\tstart = (start + 1) % gas.length;\n\t\t\t}\n\t\t\tif (start == end)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null) return false;\n        if (root.left == null && root.right == null) return sum == root.val;\n        return hasPathSum(root.left, sum - root.val) || \n               hasPathSum(root.right, sum - root.val);\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int numDecodings(String s) {\n        if (s.length()==0) {\n            return 0;\n        }\n        Map<String,Integer> map=new HashMap<String, Integer>();\n        return f(s,map);\n    }\n    public int f(String s,Map<String,Integer> map){\n        if (s.length()==0) {\n            return 1;\n        }\n        if (map.get(s)==null) {\n            int length=s.length();\n            int one=-1;\n            if (length>=1) {\n                one=Integer.parseInt(s.substring(0,1));\n            }\n            int two=-1;\n            if (length>=2) {\n                two=Integer.parseInt(s.substring(0,2));\n            }\n            int value=(one>0?f(s.substring(1,s.length()),map):0)+((one>0&&two>0&&two<27)?f(s.substring(2,s.length()),map):0);\n            map.put(s, value);\n            return value;\n        }\n        return map.get(s);\n    }\n}", "nl": "corpsepiges"}
{"code": "public class HIndex\n{\n\n    public int hIndex( int[] citations )\n    {\n    \tint startPos = 0;\n    \tint endPos = citations.length;\n   \t\n    \twhile ( startPos + 1 < endPos )\n    \t{\n    \t\tint midPos = ( endPos - startPos ) / 2 + startPos;\n    \t\tint numQualified = calcNumPapersWithHigherCitations( citations, midPos );\n    \t\tif ( numQualified < midPos )\n    \t\t{\n    \t\t\tendPos = midPos;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tstartPos = midPos;\n    \t\t}\n    \t}\n    \t\n    \tint numQualified = calcNumPapersWithHigherCitations( citations, endPos );\n    \tif ( numQualified == endPos )\n    \t{\n    \t\treturn endPos;\n    \t}\n    \telse\n    \t{\n    \t\treturn startPos;\n    \t}\n    }\n\n    private int calcNumPapersWithHigherCitations( int[] citations, int target )\n    {\n    \tint numQualifiedPapers = 0;\n    \tfor ( int num : citations )\n    \t{\n    \t\tif ( num >= target )\n    \t\t{\n    \t\t\tnumQualifiedPapers++;\n    \t\t}\n    \t}\n    \treturn numQualifiedPapers;\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertEquals( 1, hIndex( new int[]{ 1, 1 } ) );\n    \tassertEquals( 3, hIndex( new int[]{ 3, 0, 6, 1, 5} ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class ReverseLinkedList \n{\n\t@Test\n\tpublic void testIterative()\n\t{\n\t\tListNode node1 = new ListNode( 1 );\n\t\tListNode node2 = new ListNode( 2 );\n\t\tListNode node3 = new ListNode( 3 );\n\t\tListNode node4 = new ListNode( 4 );\n\t\tListNode node5 = new ListNode( 5 );\n\t\tListNode node6 = new ListNode( 6 );\n\t\tnode1.next = node2;\n\t\tnode2.next = node3;\n\t\tnode3.next = node4;\n\t\tnode4.next = node5;\n\t\tnode5.next = node6;\n\t\tprintList( reverseSinglyLinkedListIteratively( node1 ) );\n\t}\n\t\n\t@Test\n\tpublic void testRecursive()\n\t{\n\t\tListNode node1 = new ListNode( 1 );\n\t\tListNode node2 = new ListNode( 2 );\n\t\tListNode node3 = new ListNode( 3 );\n\t\tListNode node4 = new ListNode( 4 );\n\t\tListNode node5 = new ListNode( 5 );\n\t\tListNode node6 = new ListNode( 6 );\n\t\tnode1.next = node2;\n\t\tnode2.next = node3;\n\t\tnode3.next = node4;\n\t\tnode4.next = node5;\n\t\tnode5.next = node6;\n\t\tprintList( reverseSinglyLinkedListRecursively( node1 ) );\t\t\n\t}\n\t\n\tprivate void printList( ListNode head )\n\t{\n\t\tListNode currNode = head;\n\t\twhile ( currNode != null )\n\t\t{\n\t\t\tSystem.out.print( currNode.val + \"->\");\n\t\t\tcurrNode = currNode.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n    public ListNode reverseSinglyLinkedListRecursively( ListNode head )\n    {\n    \tif ( head == null || head.next == null )\n    \t{\n    \t\treturn head;\n    \t}\n    \t\n    \tListNode reversedListTail = head.next;\n    \tListNode reversedListHead = reverseSinglyLinkedListRecursively( head.next );\n    \treversedListTail.next = head;\n    \thead.next = null;\n    \t\n    \treturn reversedListHead;\n    }\n    \n    public ListNode reverseSinglyLinkedListIteratively( ListNode head )\n    {\n    \tListNode dummyHead = new ListNode( 0 );\n    \tListNode currNode = head;\n    \twhile ( currNode != null )\n    \t{\n    \t\tListNode oldFirst = dummyHead.next;\n    \t\tListNode nextNode = currNode.next;    \t\t\n    \t\tdummyHead.next = currNode;\n    \t\tcurrNode.next = oldFirst;\n    \t\tcurrNode = nextNode;\n    \t}\n    \t\n    \treturn dummyHead.next;\n    }    \n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public boolean canJump(int[] nums) {\n        int k=-1;\n        int tar=-1;\n        for (int i = nums.length-1; i>=0 ; i--) {\n            if (k==-1&&nums[i]==0) {\n                k=0;\n                tar=i;\n            }\n            if (k==0) {\n                if(tar==nums.length-1&&nums[i]>=tar-i){\n                    k=-1;\n                }\n                if (nums[i]>tar-i) {\n                    k=-1;\n                }\n            }\n        }\n        if (k==-1) {\n            return true;\n        }else {\n            return false;\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public String reverseWords(String s) {\n        if (s == null || s.length() == 0 || s.indexOf(\" \") == -1) {\n            return s;\n        }\n\n        String[] strs = s.split(\"\\\\s+\");\n        StringBuffer sb = new StringBuffer();\n\n        for (String str : strs) {\n            sb.insert(0, str + \" \");\n        }\n\n        return sb.toString().trim();\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class PlusOne {\n  public int[] plusOne(int[] digits) {\n    int length = digits.length;\n    int add = 1;\n    for (int i = length - 1; i >= 0; i--) {\n      int sum = digits[i] + add;\n      digits[i] = sum % 10;\n      add = sum / 10;\n      if (add == 0) return digits;\n    }\n    int[] ret = new int[length + 1];\n    ret[0] = add;\n    for (int i = 0; i < length; i++) {\n      ret[i + 1] = digits[i];\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class SearchforaRange {\n  public int[] searchRange(int[] A, int target) {\n    int low = findLow(A, target, 0, A.length - 1);\n    int high = findHigh(A, target, 0, A.length - 1);\n    int[] ret = new int[2];\n    ret[0] = low;\n    ret[1] = high;\n    return ret;\n  }\n\n  private int findLow(int[] A, int target, int l, int r) {\n    int mid = 0;\n    int ret = -1;\n    while (l <= r) {\n      mid = (l + r) / 2;\n      if (A[mid] == target) {\n        ret = mid;\n        int next = findLow(A, target, l, mid - 1);\n        if (next != -1) {\n          ret = next;\n        }\n        break;\n      } else if (A[mid] < target) {\n        l = mid + 1;\n      } else {\n        r = mid - 1;\n      }\n    }\n    return ret;\n  }\n\n  private int findHigh(int[] A, int target, int l, int r) {\n    int mid = 0;\n    int ret = -1;\n    while (l <= r) {\n      mid = (l + r) / 2;\n      if (A[mid] == target) {\n        ret = mid;\n        int next = findHigh(A, target, mid + 1, r);\n        if (next != -1) {\n          ret = next;\n        }\n        break;\n      } else if (A[mid] < target) {\n        l = mid + 1;\n      } else {\n        r = mid - 1;\n      }\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class GrayCode2 {\n\tpublic class Solution {\n\t    public ArrayList<Integer> grayCode(int n) {\n\t        if(n==0) {\n\t            ArrayList<Integer> result = new ArrayList<Integer>();\n\t            result.add(0);\n\t            return result;\n\t        }\n\t        \n\t        ArrayList<Integer> tmp = grayCode(n-1);\n\t        int addNumber = 1 << (n-1);\n\t        ArrayList<Integer> result = new ArrayList<Integer>(tmp);\n\t        for(int i=tmp.size()-1;i>=0;i--) {\n\t            result.add(addNumber + tmp.get(i));\n\t        }\n\t        return result;\n\t    }\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public boolean isValid(String s) {\n    String ns=\"\";\n    for (int i = 0; i <s.length(); i++) {\n        String k=s.substring(i,i+1);\n        if (k.equals(\"{\")) {\n            ns+=k;\n            continue;\n        }\n        if (k.equals(\"[\")) {\n            ns+=k;\n            continue;\n        }\n        if (k.equals(\"(\")) {\n            ns+=k;\n            continue;\n        }\n        if (k.equals(\"}\")) {\n            if (ns.length()>0&&ns.substring(ns.length()-1, ns.length()).equals(\"{\")) {\n                ns=ns.substring(0, ns.length()-1);\n                continue;\n            }else {\n                return false;    \n            }\n        }\n        if (k.equals(\"]\")) {\n            if (ns.length()>0&&ns.substring(ns.length()-1, ns.length()).equals(\"[\")) {\n                ns=ns.substring(0, ns.length()-1);\n                continue;\n            }else {\n                return false;    \n            }\n        }\n        if (k.equals(\")\")) {\n            if (ns.length()>0&&ns.substring(ns.length()-1, ns.length()).equals(\"(\")) {\n                ns=ns.substring(0, ns.length()-1);\n                continue;\n            }else {\n                return false;    \n            }\n        }\n    }\n    if (ns.length()!=0) {\n        return false;\n    }else {\n        return true;\n    }\n}\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public boolean wordBreak(String s, Set<String> dict) {\n        int n = s.length();\n        boolean[] dp = new boolean[n+1];\n        dp[n] = true;\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = i; j < n; ++j) {\n                if (dict.contains(s.substring(i,j+1)) && dp[j+1]) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[0];\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> answerList=new ArrayList<String>();\n        for (int i = 1; i <=3; i++) {\n            for (int j = 1; j <=3; j++) {\n                for (int k = 1; k <=3; k++) {\n                    int[] a={i,j,k};\n                    if (i+j+k<s.length()) {\n                        String t=new Solution().validate(s, a);\n                        if (!(t.equals(\"\"))) {\n                            answerList.add(t);\n                        }\n                    }\n                }\n            }\n        }\n        return answerList;\n    }\n    public String validate(String s,int[] a){\n        String s4=s.substring(a[0]+a[1]+a[2],s.length());\n        if (s4.length()>3||(s4.length()>1&&s4.substring(0, 1).equals(\"0\"))||Integer.parseInt(s4)>255) {\n            return \"\";\n        }\n        String s1=s.substring(0,a[0]);\n        String s2=s.substring(a[0],a[0]+a[1]);\n        String s3=s.substring(a[0]+a[1],a[0]+a[1]+a[2]);\n        if ((s3.length()>1&&s3.substring(0, 1).equals(\"0\"))||(s2.length()>1&&s2.substring(0, 1).equals(\"0\"))||(s1.length()>1&&s1.substring(0, 1).equals(\"0\"))||Integer.parseInt(s3)>255||Integer.parseInt(s2)>255||Integer.parseInt(s1)>255) {\n            return \"\";\n        }\n        return s1+\".\"+s2+\".\"+s3+\".\"+s4;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class BinaryTreeInorderTraversal {\n\tpublic ArrayList<Integer> inorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (root == null)\n\t\t\treturn list;\n\t\thelper(root, list);\n\t\treturn list;\n\t}\n\n\tpublic void helper(TreeNode root, ArrayList<Integer> list) {\n\t\tif (root != null) {\n\t\t\thelper(root.left, list);\n\t\t\tlist.add(root.val);\n\t\t\thelper(root.right, list);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ValidPalindrome \n{\n\t@Test\n\tpublic void test()\n\t{\n\t\tassertTrue( isPalindrome( \"aA\" ) );\n\t\tassertTrue( !isPalindrome( \"0P\" ) );\n\t}\n\t\n    public boolean isPalindrome( String s )\n    {\n    \tint start = 0;\n    \tint end = s.length() - 1;\n    \twhile ( start < end )\n    \t{\n    \t\twhile ( start < end && !isValid( s.charAt( start ) ) )\n    \t\t{\n    \t\t\tstart++;\n    \t\t}\n    \t\twhile ( start < end && !isValid( s.charAt( end ) ) )\n    \t\t{\n    \t\t\tend--;\n    \t\t}\n    \t\t\n    \t\tif ( start < end ) \n    \t\t{\n    \t\t\tif ( Character.toLowerCase( s.charAt( start ) ) != Character.toLowerCase( s.charAt( end ) ) )\n    \t\t\t{\n        \t\t\treturn false;    \t\t\t\t    \t\t\t\t\n    \t\t\t}\n    \t\t\tstart++;\n    \t\t\tend--;\n    \t\t}    \t\t\n    \t}\n    \treturn true;\n    }\n    \n    private boolean isValid( char ch )\n    {\n    \treturn Character.isLetter( ch ) || Character.isDigit( ch );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "class Solution {\n    public String countAndSay(int n) {\n        if (n <= 1) {\n            return n + \"\";\n        }\n        String curr = \"1\";\n        for (int i = 2; i <= n; i++) {\n            int count = 1;\n            char c = curr.charAt(0);\n            int size = curr.length();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 1; j < size; j++) {\n                if (curr.charAt(j) == curr.charAt(j - 1)) {\n                    count++;\n                } else {\n                    sb.append(count + String.valueOf(c));\n                    c = curr.charAt(j);\n                    count = 1;\n                }\n            }\n            sb.append(count + String.valueOf(c)); // append end letter for each row\n            curr = sb.toString();\n        }\n        \n        return curr;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length==0) {\n            return \"\";\n        }\n        if (strs.length==1) {\n            return strs[0];\n        }\n        int n=0;\n        if (strs[0].length()<strs[1].length()) {\n            n=strs[0].length();\n        }else {\n            n=strs[1].length();\n        }\n        String answer=\"\";\n        for (int i = 0; i < n; i++) {\n            String k0=strs[0].substring(i,i+1);\n            String k1=strs[1].substring(i,i+1);\n            if (k0.equals(k1)) {\n                answer+=k0;\n            }else {\n                break;\n            }\n        }\n        if (strs.length==2) {\n            return answer;\n        }\n        for (int i = 2; i < strs.length; i++) {\n            if (answer.length()==0) {\n                return \"\";\n            }\n            int length=0;\n            String k=\"\";\n            if (strs[i].length()<answer.length()) {\n                length=strs[i].length();\n            }else {\n                length=answer.length();\n            }\n            while (!answer.substring(0, length).equals(strs[i].substring(0, length))) {\n                length--;\n            }\n            answer=answer.substring(0,length);\n        }\n        return answer;\n    \n        \n    }\n}", "nl": "corpsepiges"}
{"code": "public class L002_Add_Two_Numbers {\n\n\tpublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n\n\t\tif (l1 == null && l2 == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (l1 == null) {\n\t\t\treturn l2;\n\t\t}\n\n\t\tif (l2 == null) {\n\t\t\treturn l1;\n\t\t}\n\n\t\tListNode p1 = l1;\n\t\tListNode p2 = l2;\n\n\t\tint carry = 0;\n\n\t\tListNode head = new ListNode(0);\n\t\tListNode result = head;\n\n\t\twhile (carry != 0 || p1 != null || p2 != null) {\n\n\t\t\tint v1 = 0;\n\t\t\tif (p1 != null) {\n\t\t\t\tv1 = p1.val;\n\t\t\t\tp1 = p1.next;\n\t\t\t}\n\n\t\t\tint v2 = 0;\n\t\t\tif (p2 != null) {\n\t\t\t\tv2 = p2.val;\n\t\t\t\tp2 = p2.next;\n\t\t\t}\n\n\t\t\tint tmp = v1 + v2 + carry;\n\t\t\tcarry = tmp / 10;\n\t\t\thead.next = new ListNode(tmp % 10);\n\t\t\thead = head.next;\n\t\t}\n\n\t\treturn result.next;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> combinationSum2(int[] num, int target) {\n        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n        Arrays.sort(num);\n        combinationSum2(num,target,0,new ArrayList<Integer>(),result);\n        return result;\n    }\n    \n    public void combinationSum2(int[] num, int target, int pointer, ArrayList<Integer> currentCombo,ArrayList<ArrayList<Integer>> result) {\n        if(target==0){\n            if(!result.contains(currentCombo))\n                result.add(new ArrayList<Integer>(currentCombo));\n            return;\n        }else if(target<0 || pointer<0)\n            return;\n        \n        for(int i=pointer;i<num.length;i++){\n            currentCombo.add(num[i]);\n            combinationSum2(num,target-num[i],i+1,currentCombo,result);\n            currentCombo.remove(currentCombo.size()-1);\n        }\n    \n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public ListNode rotateRight(ListNode head, int n) {\n        if(head == null || n ==0)\n    \t\treturn head;\n\n        ListNode p = head;\n        ListNode q = p ;\n        ListNode end = null;\n        int i=0;\n        while(i<n){\n        \tif(q.next==null){\t\t// When q reach the tail of the list, make p.next = head to\n        \t\tend = q;\t\t\t// enable the continuation of finding the breakpoint for the list\n        \t\tend.next = head;\t// Unlike a similar problem whose input is an array, we cannot \n        \t}\t\t\t\t\t\t// do a module operation to avoid this since we don't know the length until traverse the list\n        \tq=q.next;\n        \ti++;\n        }\n\n        if(end!=null) end.next = null;\n\n        while(q.next!=null){\n        \tp=p.next;\n        \tq=q.next;\n        }\n\n        q.next =head;\n        ListNode newHead = p.next;\n        p.next = null;\n        return newHead;\n\n    }\n}", "nl": "azheanda"}
{"code": "public class ContainerWithMostWater {\n  public int maxArea(int[] height) {\n    int len = height.length, low = 0, high = len - 1;\n    int maxArea = 0;\n    while (low < high) {\n      maxArea = Math.max(maxArea, (high - low) * Math.min(height[low], height[high]));\n      if (height[low] < height[high]) {\n        low++;\n      } else {\n        high--;\n      }\n    }\n    return maxArea;\n  }\n}\n", "nl": "mengli"}
{"code": "public class RotateImage {\n\n    public class Solution {\n        public void rotate(int[][] matrix) {\n            int n = matrix.length;\n            for (int row = 0; row < n / 2; row++) {\n                for (int i = row; i < n - row - 1; i++) {\n                    int temp = matrix[row][i];\n                    matrix[row][i] = matrix[n - i - 1][row];\n                    matrix[n - i - 1][row] = matrix[n - row - 1][n - i - 1];\n                    matrix[n - row - 1][n - i - 1] = matrix[i][n - row - 1];\n                    matrix[i][n - row - 1] = temp;\n                }\n            }\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public void sortColors(int[] A) {\n        int n = A.length;\n        if (n <= 1) return;\n        for (int i = 0, left = 0, right = n - 1; i <= right;) {\n            if (A[i] == 0) {\n                A[i++] = A[left];\n                A[left++] = 0;\n            } else if (A[i] == 2) {\n                A[i] = A[right];\n                A[right--] = 2;\n            } else i++;\n        }\n    }\n}", "nl": "leetcoders"}
{"code": "public class LinkedListCycle {\n\tpublic boolean hasCycle(ListNode head) {\n\t\tif (head == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tListNode fast = head;\n\t\tListNode slow = head;\n\n\t\twhile (fast.next != null) {\n\t\t\tfast = fast.next.next;\n\n\t\t\tif (fast == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tslow = slow.next;\n\t\t\t\n\t\t\tif (fast == slow) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tListNode n1 = new ListNode(1);\n\t\tListNode n2 = new ListNode(2);\n\t\tListNode n3 = new ListNode(3);\n\t\tListNode n4 = new ListNode(4);\n\t\tListNode n5 = new ListNode(5);\n\t\tn1.next = n2;\n\t\tn2.next = n3;\n\t\tn3.next = n4;\n\t\tn4.next = n5;\n\t\tn5.next = n3;\n\n\t\tLinkedListCycle slt = new LinkedListCycle();\n\t\tboolean result = slt.hasCycle(n1);\n\t\tSystem.out.println(result);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    public void rotate(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return;\n        }\n        int width = matrix.length;\n        for (int i = 0; i < width/2; i++) {\n            for (int j = 0; j < Math.ceil(width/2.0); j++) {\n               int temp = matrix[i][j];\n               matrix[i][j] = matrix[width - 1 - j][i];\n               matrix[width - 1 - j][i] = matrix[width - 1 - i][width - 1 - j];\n               matrix[width - 1 - i][width - 1 - j] = matrix[j][width - 1 - i];\n               matrix[j][width - 1 - i] = temp;\n            }\n        }\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    \n    public int lengthOfLastWord(String s) {\n        if (s == null || s.length() == 0) {\n        \treturn 0;\n        }\n        String[] arr = s.split(\"\\\\ \");\n        String lastWord = arr[arr.length - 1];\n\n       \treturn lastWord.length();\n    }\n}\n", "nl": "awangdev"}
{"code": "public class L144_Binary_Tree_Preorder_Traversal {\n\n\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\n\t\tList<Integer> rt = new ArrayList<Integer>();\n\n\t\tif (root == null) {\n\t\t\treturn rt;\n\t\t}\n\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tTreeNode p = root;\n\n\t\twhile (p != null || !stack.empty()) {\n\n\t\t\twhile (p != null) {\n\t\t\t\trt.add(p.val);\n\t\t\t\tstack.push(p);\n\t\t\t\tp = p.left;\n\t\t\t}\n\n\t\t\tif (!stack.empty()) {\n\t\t\t\tp = stack.pop();\n\t\t\t\tp = p.right;\n\t\t\t}\n\t\t}\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1==null) {\n            return l2;\n        }\n        if (l2==null) {\n            return l1;\n        }\n        ListNode l=null;\n        if (l1.val>l2.val) {\n            l=new ListNode(l2.val);\n            l.next=mergeTwoLists(l1,l2.next);\n        }else {\n            l=new ListNode(l1.val);\n            l.next=mergeTwoLists(l1.next,l2);\n        }\n        return l;\n    }\n}", "nl": "corpsepiges"}
{"code": "class Solution {\n    public int findPeakElement(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int n = nums.length;\n        int start = 0;\n        int end = n - 1;\n        while (start + 1 < end) {\n            int mid = (start + end) >> 1;\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) { // match\n                return mid;\n            } else if (nums[mid] > nums[mid - 1]) { // ascending slope\n                start = mid;\n            } else { // descending slope\n                end = mid;\n            }\n        }\n        return nums[start] > nums[end] ? start : end;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder sb = new StringBuilder();\n        int i = a.length() - 1, j = b.length() -1, carry = 0;\n        while (i >= 0 || j >= 0) {\n            int sum = carry;\n            if (i >= 0) sum += a.charAt(i--) - '0';\n            if (j >= 0) sum += b.charAt(j--) - '0';\n            sb.insert(0, sum % 2);\n            carry = sum / 2;\n        }\n        if (carry != 0) sb.insert(0, carry);\n        return sb.toString();\n    }\n}\n", "nl": "awangdev"}
{"code": "public class ValidParentheses {\n  public static void main(String[] args) {\n    System.out.println(hasBalancedBrackets(\"(h[e\"));\n  }\n\n  private static Map<Character, Character> MAP = new HashMap<>();\n\n  public static int hasBalancedBrackets(String str) {\n    if (str == null) return 1;\n\n    MAP.put(')', '(');\n    MAP.put('}', '{');\n    MAP.put('>', '<');\n    MAP.put(']', '[');\n\n    Stack<Character> stack = new Stack<>();\n    for (int i = 0, l = str.length(); i < l; i++) {\n      switch (str.charAt(i)) {\n        case '(':\n        case '{':\n        case '[':\n        case '<':\n          stack.push(str.charAt(i));\n          break;\n\n        case ')':\n        case '}':\n        case ']':\n        case '>':\n          if (stack.isEmpty()) return 0;\n          char top = stack.pop();\n          if (top != MAP.get(str.charAt(i))) return 0;\n          break;\n\n        default: // ignore\n      }\n    }\n    return stack.isEmpty() ? 1 : 0;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class HIndex2 {\n\n  \n  public int hIndex(int[] citations) {\n    if (citations == null || citations.length == 0) {\n      return 0;\n    }\n    int l = 0;\n    int h = citations.length - 1;\n    while (l <= h) {\n      int m = l + (h - l) / 2;\n      if (citations[m] == citations.length - m) {\n        return citations[m];\n      } else if (citations[m] > citations.length - m) {\n        h = m - 1;\n      } else {\n        l = m + 1;\n      }\n    }\n    return citations.length - l;\n  }\n\n  public int hIndex2(int[] citations) {\n    if (citations == null || citations.length == 0) return 0;\n    int l = 0;\n    int h = citations.length;\n    int mid;\n    while (l < h) {\n      mid = l + (h - l) / 2;\n      if (citations[mid] == citations.length - mid) {\n        return citations[mid];\n      } else if (citations[mid] > citations.length - mid) {\n        h = mid;\n      } else {\n        l = mid + 1;\n      }\n    }\n    return citations.length - h;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SearchInsertPosition {\n\tpublic int searchInsert(int[] A, int target) {\n\t\tint left = 0;\n\t\tint right = A.length - 1;\n\t\tint mid = 0;\n\n\t\twhile (left <= right) {\n\t\t\tmid = (left + right) / 2;\n\t\t\tif (A[mid] > target) {\n\t\t\t\tright = mid - 1;\n\t\t\t} else if (A[mid] < target) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\treturn left;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint[] A = new int[] { 1, 3, 5, 6 };\n\t\tSearchInsertPosition slt = new SearchInsertPosition();\n\t\tSystem.out.println(slt.searchInsert(A, 0));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class LengthofLastWord3 {\n\tpublic int lengthOfLastWord(String s) {\n\t\tif (s == null || s.length() == 0) \n\t\t\treturn 0;\n\t\tint count = 0;\n\t\tfor (int i = s.length() - 1; i >=0; i--) {\n\t\t\tif (s.charAt(i) != ' ') \n\t\t\t\tcount++;\n\t\t\tif (s.charAt(i) == ' ' && count != 0) {\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class AddBinary {\n\n  \n  public static void main(String[] args) {\n    System.out.println(new AddBinary().addBinary(\"000001010000101001\", \"0\"));\n  }\n\n  public String addBinary(String a, String b) {\n    if (a.length() > b.length()) {\n      return calculate(a, b);\n    } else return calculate(b, a);\n  }\n\n  \n  private String calculate(String a, String b) {\n    int carry = 0;\n    int d = a.length() - b.length();\n    StringBuilder sb = new StringBuilder();\n    for (int i = a.length() - 1; i >= 0; i--) {\n      int first = Integer.parseInt(String.valueOf(a.charAt(i)));\n      int second = i - d >= 0 ? Integer.parseInt(String.valueOf(b.charAt(i - d))) : 0;\n      int sum = (first + second + carry);\n      carry = sum / 2;\n      sb.append(sum % 2);\n    }\n    if (carry != 0) sb.append(carry);\n    return sb.reverse().toString();\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class L078_Subsets {\n\n\tint target;// \u6b21\u6570\n\tInteger[] stack;// \u5b58\u50a8\u6bcf\u6b21\u6392\u5217\n\n\tList<List<Integer>> rt;// \u5b58\u50a8\u7ed3\u679c\n\n\tpublic void search(int p, int[] nums) {\n\n\t\tif (p == target) {\n\t\t\trt.add(new ArrayList<Integer>(Arrays.asList(stack)));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\n\t\t\tif (p > 0 && nums[i] <= stack[p - 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstack[p] = nums[i];\n\t\t\tsearch(p + 1, nums);\n\t\t}\n\t}\n\n\tpublic List<List<Integer>> subsets(int[] nums) {\n\n\t\tArrays.sort(nums);\n\n\t\trt = new ArrayList<List<Integer>>();\n\n\t\tfor (int i = 0; i <= nums.length; i++) {\n\t\t\ttarget = i;\n\t\t\tstack = new Integer[i];\n\t\t\tsearch(0, nums);\n\t\t}\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node!=null) {\n            Map<UndirectedGraphNode, Integer> initMap=f(node,new HashMap<UndirectedGraphNode, Integer>());\n            Map<UndirectedGraphNode, Integer> map=new HashMap<UndirectedGraphNode, Integer>();\n            map.put(node, 0);\n            List<UndirectedGraphNode> list=new ArrayList<UndirectedGraphNode>();\n            list.add(node);\n            List<UndirectedGraphNode> ans=new ArrayList<UndirectedGraphNode>();\n            UndirectedGraphNode init=new UndirectedGraphNode(node.label);\n            ans.add(init);\n            int k=1;\n            for (UndirectedGraphNode ugn : initMap.keySet()) {\n                if (ugn!=node) {\n                    map.put(ugn, k);\n                    list.add(ugn);\n                    ans.add(new UndirectedGraphNode(ugn.label));\n                    k++;\n                }\n            }\n            for (int i = 0; i < list.size(); i++) {\n                List<UndirectedGraphNode> neis=list.get(i).neighbors;\n                UndirectedGraphNode u=ans.get(i);\n                for (int j = 0; j < neis.size(); j++) {\n                    u.neighbors.add(ans.get(map.get(neis.get(j))));\n                }\n            }\n            return init;\n        }\n        return null;\n    }\n    public Map<UndirectedGraphNode, Integer> f(UndirectedGraphNode node,Map<UndirectedGraphNode, Integer> map){\n        if (node!=null&&map.get(node)==null) {\n            map.put(node, 1);\n            List<UndirectedGraphNode> list=node.neighbors;\n            if (list!=null) {\n                for (int i = 0; i < list.size(); i++) {\n                    map=f(list.get(i),map);\n                }\n            }\n        }\n        return map;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> ans=new ArrayList<Integer>();\n        List<String> list=new ArrayList<String>();\n        if (n==0) {\n            ans.add(0);\n            return ans;\n        }\n        list.add(\"0\");\n        list.add(\"1\");\n        for (int i = 1; i < n; i++) {\n            List<String> newList=new ArrayList<String>();\n            for (int j = 0; j < list.size(); j++) {\n                newList.add(\"0\"+list.get(j));\n            }\n            for (int j = list.size()-1; j >= 0 ; j--) {\n                newList.add(\"1\"+list.get(j));\n            }\n            list=newList;\n        }\n        for (int i = 0; i < list.size(); i++) {\n            ans.add(Integer.valueOf(list.get(i), 2));\n        }\n        return ans;\n    }\n}", "nl": "corpsepiges"}
{"code": "class BinaryTreePreorderTraversal {\n\n  \n  public List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> res = new ArrayList<Integer>();\n    if (root == null) return res;\n    Stack<TreeNode> s = new Stack<TreeNode>();\n    s.push(root);\n    while (!s.isEmpty()) {\n      TreeNode curNode = s.pop();\n      res.add(curNode.val); // visit\n      if (curNode.right != null) s.push(curNode.right);\n      if (curNode.left != null) s.push(curNode.left); // left pop first\n    }\n    return res;\n  }\n\n  \n  public List<Integer> preorderTraversalB(TreeNode root) {\n    List<Integer> res = new ArrayList<>();\n    if (root == null) return res;\n    preorderTraversalB(root, res);\n    return res;\n  }\n\n  public void preorderTraversalB(TreeNode root, List<Integer> res) {\n    if (root == null) return;\n    res.add(root.val);\n    preorderTraversalB(root.left, res);\n    preorderTraversalB(root.right, res);\n  }\n\n  class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int minDepth(TreeNode root) {\n        if (root==null) {\n            return 0;\n        }\n        if(root.left==null&&root.right==null){\n            return 1;\n        }\n        int left=-1;\n        if(root.left!=null){\n           left=minDepth(root.left)+1;\n        }\n        int right=-1;\n        if(root.right!=null){\n           right=minDepth(root.right)+1;\n        }\n        if(left==-1){\n            return right;\n        }\n        if(right==-1){\n            return left;\n        }\n    \n        \n        return Math.min(left, right);\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Combinations {\n\n  public static void main(String[] args) throws Exception {\n    List<List<Integer>> result = new Combinations().combine(3, 3);\n  }\n\n  public List<List<Integer>> combine(int n, int k) {\n    int[] subArr = new int[k];\n    List<List<Integer>> result = new ArrayList<>();\n    getNext(0, 0, n, k, subArr, result);\n    return result;\n  }\n\n  private void getNext(int i, int count, int n, int k, int[] subArr, List<List<Integer>> result) {\n    if (k == 0) {\n      List<Integer> subList = new ArrayList<>();\n      for (int a : subArr) subList.add(a);\n      result.add(subList);\n    } else {\n      for (int j = i + 1; j <= n; j++) {\n        subArr[count] = j;\n        getNext(j, count + 1, n, k - 1, subArr, result);\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        } else if (head.next == null) { // be carefull in dfs\n            return new TreeNode(head.val);\n        }\n        \n        ListNode midNode = findMid(head);\n        TreeNode root = new TreeNode(midNode.next.val);\n        root.right = sortedListToBST(midNode.next.next);\n        midNode.next = null;\n        root.left = sortedListToBST(head);\n        return root;\n    }\n    \n    \n    public ListNode findMid(ListNode node) {\n        ListNode fastNode = node.next;\n        while (fastNode.next != null && fastNode.next.next != null) {\n            node = node.next;\n            fastNode = fastNode.next.next;\n        }\n        return node;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public int singleNumber(int[] nums) {\n        int answer=0;\n        for (int i = 0; i < nums.length; i++) {\n            answer^=nums[i];\n        }\n        return answer;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public int search(int[] A, int target) {\n        int i = 0, j = A.length - 1;\n        while (i <= j) {\n            int mid = (i + j) / 2;\n            if (A[mid] == target)\n                return mid;\n            if (A[i] <= A[mid]) {\n                if (A[i] <= target && target < A[mid])\n                    j = mid - 1;\n                else\n                    i = mid + 1;\n            } else {\n                if (A[mid] < target && target <= A[j])\n                    i = mid + 1;\n                else\n                    j = mid - 1;\n            }\n        }\n        return -1;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> answerList=new ArrayList<List<Integer>>();\n        for (int i = 1; i <=n; i++) {\n            List<Integer> list=new ArrayList<Integer>();\n            list.add(i);\n            answerList.add(list);\n        }\n        for (int i = 0; i <answerList.size(); i++) {\n            if (answerList.get(i).size()<k) {\n                if ((n-answerList.get(i).get(answerList.get(i).size()-1))<(k-answerList.get(i).size())) {\n                    answerList.remove(i);\n                    i--;\n                }else {\n                    for (int j = answerList.get(i).get(answerList.get(i).size()-1)+1; j <=n; j++) {\n                        System.out.println(\"j=\"+j);\n                        List<Integer> alist=new ArrayList<Integer>();\n                        for (int l = 0; l <answerList.get(i).size(); l++) {\n                            alist.add(answerList.get(i).get(l));\n                        }\n                        alist.add(j);\n                        answerList.add(alist);                        \n                    }\n                    answerList.remove(i);\n                    System.out.println();\n                    i--;\n                }\n            }\n        }\n        return answerList;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class ConstructBinaryTreefromInorderandPostorderTraversal {\n  public TreeNode buildTree(int[] inorder, int[] postorder) {\n    return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\n  }\n\n  public TreeNode buildTree(int[] inorder, int is, int ie, int[] postorder, int ps, int pe) {\n    if (is > ie || ps > pe) return null;\n    int rootVal = postorder[pe];\n    TreeNode root = new TreeNode(rootVal);\n    for (int i = is; i <= ie; i++) {\n      if (inorder[i] == rootVal) {\n        TreeNode left = buildTree(inorder, is, i - 1, postorder, ps, ps + i - is - 1);\n        TreeNode right = buildTree(inorder, i + 1, ie, postorder, pe - ie + i, pe - 1);\n        root.left = left;\n        root.right = right;\n      }\n    }\n    return root;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public List<String> generateParenthesis(int n) {\n        ArrayList<String> res = new ArrayList<String>();\n        generateParenthesisRe(res, n, n, \"\");\n        return res;\n    }\n    public void generateParenthesisRe(ArrayList<String> res, int left, int right, String s) {\n        if (left == 0 && right == 0)\n            res.add(s);\n        if (left > 0)\n            generateParenthesisRe(res, left - 1, right, s + \"(\");\n        if (right > left)\n            generateParenthesisRe(res, left, right - 1, s + \")\");\n    }\n}", "nl": "leetcoders"}
{"code": "public class ReverseInteger2 {\n\tpublic int reverse(int x) {\n\t\tStringBuilder num = new StringBuilder();\n\t\tint val = 0;\n\n\t\tif (x > 0) {\n\t\t\tnum = num.append(x).reverse();\n\t\t\ttry {\n\t\t\t\tval = (int) Integer.parseInt(num.toString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn val;\n\t\t}\n\n\t\telse {\n\t\t\tx = -x;\n\t\t\tnum = num.append(x).reverse();\n\t\t\ttry {\n\t\t\t\tval = (int) Integer.parseInt(num.toString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn -val;\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class FindPeakElement {\n\tpublic int findPeakElement(int[] num) {\n\t\tif (num.length == 1)\n\t\t\treturn 0;\n\t\tfor (int i = 0; i < num.length; i++) {\n\t\t\tif (i == 0 && num[i] > num[i + 1])\n\t\t\t\treturn i;\n\t\t\telse if (i == num.length-1 && num[i] > num[i - 1])\n\t\t\t\treturn i;\n\t\t\telse if (i != 0 && i != num.length-1 && num[i] > num[i + 1] && num[i] > num[i - 1])\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    \n    public List<Interval> merge(List<Interval> intervals) {\n        if (intervals == null || intervals.size() == 0) {\n        \treturn intervals;\n        }\n\n        Collections.sort(intervals, new Comparator<Interval>(){\n            public int compare(Interval a, Interval b){\n        \t\treturn a.start - b.start;\n        \t}\n        });\n        Interval pre = intervals.get(0);\n        Interval curr = null;\n        for (int i = 1; i < intervals.size(); i++) {\n        \tcurr = intervals.get(i);\n        \tif (pre.end >= curr.start) {\n        \t\tpre.end = pre.end > curr.end ? pre.end : curr.end;\n        \t\tintervals.remove(i);\n        \t\ti--;\n        \t} else {\n        \t    pre = curr;\n        \t}\n        }\n    \n        return intervals;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class GasStation {\n  public int canCompleteCircuit(int[] gas, int[] cost) {\n    int sum = 0, total = 0, len = gas.length, index = -1;\n    for (int i = 0; i < len; i++) {\n      sum += gas[i] - cost[i];\n      total += gas[i] - cost[i];\n      if (sum < 0) {\n        index = i;\n        sum = 0;\n      }\n    }\n    return total >= 0 ? index + 1 : -1;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public ListNode sortList(ListNode head) {\n        if (head==null||head.next==null) {\n            return head;\n        }\n        ListNode mid=getMid(head);\n        ListNode next=mid.next;\n        mid.next=null;\n        return merge(sortList(head),sortList(next));\n    }\n    public ListNode getMid(ListNode head){\n        ListNode fast=head;\n        ListNode slow=head;\n        while(fast.next!=null&&fast.next.next!=null) {  \n            slow = slow.next;  \n            fast = fast.next.next;  \n        }  \n        return slow;\n    }\n    public ListNode merge(ListNode a,ListNode b){\n        ListNode ans=new ListNode(0);\n        ListNode node=ans;\n        while (a!=null&&b!=null) {\n            if (a.val<b.val) {\n                node.next=a;\n                a=a.next;\n            }else {\n                node.next=b;\n                b=b.next;\n            }\n            node=node.next;\n        }\n        node.next=a==null?b:a;\n        return ans.next;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class SwapNodesInPairs\n{\n    public ListNode swapPairs( ListNode head ) \n    {\n    \tListNode dummy = new ListNode( 0 );\n    \tdummy.next = head;\n    \tListNode current = dummy;\n    \twhile ( current.next != null && current.next.next != null )\n    \t{\n    \t\tListNode first = current.next;\n    \t\tListNode second = current.next.next;\n    \t\tfirst.next = second.next;\n    \t\tcurrent.next = second;\n    \t\tcurrent.next.next = first;\n    \t\tcurrent = current.next.next;\n    \t}\n    \treturn dummy.next;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int sqrt(int x) {\n        int left = 1, right = x/2;\n        if(x<2) return x;\n        while (left <= right) {\n            int mid = (left + right)/2;\n            if (x/mid == mid) return mid;\n            if (x/mid > mid) left = mid + 1;\n            else right = mid - 1;\n        }\n        return right;\n    }\n}", "nl": "leetcoders"}
{"code": "class MinStack {\n\n  private Stack<Integer> s = new Stack<>();\n  \n  private Stack<Integer> minStack = new Stack<>();\n\n  \n  public void push(int x) {\n    s.push(x);\n    if (minStack.isEmpty() || x <= minStack.peek()) { // even smaller\n      minStack.push(x);\n    }\n  }\n\n  \n  public void pop() {\n    if (s.pop().equals(minStack.peek())) minStack.pop();\n  }\n\n  public int top() {\n    return s.peek();\n  }\n\n  \n  public int getMin() {\n    return minStack.peek();\n  }\n}\n\n\nclass MinStackDP {\n\n  Stack<Element> s;\n\n  public void push(int x) {\n    if (s == null) s = new Stack<>();\n    int min = s.isEmpty() ? x : Math.min(x, s.peek().min);\n    s.push(new Element(x, min));\n  }\n\n  public void pop() {\n    s.pop();\n  }\n\n  public int top() {\n    return s.peek().value;\n  }\n\n  public int getMin() {\n    return s.peek().min;\n  }\n\n  \n  static class Element {\n\n    final int value;\n    final int min;\n\n    public Element(int x, int min) {\n      this.value = x;\n      this.min = min;\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class L034_Search_for_a_Range {\n\n\tpublic int[] searchRange(int[] nums, int target) {\n\n\t\tint l = 0, r = nums.length;\n\n\t\twhile (l < r) {\n\n\t\t\tint m = l + (r - l) / 2;\n\n\t\t\tif (nums[m] == target) {\n\n\t\t\t\tint s = m, e = m;\n\n\t\t\t\twhile (s - 1 >= 0 && nums[s - 1] == target) {\n\t\t\t\t\ts--;\n\t\t\t\t}\n\n\t\t\t\twhile (e + 1 < nums.length && nums[e + 1] == target) {\n\t\t\t\t\te++;\n\t\t\t\t}\n\n\t\t\t\treturn new int[] { s, e };\n\n\t\t\t} else if (nums[m] > target) {\n\t\t\t\tr = m;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn new int[] { -1, -1 };\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    \n    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {\n        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n        if (root == null) {\n            return result;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            ArrayList<Integer> list = new ArrayList<Integer>();\n            int size = queue.size();//Limit the size, since the queue is increasing\n            for (int i = 0; i < size; i++) {\n                TreeNode levelNode = queue.poll();\n                list.add(levelNode.val);//Add all the values from this current level\n                if (levelNode.left != null) {\n                    queue.offer(levelNode.left);\n                }\n                if (levelNode.right != null) {\n                    queue.offer(levelNode.right);                    \n                }\n            }\n            result.add(list);\n        }//while\n        \n        return result;    \n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class LRUCache<K, V> {\n\n    private final int capacity;\n    private Map<K, Node> cache;\n    private Node dummyHead = new Node();\n    private Node tail = new Node();\n\n\n    public LRUCache(int capacity) {\n        if (capacity <= 0) {\n            throw new InvalidParameterException(\"Cache capacity should be larger than 0\");\n        }\n        this.capacity = capacity;\n        cache = new HashMap<>(capacity);\n        dummyHead.next = tail;\n        dummyHead.prev = null;\n        tail.prev = dummyHead;\n        tail.next = null;\n    }\n\n    public void set(K key, V val) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.val = val;\n            moveToHead(node);\n        } else {\n            Node newNode = new Node(key, val);\n            addFirst(newNode);\n            cache.put(key, newNode);\n            if (cache.size() > capacity) {\n                K toRemove = removeLast();\n                cache.remove(toRemove);\n            }\n        }\n    }\n\n    public V get(K key) {\n        if (!cache.containsKey(key)) {\n            throw new NullPointerException(\"This key is NOT in cache.\");\n        }\n        Node node = cache.get(key);\n        moveToHead(node);\n        return node.val;\n    }\n\n    private void moveToHead(Node node) {\n        removeNode(node);\n        addFirst(node);\n    }\n\n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addFirst(Node n) {\n        n.prev = dummyHead;\n        n.next = dummyHead.next;\n\n        n.next.prev = n;\n        n.prev.next = n;\n    }\n\n    private K removeLast() {\n        K key = tail.prev.key;\n        removeNode(tail.prev);\n        return key;\n    }\n\n    class Node {\n\n        Node prev;\n        Node next;\n        K key;\n        V val;\n\n        public Node() {\n        }\n\n        public Node(K key, V val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class MultiplyStrings {\n  public String multiply(String num1, String num2) {\n    int length1 = num1.length();\n    int length2 = num2.length();\n    int[] m = new int[length1 + length2];\n    for (int k = length2 - 1, offset2 = 0; k >= 0; k--, offset2++) {\n      for (int i = length1 - 1, offset1 = 0; i >= 0; i--, offset1++) {\n        m[length1 + length2 - 1 - offset1 - offset2] +=\n            (num1.charAt(i) - '0') * (num2.charAt(k) - '0');\n      }\n    }\n    int add = 0;\n    for (int t = length1 + length2 - 1; t >= 0; t--) {\n      int value = m[t] + add;\n      add = value / 10;\n      m[t] = value % 10;\n    }\n    StringBuffer sb = new StringBuffer();\n    int w = 0;\n    for (; w < length1 + length2; w++) {\n      if (m[w] != 0) break;\n    }\n    for (int e = w; e < length1 + length2; e++) {\n      sb.append(m[e]);\n    }\n    return sb.length() == 0 ? \"0\" : sb.toString();\n  }\n}\n", "nl": "mengli"}
{"code": "public class ImplementstrStr {\n\n    public class Solution {\n        public int strStr(String haystack, String needle) {\n            return haystack.indexOf(needle);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class L055_Jump_Game {\n\n\tpublic boolean canJump(int[] nums) {\n\n\t\tif (nums == null || nums.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint maxStep = 0;\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\n\t\t\tif (maxStep >= nums.length - 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (nums[i] == 0 && maxStep == i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tmaxStep = Math.max(maxStep, nums[i] + i);\n\t\t}\n\n\t\treturn true;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class AddBinary {\n\n  \n  public String addBinary(String a, String b) {\n    StringBuilder sum = new StringBuilder();\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n    int c = 0;\n    while (i >= 0 || j >= 0 || c == 1) {\n      c += (i >= 0 ? a.charAt(i--) - '0' : 0);\n      c += (j >= 0 ? b.charAt(j--) - '0' : 0);\n      sum.insert(0, c % 2);\n      c >>= 1;\n    }\n    return sum.toString();\n  }\n\n  \n  public String addBinary2(String a, String b) {\n    int m = a.length();\n    int n = b.length();\n    int carry = 0;\n    StringBuilder res = new StringBuilder();\n    int i = 0;\n    while (i < m || i < n) { // The longer one of ab and b\n      int p = i < m ? a.charAt(m - 1 - i) - '0' : 0;\n      int q = i < n ? b.charAt(n - 1 - i) - '0' : 0;\n      int temp = p + q + carry; // Sum of current digits and previous carry\n      carry = temp / 2; // temp can be 0, 1, 2, 3. When temp >= 2, carry = 1; otherwise, carry = 0\n      res.insert(0, temp % 2); // When temp is odd, result is 1; otherwise, result is 0\n      i++;\n    }\n    return carry == 0 ? res.toString() : \"1\" + res.toString(); // Don't forget the carry at last.\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public String reverseWords(String s) { \n        StringBuffer sb = new StringBuffer();\n        for (int i = s.length() - 1; i >= 0;) {\n            while (i >= 0 && s.charAt(i) == ' ') --i;\n            StringBuffer temp = new StringBuffer();\n            while (i >= 0 && s.charAt(i) != ' ') {\n                temp.append(s.charAt(i--));\n            }\n            temp.reverse();\n            if (sb.length() > 0 && temp.length() > 0) sb.append(\" \");\n            sb.append(temp);\n        }\n        return sb.toString();\n    } \n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    \n    public int searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int x = row - 1;\n        int y = 0;\n        int count = 0;\n        while (x >= 0 && y < col) {\n            if (matrix[x][y] < target) {\n                y++;\n            } else if (matrix[x][y] > target) {\n                x--;\n            } else {//matrix[x][y] == target\n                count++;\n                x--;\n                y++;\n            }\n        }\n        return count;\n    }\n}\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class PalindromePartitioning {\n\n    public class Solution {\n        private boolean isPalindromic(String s) {\n            for (int i = 0; i < s.length() / 2; i++) {\n                if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private Map<String, ArrayList<ArrayList<String>>> cache = new HashMap<String, ArrayList<ArrayList<String>>>();\n\n        public ArrayList<ArrayList<String>> partition(String s) {\n            ArrayList<ArrayList<String>> ans = cache.get(s);\n            if (ans != null) {\n                return ans;\n            }\n            ans = new ArrayList<ArrayList<String>>();\n            for (int i = 1; i < s.length(); i++) {\n                String prefix = s.substring(0, i);\n                if (isPalindromic(prefix)) {\n                    for (ArrayList<String> subans : partition(s.substring(i))) {\n                        ArrayList<String> temp = new ArrayList<String>();\n                        temp.add(prefix);\n                        temp.addAll(subans);\n                        ans.add(temp);\n                    }\n                }\n            }\n            if (isPalindromic(s)) {\n                ArrayList<String> temp = new ArrayList<String>();\n                temp.add(s);\n                ans.add(temp);\n            }\n            cache.put(s, ans);\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class GasStation2 {\n\tpublic int canCompleteCircuit(int[] gas, int[] cost) {\n\t\tif (gas.length == 1)\n\t\t\treturn gas[0] - cost[0] < 0 ? -1 : 0;\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint total = 0;\n\t\tfor (int i = 0; i < gas.length; i++) {\n\t\t\tint left = gas[i] - cost[i];\n\t\t\ttotal += left;\n\t\t\tif (sum + left < left) {\n\t\t\t\tstart = i;\n\t\t\t\tsum = left;\n\t\t\t} else {\n\t\t\t\tsum += left;\n\t\t\t}\n\t\t}\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\treturn start;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class WordSearch\n{\n\tpublic boolean exist( char[][] board, String word )\n\t{\n\t\tint height = board.length;\n\t\tint width = board[0].length;\n\t\tboolean[][] isVisited = new boolean[height][width];\n\t\t\n\t\tfor ( int i = 0; i < height; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < width; j++ )\n\t\t\t{\n\t\t\t\tif ( dfs( board, word, isVisited, i, j, 0 ) )\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate boolean dfs( char[][] board, String word, boolean[][] isVisited, int xCoor, int yCoor, int index )\n\t{\n\t\tif ( index == word.length() )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif ( xCoor >= board.length \n\t\t\t\t|| yCoor >= board[0].length\n\t\t\t\t|| xCoor < 0 \n\t\t\t\t|| yCoor < 0\n\t\t\t\t|| isVisited[xCoor][yCoor] \n\t\t\t\t|| word.charAt( index ) != board[xCoor][yCoor] )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tisVisited[xCoor][yCoor] = true;\n\t\tboolean result = dfs( board, word, isVisited, xCoor + 1, yCoor, index + 1 )\n\t\t\t\t\t|| dfs( board, word, isVisited, xCoor - 1, yCoor, index + 1 )\n\t\t\t\t\t|| dfs( board, word, isVisited, xCoor, yCoor - 1, index + 1 )\n\t\t\t\t\t|| dfs( board, word, isVisited, xCoor, yCoor + 1, index + 1 );\t\t\n\t\tisVisited[xCoor][yCoor] = false;\n\t\treturn result;\n\t}\n}\n", "nl": "FreemanZhang"}
{"code": "    public class Solution {\n        public int largestRectangleArea(int[] height) {\n            return find_largestRectangleArea(height,0,height.length-1);    \n        }\n        \n        public int find_largestRectangleArea(int[] height,int l, int r){\n            int lowest=0, maxArea = 0;\n            if(l<=r){\n                lowest = find_min(height,l,r);\n                int area = height[lowest]*(r+1-l);\n                \n                maxArea = Math.max(\n                find_largestRectangleArea(height,l,lowest-1),\n                find_largestRectangleArea(height,lowest+1,r));\n                \n                return area>maxArea?area:maxArea;\n            }\n            return 0;    \n        }\n        \n        \n        public int find_min(int[] A,int l, int r){\n            int minIndex =l;\n            if(l<=r)\n                for(int i=l;i<=r;i++)\n                    if(A[i]<A[minIndex])\n                        minIndex = i;\n            return minIndex;\n                \n        }\n        \n    }", "nl": "azheanda"}
{"code": "public class L038_Count_and_Say {\n\n\tpublic String countAndSay(int n) {\n\n\t\tString init = \"1\";\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tinit = countAndSay(init);\n\t\t}\n\n\t\treturn init;\n\t}\n\n\tString countAndSay(String string) {\n\n\t\tchar[] str = string.toCharArray();\n\n\t\tString s = \"\";\n\n\t\tint p = 1;\n\t\tint count = 1;\n\t\tchar last = str[0];\n\n\t\tfor (; p < str.length; p++) {\n\t\t\tif (str[p] == last) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\ts += \"\" + count + last;\n\t\t\t\tcount = 1;\n\t\t\t\tlast = str[p];\n\t\t\t}\n\t\t}\n\n\t\ts += \"\" + count + last;\n\n\t\treturn s;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class MergeIntervals {\n  public static class Interval {\n    int start;\n    int end;\n\n    Interval() {\n      start = 0;\n      end = 0;\n    }\n\n    Interval(int s, int e) {\n      start = s;\n      end = e;\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    Interval i1 = new Interval(1, 2);\n    Interval i2 = new Interval(3, 4);\n    Interval i3 = new Interval(5, 6);\n    Interval i4 = new Interval(1, 10);\n    List<Interval> result = new MergeIntervals().merge(Arrays.asList(i1, i2, i3, i4));\n    result.forEach((I) -> System.out.println(I.start + \" \" + I.end));\n  }\n\n  public List<Interval> merge(List<Interval> intervals) {\n    if (intervals.isEmpty()) return new ArrayList<>();\n    Collections.sort(intervals, (o1, o2) -> Integer.compare(o1.start, o2.start));\n    List<Interval> result = new ArrayList<>();\n    Interval curr = intervals.get(0);\n    for (int i = 1, l = intervals.size(); i < l; i++) {\n      Interval I = intervals.get(i);\n      if (I.start >= curr.start\n          && I.start <= curr.end) { // check if the new interval overlaps with the current\n        curr.end = curr.end > I.end ? curr.end : I.end;\n      } else {\n        result.add(curr);\n        curr = I;\n      }\n    }\n    result.add(curr);\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> rst = new ArrayList<Integer>();\n        if (n < 0) {\n            return rst;\n        } else if (n == 0) {\n            rst.add(0);\n            return rst;\n        }\n        char[] list = new char[n];\n        for (int i = 0; i < n; i++) {\n            list[i] = '0';\n        }\n        helper(rst, list, n - 1);\n        \n        return rst;\n    }\n    \n    public void helper(List<Integer> rst, char[] list, int index) {\n        \n        rst.add(Integer.parseInt(new String(list), 2));                \n        \n        list[index] = list[index] == '0' ? '1' : '0';\n        int num = Integer.parseInt(new String(list), 2);\n        if (!rst.contains(num)) {\n            helper(rst, list, index);\n        }\n        list[index] = list[index] == '0' ? '1' : '0';\n        \n        if (index -1 >= 0) {\n             list[index - 1] = list[index - 1] == '0' ? '1' : '0';\n             num = Integer.parseInt(new String(list), 2);\n             if (!rst.contains(num)) {\n                 helper(rst, list, index - 1);\n             }\n            list[index - 1] = list[index - 1] == '0' ? '1' : '0';\n        }\n        \n        if (index + 1 < list.length) {\n             list[index + 1] = list[index + 1] == '0' ? '1' : '0';\n             num = Integer.parseInt(new String(list), 2);\n             if (!rst.contains(num)) {\n                 helper(rst, list, index + 1);\n             }\n            list[index + 1] = list[index + 1] == '0' ? '1' : '0';\n        }\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public String countAndSay(int n) {\n        String current=\"1\", next=\"\";\n        if(n==1)\n            return current;\n        \n        for(int i=2;i<=n;i++){\n            int count=1;\n            for(int j=0;j<current.length();j++){\n                if(j>0) \n                    if(current.charAt(j)==current.charAt(j-1))\n                        count++;\n                    else{\n                        next=next+count+current.charAt(j-1);\n                        count=1;\n                    }          \n                if(j == current.length()-1)\n                    next=next+count+current.charAt(j);\n                \n                                    \n            }\n            current = next;\n            next = \"\";\n        }\n        \n        return current;\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class AddBinary {\n\tpublic String addBinary(String a, String b) {\n\t\tchar[] str1;\n\t\tchar[] str2;\n\n\t\tif (a.length() >= b.length()) {\n\t\t\tstr1 = a.toCharArray();\n\t\t\tstr2 = b.toCharArray();\n\t\t} else {\n\t\t\tstr1 = b.toCharArray();\n\t\t\tstr2 = a.toCharArray();\n\t\t}\n\n\t\tint m = str1.length;\n\t\tint n = str2.length;\n\n\t\tchar[] sum = new char[m];\n\n\t\tint i = m - 1;\n\t\tchar carry = '0';\n\n\t\t--m;\n\t\t--n;\n\n\t\twhile (n >= 0) {\n\t\t\tif (str1[m] == '0' && str2[n] == '0') {\n\t\t\t\tsum[i] = carry;\n\t\t\t\tcarry = '0';\n\t\t\t} else if (str1[m] == '1' && str2[n] == '1') {\n\t\t\t\tsum[i] = carry;\n\t\t\t\tcarry = '1';\n\t\t\t} else {\n\t\t\t\tif (carry == '1') {\n\t\t\t\t\tsum[i] = '0';\n\t\t\t\t} else {\n\t\t\t\t\tsum[i] = '1';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t--m;\n\t\t\t--n;\n\t\t\t--i;\n\t\t}\n\n\t\twhile (m >= 0) {\n\t\t\tif (str1[m] == '1') {\n\t\t\t\tif (carry == '1') {\n\t\t\t\t\tsum[i] = '0';\n\t\t\t\t} else {\n\t\t\t\t\tsum[i] = '1';\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tsum[i] = carry;\n\t\t\t\tcarry = '0';\n\t\t\t}\n\t\t\t--m;\n\t\t\t--i;\n\t\t}\n\n\t\tString result = new String(sum);\n\n\t\tif (carry == '1') {\n\t\t\treturn \"1\" + result;\n\t\t} \n\t\t\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString a = \"11\";\n\t\tString b = \"10\";\n\n\t\tAddBinary slt = new AddBinary();\n\t\tString result = slt.addBinary(a, b);\n\t\tSystem.out.println(result);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class MergeIntervals2 {\n\n\tpublic ArrayList<Interval> merge(ArrayList<Interval> intervals) {\n\t\tArrayList<Interval> res = new ArrayList<Interval>();\n\t\tif (intervals == null)\n\t\t\treturn intervals;\n\t\tint len = intervals.size();\n\t\tif (len == 0 || len == 1)\n\t\t\treturn intervals;\n\n\t\tCollections.sort(intervals, new Comparator<Interval>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Interval a, Interval b) {\n\t\t\t\treturn a.start - b.start;\n\t\t\t}\n\t\t});\n\n\t\tInterval a = intervals.get(0);\n\t\tfor (int i = 1; i < len; i++) {\n\t\t\tInterval b = intervals.get(i);\n\t\t\tif (a.end >= b.start) {\n\t\t\t\ta = new Interval(Math.min(a.start, b.start), Math.max(a.end,\n\t\t\t\t\t\tb.end));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.add(a);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t}\n\t\tres.add(a);\n\t\treturn res;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class TextJustification2 {\n\tpublic ArrayList<String> fullJustify(String[] words, int L) {\n\t\tArrayList<String> ret = new ArrayList<String>();\n\t\tif (words == null || words.length == 0)\n\t\t\treturn ret;\n\n\t\tint start = 0, end = pack(words, start, L);\n\t\tret.add(convert(words, start, end, L));\n\t\twhile (end != words.length - 1) {\n\t\t\tstart = end + 1;\n\t\t\tend = pack(words, start, L);\n\t\t\tret.add(convert(words, start, end, L));\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate int pack(String[] words, int start, int L) {\n\t\tint next = start; // the index of the next word\n\t\tint length = words[next].length();\n\n\t\twhile (next + 1 < words.length && length + 1 + words[next + 1].length() <= L)\n\t\t\tlength += words[++next].length() + 1;\n\t\treturn next;\n\t}\n\n\tprivate String convert(String[] words, int start, int end, int L) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tif (start == end) {\n\t\t\tsb.append(words[start]);\n\t\t\tfor (int i = 0; i < L - words[start].length(); i++) {\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\telse if (end == words.length - 1) {\n\t\t\tint curLen = 0;\n\t\t\tfor (int i = start; i < end; i++) {\n\t\t\t\tsb.append(words[i]);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tcurLen += words[i].length() + 1;\n\t\t\t}\n\t\t\tsb.append(words[end]);\n\t\t\tcurLen += words[end].length();\n\n\t\t\tfor (int i = 0; i < L - curLen; i++) {\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tint totalLen = 0, numOfSpaces = end - start;\n\t\tfor (int i = start; i <= end; i++)\n\t\t\ttotalLen += words[i].length();\n\t\tint lenOfPaddingSpace = (L - totalLen) / numOfSpaces;\n\t\tint numOfExtraSpaces = (L - totalLen) % numOfSpaces;\n\n\t\tint count = 0; // count of the extra spaces\n\t\tfor (int i = start; i < end; i++) {\n\t\t\tsb.append(words[i]);\n\t\t\tfor (int j = 0; j < lenOfPaddingSpace; j++)\n\t\t\t\tsb.append(\" \");\n\t\t\tif (count < numOfExtraSpaces)\n\t\t\t\tsb.append(\" \");\n\t\t\tcount++;\n\t\t}\n\t\tsb.append(words[end]);\n\n\t\treturn sb.toString();\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class UniquePaths2 {\n\tpublic int uniquePaths(int m, int n) {\n\t\treturn backtrack(0, 0, m, n);\n\t}\n\tpublic int backtrack(int r, int c, int m, int n) {\n\t\tif (r == m - 1 && c == n - 1)\n\t\t\treturn 1;\n\t\tif (r > m - 1 || c > n - 1)\n\t\t\treturn 0;\n\t\treturn backtrack(r + 1, c, m, n) + backtrack(r, c + 1, m, n);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MergeIntervals {\n  public class IntervalCmp implements Comparator<Interval> {\n    @Override\n    public int compare(Interval i1, Interval i2) {\n      if (i1.start < i2.start) return -1;\n      if (i1.start == i2.start && i1.end <= i2.end) return -1;\n      return 1;\n    }\n  }\n\n  public ArrayList<Interval> merge(ArrayList<Interval> intervals) {\n    ArrayList<Interval> ret = new ArrayList<Interval>();\n    if (intervals.size() == 0) return ret;\n    Interval[] arr = new Interval[intervals.size()];\n    intervals.toArray(arr);\n    Arrays.sort(arr, new IntervalCmp());\n    int start = arr[0].start;\n    int end = arr[0].end;\n    for (int i = 0; i < arr.length; i++) {\n      if (arr[i].start <= end) {\n        end = Math.max(end, arr[i].end);\n      } else {\n        ret.add(new Interval(start, end));\n        start = arr[i].start;\n        end = arr[i].end;\n      }\n    }\n    ret.add(new Interval(start, end));\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class BinaryTreePreorderTraversal {\n\tpublic ArrayList<Integer> preorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\n\t\tif (root != null) {\n\t\t\tresult.add(root.val);\n\n\t\t\tresult.addAll(preorderTraversal(root.left));\n\n\t\t\tresult.addAll(preorderTraversal(root.right));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic ArrayList<Integer> preorderTraversalIter(TreeNode root) {\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\n\t\tif (root == null) {\n\t\t\treturn result;\n\t\t}\n\n\t\tStack<TreeNode> nodeStack = new Stack<TreeNode>();\n\t\tnodeStack.push(root);\n\n\t\twhile (!nodeStack.empty()) { \n\t\t\tTreeNode node = nodeStack.pop();\n\t\t\tresult.add(node.val);\n\n\t\t\tif (node.right != null) {\n\t\t\t\tnodeStack.push(node.right);\n\t\t\t}\n\n\t\t\tif (node.left != null) {\n\t\t\t\tnodeStack.push(node.left);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tBinaryTreePreorderTraversal slt = new BinaryTreePreorderTraversal();\n\t\tTreeNode root = new TreeNode(1);\n\t\tTreeNode n2 = new TreeNode(2);\n\t\tTreeNode n3 = new TreeNode(3);\n\t\troot.right = n2;\n\t\tn2.left = n3;\n\t\t\n\t\tArrayList<Integer> res = slt.preorderTraversal(root);\n\t\tSystem.out.println(res.toString());\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class ContainerWithMostWater {\n\n\tpublic int maxArea(int[] height) {\n\t\tint len = height.length, low = 0, high = len - 1;\n\t\tint maxArea = 0;\n\t\twhile (low < high) {\n\t\t\tmaxArea = Math.max(maxArea, (high - low) * Math.min(height[low], height[high]));\n\t\t\tif (height[low] < height[high]) {\n\t\t\t\tlow++;\n\t\t\t} else {\n\t\t\t\thigh--;\n\t\t\t}\n\t\t}\n\t\treturn maxArea;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class BinaryTreeInorderTraversal2 {\n\tpublic ArrayList<Integer> inorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (root == null)\n\t\t\treturn list;\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tTreeNode node = root;\n\t\twhile (!stack.isEmpty() || node != null) {\n\t\t\twhile (node != null) {\n\t\t\t\tstack.push(node);\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t\tnode = stack.pop();\n\t\t\tlist.add(node.val);\n\t\t\tnode = node.right;\n\t\t}\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public String addBinary(String a, String b) {\n        if (a.equals(\"0\")) {\n            return b;\n        }\n        if (b.equals(\"0\")) {\n            return a;\n        }\n        if (a.length()<b.length()) {\n            return new Solution().addBinary(b, a);\n        }\n        int[] ia=new int[a.length()];\n        for (int i = a.length()-1; i >=0; i--) {\n            ia[a.length()-1-i]=Integer.parseInt(a.substring(i, i+1));\n        }\n        int[] ib=new int[b.length()];\n        for (int i = b.length()-1; i >=0; i--) {\n            ib[b.length()-1-i]=Integer.parseInt(b.substring(i, i+1));\n        }\n        int target=0;\n        int[] ias=new int[a.length()];\n        for (int i = 0; i < ia.length; i++) {\n            int k=0;\n            if (i<ib.length) {\n                k=ia[i]+ib[i]+target;\n                ias[i]=k%2;\n                target=k/2;\n            }else {\n                k=ia[i]+target;\n                ias[i]=k%2;\n                target=k/2;\n            }\n        }\n        StringBuffer sb=new StringBuffer();\n        if (target==1) {\n            sb.append(\"1\");\n        }\n        for (int i = ias.length-1; i >=0 ; i--) {\n            sb.append(\"\"+ias[i]);\n        }\n        return sb.toString();\n    }\n}", "nl": "corpsepiges"}
{"code": "public class ValidPalindrome2 {\n\tpublic boolean isPalindrome(String s) {\n\t\tif (s.length() < 2)\n\t\t\treturn true;\n\t\ts = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\t\tStack<Character> stack = new Stack<Character>();\n\n\t\tint index = 0;\n\t\twhile (index < s.length() / 2) {\n\t\t\tstack.push(s.charAt(index));\n\t\t\tindex++;\n\t\t}\n\n\t\tif (s.length() % 2 == 1)\n\t\t\tindex++;\n\n\t\twhile (index < s.length()) {\n\t\t\tif (stack.empty())\n\t\t\t\treturn false;\n\t\t\tif (s.charAt(index) != stack.pop())\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\tindex++;\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class TextJustification\n{\n\t@Test\n\tpublic void test()\n\t{\n\t\tSystem.out.println( fullJustify( new String[]{ \"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification\" }, 16 ) );\n\t\tSystem.out.println( fullJustify( new String[]{ \"What\", \"must\", \"be\", \"shall\", \"be\" }, 12 ) );\n\t}\n\t\n\tprivate void leftAlign( List<String> result, String[] words, int startPos, int numWords, int maxWidth )\n\t{\n\t\tStringBuilder currLine = new StringBuilder();\n\t\tfor ( int i = 0; i < numWords; i++ )\n\t\t{\n\t\t\tcurrLine.append( words[startPos + i] );\n\t\t\tcurrLine.append( ' ' );\n\t\t}\n\t\tif ( currLine.length() > maxWidth )\n\t\t{\n\t\t\tcurrLine.deleteCharAt( currLine.length() - 1 );\n\t\t}\n\t\t\n\t\tfor ( int i = 0; i < maxWidth - currLine.length(); i++ )\n\t\t{\n\t\t\tcurrLine.append( ' ' );\n\t\t}\n\t\tresult.add( currLine.toString() );\n\t}\n\t\n\tprivate void evenlyDisperse( List<String> result, String[] words, int startPos, int numWords, int maxWidth )\n\t{\n \t   int numSpaces = maxWidth;\n \t   for ( int i = 0; i < numWords; i++ )\n \t   {\n \t\t   numSpaces -= words[i + startPos].length();\n \t   }\n \t   int average = numSpaces / ( numWords - 1 );\n \t   int residual = numSpaces % ( numWords - 1 );\n \t       \t   \n \t   StringBuilder currLine = new StringBuilder();\n \t   for ( int i = 0; i < numWords - 1; i++ )\n \t   {\n \t\t   currLine.append( words[startPos + i] );\n \t\t   \n \t\t   for ( int j = 0; j < average; j++ )\n \t\t   {\n \t\t\t   currLine.append(' ');\n \t\t   }\t    \t\t   \n \t\t   if ( residual > 0 )\n \t\t   {\n \t\t\t   currLine.append(' ');\n \t\t\t   residual--;\n \t\t   }\n \t   }\n \t   currLine.append( words[startPos + numWords - 1] );\n \t   result.add( currLine.toString() );\n\t}\n\t\n\tprivate int calcNumWords( int startPos, String[] words, int maxWidth )\n\t{\n\t\tint numWords = 0;\n\t\tint lineLength = 0;\n\t\twhile ( startPos + numWords < words.length && words[startPos + numWords].length() + lineLength <= maxWidth )\n\t\t{\n\t\t\tlineLength += words[startPos + numWords].length();\n\t\t\tlineLength += 1;\n\t\t\tnumWords++;\n\t\t}\n\t\treturn numWords;\n\t}\n\t\n    public List<String> fullJustify( String[] words, int maxWidth )\n    {\n       List<String> result = new ArrayList<>();\n       \n       for ( int endPos = 0; endPos < words.length; )\n       {    \t       \t   \n    \t   int startPos = endPos;\n    \t   int numWords = calcNumWords( endPos, words, maxWidth );\n    \t   endPos += numWords;\n\n    \t   if ( numWords == 1 \n    \t\t\t   || endPos == words.length )\n    \t   {\n    \t\t   leftAlign( result, words, startPos, numWords, maxWidth );\n    \t   }\n    \t   else\n    \t   {\n    \t\t   evenlyDisperse( result, words, startPos, numWords, maxWidth );\n    \t   }\n       }\n       \n       return result;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class WordSearch {\n  public boolean exist(char[][] board, String word) {\n    int height = board.length;\n    int width = board[0].length;\n    boolean[][] map = new boolean[height][width];\n    for (int i = 0; i < height; i++) {\n      for (int j = 0; j < width; j++) {\n        if (search(board, map, i, j, word, 0)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private boolean search(char[][] board, boolean[][] map, int x, int y, String word, int index) {\n    if (word.charAt(index) != board[x][y]) {\n      return false;\n    }\n    if (index == word.length() - 1) {\n      return true;\n    }\n\n    int height = board.length;\n    int width = board[0].length;\n    map[x][y] = true;\n\n    if (x > 0 && !map[x - 1][y] && search(board, map, x - 1, y, word, index + 1)) {\n      return true;\n    }\n\n    if (x < height - 1 && !map[x + 1][y] && search(board, map, x + 1, y, word, index + 1)) {\n      return true;\n    }\n\n    if (y > 0 && !map[x][y - 1] && search(board, map, x, y - 1, word, index + 1)) {\n      return true;\n    }\n\n    if (y < width - 1 && !map[x][y + 1] && search(board, map, x, y + 1, word, index + 1)) {\n      return true;\n    }\n\n    map[x][y] = false;\n\n    return false;\n  }\n}\n", "nl": "mengli"}
{"code": "public class ReverseLinkedList {\n  private ListNode newHead;\n\n  public static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n\n  \n  public static void main(String[] args) throws Exception {\n    ListNode node1 = new ListNode(1);\n    ListNode node2 = new ListNode(2);\n    ListNode node3 = new ListNode(3);\n    ListNode node4 = new ListNode(4);\n    ListNode node5 = new ListNode(5);\n    ListNode node6 = new ListNode(6);\n    node1.next = node2;\n    node2.next = node3;\n    node3.next = node4;\n    node4.next = node5;\n    ListNode newNode = new ReverseLinkedList().reverseList(node1);\n    System.out.println(newNode.val);\n  }\n\n  public ListNode reverseList(ListNode head) {\n    if (head == null) return null;\n    else if (head.next == null) return head;\n    reverse(head).next = null;\n    return newHead;\n  }\n\n  private ListNode reverse(ListNode head) {\n    if (head.next == null) {\n      newHead = head;\n      return head;\n    }\n    ListNode node = reverse(head.next);\n    node.next = head;\n    return head;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "class NextPermutation {\n    public static void main(String[] args) {\n\n    }\n\n    \n    public void nextPermutation(int[] num) {\n        if (num == null || num.length < 2) return;\n        for (int i = num.length - 2; i >= 0; i--) {\n            if (num[i] < num[i + 1]) {\n                int j = num.length - 1;\n                for (; j > i; j--) if (num[j] > num[i]) break;\n                swap(num, i, j);\n                reverse(num, i + 1);\n                return;\n            }\n        }\n        reverse(num, 0);\n        return;\n    }\n\n    private void swap(int[] num, int i, int j) {\n        int t = num[i];\n        num[i] = num[j];\n        num[j] = t;\n    }\n\n    private void reverse(int[] num, int s) {\n        int e = num.length - 1;\n        while (s < e) {\n            swap(num, s, e);\n            s++;\n            e--;\n        }\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class MaximumDepthOfBinaryTree {\n\n  \n  private int maxDepth(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n    int left = maxDepth(root.left);\n    int right = maxDepth(root.right);\n    return Math.max(left, right) + 1;\n  }\n\n  \n  private int maxDepthB(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    Deque<Integer> depths = new ArrayDeque<>();\n    stack.push(root);\n    depths.push(1);\n    int maxDepth = 0;\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pop();\n      int d = depths.pop();\n      maxDepth = Math.max(d, maxDepth);\n      if (node.left != null) {\n        stack.push(node.left);\n        depths.push(d + 1);\n      }\n      if (node.right != null) {\n        stack.push(node.right);\n        depths.push(d + 1);\n      }\n    }\n    return maxDepth;\n  }\n\n  \n  public int maxDepthC(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int depth = 0;\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.poll();\n        if (node.left != null) {\n          queue.offer(node.left);\n        }\n        if (node.right != null) {\n          queue.offer(node.right);\n        }\n      }\n      depth++;\n    }\n    return depth;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class CombinationSumII {\n\tpublic ArrayList<ArrayList<Integer>> combinationSum2(int[] num, int target) {\n\t\tArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\t\tif (num == null || num.length == 0)\n\t\t\treturn res;\n\t\tArrays.sort(num);\n\t\thelper(num, 0, target, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\n\tprivate void helper(int[] num, int start, int target, ArrayList<Integer> item, ArrayList<ArrayList<Integer>> res) {\n\t\tif (target == 0) {\n\t\t\tres.add(new ArrayList<Integer>(item));\n\t\t\treturn;\n\t\t}\n\t\tif (target < 0)\n\t\t\treturn;\n\t\tfor (int i = start; i < num.length; i++) {\n\t\t\tif (i > start && num[i] == num[i - 1])\n\t\t\t\tcontinue;\n\t\t\titem.add(num[i]);\n\t\t\thelper(num, i + 1, target - num[i], item, res);\n\t\t\titem.remove(item.size() - 1);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    ArrayList<String> rst = new ArrayList<String>();\n    public ArrayList<String> generateParenthesis(int n) {\n    \tif (n <= 0) {\n    \t\treturn rst;\n    \t} \n    \tArrayList<String> list = new ArrayList<String>();\n    \thelper(list, 0, 0, n);\n    \treturn rst;\n    }\n\n    public void helper(ArrayList<String> list, int left, int right, int n) {\n    \tif (left == n && right == n) {\n    \t\tStringBuffer sb = new StringBuffer();\n    \t\tfor (String s : list) {\n    \t\t\tsb.append(s);\n    \t\t}\n    \t\trst.add(sb.toString());\n    \t\treturn;\n    \t}\n    \tif (left < n) {\n    \t\tlist.add(\"(\");\n    \t\thelper(list, left + 1, right, n);\n    \t\tlist.remove(list.size() - 1);\n    \t}\n    \tif (right < left) {\n    \t\tlist.add(\")\");\n    \t\thelper(list, left, right + 1, n);\n    \t\tlist.remove(list.size() - 1);\n    \t}\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class SubsetsII2 {\n\tpublic class Solution {\n\t\tpublic ArrayList<ArrayList<Integer>> subsetsWithDup(int[] num) {\n\t\t\tArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<Integer> tmp = new ArrayList<Integer>();\n\t\t\tArrays.sort(num);\n\t\t\tres.add(tmp);\n\t\t\tdfs(res, tmp, num, 0);\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic void dfs(ArrayList<ArrayList<Integer>> res, ArrayList<Integer> tmp, int[] num, int pos) {\n\t\t\tfor (int i = pos; i <= num.length - 1; i++) {\n\t\t\t\ttmp.add(num[i]);\n\t\t\t\tres.add(new ArrayList<Integer>(tmp));\n\t\t\t\tdfs(res, tmp, num, i + 1);\n\t\t\t\ttmp.remove(tmp.size() - 1);\n\t\t\t\twhile (i < num.length - 1 && num[i] == num[i + 1])\n\t\t\t\t\ti++; // \u935e\ue219\u7af4\u9428\u52eb\u5c2f\u9352\ue0a2\u6c28\u9366\u3128\u7e56\u6d93\u741b\n\t\t\t}\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public int reverseInteger(int n) {\n        long num = (long)n;\n        int sign = n > 0 ? 1 : -1;\n        String rst = new StringBuilder(Math.abs(num)+\"\").reverse().toString();\n\t\tnum = Long.parseLong(rst) * sign;\n\t\t\n\t\tif (num > Integer.MAX_VALUE || num < Integer.MIN_VALUE) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn (int)num;\n\t\t}\n    }\n}\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int minPathSum(int[][] grid) {\n        \n        for(int i=0;i<grid.length;i++)\n            for(int j=0;j<grid[i].length;j++){\n                if(i==0 && j>0)\n                    grid[i][j] += grid[i][j-1];\n                else if(i>0&&j==0)\n                    grid[i][j] += grid[i-1][j];\n                else if(i>0 && j>0)\n                    grid[i][j] += Math.min(grid[i][j-1],grid[i-1][j]);                                   \n                \n            }\n        return grid[grid.length-1][grid[0].length-1];\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class MergeTwoSortedLists {\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tif (l1 == null) {\n\t\t\treturn l2;\n\t\t}\n\t\tif (l2 == null) {\n\t\t\treturn l1;\n\t\t}\n\n\t\tListNode node = null;\n\t\tListNode head = null;\n\n\t\twhile (l1 != null && l2 != null) {\n\t\t\tif (l1.val <= l2.val) {\n\t\t\t\tif (node == null) {\n\t\t\t\t\tnode = l1;\n\t\t\t\t\thead = node;\n\t\t\t\t} else {\n\t\t\t\t\tnode.next = l1;\n\t\t\t\t\tnode = node.next;\n\t\t\t\t}\n\n\t\t\t\tl1 = l1.next;\n\t\t\t} else {\n\t\t\t\tif (node == null) {\n\t\t\t\t\tnode = l2;\n\t\t\t\t\thead = node;\n\t\t\t\t} else {\n\t\t\t\t\tnode.next = l2;\n\t\t\t\t\tnode = node.next;\n\t\t\t\t}\n\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t}\n\n\t\tif (l1 != null) {\n\t\t\tnode.next = l1;\n\t\t} else if (l2 != null) {\n\t\t\tnode.next = l2;\n\t\t}\n\n\t\treturn head;\n\t}\n\n\tpublic void printList(ListNode node) {\n\t\twhile (node != null) {\n\t\t\tSystem.out.print(node.val + \"->\");\n\t\t\tnode = node.next;\n\t\t}\n\t\tSystem.out.println(\" \");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tListNode a1 = new ListNode(1);\n\t\tListNode a2 = new ListNode(3);\n\t\tListNode a3 = new ListNode(7);\n\t\ta1.next = a2;\n\t\ta2.next = a3;\n\n\t\tListNode b1 = new ListNode(2);\n\t\tListNode b2 = new ListNode(4);\n\t\tb1.next = b2;\n\n\t\tMergeTwoSortedLists slt = new MergeTwoSortedLists();\n\t\tListNode res = slt.mergeTwoLists(a1, b1);\n\t\tslt.printList(res);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class SortList {\n\n    public class Solution {\n\n        private ListNode merge(ListNode h1, ListNode h2) {\n            ListNode dummy = new ListNode(0);\n            ListNode prefix = dummy;\n            while (h1 != null || h2 != null) {\n                if (h2 == null || (h1 != null && h1.val < h2.val)) {\n                    prefix.next = h1;\n                    prefix = h1;\n                    h1 = h1.next;\n                } else {\n                    prefix.next = h2;\n                    prefix = h2;\n                    h2 = h2.next;\n                }\n            }\n            return dummy.next;\n        }\n\n        private ListNode sortList(ListNode head, int start, int end,\n                ListNode[] tail) {\n            if (start == end) {\n                tail[0] = head;\n                return null;\n            }\n            if (end - start == 1) {\n                tail[0] = head.next;\n                head.next = null;\n                return head;\n            }\n            int mid = start + (end - start) / 2;\n            ListNode left = sortList(head, start, mid, tail);\n            ListNode right = sortList(tail[0], mid, end, tail);\n            return merge(left, right);\n        }\n\n        private int len(ListNode head) {\n            int len = 0;\n            while (head != null) {\n                len++;\n                head = head.next;\n            }\n            return len;\n        }\n\n        public ListNode sortList(ListNode head) {\n            return sortList(head, 0, len(head), new ListNode[1]);\n        }\n    }\n\n    public static class UnitTest {\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MergeIntervals {\n\tpublic class Solution {\n\t\tpublic ArrayList<Interval> merge(ArrayList<Interval> intervals) {\n\n\t\t\tCollections.sort(intervals, new Comparator<Interval>() {\n\t\t\t\tpublic int compare(Interval a, Interval b) {\n\t\t\t\t\treturn a.start > b.start ? 1 : (a.start == b.start ? 0 : -1);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tArrayList<Interval> res = new ArrayList<Interval>();\n\t\t\tint i = 0;\n\t\t\twhile (i < intervals.size()) {\n\t\t\t\tint j = i + 1;\n\t\t\t\tint end = intervals.get(i).end;\n\t\t\t\twhile (j < intervals.size() && end >= intervals.get(j).start) {\n\t\t\t\t\tend = Math.max(end, intervals.get(j).end);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tres.add(new Interval(intervals.get(i).start, end));\n\t\t\t\ti = j;\n\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node == null) {\n            return node;\n        }\n        if (map.containsKey(node)) {\n            return map.get(node);\n        }\n\n        UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);\n        map.put(node, newNode);\n        for (UndirectedGraphNode neighbor: node.neighbors) {\n            newNode.neighbors.add(cloneGraph(neighbor));\n        }\n        return newNode;\n    }\n}", "nl": "awangdev"}
{"code": "public class L082_Remove_Duplicates_from_Sorted_List_II {\n\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\n\t\tif (head == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (head.next == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tint val = head.val;\n\n\t\tListNode node = head;\n\n\t\tboolean killme = false;\n\t\t\n\t\twhile (node.next != null && node.next.val == val) {\n\t\t\tnode = node.next;\n\t\t\tkillme = true;\n\t\t}\n\n\t\tif (killme) {\n\t\t\thead = deleteDuplicates(node.next);\n\t\t} else {\n\t\t\thead.next = deleteDuplicates(node.next);\n\t\t}\n\n\t\treturn head;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n         List<List<Integer>> answerList=new ArrayList<List<Integer>>();\n            for (int i = 0; i < nums.length; i++) {\n                int size=answerList.size();\n                if (size==0) {\n                    for (int j = 0; j < nums.length; j++) {\n                        List<Integer> intList=new ArrayList<Integer>();\n                        intList.add(nums[j]);\n                        answerList.add(intList);\n                    }\n                }else {\n                    for (int j = 0; j < size; j++) {\n                        List<Integer> intList=answerList.get(j);\n                        Map<Integer,String> map=new HashMap<Integer,String>();\n                        for (int l = 0; l <intList.size(); l++) {\n                            map.put(intList.get(l), \"\u701b\u6a3a\u6e6a\");\n                        }\n                        for (int k = 0; k < nums.length; k++) {\n                            if (map.get(nums[k])==null) {\n                                System.out.println(\"k=\"+k);\n                                List<Integer> newList=new ArrayList<Integer>();\n                                for (int l = 0; l < intList.size(); l++) {\n                                    newList.add(intList.get(l));\n                                }\n                                newList.add(nums[k]);\n                                System.out.println();\n                                answerList.add(newList);\n                            }\n                        }\n                    }\n                    if (size!=answerList.size()) {\n                        for (int j = size-1; j >=0; j--) {\n                            answerList.remove(j);\n                        }\n                    }\n                }\n            }\n         \n         return answerList;\n        }\n}", "nl": "corpsepiges"}
{"code": "public class SingleNumber {\n\n    public class Solution {\n        public int singleNumber(int[] A) {\n            int ans = 0;\n            for (int i : A) {\n                ans ^= i;\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public int largestRectangleArea(int[] height) {\n        int[] area = new int[height.length];\n        int t=0;\n        Stack<Integer> stack = new Stack<Integer>();\n\n        for(int i=0;i<height.length;i++){\n          while(!stack.empty() && height[i]<=height[stack.peek()])\n                stack.pop();\n          \n          if(stack.empty())\n            t = -1;\n          else\n            t = stack.peek();\n\n          area[i] = i-t-1;\n          stack.push(i);\n        }\n\n        while(!stack.empty())\n          stack.pop();\n\n        for(int i=height.length-1;i>=0;i--){\n          while(!stack.empty() && height[i]<=height[stack.peek()])\n                stack.pop();\n          \n          if(stack.empty())\n            t = height.length;\n          else\n            t = stack.peek();\n\n          area[i] += t-i-1;\n          stack.push(i);\n        }\n\n        int max = 0;  \n        for (int i=0; i<area.length; i++)  {  \n            area[i] = height[i] * (area[i] + 1);  \n            if (area[i] > max)  \n              max = area[i];  \n        }  \n          \n        return max;  \n    }\n}\n ", "nl": "azheanda"}
{"code": "public class _41_firstMissingPositive {\n    public static void main(String[] args) {\n        _41_firstMissingPositive firstMissingPositive = new _41_firstMissingPositive();\n        System.out.println(firstMissingPositive.firstMissingPositive(new int[]{3, 4, -1, 1}));\n    }\n\n    \n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n\n        int contains = 0;\n        for (int i = 0; i < n; i++)\n            if (nums[i] == 1) {\n                contains++;\n                break;\n            }\n\n        if (contains == 0)\n            return 1;\n\n        if (n == 1)\n            return 2;\n\n        for (int i = 0; i < n; i++)\n            if ((nums[i] <= 0) || (nums[i] > n))\n                nums[i] = 1;\n\n        for (int i = 0; i < n; i++) {\n            int a = Math.abs(nums[i]);\n            if (a == n)\n                nums[0] = -Math.abs(nums[0]);\n            else\n                nums[a] = -Math.abs(nums[a]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            if (nums[i] > 0)\n                return i;\n        }\n\n        if (nums[0] > 0)\n            return n;\n\n        return n + 1;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class ReverseLinkedList2 {\n\n\tpublic  ListNode reverseList(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn head;\n\t\tif(head.next==null)\n\t\t    return head;\n\t\tListNode newHead = reverseList(head.next);\n\t\thead.next.next=head;\n\t\thead.next=null;\n\t\treturn newHead;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MajorityElement2 {\n\t  public int majorityElement(int[] num) {\n\t        int maj=0;\n\t        int count = 0;\n\t        for (int i = 0; i < num.length; i++){\n\t            if (count == 0){\n\t                maj = num[i];\n\t                count++;\n\t            }\n\t            else if (num[i] == maj){\n\t                count++;\n\t                if (count > num.length/2) return maj;\n\t            }\n\t            else count--;\n\t        }\n\t        return maj;\n\t    }\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int[] plusOne(int[] digits) {\n        if (digits.length == 0) return digits;\n        int carry = 1;\n        for (int i = digits.length - 1; i >= 0; --i) {\n            digits[i] += carry;\n            carry = digits[i] / 10;\n            digits[i] = digits[i] % 10;\n        }\n        if (carry == 0) return digits;\n        int[] res = new int[digits.length + 1];\n        res[0] = carry;\n        System.arraycopy(digits, 0, res, 1, digits.length);\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class WordBreak2 {\n\tpublic static boolean wordBreak(String s, Set<String> dict) {\n\t\tboolean[] t = new boolean[s.length() + 1];\n\t\tt[0] = true; // set first to be true, why?\n\n\t\tfor (int i = 0; i <= s.length(); i++) {\n\t\t\tfor (int j = i ; j >= 0; j--) {\n\t\t\t\tif (t[j] && dict.contains(s.substring(j, i))) {\n\t\t\t\t\tSystem.out.println(\"t[\"+i+\"]\"+t[i]);\n\t\t\t\t\tt[i] = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn t[s.length()];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tHashSet<String> dict = new HashSet<>();\n\t\tdict.add(\"cat\");\n\t\tdict.add(\"cats\");\n\t\tdict.add(\"and\");\n\t\tdict.add(\"sand\");\n\t\tdict.add(\"dog\");\n\t\tString s = \"catsanddog\";\n\t\tSystem.out.println(wordBreak(s, dict));\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L125_Valid_Palindrome {\n\n\tpublic boolean isPalindrome(String s) {\n\n\t\tif (s.length() <= 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\tchar[] chars = s.toLowerCase().toCharArray();\n\n\t\tfor (int st = 0, ed = chars.length - 1; st <= ed; st++, ed--) {\n\n\t\t\twhile (st < ed && !isValid(s, st))\n\t\t\t\tst++;\n\t\t\twhile (st < ed && !isValid(s, ed))\n\t\t\t\ted--;\n\n\t\t\tif (chars[st] != chars[ed])\n\t\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tboolean isValid(String s, int i) {\n\n\t\tchar c = s.charAt(i);\n\n\t\treturn (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z')\n\t\t\t\t|| (c >= 'A' && c <= 'Z');\n\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class L020_Valid_Parentheses {\n\n\tpublic boolean isValid(String s) {\n\n\t\tif (s == null || s.length() % 2 == 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tHashMap<Character, Character> map = new HashMap<Character, Character>();\n\t\tmap.put('(', ')');\n\t\tmap.put('[', ']');\n\t\tmap.put('{', '}');\n\n\t\tStack<Character> stack = new Stack<Character>();\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\n\t\t\tif (map.keySet().contains(c)) {\n\t\t\t\tstack.push(c);\n\n\t\t\t} else if (map.values().contains(c)) {\n\n\t\t\t\tif (!stack.empty() && map.get(stack.peek()) == c) {\n\t\t\t\t\tstack.pop();\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stack.empty();\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class JumpGame \n{\n    public boolean canJump( int[] nums )\n    {\n    \tif ( nums.length == 0 )\n    \t{\n    \t\treturn true;\n    \t}\n    \t\n    \tint maxPos = 0;\n    \tfor ( int i = 0; i < nums.length; i++ )\n    \t{\n    \t\tif ( maxPos < i )\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\t\n    \t\tmaxPos = Math.max( maxPos, i + nums[i] );\n    \t}\n    \t\n    \treturn maxPos >= nums.length - 1;\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertEquals( false, canJump( new int[]{ 0, 1 } ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class _58_lengthOfLastWord {\n\n    public static void main(String[] args) {\n        _58_lengthOfLastWord length = new _58_lengthOfLastWord();\n        System.out.println(length.lengthOfLastWord(\"Hello World\"));\n        System.out.println(length.lengthOfLastWord(\"  s  \"));\n        System.out.println(length.lengthOfLastWord(\" Hell    \"));\n    }\n\n    \n    public int lengthOfLastWord(String s) {\n        int startIndex = -1, endIndex = -1;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (startIndex != -1 && s.charAt(i) == ' ') {\n                endIndex = i;\n                break;\n            }\n            if (startIndex == -1 && s.charAt(i) != ' ') {\n                startIndex = i;\n            }\n        }\n        if (startIndex == -1) {\n            return 0;\n        }\n        return startIndex - endIndex;\n    }\n}\n", "nl": "pphdsny"}

{"code": "public class Subsets \n{\n    public List<List<Integer>> subsets( int[] nums ) \n    {\n    \tList<List<Integer>> allSubsets = new LinkedList<>();\n    \tLinkedList<Integer> oneSubset = new LinkedList<>();\n    \tgenerateSubsets( allSubsets, oneSubset, nums, 0 );\n    \treturn allSubsets;\n    }\n    \n    private void generateSubsets( List<List<Integer>> allSubsets, LinkedList<Integer> oneSubset, int[] nums, int startPos )\n    {\n    \tif ( startPos > nums.length )\n    \t{\n    \t\treturn;\n    \t}\n    \t\n    \tallSubsets.add( new LinkedList<>( oneSubset ) );\n    \t\n    \tfor ( int i = startPos; i < nums.length; i++ )\n    \t{\n    \t\toneSubset.addLast( nums[i] );\n    \t\tgenerateSubsets( allSubsets, oneSubset, nums, i + 1 );\n    \t\toneSubset.removeLast( );\n    \t}\n    }\n\n    @Test\n    public void test()\n    {\n    \tSystem.out.println( subsets( new int[]{ 1, 2, 3 } ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class LargestRectangleInHistogram\n{\n    public int largestRectangleArea( int[] heights )\n    {\n    \tif ( heights == null || heights.length == 0 )\n    \t{\n    \t\treturn 0;\n    \t}\n    \t\n    \tint maxRecArea = 0;\n    \tStack<Integer> incSeq = new Stack<>();\n    \tincSeq.push( -1 );\n    \tfor ( int i = 0; i < heights.length; i++ )\n    \t{\n    \t\tmaxRecArea = Math.max( maxRecArea, updateMaxRec( incSeq, i, heights[i], heights ) );\n\t\t\tincSeq.push( i );\n    \t}\n    \tmaxRecArea = Math.max( maxRecArea, updateMaxRec( incSeq, heights.length, 0, heights ) );\n    \treturn maxRecArea;\n    }\n    \n    private int updateMaxRec( Stack<Integer> incSeq, int nextIndex, int nextValue, int[] heights )\n    {\n    \tint maxRecArea = 0;\n\t    while ( incSeq.size() > 1 && heights[incSeq.peek()] >= nextValue )\n\t    {\n\t    \tint currIndex = incSeq.pop();\n\t    \tmaxRecArea = Math.max( maxRecArea, heights[currIndex] * ( nextIndex - incSeq.peek() - 1 ) ); \n\t    }\n    \treturn maxRecArea;\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertEquals( 10, largestRectangleArea( new int[]{ 2, 1, 5, 6, 2, 3} ) );\n    \tassertEquals( 6, largestRectangleArea( new int[]{ 4, 3, 2, 1} ) );\n    \tassertEquals( 12, largestRectangleArea( new int[]{ 1, 2, 3, 4, 5, 6} ) );\n    \tassertEquals( 2, largestRectangleArea( new int[]{ 1, 1} ) );\n    \tassertEquals( 3, largestRectangleArea( new int[]{ 2, 1, 2} ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class L198_House_Robber {\n\n\tpublic int rob(int[] nums) {\n\n\t\tint take = 0;\n\t\tint nonTake = 0;\n\t\tint max = 0;\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\ttake = nums[i] + nonTake;\n\t\t\tnonTake = max;\n\t\t\tmax = Math.max(take, nonTake);\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tpublic int rob2(int[] nums) {\n\n\t\tif (nums.length == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (nums.length == 1) {\n\t\t\treturn nums[0];\n\t\t}\n\n\t\tint[] P = new int[nums.length];\n\n\t\tP[0] = nums[0];\n\t\tP[1] = Math.max(nums[0], nums[1]);\n\n\t\tfor (int i = 2; i < nums.length; i++) {\n\t\t\tP[i] = Math.max(nums[i] + P[i - 2], P[i - 1]);\n\t\t}\n\n\t\treturn P[nums.length - 1];\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public void merge(int A[], int m, int B[], int n) {\n        int a = m-1;\n        int b = n-1;\n        int c = m+n-1;\n        \n        while(c>=0){\n            if(a>=0 && b>=0)\n                A[c] = A[a]>=B[b]?A[a--]:B[b--];\n                \n            else if(a<0)\n                A[c] = B[b--];\n            \n            else\n                A[c] = A[a--];\n                \n            c--;\n            \n        }       \n        \n    }\n}", "nl": "azheanda"}
{"code": "public class BinaryTreePostorderTraversal {\n  public static class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    TreeNode root = new TreeNode(1);\n    root.right = new TreeNode(2);\n    root.right.left = new TreeNode(3);\n    List<Integer> result = new BinaryTreePostorderTraversal().postorderTraversal(root);\n    result.forEach(System.out::println);\n  }\n\n  public List<Integer> postorderTraversal(TreeNode root) {\n    Stack<TreeNode> stack = new Stack<>();\n    List<Integer> result = new ArrayList<>();\n    if (root != null) {\n      stack.push(root);\n    }\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pop();\n      result.add(node.val);\n      if (node.left != null) {\n        stack.push(node.left);\n      }\n      if (node.right != null) {\n        stack.push(node.right);\n      }\n    }\n    Collections.reverse(result);\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class PathSum2 {\n\n  public List<List<Integer>> pathSum(TreeNode root, int sum) {\n    List<List<Integer>> res = new ArrayList<>();\n    if (root == null) return res;\n    dfs(root, sum, new ArrayList<>(), res);\n    return res;\n  }\n\n  public void dfs(TreeNode root, int sum, List<Integer> path, List<List<Integer>> res) {\n    if (root == null) return;\n    sum -= root.val;\n\n    if (root.left == null && root.right == null && sum == 0) {\n      path.add(root.val);\n      res.add(new ArrayList<>(path));\n      path.remove(path.size() - 1);\n      return;\n    }\n    path.add(root.val);\n    dfs(root.left, sum, path, res);\n    dfs(root.right, sum, path, res);\n    path.remove(path.size() - 1);\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int climbStairs(int n) {\n        int[] level =  new int[n+1];\n        level[0] = 1;\n        level[1] = 1;\n        for(int i=2;i<level.length;i++)\n            level[i] = level[i-1]+level[i-2];\n        return level[n];\n         \n    } \n}", "nl": "azheanda"}
{"code": "public class RotateList {\n\tpublic ListNode rotateRight(ListNode head, int n) {\n\t\tif (head == null || n == 0) {\n\t\t\treturn head;\n\t\t}\n\n\t\tint length = 1;\n\t\tListNode node = head;\n\t\twhile (node.next != null) {\n\t\t\t++length;\n\t\t\tnode = node.next;\n\t\t}\n\n\t\tnode.next = head;\n\n\t\tint m = n % length;\n\n\t\tfor (int i = 0; i < length - m; ++i) {\n\t\t\tnode = node.next;\n\t\t}\n\n\t\thead = node.next;\n\n\t\tnode.next = null;\n\n\t\treturn head;\n\t}\n\n\tpublic void printList(ListNode node) {\n\t\twhile (node != null) {\n\t\t\tSystem.out.print(node.val + \"->\");\n\t\t\tnode = node.next;\n\t\t}\n\t\tSystem.out.println(\" \");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tListNode head = new ListNode(1);\n\t\tListNode n2 = new ListNode(2);\n\t\tListNode n3 = new ListNode(3);\n\t\tListNode n4 = new ListNode(4);\n\t\thead.next = n2;\n\t\tn2.next = n3;\n\t\tn3.next = n4;\n\n\t\tRotateList slt = new RotateList();\n\t\tslt.printList(head);\n\t\tListNode res = slt.rotateRight(head, 1);\n\t\tslt.printList(res);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class ReverseInteger {\n  public int reverse(int x) {\n    long l = x;\n    long num = Math.abs(l);\n    long ret = 0;\n    while (num != 0) {\n      long d = num - num / 10 * 10;\n      ret = ret * 10 + d;\n      num /= 10;\n    }\n    if (x < 0) return (int) (-ret < -2147483648 ? 0 : -ret);\n    else return (int) (ret > 2147483647 ? 0 : ret);\n  }\n}\n", "nl": "mengli"}
{"code": "public class SearchinRotatedSortedArray {\n\tpublic int search(int[] A, int target) {\n\t\tint start = 0, end = A.length - 1;\n\t\twhile (start <= end) {\n\t\t\tif (start > end)\n\t\t\t\treturn -1;\n\t\t\tint mid = (start + end) >> 1;\n\t\t\tif (A[mid] == target)\n\t\t\t\treturn mid;\n\t\t\tif (A[mid] >A[start]) {\n\t\t\t\tif ( A[start]<=target&&target< A[mid])\n\t\t\t\t\tend = mid - 1;\n\t\t\t\telse\n\t\t\t\t\tstart = mid + 1;\n\t\t\t} else {\n\t\t\t\tif (A[mid]<target&&target<=A[end])\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\telse\n\t\t\t\t\tend = mid - 1;\n\t\t\t}\n\t\t}\n\t\t\treturn -1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class SpiralMatrix {\n\n    public static void main(String[] args) {\n\n    }\n\n    \n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (matrix == null || matrix.length == 0) {\n            return res;\n        }\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int lv = 0;\n\n        while (2 * lv < m && 2 * lv < n) { // note 2 * level\n            for (int i = lv; i < n - lv; i++) {\n                res.add(matrix[lv][i]); // right\n            }\n            for (int i = lv + 1; i < m - lv; i++) {\n                res.add(matrix[i][n - lv - 1]); // down\n            }\n            if (2 * lv == m - 1 || 2 * lv == n - 1) {\n                break; // reach last row/col\n            }\n            for (int i = n - lv - 2; i >= lv; i--) {\n                res.add(matrix[m - lv - 1][i]);\n            }\n            for (int i = m - lv - 2; i >= lv + 1; i--) {\n                res.add(matrix[i][lv]);\n            }\n            lv++;\n        }\n        return res;\n    }\n\n    \n    public List<Integer> spiralOrderB(int[][] matrix) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return res;\n        }\n        int iMin = 0;\n        int iMax = matrix.length - 1;\n        int jMin = 0;\n        int jMax = matrix[0].length - 1;\n        int i = 0;\n        int j = 0;\n        while (iMin <= iMax && jMin <= jMax) {\n            for (j = jMin; j <= jMax; j++) {\n                res.add(matrix[iMin][j]);\n            }\n            iMin++;\n            if (iMin > iMax) {\n                break; // break as soon as possible\n            }\n            for (i = iMin; i <= iMax; i++) {\n                res.add(matrix[i][jMax]);\n            }\n            jMax--;\n            if (jMax < jMin) {\n                break;\n            }\n            for (j = jMax; j >= jMin; j--) {\n                res.add(matrix[iMax][j]);\n            }\n            iMax--;\n            if (iMax < iMin) {\n                break;\n            }\n            for (i = iMax; i >= iMin; i--) {\n                res.add(matrix[i][jMin]);\n            }\n            jMin++;\n        }\n        return res;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class WordLadder {\n  public int ladderLength(String start, String end, HashSet<String> dict) {\n    if (dict.size() == 0) return 0;\n    int currentLevel = 1;\n    int nextLevel = 0;\n    int step = 1;\n    boolean found = false;\n    Queue<String> st = new LinkedList<String>();\n    HashSet<String> visited = new HashSet<String>();\n    st.add(start);\n    while (!st.isEmpty()) {\n      String s = st.remove();\n      currentLevel--;\n      if (stringDiff(s, end) == 1) {\n        found = true;\n        step++;\n        break;\n      } else {\n        int length = s.length();\n        StringBuffer sb = new StringBuffer(s);\n        for (int i = 0; i < length; i++) {\n          for (int j = 0; j < 26; j++) {\n            char c = sb.charAt(i);\n            sb.setCharAt(i, (char) ('a' + j));\n            if (dict.contains(sb.toString()) && !visited.contains(sb.toString())) {\n              nextLevel++;\n              st.add(sb.toString());\n              visited.add(sb.toString());\n            }\n            sb.setCharAt(i, c);\n          }\n        }\n      }\n      if (currentLevel == 0) {\n        currentLevel = nextLevel;\n        nextLevel = 0;\n        step++;\n      }\n    }\n    return found ? step : 0;\n  }\n\n  private int stringDiff(String s1, String s2) {\n    int diff = 0;\n    int length = s1.length();\n    for (int i = 0; i < length; i++) {\n      if (s1.charAt(i) != s2.charAt(i)) {\n        diff++;\n      }\n    }\n    return diff;\n  }\n}\n", "nl": "mengli"}
{"code": "class JumpGame {\n    public static void main(String[] args) {\n        JumpGame j = new JumpGame();\n        int[] A = {3, 2, 1, 0, 4};\n        int[] B = {2, 3, 1, 1, 4};\n        int[] C = {0};\n        int[] D = {2, 5, 0, 0};\n        System.out.println(j.canJump(A));\n        System.out.println(j.canJump(B));\n        System.out.println(j.canJump(C));\n        System.out.println(j.canJump(D));\n    }\n\n    \n    public boolean canJump(int[] A) {\n        if (A == null || A.length == 0) return false;\n        if (A.length == 1) return true; // already reach last index\n        if (A[0] == 0) return false; // note its important cause we start from 1\n        int maxJump = A[0];\n        for (int i = 1; i < A.length - 1; i++) {\n            maxJump = Math.max(maxJump - 1, A[i]);\n            if (maxJump == 0) return false;\n        }\n        return true;\n    }\n\n    public boolean canJump2(int[] A) {\n        int len = A.length;\n        int i = 0;\n        for (int reach = 0; i < len && i <= reach; i++) {\n            reach = Math.max(A[i] + i, reach);\n            if (reach >= len - 1)\n                return true;\n        }\n        return false;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class DecodeWays\n{\n    public int numDecodings( String s )\n    {\n    \tif ( s == null || s.length() == 0 || s.charAt( 0 ) == '0' )\n    \t{\n    \t\treturn 0;\n    \t}\n    \tif ( s.length() == 0 )\n    \t{\n    \t\treturn 1;\n    \t}\n    \t\n    \tint[] numWays = new int[3];\n    \tnumWays[0] = 1;\n    \tnumWays[1] = s.charAt( 0 ) == '0' ? 0 : 1;\n    \tfor ( int i = 2; i <= s.length(); i++ )\n    \t{\n    \t\tnumWays[i % 3] = 0;\n    \t\tint oneDigitNum = s.charAt( i - 1 ) - '0';\n    \t\tif ( oneDigitNum > 0 )\n    \t\t{\n    \t\t\tnumWays[i % 3] += numWays[(i - 1) % 3];\n    \t\t}\n    \t\t\n    \t\tint twoDigitNum = s.charAt( i - 2 ) - '0';\n    \t\tif ( twoDigitNum > 0 )\n    \t\t{\n    \t\t\tint value = twoDigitNum * 10 + oneDigitNum;\n    \t\t\tif ( value >= 1 && value <= 26 )\n    \t\t\t{\n    \t\t\t\tnumWays[i % 3] += numWays[(i - 2) % 3];\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn numWays[s.length() % 3];\n    }\n\n    @Test\n    public void test()\n    {\n    \tassertEquals( 2, numDecodings( \"12\" ) );\n    \tassertEquals( 2, numDecodings( \"26\" ) );\n    \tassertEquals( 0, numDecodings( \"0\" ) );\n    \tassertEquals( 1, numDecodings( \"10\" ) );\n    \tassertEquals( 0, numDecodings( \"100\" ) );\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class SearchInRotatedSortedArray \n{\n    public int search( int[] nums, int target )\n    {\n    \tif ( nums.length == 0 )\n    \t{\n    \t\treturn -1;\n    \t}\n    \t\n    \tint start = 0;\n    \tint end = nums.length - 1;\n    \twhile ( start + 1 < end )\n    \t{\n    \t\tint mid = ( end - start ) / 2 + start;\n    \t\tif ( nums[mid] < nums[end] )\t// pivot point inside [start,mid]\n    \t\t{\n    \t\t\tif ( target > nums[mid] \n    \t\t\t\t\t&& target <= nums[end] )\n    \t\t\t{\n    \t\t\t\tstart = mid;\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tend = mid;\n    \t\t\t}\n    \t\t}\n    \t\telse\t// pivot point inside [mid, end]\n    \t\t{\n    \t\t\tif ( target < nums[mid] \n    \t\t\t\t\t&& target >= nums[start] )\n    \t\t\t{\n    \t\t\t\tend = mid;\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tstart = mid;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \tif ( nums[start] == target )\n    \t{\n    \t\treturn start;\n    \t}\n    \telse if ( nums[end] == target )\n    \t{\n    \t\treturn end;\n    \t}\n    \telse\n    \t{\n    \t\treturn -1;\n    \t}\n    }\n\n    @Test\n    public void test()\n    {\n    \tassertEquals( 1, search( new int[]{3, 5, 1}, 1 ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class SpiralMatrix {\n\n    public class Solution {\n        public ArrayList<Integer> spiralOrder(int[][] matrix) {\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            if (matrix.length == 0 || matrix[0].length == 0) {\n                return ans;\n            }\n            int beginX = 0;\n            int beginY = 0;\n            int endX = matrix.length - 1;\n            int endY = matrix[0].length - 1;\n            while (beginX <= endX && beginY <= endY) {\n                for (int i = beginY; i <= endY; i++) {\n                    ans.add(matrix[beginX][i]);\n                }\n                for (int i = beginX + 1; i < endX; i++) {\n                    ans.add(matrix[i][endY]);\n                }\n                if (beginX != endX) {\n                    for (int i = endY; i >= beginY; i--) {\n                        ans.add(matrix[endX][i]);\n                    }\n                }\n                if (beginY != endY) {\n                    for (int i = endX - 1; i > beginX; i--) {\n                        ans.add(matrix[i][beginY]);\n                    }\n                }\n                beginX++;\n                endX--;\n                beginY++;\n                endY--;\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "class Solution {\n    public int longestValidParentheses(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int n = s.length();\n        \n        int[] dp = new int[n];\n        dp[0] = 0;\n\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n            if (s.charAt(i) == ')') {\n                if (s.charAt(i - 1) == '(') {\n                    dp[i] = 2 + addPriorLength(i - 1, dp);\n                } else {\n                    int priorIndex = i - dp[i - 1] - 1; // 1 spot ahead of the known start index of valid string with dp[i-1]\n                    if (priorIndex >= 0 && s.charAt(priorIndex) == '(') {\n                        dp[i] = dp[i - 1] + 2 + addPriorLength(priorIndex, dp);\n                    } \n                }\n                max = Math.max(max, dp[i]);\n            }\n        }\n\n        return max;\n    }\n\n    private int addPriorLength(int priorIndex, int[] dp) {\n        return (priorIndex - 1 >= 0) ? dp[priorIndex - 1] : 0;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class SingleNumber\n{\n\t\n    public int singleNumber(int[] nums) \n    {\n    \tint result = 0;\n    \tfor ( int num : nums )\n    \t{\n    \t\tresult ^= num;\n    \t}\n    \treturn result;\n    }\n\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n        ArrayList<Interval> res = new ArrayList<Interval>();        \n        Interval t= new Interval(newInterval.start,newInterval.end);\n        Iterator<Interval> itr = intervals.iterator();\n        \n        while(itr.hasNext()){\n            Interval i = itr.next();\n            if(i.start>t.end){\n                res.add(t);\n                res.add(i);\n                while(itr.hasNext()){res.add(itr.next());}\n                return res;\n            }\n            \n            if(t.start>i.end) \n                res.add(i);\n            else{\n                 t.start = Math.min(i.start,t.start);\n                 t.end = Math.max(i.end,t.end);   \n            }\n        }\n        res.add(t);\n        return res;\n\n    }\n}\t", "nl": "azheanda"}
{"code": "public class L100_Same_Tree {\n\n\tpublic boolean isSameTree(TreeNode p, TreeNode q) {\n\n\t\tif (p == null && q == null) {\n\t\t\treturn true;\n\t\t} else if (p == null || q == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn p.val == q.val && isSameTree(p.left, q.left)\n\t\t\t\t&& isSameTree(p.right, q.right);\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Powxn3 {\n\tpublic double pow(double x, int n) {\n\t\tif (n == 0)\n\t\t\treturn 1.;\n\t\tif (x == 0)\n\t\t\treturn 0.;\n\t\tif (n < 0) {\n\t\t\tn = -n;\n\t\t\tx = 1. / x;\n\t\t}\n\n\t\tdouble res = 1.0;\n\t\twhile (n > 0) {\n\t\t\tif (n % 2 == 1)\n\t\t\t\tres *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<Integer> inorderTraversal_1(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) return res;\n        inorder(root, res);\n        return res;\n    }\n    public void inorder(TreeNode root, List<Integer> res) {\n        if (root == null) return;\n        inorder(root.left, res);\n        res.add(root.val);\n        inorder(root.right, res);\n    }\n    public List<Integer> inorderTraversal_2(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        Stack<TreeNode> stk = new Stack<TreeNode>();\n        TreeNode cur = root;\n        while (stk.isEmpty() == false || cur != null) {\n            if (cur != null) {\n                stk.push(cur);\n                cur = cur.left;\n            } else {\n                cur = stk.pop();\n                res.add(cur.val);\n                cur = cur.right;\n            }\n        }\n        return res;\n    }\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        TreeNode cur = root;\n        while (cur != null) {\n            if (cur.left == null) {\n                res.add(cur.val);\n                cur = cur.right;\n            } else {\n                TreeNode node = cur.left;\n                while (node.right != null && node.right != cur)\n                    node  = node.right;\n                if (node.right == null) {\n                    node.right = cur;\n                    cur = cur.left;\n                } else {\n                    res.add(cur.val);\n                    node.right = null;\n                    cur = cur.right;\n                }\n            }\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class SpiralMatrix\n{\n    public List<Integer> spiralOrderIterative( int[][] matrix )\n    {\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif ( matrix == null || matrix.length == 0 )\n\t\t\treturn result;\n\t\tint height = matrix.length;\n\t\tint width = matrix[0].length;\n\t\tint xStart = 0;\n\t\tint yStart = 0;\n\t\twhile ( height > 0 && width > 0 )\n\t\t{\n\n\t\t\tif ( height == 1 )\n\t\t\t{\n\t\t\t\tfor ( int i = 0; i < width; i++ )\n\t\t\t\t{\n\t\t\t\t\tresult.add( matrix[xStart][yStart++] );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( width == 1 )\n\t\t\t{\n\t\t\t\tfor ( int i = 0; i < height; i++ )\n\t\t\t\t{\n\t\t\t\t\tresult.add( matrix[xStart++][yStart] );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor ( int i = 0; i < width - 1; i++ )\n\t\t\t{\n\t\t\t\tresult.add( matrix[xStart][yStart++] );\n\t\t\t}\n\t\t\tfor ( int i = 0; i < height - 1; i++ )\n\t\t\t{\n\t\t\t\tresult.add( matrix[xStart++][yStart] );\n\t\t\t}\n\t\t\tfor ( int i = 0; i < width - 1; i++ )\n\t\t\t{\n\t\t\t\tresult.add( matrix[xStart][yStart--] );\n\t\t\t}\n\t\t\tfor ( int i = 0; i < height - 1; i++ )\n\t\t\t{\n\t\t\t\tresult.add( matrix[xStart--][yStart] );\n\t\t\t}\n\t\t\txStart++;\n\t\t\tyStart++;\n\t\t\theight = height - 2;\n\t\t\twidth = width - 2;\n\t\t}\n\n\t\treturn result;\n    }\n\n    public List<Integer> spiralOrderRecursive( int[][] matrix )\n    {\n\t\tif ( matrix == null || matrix.length == 0 )\n\t\t{\n\t\t\treturn new ArrayList<Integer>();\n\t\t}\n\t\treturn spiralOrder( matrix, 0, 0, matrix.length, matrix[0].length );\n    }\n    \n\tprivate List<Integer> spiralOrder( int[][] matrix, int xStart, int yStart, int height, int width )\n\t{\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif ( height <= 0 || width <= 0 )\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tif ( height == 1 && width == 1 )\n\t\t{\n\t\t\tresult.add( matrix[xStart][yStart] );\n\t\t\treturn result;\n\t\t}\n\n\t\tfor ( int i = 0; i < width - 1; i++ )\n\t\t{\n\t\t\tresult.add( matrix[xStart][yStart++] );\n\t\t}\n\t\tfor ( int i = 0; i < height - 1; i++ )\n\t\t{\n\t\t\tresult.add( matrix[xStart++][yStart] );\n\t\t}\n\t\tif ( width > 1 )\n\t\t{\n\t\t\tfor ( int i = 0; i < width - 1; i++ )\n\t\t\t{\n\t\t\t\tresult.add( matrix[xStart][yStart--] );\n\t\t\t}\n\t\t}\n\t\tif ( height > 1 )\n\t\t{\n\t\t\tfor ( int i = 0; i < height - 1; i++ )\n\t\t\t{\n\t\t\t\tresult.add( matrix[xStart--][yStart] );\n\t\t\t}\n\t\t}\n\n\t\tif ( height == 1 || width == 1 )\n\t\t{\n\t\t\tresult.addAll( spiralOrder( matrix, xStart, yStart, 1, 1 ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.addAll( spiralOrder( matrix, xStart + 1, yStart + 1, height - 2, width - 2 ) );\n\t\t}\n\t\treturn result;\n\t}\n    \n    @Test\n    public void test()\n    {\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length<=1){\n            return nums.length;\n        }\n       int tar=nums[0];\n    int l=1;\n    int end=nums.length;\n    int kuang=0;\n    for (int i = 1; i < end; i++) {\n        if (nums[i]==tar) {\n            for (int j = i; j < end-1; j++) {\n                kuang=nums[j];\n                nums[j]=nums[j+1];\n                nums[j+1]=kuang;\n            }\n            end--;\n            i--;\n        }else {\n            tar=nums[i];\n            l++;\n        }\n    }\n    return l;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MinimumDepthOfBinaryTree\n{\n    public int minDepth(TreeNode root) \n    {\n    \treturn 0;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class PowXN {\n  public double pow(double x, int n) {\n    if (n == 0) return 1;\n    else if (n % 2 == 0) {\n      double d = pow(x, n / 2);\n      return d * d;\n    } else if (n > 0) {\n      double d = pow(x, (n - 1) / 2);\n      return d * d * x;\n    } else {\n      double d = pow(x, (n + 1) / 2);\n      return d * d / x;\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null) {\n        \treturn head;\n        }\n       \tListNode reversedList = null;\n        while (head != null) {\n        \tListNode cutOff = head.next;\n        \thead.next = reversedList;\n        \treversedList = head;\n        \thead = cutOff;\n        }\n        return reversedList;\n    }\n}", "nl": "awangdev"}
{"code": "public class NQueens2 {\n\tpublic ArrayList<String[]> solveNQueens(int n) {\n\t\tArrayList<String[]> res = new ArrayList<String[]>();\n\t\thelper(n, 0, new int[n][n], res);\n\t\treturn res;\n\t}\n\n\tprivate void helper(int n, int row, int[][] columnForRow, ArrayList<String[]> res) {\n\t\tif (row == n) {\n\t\t\tString[] item = new String[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tStringBuilder strRow = new StringBuilder();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (columnForRow[i][j] == 1)\n\t\t\t\t\t\tstrRow.append('Q');\n\t\t\t\t\telse\n\t\t\t\t\t\tstrRow.append('.');\n\t\t\t\t}\n\t\t\t\titem[i] = strRow.toString();\n\t\t\t}\n\t\t\tres.add(item);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcolumnForRow[row][i] = 1;\n\t\t\tif (check(row, i, columnForRow))\n\t\t\t\thelper(n, row + 1, columnForRow, res);\n\t\t}\n\t}\n\n\tprivate boolean check(int row, int col, int[][] columnForRow) {\n\t\tfor (int i = 0; i < row; i++)\n\t\t\tif (columnForRow[i][col] == 1)\n\t\t\t\treturn false;\n\t\tfor (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n\t\t\tif (columnForRow[i][j] == 1)\n\t\t\t\treturn false;\n\t\tfor (int i = row - 1, j = col + 1; i >= 0 && j < columnForRow.length; i--, j++)\n\t\t\tif (columnForRow[i][j] == 1)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L274_H_Index {\n\n\tpublic int hIndex(int[] citations) {\n\n\t\tif (citations == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint h = 0, n = citations.length;\n\t\tArrays.sort(citations);\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (citations[i] >= n - i) {\n\t\t\t\th = n - i;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn h;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class L106_Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal {\n\n\tint p;\n\tint[] postorder;\n\tint[] inorder;\n\n\tpublic TreeNode buildTree(int[] inorder, int[] postorder) {\n\n\t\tthis.p = postorder.length - 1;\n\t\tthis.inorder = inorder;\n\t\tthis.postorder = postorder;\n\n\t\treturn buildTree(0, postorder.length);\n\t}\n\n\tTreeNode buildTree(int start, int end) {\n\n\t\tif (start >= end) {\n\t\t\treturn null;\n\t\t}\n\n\t\tTreeNode root = new TreeNode(postorder[p]);\n\n\t\tint i;\n\t\tfor (i = start; i < end && postorder[p] != inorder[i]; i++)\n\t\t\t;\n\n\t\tp--;\n\t\troot.right = buildTree(i + 1, end);\n\t\troot.left = buildTree(start, i);\n\n\t\treturn root;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    public boolean helper(TreeNode root, long min, long max) {\n        if (root == null) {\n            return true;\n        }\n        if (root.val < max && root.val > min && \n            helper(root.left, min, root.val) &&\n            helper(root.right, root.val, max)) {\n                return true;\n        } \n        return false;\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root==null) {\n            return 0;\n        }\n        if(root.left==null&&root.right==null){\n            return 1;\n        }\n        int left=-1;\n        if(root.left!=null){\n           left=maxDepth(root.left)+1;\n        }\n        int right=-1;\n        if(root.right!=null){\n           right=maxDepth(root.right)+1;\n        }\n        if(left==-1){\n            return right;\n        }\n        if(right==-1){\n            return left;\n        }\n    \n        \n        return Math.max(left, right);\n    }\n}", "nl": "corpsepiges"}
{"code": "public class TwoSum2 {\n\n    \n    public int[] twoSum(int[] numbers, int target) {\n        int start = 0;\n        int end = numbers.length - 1;\n        while (start < end) {\n            long sum = numbers[start] + numbers[end];\n            if (sum > target) {\n                end--;\n            } else if (sum < target) {\n                start++;\n            } else {\n                break;\n            }\n        }\n        return new int[]{start + 1, end + 1};\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class _169_majorityElement {\n    public static void main(String[] args) {\n        _169_majorityElement majorityElement = new _169_majorityElement();\n        System.out.println(majorityElement.majorityElement(new int[]{3, 2, 3}));\n        System.out.println(majorityElement.majorityElement(new int[]{2, 2, 1, 1, 1, 2, 2}));\n    }\n\n    \n    public int majorityElement(int[] nums) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int maxCount = Integer.MIN_VALUE;\n        int maxValue = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int item = nums[i];\n            Integer count = map.getOrDefault(item, 0);\n            map.put(item, ++count);\n            if (count > maxCount) {\n                maxCount = count;\n                maxValue = item;\n            }\n        }\n        return maxValue;\n    }\n\n    \n    public int majorityElement2(int[] nums) {\n        int result = nums[0];\n        int count = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (count == 0) {\n                result = nums[i];\n                count++;\n            } else if (result == nums[i]) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        return result;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class DecodeWays2 {\n\n    private static final int M = (int) (Math.pow(10, 9) + 7);\n\n    \n    public int numDecodings(String s) {\n        long[] ways = new long[s.length() + 1];\n        ways[0] = 1;\n        ways[1] = getNumDecodings(s.charAt(0));\n        for (int i = 2; i < ways.length; i++) {\n            ways[i] += (ways[i - 1] * getNumDecodings(s.charAt(i - 1))) % M;\n            ways[i] += (ways[i - 2] * getNumDecodings(s.charAt(i - 2), s.charAt(i - 1))) % M;\n        }\n        return (int) (ways[s.length()] % M);\n    }\n\n    \n    public int numDecodings2(String s) {\n        long first = 1;\n        long second = getNumDecodings(s.charAt(0));\n        for (int i = 2; i < s.length() + 1; i++) {\n            long current = (second * getNumDecodings(s.charAt(i - 1))) % M;\n            current = (current + (first * getNumDecodings(s.charAt(i - 2), s.charAt(i - 1)) % M)) % M;\n            first = second;\n            second = current;\n        }\n        return (int) second;\n    }\n\n    \n    private int getNumDecodings(char single) {\n        if (single == '*') return 9;\n        if (single == '0') return 0;\n        return 1;\n    }\n\n    \n    private int getNumDecodings(char first, char second) {\n        int ways = 0;\n        if (first == '*') {\n            if (second == '*') {\n                ways = 15;\n            } else {\n                ways = (second - '0' <= 6 ? 2 : 1);\n            }\n        } else if (first == '1') {\n            if (second == '*') ways = 9;\n            else ways = 1;\n        } else if (first == '2') {\n            if (second == '*') ways = 6;\n            else ways = (second - '0' <= 6 ? 1 : 0);\n        }\n        return ways;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 1;\n        }\n        if (nums.length == 1) {\n            return nums[0] == 1 ? 2 : 1;\n        }\n        int n = nums.length;\n        int i = 0;\n        while (i < n) {\n            int val = nums[i];\n            if (val != i && val >= 0 && val < n && val != nums[val]) { // val != nums[val], avoid infinitely loop\n                int temp = nums[val];\n                nums[val] = nums[i];\n                nums[i] = temp;\n            } else {\n                i++;\n            }\n        }\n\n        for (i = 1; i < n; i++) {\n            if (nums[i] != i) {\n                return i;\n            }\n        }\n        \n        if (nums[0] == n) {\n            return n + 1;\n        }\n\n        return n;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class TextJustification {\n\n  \n  public List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> lines = new ArrayList<>();\n    for (int i = 0, j; i < words.length; i = j) {\n      int len = -1;\n      for (j = i; j < words.length && len + 1 + words[j].length() <= maxWidth; j++) {\n        len += (1 + words[j].length());\n      }\n\n      StringBuilder line = new StringBuilder();\n      line.append(words[i]); // First word doesn't have prepending space. Append it first.\n      int spaces = 1; // Left justified.\n      int extra = 0;\n      if (j != i + 1 && j < words.length) { // Fully justified.\n        int totalSpaces = maxWidth - len;\n        int intervals = j - i - 1; // Intervals can be zero when j = i + 1, only 1 word.\n        spaces = totalSpaces / intervals + 1; // Adding 1 to include default space.\n        extra = totalSpaces % intervals;\n      }\n      for (int k = i + 1; k < j; k++) {\n        for (int s = spaces; s > 0; s--) line.append(' ');\n        if (extra > 0) line.append(' ');\n        extra--;\n        line.append(words[k]);\n      }\n      for (int r = maxWidth - line.length(); r > 0; r--) { // Add remaining spaces to the end of line.\n        line.append(' ');\n      }\n      lines.add(line.toString());\n    }\n    return lines;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class LRUCache {\n    private Map<Integer, Integer> map;\n    private int capacity;\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new LinkedHashMap<Integer, Integer>(capacity + 1);\n    }\n    \n    public int get(int key) {\n        Integer val = map.get(key);\n        if (val == null) return -1;\n        map.remove(key);\n        map.put(key, val);\n        return val;\n    }\n    \n    public void set(int key, int value) {\n        map.remove(key);\n        map.put(key, value);\n        if (map.size() > capacity)\n            map.remove(map.entrySet().iterator().next().getKey());\n    }\n}\n", "nl": "leetcoders"}
{"code": "public class L046_Permutations {\n\n\tpublic List<List<Integer>> permute(int[] nums) {\n\n\t\tif (nums == null || nums.length == 0) {\n\t\t\treturn new ArrayList<List<Integer>>();\n\t\t}\n\n\t\tArrayList<List<Integer>> rt = new ArrayList<List<Integer>>();\n\n\t\tif (nums.length == 1) {\n\t\t\trt.add(new ArrayList<Integer>(Arrays.asList(nums[0])));\n\t\t} else {\n\n\t\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\t\tfor (List<Integer> l : permute(resetof(nums, i))) {\n\t\t\t\t\tl.add(nums[i]);\n\t\t\t\t\trt.add(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rt;\n\t}\n\n\tprivate int[] resetof(int[] nums, int index) {\n\n\t\tint[] rt = new int[nums.length - 1];\n\n\t\tint s = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (i != index) {\n\t\t\t\trt[s++] = nums[i];\n\t\t\t}\n\t\t}\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class MergeSortedArray {\n\n  \n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    for (int i = m - 1, j = n - 1, k = m + n - 1; k >= 0 && j >= 0; k--) {\n      nums1[k] = (i < 0 || nums1[i] < nums2[j]) ? nums2[j--] : nums1[i--];\n    }\n  }\n\n  \n  public void merge2(int[] nums1, int m, int[] nums2, int n) {\n    for (int i = m + n - 1; i >= 0 && n - 1 >= 0; i--) {\n      nums1[i] = (m - 1 < 0 || nums1[m - 1] < nums2[n - 1]) ? nums2[n-- - 1] : nums1[m-- - 1];\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class L077_Combinations {\n\n\tint target;// \u6b21\u6570\n\tInteger[] stack;// \u5b58\u50a8\u6bcf\u6b21\u6392\u5217\n\tInteger[] nums;// \u5b58\u50a81~n\n\n\tList<List<Integer>> rt;// \u5b58\u50a8\u7ed3\u679c\n\n\tpublic void search(int p) {\n\n\t\tif (p == target) {\n\t\t\trt.add(new ArrayList<Integer>(Arrays.asList(stack)));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Integer n : nums) {\n\t\t\tif (p > 0 && n <= stack[p - 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstack[p] = n;\n\t\t\tsearch(p + 1);\n\t\t}\n\t}\n\n\tpublic List<List<Integer>> combine(int n, int k) {\n\n\t\ttarget = k;\n\t\tnums = new Integer[n];\n\t\tstack = new Integer[k];\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tnums[i] = i + 1;\n\t\t}\n\n\t\trt = new ArrayList<List<Integer>>();\n\n\t\tsearch(0);\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class GrayCode {\n\n  \n  public static void main(String[] args) throws Exception {\n    List<Integer> result = new GrayCode().grayCode(3);\n  }\n\n  public List<Integer> grayCode(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i <= ((1 << n) - 1); i++) result.add(i ^ (i >> 1));\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    \n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode sortedListHead = new ListNode(0);//dummy head\n        ListNode pre,curr,next;\n        curr = head;\n        \n        while (curr != null) {// insert every single curr into sorted list\n            next = curr.next; //prepare for insertion && swapping.\n            pre = sortedListHead;//the list to scan\n            while (pre.next != null && pre.next.val <= curr.val) {\n                pre = pre.next;\n            }\n            curr.next = pre.next;\n            pre.next = curr;\n            \n            curr = next;//use the original next, instead of the new curr.next\n        }//end while\n        \n        return sortedListHead.next;\n    }\n}\n\n\n\n\n \n", "nl": "awangdev"}
{"code": "public class Solution {\n    int heap_size ;\n    public ListNode mergeKLists(ArrayList<ListNode> lists) {\n        if(lists.size()==0 )\n            return null;\n        \n        ListNode[] A = new ListNode[lists.size()];\n    \tint i=0;\n    \tfor(ListNode node : lists){\n             if(!(node==null)){   //in stupid leetcode judge, I can say \"if(node!=null)\" because it will complain that operator ! cannot be applied to <nulltype>\"\n    \t\t    A[i++]=node;\n    \t\t    node = node.next;         \n                heap_size++;\n             }\n    \t}\n    \tbuild_min_heap(A);\n    \treturn mergeKLists(A);\n        \n    }\n\n    public ListNode mergeKLists(ListNode[] A){\n    \tListNode dumbNode = new ListNode(0);\n\t\tListNode currentNode = dumbNode;\n    \t\n    \twhile(heap_size!=0){\n    \t\tcurrentNode.next=A[0];\n    \t\tcurrentNode = currentNode.next;\n    \t\tif(A[0].next!=null)\n    \t\t\tA[0]=A[0].next;\n    \t\telse{\n                swap(A,0,heap_size-1);\n    \t\t\theap_size--;\n    \t\t}\n    \t\tmin_heapify(A,0);\n    \t}\n\n    \treturn dumbNode.next;\n    }\n\n    public void build_min_heap(ListNode[] A){\n    \tfor(int i=A.length/2;i>=0;i--)\n    \t\tmin_heapify(A,i);\n    }\n\n    public void min_heapify(ListNode[] A,int i){\n    \tint l = 2*i; //LEFT(i)\n    \tint r = 2*i+1; //RIGHT(i)\n    \tint smallest=0;\n    \tsmallest = (l<heap_size && A[l].val<A[i].val)?l:i;\n   \t\tsmallest = (r<heap_size && A[r].val<A[smallest].val)?r:smallest;\n   \t\tif(smallest!=i){\n   \t\t\tswap(A,i,smallest);\n   \t\t\tmin_heapify(A,smallest);\n   \t\t}\n    }\n\n    public void swap(ListNode[] A, int i, int j){\n    \tListNode temp = A[i];\n    \tA[i] = A[j];\n    \tA[j] = temp;\n    }\n}", "nl": "azheanda"}
{"code": "public class BestTimetoBuyandSellStock {\n\n    public class Solution {\n        public int maxProfit(int[] prices) {\n            if (prices.length == 0) {\n                return 0;\n            }\n            int maxProfit = 0;\n            int minPrice = prices[0];\n            for (int i = 1; i < prices.length; i++) {\n                maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n                minPrice = Math.min(minPrice, prices[i]);\n            }\n            return maxProfit;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class PathSum {\n\tpublic boolean hasPathSum(TreeNode root, int sum) {\n\t\tif (root == null)\n\t\t\treturn false;\n\t\tif (root.left == null && root.right == null && root.val == sum)\n\t\t\treturn true;\n\t\treturn hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public static ListNode deleteDuplicates(ListNode head) { \n        if (head == null) {\n            return head;\n        }\n        ListNode node = head;\n        while (node.next != null) {\n            if (node.val == node.next.val) {\n                node.next = node.next.next;\n            } else {\n                node = node.next;\n            }\n        }\n        return head;\n    }  \n}\n\n\n\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class UniqueBinarySearchTrees {\n  public int numTrees(int n) {\n    if (n == 1) return 1;\n    if (n == 2) return 2;\n    int[] record = new int[n + 1];\n    record[0] = 1;\n    record[1] = 1;\n    record[2] = 2;\n    for (int i = 3; i <= n; i++) {\n      int tmp = 0;\n      for (int k = 0; k < i; k++) {\n        tmp += (record[k] * record[i - k - 1]);\n      }\n      record[i] = tmp;\n    }\n    return record[n];\n  }\n}\n", "nl": "mengli"}
{"code": "class Solution {\n    class Point {\n        int val, flag;\n        public Point(int val, int flag) {\n            this.val = val;\n            this.flag = flag;\n        }\n    }\n\n    public List<Interval> merge(List<Interval> intervals) {\n        List<Interval> rst = new ArrayList<>();\n        if (intervals == null || intervals.size() == 0) {\n            return rst;\n        }\n        PriorityQueue<Point> queue = new PriorityQueue<>(Comparator.comparing(p -> p.val));\n        \n        for (Interval interval : intervals) {\n            queue.offer(new Point(interval.start, 1));\n            queue.offer(new Point(interval.end, -1));\n        }\n        \n        int count = 0;\n        Interval interval = new Interval();\n        while (!queue.isEmpty()) {\n            Point p = queue.poll();\n            if (count == 0) {//detect start\n                interval.start = p.val;\n            }    \n            count += p.flag;\n            while (!queue.isEmpty() && p.val == queue.peek().val) {\n                p = queue.poll();\n                count += p.flag;\n            }\n            if (count == 0) {//detect end\n                interval.end = p.val;\n                rst.add(interval);\n                interval = new Interval();\n            }\n        }\n        \n        return rst;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class MedianOfTwoSortedArrays {\n  \n  public static void main(String[] args) throws Exception {\n    int[] A = {1, 2, 5, 8, 44, 45, 45};\n    int[] B = {1, 2, 3, 4, 5, 6, 7, 23, 23, 23, 33, 44, 45, 45, 56, 77, 5555};\n    System.out.println(new MedianOfTwoSortedArrays().findMedianSortedArrays(A, B));\n  }\n\n  \n  public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length)\n      return findMedianSortedArrays(nums2, nums1); // ensure always nums1 is the shortest array\n    int T = nums1.length + nums2.length, low = -1, high = -1;\n    int median = (T - 1) / 2;\n    boolean isOdd = false;\n    if ((T % 2) != 0) isOdd = true;\n\n    int s = 0, e = nums1.length - 1;\n    while (s <= e) {\n      int m = s + (e - s) / 2;\n      if ((median - m - 1) < 0 || nums1[m] >= nums2[median - m - 1]) {\n        e = m - 1;\n        low = m;\n        high = median - m;\n      } else s = m + 1;\n    }\n\n    if (low == -1) {\n      if (isOdd) return nums2[median - nums1.length];\n      else return (double) (nums2[median - nums1.length] + nums2[median - nums1.length + 1]) / 2.0D;\n    } else {\n      if (isOdd) return nums1[low] < nums2[high] ? nums1[low] : nums2[high];\n      else {\n        List<Integer> list = new ArrayList<>();\n        list.add(nums1[low]);\n        if (low + 1 < nums1.length) list.add(nums1[low + 1]);\n        list.add(nums2[high]);\n        if (high + 1 < nums2.length) list.add(nums2[high + 1]);\n        Collections.sort(list);\n        return (double) (list.get(0) + list.get(1)) / 2.0;\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class L098_Validate_Binary_Search_Tree {\n\n\tboolean failed = false;\n\n\tlong last = Long.MIN_VALUE;\n\n\tpublic boolean isValidBST(TreeNode root) {\n\n\t\tif (root == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tinorder(root);\n\t\treturn !failed;\n\t}\n\n\tprivate void inorder(TreeNode root) {\n\n\t\tif (root == null || failed) {\n\t\t\treturn;\n\t\t}\n\n\t\tinorder(root.left);\n\n\t\tif (last >= root.val) {\n\t\t\tfailed = true;\n\t\t}\n\t\tlast = root.val;\n\n\t\tinorder(root.right);\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class WordBreak {\n\n    public class Solution {\n        public boolean wordBreak(String s, Set<String> dict) {\n            assert !s.isEmpty();\n            boolean[] dp = new boolean[s.length() + 1];\n            dp[0] = true;\n            for (int i = 1; i <= s.length(); i++) {\n                dp[i] = false;\n                for (int j = 0; j < i; j++) {\n                    if (dp[j] && dict.contains(s.substring(j, i))) {\n                        dp[i] = true;\n                        break;\n                    }\n                }\n            }\n            return dp[s.length()];\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class AddBinary {\n\tpublic String addBinary(String a, String b) {    \n\t\tif (a == null || a.length() == 0)\n\t\t\treturn b;\n\t\tif (b == null || b.length() == 0)\n\t\t\treturn a;\n\t\tint i = a.length() - 1;\n\t\tint j = b.length() - 1;\n\t\tint carry = 0;\n\t\tStringBuilder res = new StringBuilder();\n\t\twhile (i >= 0 && j >= 0) {\n\t\t\tint digit = (int) (a.charAt(i) - '0' + b.charAt(j) - '0') + carry;\n\t\t\tcarry = digit / 2;\n\t\t\tdigit %= 2;\n\t\t\tres.insert(0, digit);\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\twhile (i >= 0) {\n\t\t\tint digit = (int) (a.charAt(i) - '0') + carry;\n\t\t\tcarry = digit / 2;\n\t\t\tdigit %= 2;\n\t\t\tres.insert(0, digit);\n\t\t\ti--;\n\t\t}\n\t\twhile (j >= 0) {\n\t\t\tint digit = (int) (b.charAt(j) - '0') + carry;\n\t\t\tcarry = digit / 2;\n\t\t\tdigit %= 2;\n\t\t\tres.insert(0, digit);\n\t\t\tj--;\n\t\t}\n\t\tif (carry > 0) {\n\t\t\tres.insert(0, carry);\n\t\t}\n\t\treturn res.toString();\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MinimumPathSum\n{\n    public int minPathSum( int[][] grid )\n    {\n    \tif ( grid.length == 0 \n    \t\t\t|| grid[0].length == 0 )\n    \t{\n    \t\tthrow new IllegalArgumentException();\n    \t}\n    \t\n    \tint height = grid.length;\n    \tint width = grid[0].length;\n \n    \tint[][] minPathSumGrid = new int[height][width];\n    \tminPathSumGrid[0][0] = grid[0][0];\n    \tfor ( int i = 1; i < height; i++ )\n    \t{\n    \t\tminPathSumGrid[i][0] = minPathSumGrid[i-1][0] + grid[i][0];\n    \t}\n    \tfor ( int j = 1; j < width; j++ )\n    \t{\n    \t\tminPathSumGrid[0][j] = minPathSumGrid[0][j-1] + grid[0][j];\n    \t}\n    \t\n    \tfor ( int i = 1; i < height; i++ )\n    \t{\n    \t\tfor ( int j = 1; j < width; j++ )\n    \t\t{\n    \t\t\tminPathSumGrid[i][j] = Math.min( minPathSumGrid[i-1][j], minPathSumGrid[i][j-1] ) + grid[i][j];\n    \t\t}\n    \t}\n    \t\n    \treturn minPathSumGrid[height-1][width-1];\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class AddTwoNumbers {\n  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    if (l1 == null) return l2;\n    if (l2 == null) return l1;\n    ListNode head = new ListNode(0);\n    ListNode cur = head;\n    int plus = 0;\n    while (l1 != null && l2 != null) {\n      int sum = l1.val + l2.val + plus;\n      plus = sum / 10;\n      sum = sum % 10;\n      cur.next = new ListNode(sum);\n      cur = cur.next;\n      l1 = l1.next;\n      l2 = l2.next;\n    }\n    if (l1 != null) {\n      if (plus != 0) {\n        cur.next = addTwoNumbers(l1, new ListNode(plus));\n      } else {\n        cur.next = l1;\n      }\n    } else if (l2 != null) {\n      if (plus != 0) {\n        cur.next = addTwoNumbers(l2, new ListNode(plus));\n      } else {\n        cur.next = l2;\n      }\n    } else if (plus != 0) {\n      cur.next = new ListNode(plus);\n    }\n\n    return head.next;\n  }\n}\n", "nl": "mengli"}
{"code": "public class LargestRectangleinHistogram {\n  public int largestRectangleArea(int[] height) {\n    Stack<Integer> stack = new Stack<Integer>();\n    int i = 0;\n    int maxArea = 0;\n    int[] h = new int[height.length + 1];\n    h = Arrays.copyOf(height, height.length + 1);\n    while (i < h.length) {\n      if (stack.isEmpty() || h[stack.peek()] <= h[i]) {\n        stack.push(i++);\n      } else {\n        int t = stack.pop();\n        maxArea = Math.max(maxArea, h[t] * (stack.isEmpty() ? i : i - stack.peek() - 1));\n      }\n    }\n    return maxArea;\n  }\n}\n", "nl": "mengli"}
{"code": "public class _14_longestCommonPrefix {\n\n    public static void main(String[] args) {\n        System.out.println(longestCommonPrefix(new String[]{\"flower\", \"flow\", \"flight\"}));\n        System.out.println(longestCommonPrefix(new String[]{\"dog\", \"racecar\", \"car\"}));\n        System.out.println(longestCommonPrefix(new String[]{}));\n        Util.printDivideLine();\n        System.out.println(longestCommonPrefix2(new String[]{\"flower\", \"flow11\", \"flight\"}));\n        System.out.println(longestCommonPrefix2(new String[]{\"dog\", \"racecar\", \"car\"}));\n        System.out.println(longestCommonPrefix2(new String[]{}));\n    }\n\n    \n    public static String longestCommonPrefix2(String[] strs) {\n        if (strs.length == 0) {\n            return \"\";\n        }\n        return getPrefix(strs, 0, strs.length - 1);\n    }\n\n    private static String getPrefix(String[] strs, int start, int end) {\n        if (start == end) {\n            return strs[start];\n        }\n        String leftPre = getPrefix(strs, start, (start + end) / 2);\n        String rightPre = getPrefix(strs, (start + end) / 2 + 1, end);\n        return getTwoLongestCommonPrefix(leftPre, rightPre);\n    }\n\n    \n    public static String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) {\n            return \"\";\n        }\n        String preStr = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            preStr = getTwoLongestCommonPrefix(preStr, strs[i]);\n        }\n\n        return preStr;\n    }\n\n    private static String getTwoLongestCommonPrefix(String s1, String s2) {\n        int index = 0;\n        while (index < s1.length() && index < s2.length()) {\n            if (s1.charAt(index) == s2.charAt(index)) {\n                index++;\n            } else {\n                break;\n            }\n        }\n        return s1.substring(0, index);\n    }\n\n}\n", "nl": "pphdsny"}
{"code": "public class MinimumPathSum2 {\n\tpublic int minPathSum(int[][] grid) {\n\tint row = grid.length;\n\tint col = grid[0].length;\n\tint[] mindist = new int[col];\n\tmindist[0] = grid[0][0];\n\tfor (int i = 1; i < col; i++) {\n\t\tmindist[i] = mindist[i - 1] + grid[0][i];\n\t}\n\n\tfor (int i = 1; i < row; i++) {\n\t\tmindist[0]=mindist[0]+grid[i][0];\n\t\tfor (int j = 1; j < col; j++) {\n\t\t\tmindist[j] = Math.min(mindist[j - 1], mindist[j]) + grid[i][j];\n\t\t}\n\t}\n\treturn mindist[col - 1];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int[] plusOne(int[] digits) {\n        if(digits.length==0) return digits;\n        \n        digits[digits.length-1] += 1;\n        for(int i = digits.length-1; i>0; i--){\n            if(digits[i] == 10){\n                digits[i]=0;\n                digits[i-1]+=1;\n            }\n            else return digits;\n        }\n        \n        if(digits[0]==10){\n            int[] output = new int[digits.length+1];\n            output[0] = 1;\n            output[1] = 0;\n            for(int i=2; i<output.length-1; i++){\n                output[i]=digits[i-1];\n            }\n            return output;\n        }\n        else return digits;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int findPeakElement(int[] nums) {\n\t\tif (nums == null || nums.length <= 1) {\n\t\t\treturn 0;\n\t\t}        \n\t\tint start = 0; // 0\n\t\tint end = nums.length - 1;// 2\n\t\tint mid;\n\t\twhile (start + 1 < end) {\n\t\t\tmid = start + (end - start)/2;//1\n\t\t\tif (mid <= 0 || mid >= nums.length - 1) {//start and end are adjacent, jump to end\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nums[mid - 1] < nums[mid] && nums[mid] > nums[mid + 1]) {\n\t\t\t\treturn mid;\n\t\t\t} else if (nums[mid - 1] < nums[mid] && nums[mid] < nums[mid + 1]) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else if (nums[mid - 1] > nums[mid] && nums[mid] > nums[mid + 1]) {\n\t\t\t\tend = mid - 1;\n\t\t\t} else {//1,0,1 case\n\t\t\t\tend = mid - 1;\n\t\t\t}\n\t\t}//end while\n\t\treturn nums[start] > nums[end] ? start : end;\n    }\n}\n", "nl": "awangdev"}
{"code": "class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null || l2 == null) {\n            return l1 == null ? l2 : l1;\n        }\n        final ListNode head = new ListNode(0);\n        ListNode node = head;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                node.next = l1;\n                l1 = l1.next;\n            } else {\n                node.next = l2;\n                l2 = l2.next;\n            }\n            node = node.next;\n        }\n\n        if (l1 != null) {\n            node.next = l1;\n        } else if (l2 != null) {\n            node.next = l2;\n        }\n        return head.next;\n    }\n}\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode fast=head;\n        ListNode slow=head;\n        while (true) {\n            if (fast==null||fast.next==null||slow==null) {\n                return false;\n            }\n            fast=fast.next.next;\n            slow=slow.next;\n            if (fast==slow) {\n                return true;\n            }\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class L145_Binary_Tree_Postorder_Traversal {\n\n\tpublic class PostTreeNode {\n\t\tTreeNode node;\n\t\tboolean first;\n\t}\n\n\tpublic List<Integer> postorderTraversal(TreeNode root) {\n\n\t\tList<Integer> rt = new ArrayList<Integer>();\n\n\t\tif (root == null) {\n\t\t\treturn rt;\n\t\t}\n\n\t\tStack<PostTreeNode> stack = new Stack<PostTreeNode>();\n\t\tTreeNode p = root;\n\t\tPostTreeNode t;\n\n\t\twhile (p != null || !stack.empty()) {\n\n\t\t\twhile (p != null) {\n\n\t\t\t\tPostTreeNode post = new PostTreeNode();\n\t\t\t\tpost.node = p;\n\t\t\t\tpost.first = true;\n\t\t\t\tstack.push(post);\n\t\t\t\tp = p.left;\n\t\t\t}\n\n\t\t\tif (!stack.empty()) {\n\n\t\t\t\tt = stack.pop();\n\n\t\t\t\tif (t.first == true) {\n\t\t\t\t\tt.first = false;\n\t\t\t\t\tstack.push(t);\n\t\t\t\t\tp = t.node.right;\n\t\t\t\t} else {\n\t\t\t\t\trt.add(t.node.val);\n\t\t\t\t\tp = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stk = new Stack<Character>();\n        for (int i = 0; i < s.length(); ++i) {\n            char ch = s.charAt(i);\n            if (ch == '(' || ch == '[' || ch== '{') {\n                stk.push(ch);\n            }\n            else {\n                if (stk.empty() || Math.abs(stk.pop() - ch) > 2) \n                    return false;\n            }\n        }\n        return stk.empty(); \n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    \n    public String addBinary(String a, String b) {\n        if (a == null || b == null || a.length() == 0 || b.length() == 0) {\n            return null;\n        }\n        int decimalA = Integer.parseInt(a, 2);\n        int decimalB = Integer.parseInt(b, 2);\n        \n        int sum = decimalA + decimalB;\n        \n        return Integer.toBinaryString(sum);\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int ans=0;\n        for (int i = citations.length-1; i >=0 ; i--) {\n            if (citations[i]>ans) {\n                ans++;\n            }else {\n                return ans;\n            }\n        }\n        return ans;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class BestTimeToBuyAndSellStockII\n{\n    public int maxProfit( int[] prices )\n    {\n    \tint profit = 0;\n    \tfor ( int i = 0; i < prices.length - 1; i++ )\n    \t{\n    \t\tint diff = prices[i + 1] - prices[i];\n    \t\tif ( diff > 0 )\n    \t\t{\n    \t\t\tprofit += diff;\n    \t\t}\n    \t}\n    \treturn profit;\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class ClimbingStairs3 {\n    public int climbStairs(int n) {\n        if (n == 1)\n            return 1;\n        int[] res = new int[3];\n        res[0] = 1;\n        res[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            res[i % 3] = res[(i - 1) % 3] + res[(i - 2) % 3];\n        }\n        return res[n % 3];\n    }\n\n    public int climbStairs2(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        int first = 1;\n        int second = 2;\n        for (int i = 3; i <= n; i++) {\n            int third = first + second;\n            first = second;\n            second = third;\n        }\n        return second;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class ImplementStrStr \n{\n    public int strStr( String haystack, String needle )\n    {\n    \tif ( haystack == null || needle == null || needle.length() == 0 )\n    \t{\n    \t\treturn 0;\n    \t}\n    \t\n    \tfor ( int i = 0; i < haystack.length() - needle.length() + 1; i++ )\n    \t{\n    \t\tfor ( int haystackIndex = i, needleIndex = 0; needleIndex < needle.length(); haystackIndex++, needleIndex++ )\n    \t\t{\n    \t\t\tif ( haystack.charAt( haystackIndex ) != needle.charAt( needleIndex ) )\n    \t\t\t{\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tif ( needleIndex == needle.length() - 1 )\n    \t\t\t{\n    \t\t\t\treturn i;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn -1;\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class TwoSum {\n  HashMap<Integer, Integer> map = new HashMap<>();\n\n  public int[] twoSum(int[] nums, int target) {\n    int[] result = new int[2];\n\n    for (int i : nums) {\n      if (map.keySet().contains(i)) {\n        int count = map.get(i);\n        map.put(i, ++count);\n      } else {\n        map.put(i, 1);\n      }\n    }\n\n    for (int i = 0, l = nums.length; i < l; i++) {\n      int ele = nums[i];\n      int req = target - ele;\n      if (map.keySet().contains(req)) {\n        result[0] = i;\n        if (ele == req) {\n          int count = map.get(req);\n          if (count > 1) {\n            for (int j = i + 1; j < l; j++) {\n              if (nums[j] == req) {\n                result[1] = j;\n                return result;\n              }\n            }\n          }\n        } else {\n          for (int j = i + 1; j < l; j++) {\n            if (nums[j] == req) {\n              result[1] = j;\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class DecodeWays {\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(new DecodeWays().numDecodings(\"3120\"));\n  }\n\n  public int numDecodings(String s) {\n    if (s == null || s.isEmpty()) return 0;\n    int[] dp = new int[s.length() + 2];\n    dp[s.length()] = 1;\n    dp[s.length() + 1] = 1;\n    for (int i = s.length() - 1; i >= 0; i--) {\n      for (int j = i + 1; j < i + 3; j++) {\n        if (j <= s.length()) {\n          String subStr = s.substring(i, j);\n          if (!subStr.startsWith(\"0\")) {\n            int intVal = Integer.parseInt(subStr);\n            if (intVal <= 26) {\n              dp[i] += dp[j];\n            }\n          }\n        }\n      }\n    }\n    return dp[0];\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Searcha2DMatrix {\n\tpublic boolean searchMatrix(int[][] matrix, int target) {\n\n\t\tint rows = matrix.length;\n\t\tint cols = matrix[0].length;\n\t\tint s = 0, e = rows * cols - 1;\n\t\twhile (s <= e) {\n\t\t\tint mid = s + (e - s) / 2;\n\t\t\tif (matrix[mid / cols][mid % cols] == target)\n\t\t\t\treturn true;\n\t\t\telse if (matrix[mid / cols][mid % cols] > target)\n\t\t\t\te = mid - 1;\n\t\t\telse\n\t\t\t\ts = mid + 1;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int longestValidParentheses(String s) {\n        int max=0;\n        int i=0;\n        \n        while(i<s.length()){\n            int end=i;\n            int numLeftprent=1;\n            if(s.charAt(end)=='(' && end!=s.length()-1){\n                while( ++end<s.length()){\n                    if(s.charAt(end)=='(')\n                        numLeftprent++;\n                    else\n                        numLeftprent--;\n                    if(numLeftprent==0)\n                        max = Math.max(max,end-i+1+numLeftprent);\n                    if(numLeftprent==-1 || (numLeftprent==0 && end==s.length()-1)){\n                        max = Math.max(max,end-i+1+numLeftprent);\n                        i = end+1;    \n                        break;\n                    }else if(end==s.length()-1)\n                        i++;                   \n                 }\n                   \n            }else\n                i++;\n        }\n        return max;\n    }\n}", "nl": "azheanda"}
{"code": "public class L011_Container_With_Most_Water {\n\n\tpublic static int maxArea(int[] height) {\n\n\t\tif (height == null || height.length == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint maxArea = 0;\n\n\t\tint left = 0;\n\t\tint right = height.length - 1;\n\n\t\twhile (left < right) {\n\n\t\t\tint curArea = Math.min(height[left], height[right])\n\t\t\t\t\t* (right - left);\n\t\t\tmaxArea = Math.max(maxArea, curArea);\n\n\t\t\tif (height[left] < height[right]) {\n\t\t\t\tleft++;\n\t\t\t} else {\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\n\t\treturn maxArea;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class _1_twoSum {\n\n    public static void main(String[] args) {\n        _1_twoSum twoSum = new _1_twoSum();\n        Util.printArray(twoSum.twoSum(new int[]{3, 2, 4}, 6));\n        Util.printArray(twoSum.twoSum2(new int[]{3, 2, 4}, 6));\n    }\n\n    \n    public int[] twoSum2(int[] nums, int target) {\n        int[] result = new int[2];\n        int[] copyNums = new int[nums.length];\n        System.arraycopy(nums, 0, copyNums, 0, nums.length);\n        Arrays.sort(nums);\n        int sIndex = 0;\n        int eIndex = nums.length - 1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[sIndex] + nums[eIndex] == target) {\n                result[0] = nums[sIndex];\n                result[1] = nums[eIndex];\n                break;\n            } else if (nums[sIndex] + nums[eIndex] > target) {\n                eIndex--;\n            } else {\n                sIndex++;\n            }\n\n        }\n\n        boolean fGit = false;\n        for (int i = 0; i < copyNums.length; i++) {\n            if (!fGit && copyNums[i] == result[0]) {\n                sIndex = i;\n                fGit = true;\n            } else if (copyNums[i] == result[1]) {\n                eIndex = i;\n            }\n        }\n        if (sIndex > eIndex) {\n            result[0] = eIndex;\n            result[1] = sIndex;\n        } else {\n            result[0] = sIndex;\n            result[1] = eIndex;\n        }\n\n        return result;\n    }\n\n    \n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        for (int i = 0; i < nums.length - 1; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] + nums[j] == target) {\n                    result[0] = i;\n                    result[1] = j;\n                    return result;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        return inorder(root,new ArrayList<Integer>());\n    }\n    public List<Integer> inorder(TreeNode root,List<Integer> list){\n        if (root!=null) {\n            list=inorder(root.left,list);\n            list.add(root.val);\n            list=inorder(root.right,list);\n        }\n        return list;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    \n  public boolean canJump(int[] A) {\n        if (A == null || A.length == 0) {\n            return false;\n        }\n        boolean[] can = new boolean[A.length];\n        can[0] = true;\n        for (int i = 1; i < A.length; i++) {\n            for (int j = 0; j < i; j++) {\n                if (A[j] && (j + A[j] >= i)) {\n                    can[i] = true;\n                    break;\n                }\n            }\n        }\n        return can[A.length - 1];\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public ListNode iter;\n    public TreeNode sortedListToBST_1(ListNode head) {\n        iter = head;\n        int len = 0;\n        while (head != null) {\n            ++len;\n            head = head.next;\n        }\n        return sortedListToBSTRe1(len);\n    }\n    public TreeNode sortedListToBSTRe1(int len) {\n        if (len == 0) return null;\n        int mid = len / 2;\n        TreeNode left = sortedListToBSTRe1(mid);\n        TreeNode root = new TreeNode(iter.val);\n        root.left = left;\n        iter = iter.next;\n        root.right = sortedListToBSTRe1(len - 1 - mid);\n        return root;\n    }\n    public TreeNode sortedListToBST_2(ListNode head) {\n        return sortedListToBSTRe2(head, null);\n    }\n    public TreeNode sortedListToBSTRe2(ListNode start, ListNode end) {\n        if(start == end) return null;\n        ListNode pre = null;\n        ListNode slow = start;\n        ListNode fast = start;\n        while (fast!=end&&fast.next!=end) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode node = new TreeNode(slow.val);\n        node.left = sortedListToBSTRe2(start, slow);\n        node.right = sortedListToBSTRe2(slow.next,end);\n        return node;\n    }\n    public TreeNode sortedListToBST_3(ListNode head) {\n        if (head == null) return null;\n        if (head.next==null) return new TreeNode(head.val);\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null;\n        while(fast.next!=null && fast.next.next!=null) {\n            pre = slow;\n            slow = slow.next;\n            fast =fast.next.next;\n        }\n        fast = slow.next;\n        TreeNode node = new TreeNode(slow.val);\n        if(pre!=null) {\n            pre.next = null;\n            node.left = sortedListToBST_3(head);\n        }\n        node.right = sortedListToBST_3(fast);\n        return node;\n    }\n}", "nl": "leetcoders"}
{"code": "public class JumpGame3 {\n    public boolean canJump(int[] A) {\n        int n = A.length;\n        int last = n - 1, i;\n        for (i = n - 2; i >= 0; i--) {\n            if (i + A[i] >= last) last = i;\n        }\n        return last <= 0;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class ConvertSortedListtoBinarySearchTree {\n\n    public class Solution {\n        private TreeNode sortedListToBST(ListNode head, ListNode[] tail,\n                int begin, int end) {\n            if (begin > end) {\n                tail[0] = head;\n                return null;\n            }\n            TreeNode p = new TreeNode(0);\n            int mid = begin + (end - begin) / 2;\n            p.left = sortedListToBST(head, tail, begin, mid - 1);\n            p.val = tail[0].val;\n            p.right = sortedListToBST(tail[0].next, tail, mid + 1, end);\n            return p;\n        }\n\n        public TreeNode sortedListToBST(ListNode head) {\n            ListNode p = head;\n            int len = 0;\n            while (p != null) {\n                len++;\n                p = p.next;\n            }\n            return sortedListToBST(head, new ListNode[1], 0, len - 1);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "class Permutations {\n\n  \n  public List<List<Integer>> dfs(int[] num) {\n    final List<List<Integer>> res = new ArrayList<>();\n    Arrays.sort(num);\n    dfs(num, 0, res);\n    return res;\n  }\n\n  private void dfs(int[] num, int level, List<List<Integer>> res) {\n    if (level == num.length) {\n      List<Integer> row = new ArrayList<>();\n      for (int a : num) row.add(a);\n      res.add(row);\n      return;\n    }\n    for (int i = level; i < num.length; i++) {\n      swap(num, level, i);\n      dfs(num, level + 1, res);\n      swap(num, level, i); // reset\n    }\n  }\n\n  \n  private void swap(int[] num, int i, int j) {\n    if (i == j) {\n      return;\n    }\n    num[i] = num[j] - num[i];\n    num[j] = num[j] - num[i];\n    num[i] = num[j] + num[i];\n  }\n\n  private void print(int[] num) {\n    for (int i = 0; i < num.length; i++) {\n      System.out.print(num[i] + \" \");\n    }\n    System.out.println();\n  }\n\n  \n  class Solution {\n    boolean[] isUsed;\n    int numLength;\n    ArrayList<ArrayList<Integer>> output;\n    ArrayList<Integer> al;\n\n    public ArrayList<ArrayList<Integer>> permute(int[] num) {\n      numLength = num.length;\n      al = new ArrayList<Integer>();\n      output = new ArrayList<ArrayList<Integer>>();\n      isUsed = new boolean[num.length];\n      doPermutation(0, num);\n      return output;\n    }\n\n    public void doPermutation(int index, int[] num) {\n      if (index == numLength) {\n        output.add((ArrayList<Integer>) al.clone());\n        return;\n      }\n      for (int i = 0; i < numLength; i++) {\n        if (!isUsed[i]) {\n          al.add(num[i]); // mark\n          isUsed[i] = true; // mark\n          doPermutation(index + 1, num);\n          isUsed[i] = false; // reset\n          al.remove(index); // reset\n        }\n      }\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        Map<Integer, Integer> map=new HashMap<Integer, Integer>();\n        int sum=0;\n        for (int i = 0; i <intervals.size(); i++) {\n            int s=intervals.get(i).start;\n            int e=intervals.get(i).end;\n            if (e>sum) {\n                sum=e;\n            }\n            if (s==e) {\n                if (map.get(s)==null) {\n                    map.put(s, -1);\n                }\n            }else {\n                for (int j = s; j <=e; j++) {\n                    if (j==s) {\n                        if(map.get(j)==null||map.get(j)==-1||map.get(j)==0){\n                            map.put(j, 0);\n                        }else {\n                            map.put(j, 1);\n                        }\n                    }else if (j==e) {\n                        if (map.get(j)==null||map.get(j)==-1||map.get(j)==2) {\n                            map.put(j, 2);\n                        }else {\n                            map.put(j, 1);\n                        }\n                    }else {\n                        map.put(j, 1);\n                    }\n                }\n            }\n        }\n        boolean flag=true;\n        List<Interval> answerList=new ArrayList<Interval>();\n        int s=0;\n        int e=0;\n        for (int i = 0; i <sum+2; i++) {\n            if (flag) {\n                if (map.get(i)!=null&&map.get(i)==-1) {\n                    answerList.add(new Interval(i,i));\n                }else if (map.get(i)!=null) {\n                    s=i;\n                    flag=false;\n                }\n            }else {\n                if (map.get(i)==null||map.get(i)==2) {\n                    flag=true;\n                    e=i;\n                    answerList.add(new Interval(s,e));\n                    s=0;\n                }\n            }\n        }\n        return answerList;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MaximumSubarray2 {\n\tpublic int maxSubArray(int[] A) {\n\t\tint max = A[0];\n\t\tint maxEndHere = A[0];\n\t\tfor (int i = 1; i < A.length; i++) {\n\t\t\tmaxEndHere = Math.max(A[i], maxEndHere + A[i]);\n\t\t\tmax = Math.max(max, maxEndHere);\n\t\t}\n\t\treturn max;\n\t}\n\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> res = new ArrayList<List<String>>();\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = i; j < n; ++j) {\n                dp[i][j]=(s.charAt(i)==s.charAt(j))&&(j<i+2||dp[i+1][j-1]);\n            }\n        }\n        ArrayList<String> path = new ArrayList<String>();\n        dfs(s, dp, 0, path, res);\n        return res;\n    }\n    public void dfs(String s, boolean[][] dp, int start, ArrayList<String> path, List<List<String>> res) {\n        if (s.length() == start) {\n            res.add(new ArrayList<String>(path));\n            return;\n        }\n        for (int i = start; i < s.length(); ++i) {\n            if (dp[start][i] == false) continue;\n            path.add(s.substring(start,i+1));\n            dfs(s, dp, i+1,path,res);\n            path.remove(path.size()-1);\n        }\n    }\n}", "nl": "leetcoders"}
{"code": "public class MajorityElement {\n\tpublic static int majorityElement(int[] num) {\n\t\tHashtable<Integer, Integer> table = new Hashtable<Integer, Integer>();\n\t\tfor (int i = 0; i < num.length; i++) {\n\t\t\tif (table.containsKey(num[i])) {\n\t\t\t\tif ((table.get(num[i]) + 1) > num.length / 2)\n\t\t\t\t\treturn num[i];\n\t\t\t\telse\n\t\t\t\t\ttable.put(num[i], table.get(num[i]) + 1);\n\t\t\t} else\n\t\t\t\ttable.put(num[i], 1);\n\t\t}\n\t\treturn num[0];  // length==1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    int[] memo;\n    public int climbStairs(int n) {\n        if (n <= 1) {\n            return 1;\n        }\n        memo = new int[n];\n        return dfs(n - 1) + dfs(n - 2);\n    }\n    \n    public int dfs(int n) {\n        if (n <= 1) {\n            return 1;\n        }\n        if (memo[n] > 0) {\n            return memo[n];\n        }\n        memo[n - 1] = dfs(n - 1);\n        memo[n - 2] = dfs(n - 2);\n        return memo[n - 1] + memo[n - 2];\n    }\n}", "nl": "awangdev"}
{"code": "public class InsertionSortList {\n  public ListNode insertionSortList(ListNode head) {\n    ListNode ret = new ListNode(Integer.MIN_VALUE);\n    ListNode result = ret;\n    ListNode cur = new ListNode(0);\n    cur.next = head;\n    while (cur.next != null) {\n      while (result.next != null && cur.next.val > result.next.val) {\n        result = result.next;\n      }\n      ListNode tmp = cur.next;\n      cur.next = cur.next.next;\n      if (result.next == null) {\n        result.next = tmp;\n        tmp.next = null;\n      } else {\n        ListNode tmp2 = result.next;\n        result.next = tmp;\n        tmp.next = tmp2;\n      }\n      result = ret;\n    }\n    return result.next;\n  }\n}\n", "nl": "mengli"}
{"code": "public class _147_insertionSortList {\n\n    public static void main(String[] args) {\n        ListNode node = Util.generateListNodeBySize(5);\n        Util.printListNode(node);\n        Util.printListNode(insertionSortList(node));\n    }\n\n    \n    public static ListNode insertionSortList(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n\n        ListNode dummy = new ListNode(0); //new starter of the sorted list\n        ListNode cur = head; //the node will be inserted\n        ListNode pre = dummy; //insert node between pre and pre.next\n        ListNode next = null; //the next node will be inserted\n        while (cur != null) {\n            next = cur.next;\n            while (pre.next != null && pre.next.val < cur.val) {\n                pre = pre.next;\n            }\n            cur.next = pre.next;\n            pre.next = cur;\n            pre = dummy;\n            cur = next;\n        }\n\n        return dummy.next;\n    }\n}", "nl": "pphdsny"}
{"code": "class FindMinimumInRotatedSortedArray {\n\n    public int findMin(int[] nums) {\n        int lo = 0, hi = nums.length - 1;\n        while (lo < hi) { // Stop when lo == hi.\n            int mid = lo + (hi - lo) / 2;\n            if (nums[mid] > nums[hi]) { // Minimum must be in right half, excluding mid.\n                lo = mid + 1;\n            } else { // Minimum must be in left half, including mid.\n                hi = mid;\n            }\n        }\n        return nums[lo];\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices.length <= 1) {\n            return 0;\n        }\n        int[] change = new int[prices.length - 1];\n        for (int i = 0; i < change.length; i++) {\n            change[i] = prices[i + 1] - prices[i];\n        }\n        int sum = 0;\n        for (int i = 0; i < change.length; i++) {\n            if (change[i]>0) {\n                sum+=change[i];\n            }\n        }\n        return sum;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class BinaryTreePaths {\n\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n\n  public List<String> binaryTreePaths(TreeNode root) {\n    List<String> result = new ArrayList<>();\n    new BinaryTreePaths().inorder(root, result, \"\");\n    return result;\n  }\n\n  private void inorder(TreeNode node, List<String> list, String path) {\n    if (node != null) {\n      if (node.left == null && node.right == null) {\n        list.add(path + node.val);\n      } else {\n        inorder(node.left, list, path + node.val + \"->\");\n        inorder(node.right, list, path + node.val + \"->\");\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class MinimumPathSum {\n\n    public class Solution {\n        public int minPathSum(int[][] grid) {\n            assert grid != null && grid.length != 0 && grid[0].length != 0;\n            int[] dp = new int[grid[0].length];\n            for (int i = 0; i < grid.length; i++) {\n                dp[0] = i == 0 ? grid[0][0] : dp[0] + grid[i][0];\n                for (int j = 1; j < grid[0].length; j++) {\n                    dp[j] = i == 0 ? dp[j - 1] : Math.min(dp[j], dp[j - 1]);\n                    dp[j] += grid[i][j];\n                }\n            }\n            return dp[grid[0].length - 1];\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class GenerateParentheses {\n\tpublic class Solution {\n\t\tpublic List<String> generateParenthesis(int n) {\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tif (n == 0)\n\t\t\t\tlist.add(\"\");\n\t\t\telse if (n == 1)\n\t\t\t\tlist.add(\"()\");\n\t\t\telse {\n\t\t\t\tList<String> prev = generateParenthesis(n - 1);\n\t\t\t\tfor (String s : prev) {\n\t\t\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\t\t\tif (s.charAt(i) == '(')\n\t\t\t\t\t\t\ts = insertInside(s, i);\n\t\t\t\t\t\tif (!list.contains(s))\n\t\t\t\t\t\t\tlist.add(s);\n\t\t\t\t\t}\n\t\t\t\t\tif (!list.contains(s))\n\t\t\t\t\t\tlist.add(\"()\" + s);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\n\t\tpublic String insertInside(String s, int i) {\n\t\t\tString left = s.substring(0, i+1);\n\t\t\tString right = s.substring(i+1);\n\t\t\treturn left + \"()\" + right;\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L101_Symmetric_Tree {\n\n\tpublic boolean isSymmetric(TreeNode root) {\n\n\t\tif (root == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isSymmetric(root.left, root.right);\n\t}\n\n\tboolean isSymmetric(TreeNode p, TreeNode q) {\n\n\t\tif (p == null && q == null) {\n\t\t\treturn true;\n\t\t} else if (p == null || q == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn p.val == q.val && isSymmetric(p.left, q.right)\n\t\t\t\t&& isSymmetric(p.right, q.left);\n\t}\n\n\tpublic boolean isSymmetric2(TreeNode root) {\n\n\t\tif (root == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tDeque<TreeNode> deque = new LinkedList<TreeNode>();\n\n\t\tif (root.left == null && root.right == null) {\n\t\t\treturn true;\n\t\t} else if (root.left == null || root.right == null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tdeque.addLast(root.left);\n\t\t\tdeque.addLast(root.right);\n\t\t}\n\n\t\twhile (deque.size() != 0) {\n\t\t\tTreeNode p = deque.pop();\n\t\t\tTreeNode q = deque.pop();\n\n\t\t\tif (p.val != q.val) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (p.left == null && q.right == null) {\n\t\t\t} else if (p.left == null || q.right == null) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tdeque.addLast(p.left);\n\t\t\t\tdeque.addLast(q.right);\n\t\t\t}\n\n\t\t\tif (p.right == null && q.left == null) {\n\t\t\t} else if (p.right == null || q.left == null) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tdeque.addLast(p.right);\n\t\t\t\tdeque.addLast(q.left);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class L109_Convert_Sorted_List_to_Binary_Search_Tree {\n\n\tListNode cutAtMid(ListNode head) {\n\n\t\tif (head == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tListNode fast = head;\n\t\tListNode slow = head;\n\t\tListNode pslow = head;\n\n\t\twhile (fast != null && fast.next != null) {\n\t\t\tpslow = slow;\n\t\t\tslow = slow.next;\n\t\t\tfast = fast.next.next;\n\t\t}\n\n\t\tpslow.next = null;\n\t\treturn slow;\n\t}\n\n\tpublic TreeNode sortedListToBST(ListNode head) {\n\n\t\tif (head == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (head.next == null) {\n\t\t\treturn new TreeNode(head.val);\n\t\t}\n\n\t\tListNode mid = cutAtMid(head);\n\n\t\tTreeNode root = new TreeNode(mid.val);\n\t\troot.left = sortedListToBST(head);\n\t\troot.right = sortedListToBST(mid.next);\n\n\t\treturn root;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode header = new ListNode(-1);\n        ListNode prev = header;\n        int sum=0;\n        while(l1!=null || l2!=null || sum>0){\n            if(l1!=null)\n                sum+=l1.val;\n            if(l2!=null)\n                sum+=l2.val;\n            int val = sum%10;\n            sum = sum/10;\n            ListNode current = new ListNode(val);\n            prev.next = current;\n            prev = current;\n            l1 = l1==null?l1:l1.next;\n            l2 = l2==null?l2:l2.next;\n        }\n        return header.next;\n    }\n}", "nl": "azheanda"}
{"code": "public class PlusOne2 {\n\tpublic int[] plusOne(int[] digits) {\n\t\tint carry = 1;\n\t\tfor (int i = digits.length - 1; i >= 0; i--) {\n\t\t\tif (digits[i] < 9) {\n\t\t\t\tdigits[i] += carry;\n\t\t\t\treturn digits;\n\t\t\t} else {\n\t\t\t\tdigits[i] = 0;\n\t\t\t\tcarry = 1;\n\t\t\t}\n\t\t}\n\t\tif (carry == 1) {\n\t\t\tint res[] = new int[digits.length + 1];\n\t\t\tres[0] = 1;\n\t\t\treturn res;\n\t\t}\n\t\treturn digits;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class SearchForARange {\n\n    \n    public int[] searchRange(int[] nums, int target) {\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2; // Round down.\n            if (nums[mid] >= target) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        if (nums[lo] != target) { // Failed search, no lower bound.\n            return new int[]{-1, -1};\n        }\n        int start = lo; // Save the lower bound. Otherwise it would be changed later.\n        hi = nums.length - 1; // Reset upper bound.\n        while (lo < hi) {\n            int mid = lo + (hi - lo + 1) / 2; // Round up instead. Otherwise will stuck in loop.\n            if (nums[mid] > target) {\n                hi = mid - 1;\n            } else {\n                lo = mid;\n            }\n        }\n        if (nums[hi] != target) { // Failed search, no upper bound.\n            return new int[]{-1, -1};\n        }\n        return new int[]{start, hi};\n    }\n\n    @Test\n    public void testExamples() {\n        SearchForARange s = new SearchForARange();\n        int[] A = {1, 2, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n        int[] range = s.searchRange(A, 3);\n        System.out.println(range[0] + \" ~ \" + range[1]);\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class LRUCache2 {\n\tprivate class Node {\n\t\tNode prev;\n\t\tNode next;\n\t\tint key;\n\t\tint value;\n\n\t\tpublic Node(int key, int value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t\tthis.prev = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tprivate int capacity;\n\tprivate HashMap<Integer, Node> hs = new HashMap<Integer, Node>();\n\tprivate Node head = new Node(-1, -1);\n\tprivate Node tail = new Node(-1, -1);\n\n\tpublic LRUCache2(int capacity) {\n\t\tthis.capacity = capacity;\n\t\ttail.prev = head;\n\t\thead.next = tail;\n\t}\n\n\tpublic int get(int key) {\n\t\tif (!hs.containsKey(key)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tNode current = hs.get(key);\n\t\tcurrent.prev.next = current.next;\n\t\tcurrent.next.prev = current.prev;\n\n\t\tmove_to_tail(current);\n\n\t\treturn hs.get(key).value;\n\t}\n\n\tpublic void set(int key, int value) {\n\t\tif (get(key) != -1) {\n\t\t\ths.get(key).value = value;\n\t\t\treturn;\n\t\t}\n\n\t\tif (hs.size() == capacity) {\n\t\t\ths.remove(head.next.key);\n\t\t\thead.next = head.next.next;\n\t\t\thead.next.prev = head;\n\t\t}\n\n\t\tNode insert = new Node(key, value);\n\t\ths.put(key, insert);\n\t\tmove_to_tail(insert);\n\t}\n\n\tprivate void move_to_tail(Node current) {\n\t\tcurrent.prev = tail.prev;\n\t\ttail.prev = current;\n\t\tcurrent.prev.next = current;\n\t\tcurrent.next = tail;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class LRUCache {\n\n  private final int capacity;\n  private final Map<Integer, Node> cache;\n  private final Node head;\n  private final Node tail;\n\n  \n  public LRUCache(int capacity) {\n    this.capacity = capacity;\n    cache = new HashMap<>();\n    head = new Node();\n    tail = new Node();\n    head.next = tail;\n    tail.prev = head;\n  }\n\n  \n  public int get(int key) {\n    if (!cache.containsKey(key)) {\n      return -1;\n    }\n    Node node = cache.get(key);\n    moveToHead(node);\n    return node.val;\n  }\n\n  \n  public void set(int key, int value) {\n    if (cache.containsKey(key)) {\n      Node node = cache.get(key);\n      node.val = value;\n      moveToHead(node);\n    } else {\n      Node newNode = new Node(key, value);\n      addNode(newNode);\n      cache.put(key, newNode);\n      if (cache.size() > capacity) {\n        Node last = tail.prev;\n        removeNode(last);\n        cache.remove(last.key);\n      }\n    }\n  }\n\n  \n  private void moveToHead(Node node) {\n    removeNode(node);\n    addNode(node);\n  }\n\n  \n  private void removeNode(Node node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n\n  \n  private void addNode(Node node) {\n    node.prev = head;\n    node.next = head.next;\n    head.next.prev = node;\n    head.next = node;\n  }\n\n  \n  class Node {\n\n    Node prev;\n    Node next;\n    int key;\n    int val;\n\n    public Node() {\n    }\n\n    public Node(int key, int val) {\n      this.key = key;\n      this.val = val;\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class LongestCommonPrefix {\n\n    public class Solution {\n        public String longestCommonPrefix(String[] strs) {\n            if (strs.length == 0) {\n                return \"\";\n            }\n\n            int longest = strs[0].length();\n            for (int i = 1; i < strs.length; i++) {\n                longest = Math.min(strs[i].length(), longest);\n                for (int j = 0; j < longest; j++) {\n                    if (strs[i].charAt(j) != strs[0].charAt(j)) {\n                        longest = j;\n                        break;\n                    }\n                }\n            }\n            return strs[0].substring(0, longest);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MedianOfTwoSortedArrays {\n\n    \n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        if (m == 0 && n == 0) return 0.0;\n        if (m > n) return findMedianSortedArrays(nums2, nums1); // Keep shorter array first. Note the return.\n\n        int i = 0;\n        int j = 0;\n        int iMin = 0; // i's range is [0, m].\n        int iMax = m;\n        int mid = (m + n + 1) / 2; // When m+n is odd, there median will be the maximum of left half.\n        while (iMin <= iMax) {\n            i = (iMin + iMax) / 2;\n            j = mid - i;\n            if (j > 0 && i < m && nums2[j - 1] > nums1[i]) {\n                iMin = i + 1;\n            } else if (i > 0 && j < n && nums1[i - 1] > nums2[j]) {\n                iMax = i - 1;\n            } else {\n                break;\n            }\n        }\n\n        int leftMax = 0;\n        if (i == 0) {\n            leftMax = nums2[j - 1];\n        } else if (j == 0) {\n            leftMax = nums1[i - 1];\n        } else {\n            leftMax = Math.max(nums1[i - 1], nums2[j - 1]);\n        }\n        if ((m + n) % 2 == 1) { // Total # of elements is odd.\n            return leftMax;\n        }\n        int rightMin = 0; // Total # of elements is even.\n        if (i == m) {\n            rightMin = nums2[j];\n        } else if (j == n) {\n            rightMin = nums1[i];\n        } else {\n            rightMin = Math.min(nums1[i], nums2[j]);\n        }\n        return (leftMax + rightMin) / 2.0; // Return double.\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class ValidParentheses {\n\n    \n    public boolean isValid(String s) {\n        if (s == null || s.length() == 0) {\n            return false;\n        }\n        if (s.length() % 2 != 0) { // String length must be even.\n            return false;\n        }\n        Deque<Character> stack = new ArrayDeque<>();\n        for (char c : s.toCharArray()) {\n            if (\"({[\".indexOf(c) != -1) { // Push left parens.\n                stack.push(c);\n            } else if (!stack.isEmpty() && isMatch(stack.peek(), c)) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n\n    private boolean isMatch(char c1, char c2) {\n        return (c1 == '(' && c2 == ')') || (c1 == '{' && c2 == '}') || (c1 == '[' && c2 == ']');\n    }\n\n    \n    public boolean isValid2(String s) {\n        Deque<Character> stack = new ArrayDeque<>();\n        String left = \"({[\";\n        String right = \")}]\";\n        for (char c : s.toCharArray()) {\n            int index = left.indexOf(c);\n            if (index != -1) { // Is closing.\n                stack.push(right.charAt(index)); // Push it's relative opening so that we save the match function.\n            } else if (stack.isEmpty() || stack.pop() != c) {\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class L136_Single_Number {\n\n\tpublic int singleNumber(int[] nums) {\n\n\t\tint n = 0;\n\n\t\tfor (int i : nums) {\n\t\t\tn ^= i;\n\t\t}\n\n\t\treturn n;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        if (heights == null || heights.length == 0) {\n            return 0;\n        }\n        int n = heights.length;\n        int max = 0;\n        Stack<Integer> stack = new Stack<>(); // Use stack to store the index\n        for (int i = 0; i <= n; i++) {\n            int currHeight = i == n ? -1 : heights[i];\n            while (!stack.isEmpty() && currHeight <= heights[stack.peek()]) {\n                int currPeekHeight = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                max = Math.max(max, currPeekHeight * width);\n            }\n            stack.push(i);\n        }\n\n        return max;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) {\n            return head;\n        }   \n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode node = dummyHead; // node is the leading dummy head, node.next is the head\n    \n        while (node.next != null && node.next.next != null) {\n            if (node.next.val == node.next.next.val) {\n                int duplicatedVal = node.next.val;\n                while (node.next != null && node.next.val == duplicatedVal) {\n                    node.next = node.next.next;\n                }\n            } else {\n                node = node.next;\n            }\n        }\n        \n        return dummyHead.next;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class BinaryTreePreorderTraversal {\n\n    public class Solution {\n        private void preorderTraversal(TreeNode root,\n                ArrayList<Integer> preorder) {\n            if (root == null) {\n                return;\n            }\n            preorder.add(root.val);\n            preorderTraversal(root.left, preorder);\n            preorderTraversal(root.right, preorder);\n        }\n\n        public ArrayList<Integer> preorderTraversal(TreeNode root) {\n            ArrayList<Integer> preorder = new ArrayList<Integer>();\n            preorderTraversal(root, preorder);\n            return preorder;\n        }\n\n        public ArrayList<Integer> preorderTraversalWithIterative(TreeNode root) {\n            ArrayList<Integer> preorder = new ArrayList<Integer>();\n            ArrayDeque<TreeNode> stack = new ArrayDeque<TreeNode>();\n            if (root != null) {\n                stack.offerLast(root);\n                while (!stack.isEmpty()) {\n                    TreeNode p = stack.removeLast();\n                    while (p != null) {\n                        preorder.add(p.val);\n                        if (p.right != null) {\n                            stack.offerLast(p.right);\n                        }\n                        p = p.left;\n                    }\n                }\n            }\n            return preorder;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class LinkedListCycle {\n  public boolean hasCycle(ListNode head) {\n    if (head == null) return false;\n    ListNode fast = head;\n    ListNode late = head;\n    do {\n      fast = fast.next;\n      late = late.next;\n      if (late == null) {\n        return false;\n      } else {\n        late = late.next;\n        if (fast == late) {\n          return true;\n        }\n      }\n    } while (fast != null && late != null);\n    return false;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public int rob(int[] nums) {\n        int n=nums.length;\n        if (n==0) {\n            return 0;\n        }\n        int[] ans=new int[n+1];\n        ans[0]=0;\n        ans[1]=nums[0];\n        for (int i = 2; i < n+1; i++) {\n            ans[i]=Math.max(nums[i-1]+ans[i-2], ans[i-1]);\n        }\n        return ans[n];\n    }\n}", "nl": "corpsepiges"}
{"code": "public class DecodeWays {\n  public int numDecodings(String s) {\n    if (s.length() == 0) return 0;\n    int[] c = new int[s.length() + 1];\n    c[0] = 1;\n    if (s.charAt(0) != '0') c[1] = c[0];\n    else c[1] = 0;\n    for (int i = 2; i <= s.length(); i++) {\n      if (s.charAt(i - 1) == '0') {\n        c[i] = 0;\n      } else {\n        c[i] = c[i - 1];\n      }\n      if (s.charAt(i - 2) == '1' || (s.charAt(i - 2) == '2' && s.charAt(i - 1) <= '6')) {\n        c[i] += c[i - 2];\n      }\n    }\n    return c[s.length()];\n  }\n}\n", "nl": "mengli"}
{"code": "public class Sqrtx {\n\tpublic int sqrt(int x) {\n\t\tint left = 0;\n\t\tint right = x / 2 + 1;\n\t\twhile (left <= right) {\n\t\t\tint mid = (left + right) >> 1;\n\t\t\tif ((long) mid * mid == x)\n\t\t\t\treturn mid;\n\t\t\telse if ((long) mid * mid > x)\n\t\t\t\tright = mid - 1;\n\t\t\telse\n\t\t\t\tleft = mid + 1;\n\t\t}\n\t\treturn left - 1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        \n        dfs(result, new ArrayList<>(), nums);\n        return result;\n    }\n    \n    private void dfs(List<List<Integer>> result, List<Integer> levelList, int[] nums) {\n        if (levelList.size() == nums.length) {\n            result.add(new ArrayList<>(levelList));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (levelList.contains(nums[i])) continue;\n            levelList.add(nums[i]);\n            dfs(result, levelList, nums);\n            levelList.remove(levelList.size() - 1);\n        }\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class MinimumWindowSubstring {\n\n    public class Solution {\n        public String minWindow(String S, String T) {\n            int[] tCount = new int[256];\n            for (int i = 0; i < T.length(); i++) {\n                tCount[T.charAt(i)]++;\n            }\n            int[] sCount = new int[256];\n            int i = 0;\n            for (; i < S.length(); i++) {\n                sCount[S.charAt(i)]++;\n                boolean find = true;\n                for (int j = 0; j < 256; j++) {\n                    if (sCount[j] < tCount[j]) {\n                        find = false;\n                        break;\n                    }\n                }\n                if (find) {\n                    break;\n                }\n            }\n            if (i == S.length()) {\n                return \"\";\n            }\n            int windowStart = 0;\n            int windowEnd = i;\n            int minWindowStart = windowStart;\n            int minWindowEnd = windowEnd;\n            while (windowStart < S.length()) {\n                char c = S.charAt(windowStart);\n                sCount[c]--;\n                windowStart++;\n                if (sCount[c] < tCount[c]) {\n                    windowEnd++;\n                    while (windowEnd < S.length()) {\n                        char endC = S.charAt(windowEnd);\n                        sCount[endC]++;\n                        if (c == endC) {\n                            break;\n                        }\n                        windowEnd++;\n                    }\n                    if (windowEnd == S.length()) {\n                        break;\n                    }\n                }\n                if (windowEnd - windowStart < minWindowEnd - minWindowStart) {\n                    minWindowStart = windowStart;\n                    minWindowEnd = windowEnd;\n                }\n            }\n            return S.substring(minWindowStart, minWindowEnd + 1);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MergekSortedLists3 {\n\tpublic ListNode mergeKLists(ArrayList<ListNode> lists) {\n\t\tif (lists == null || lists.size() == 0)\n\t\t\treturn null;\n\t\tif (lists.size() == 1)\n\t\t\treturn lists.get(0);\n\t\tint min = 0;\n\t\tint count = 0;\n\t\tListNode head = new ListNode(0);\n\t\tListNode curr = new ListNode(0);\n\t\twhile (count != lists.size()) {\n\t\t\tcount=0;\n\t\t\tint index=0;\n\t\t\tfor (int i=0;i<lists.size();i++) {\n\t\t\t\tListNode node= lists.get(index);\n\t\t\t\tif (node != null && min > node.val) {\n\t\t\t\t\tmin = node.val;\n\t\t\t\t\tindex=i;\n\t\t\t\t\tcurr = node;\n\t\t\t\t}\n\t\t\t}\n\t\t\thead.next = new ListNode(min);\n\t\t\tlists.remove(index);\n\t\t\tlists.add(index,curr.next);\n\t\t\tfor (ListNode node : lists) {\n\t\t\t\tif (node == null)\n\t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn head.next;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public void flatten(TreeNode root) {\n        flatten_3(root);\n    }\n    public void flatten_1(TreeNode root) {\n        if (root == null) return;\n        flatten_1(root.left);\n        flatten_1(root.right);\n        if (root.left == null) return;\n        TreeNode node = root.left;\n        while (node.right != null) node = node.right;\n        node.right = root.right;\n        root.right = root.left;\n        root.left = null;\n    }\n    public void flatten_2(TreeNode root) {\n        if (root == null) return;\n        Stack<TreeNode> stk = new Stack<TreeNode>();\n        stk.push(root);\n        while (stk.empty() == false) {\n            TreeNode cur = stk.pop();\n            if (cur.right != null) stk.push(cur.right);\n            if (cur.left != null) stk.push(cur.left);\n            cur.left = null;\n            cur.right = stk.empty() == true ? null : stk.peek();\n        }\n    }\n    public TreeNode flattenRe3(TreeNode root, TreeNode tail) {\n        if (root == null) return tail;\n        root.right = flattenRe3(root.left, flattenRe3(root.right, tail));\n        root.left = null;\n        return root;\n    }\n    public void flatten_3(TreeNode root) {\n        if (root == null) return;\n        flattenRe3(root, null);\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode dummy = new ListNode(Integer.MIN_VALUE);\n        dummy.next = head;        \n        ListNode current = dummy;\n        while(current.next!=null){\n            ListNode prev = current;\n            current = current.next;\n            boolean isDuplicate = false;\n            \n            while(current!=null && current.next!=null && current.val==current.next.val){\n                current = current.next;\n                isDuplicate = true;\n            }\n            \n            prev.next = isDuplicate?current.next:current;\n            current = isDuplicate?prev:current;   \n           \n        }\n        return dummy.next;\n    }\n}", "nl": "azheanda"}
{"code": " public class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        Arrays.sort(candidates);\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        combinationSumRe(candidates, target, 0, path, res);\n        return res;\n    }\n    void combinationSumRe(int[] candidates, int target, int start, ArrayList<Integer> path, List<List<Integer>> res) {\n        if (target == 0) {\n            ArrayList<Integer> p = new ArrayList<Integer>(path);\n            res.add(p);\n            return;\n        }\n        for (int i = start; i < candidates.length && target >= candidates[i]; ++i) {\n            path.add(candidates[i]);\n            combinationSumRe(candidates, target-candidates[i], i, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int maxSubArray_1(int[] A) {\n        if (A.length == 0) return 0;\n        int minVal = Math.min(A[0],0), res = A[0], sum = A[0];\n        for (int i = 1; i < A.length; ++i) {\n            sum += A[i];\n            res = Math.max(res, sum - minVal);\n            minVal = Math.min(minVal, sum);\n        }\n        return res;\n    }\n    public int maxSubArray_2(int[] A) {\n        if (A.length == 0) return 0;\n        int dp = A[0], res = A[0];\n        for (int i = 1; i < A.length; ++i) {\n            dp = Math.max(A[i], dp + A[i]);\n            res = Math.max(res, dp);\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class UniquePaths {\n\n    public class Solution {\n        public int uniquePaths(int m, int n) {\n            int[] dp = new int[n];\n            Arrays.fill(dp, 1);\n            for (int i = 1; i < m; i++) {\n                for (int j = 1; j < n; j++) {\n                    dp[j] += dp[j - 1];\n                }\n            }\n            return dp[n - 1];\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean isNumber(String s) {\n        int start = 0, end = s.length() -1;\n        boolean dot = false, exp = false, digit = false;\n        while (start <= end && (s.charAt(start) == ' ')) ++start;\n        while (start <= end && (s.charAt(end) == ' ')) --end;\n        if (start <= end && (s.charAt(start) == '+' || s.charAt(start) == '-')) ++start;\n        if (start > end) return false;\n        for ( ; start <= end; ++start) {\n            if (Character.isDigit(s.charAt(start))) digit = true;\n            else if (s.charAt(start) == 'e' || s.charAt(start) == 'E') {\n                if (exp == true || digit == false || start == end) return false;\n                exp = true;\n            } else if (s.charAt(start) == '.') {\n                if (dot == true || exp == true) return false;\n                if (digit == false && start == end) return false;\n                dot = true;\n            } else if (s.charAt(start) == '+' || s.charAt(start) == '-') {\n                if (start == end) return false;\n                if (s.charAt(start-1) != 'e' && s.charAt(start-1) != 'E') return false;\n            } else return false;\n        }\n        return true;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public ListNode deleteDuplicates_1(ListNode head) {\n        ListNode dummy = new ListNode(-1);\n        ListNode cur = dummy;\n        while (head != null) {\n            if (head.next != null && head.val == head.next.val) {\n                while (head.next != null && head.val == head.next.val)\n                    head = head.next;\n            } else {\n                cur.next = head;\n                cur = cur.next;\n            }\n            head = head.next;\n        }\n        cur.next = null;\n        return dummy.next;\n    }\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null || head.val != head.next.val){\n            head.next = deleteDuplicates(head.next);\n            return head;\n        }\n        while (head.next != null && head.val == head.next.val)\n            head = head.next;\n        return deleteDuplicates(head.next);\n    }\n}", "nl": "leetcoders"}
{"code": "public class _136_singleNumber {\n    public static void main(String[] args) {\n        _136_singleNumber singleNumber = new _136_singleNumber();\n        System.out.println(singleNumber.singleNumber(new int[]{2, 2, 1}));\n        System.out.println(singleNumber.singleNumber(new int[]{4, 1, 2, 1, 2}));\n    }\n\n    \n    public int singleNumber(int[] nums) {\n        int bit = 0;\n        for (int i = 0; i < nums.length; i++) {\n            bit = bit ^ nums[i];\n        }\n        return bit;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class LongestCommonPrefix {\n\tpublic String longestCommonPrefix(String[] strs) {\n\t\tint minlength = Integer.MAX_VALUE;\n\t\tString prefix = \"\";\n\t\tif (strs.length == 0)\n\t\t\treturn \"\";\n\t\tif (strs.length == 1)\n\t\t\treturn strs[0];\n\t\tfor (int i = 0; i <= strs.length - 1; i++) {\n\t\t\tif (minlength > strs[i].length())\n\t\t\t\tminlength = strs[i].length();\n\t\t}\n\t\tfor (int index = 0; index <= minlength - 1; index++) {\n\t\t\tchar ch = strs[0].charAt(index);\n\t\t\tfor (String str : strs) {\n\t\t\t\tif (ch != str.charAt(index))\n\t\t\t\t\treturn prefix;\n\t\t\t}\n\t\t\tprefix += ch;\n\t\t}\n\t\treturn prefix;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int jump(int[] A) {\n        int count = 0;\n        int start=0, end=0, newend;\n        while (end < A.length-1){\n            count++;\n            newend = 0;\n            for (int i=start; i<=end; i++)\n                newend = i+A[i]>newend ? (i+A[i]) : newend;\n            start = end+1;\n            end = newend;\n        }\n        return count;\n    }\n}\n\n\n", "nl": "azheanda"}
{"code": "public class Solution {\n    public int lengthOfLastWord(String s) {\n            int lastletter=-1,firstletter=0;\n            for(int i=s.length()-1;i>=0;i--)\n                if(s.charAt(i)!=' ') {\n                    lastletter = i;\n                    break;\n                }\n            \n            for(int i=lastletter-1;i>=0;i--)\n                if(s.charAt(i)==' '){\n                    firstletter = i+1;\n                    break;\n                }\n                    \n            return lastletter-firstletter+1;\n    }\n}", "nl": "azheanda"}
{"code": "public class L112_Path_Sum {\n\n\tboolean hasPath;\n\n\tpublic boolean hasPathSum(TreeNode root, int sum) {\n\n\t\tif (root == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\thasPath = false;\n\t\thelp(root, 0, sum);\n\t\treturn hasPath;\n\t}\n\n\tvoid help(TreeNode node, int cur, int sum) {\n\n\t\tcur += node.val;\n\n\t\tboolean isLeaf = (node.left == null) && (node.right == null);\n\n\t\tif (cur == sum && isLeaf) {\n\t\t\thasPath = true;\n\t\t}\n\n\t\tif (node.left != null) {\n\t\t\thelp(node.left, cur, sum);\n\t\t}\n\n\t\tif (node.right != null) {\n\t\t\thelp(node.right, cur, sum);\n\t\t}\n\n\t\tcur -= node.val;\n\t}\n\n\tpublic boolean hasPathSum2(TreeNode root, int sum) {\n\n\t\tif (root == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (root.left == null && root.right == null) {\n\t\t\treturn root.val == sum;\n\t\t}\n\n\t\treturn (root.left != null && hasPathSum2(root.left, sum - root.val))\n\t\t\t\t|| (root.right != null && hasPathSum2(root.right, sum\n\t\t\t\t\t\t- root.val));\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    Map<String,List<List<String>>> map=new HashMap<String, List<List<String>>>();\n    public List<List<String>> partition(String s) {\n        if (map.get(s)!=null) {\n            return map.get(s);\n        }\n        List<List<String>> ans=new ArrayList<List<String>>();\n        if(isPartition(s)){\n            List<String> list=new ArrayList<String>();\n            list.add(s);\n            ans.add(list);\n        }\n        for (int i = 0; i < s.length()-1; i++) {\n            String k=s.substring(0,i+1);\n            if (isPartition(k)) {\n                String t=s.substring(i+1,s.length());\n                List<List<String>> list=partition(t);\n                for (int j = 0; j < list.size(); j++) {\n                    List<String> l=new ArrayList<String>();\n                    l.add(k);\n                    l.addAll(list.get(j));\n                    ans.add(l);\n                }\n             }\n        }\n        map.put(s, ans);\n        return ans;\n    }\n    public boolean isPartition(String s){\n        if(s.length()==1){\n            return true;\n        }\n        char[] c=s.toCharArray();\n        int length=c.length;\n        for (int i = 0; i < length/2; i++) {\n            if(c[i]!=c[length-1-i]){\n                return false;\n            }\n        }\n        return true;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MinimumDepthofBinaryTree {\n\tpublic int minDepth(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn 0;\n\n\t\tLinkedList<TreeNode> nodes = new LinkedList<>();\n\t\tLinkedList<Integer> counts = new LinkedList<>();\n\t\tnodes.add(root);\n\t\tcounts.add(1);\n\t\twhile (!nodes.isEmpty()) {\n\t\t\tTreeNode curr = nodes.poll();\n\t\t\tint count = counts.poll();\n\t\t\tif (curr.left != null) {\n\t\t\t\tnodes.add(curr.left);\n\t\t\t\tcounts.add(count + 1);\n\t\t\t}\n\t\t\tif (curr.right != null) {\n\t\t\t\tnodes.add(curr.right);\n\t\t\t\tcounts.add(count + 1);\n\t\t\t}\n\t\t\tif (curr.left == null && curr.right == null)\n\t\t\t\treturn count;\n\t\t}\n\t\treturn 0;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {\n        ArrayList<Interval> res = new ArrayList<Interval>();\n        \n        for(Interval interval: intervals){\n            res = insert(res,interval);\n        }\n        \n        return res;\n        \n    }\n    \n  \n    public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n        ArrayList<Interval> res = new ArrayList<Interval>();        \n        Interval t= new Interval(newInterval.start,newInterval.end);\n        Iterator<Interval> itr = intervals.iterator();\n        \n        while(itr.hasNext()){\n            Interval i = itr.next();\n            if(i.start>t.end){\n                res.add(t);\n                res.add(i);\n                while(itr.hasNext()){res.add(itr.next());}\n                return res;\n            }\n            \n            if(t.start>i.end) \n                res.add(i);\n            else{\n                 t.start = Math.min(i.start,t.start);\n                 t.end = Math.max(i.end,t.end);   \n            }\n        }\n        res.add(t);\n        return res;\n\n    }\n    \n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null && l2 == null) {\n        \treturn null;\n        }\n        ListNode node = new ListNode(0);\n        ListNode dummy = node;\n        while (l1 != null || l2 != null) {\n        \tif (l1 == null) {\n        \t\tnode.next = l2;\n        \t\tbreak;\n        \t} else if (l2 == null) {\n        \t\tnode.next = l1;\n        \t\tbreak;\n        \t} else {\n        \t\tif (l1.val < l2.val) {\n        \t\t\tnode.next = l1;\n        \t\t\tl1 = l1.next;\n        \t\t} else {\n        \t\t\tnode.next = l2;\n        \t\t\tl2 = l2.next;\n        \t\t}\n    \t\t\tnode = node.next;\n        \t}\n        }//end while\n        return dummy.next;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root==null)\n            return false;\n        if(root.right==null && root.left==null)\n            return sum==root.val;\n        \n        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class WordSearch2 {\n\n  \n  public List<String> findWords(char[][] board, String[] words) {\n    List<String> res = new ArrayList<>();\n    TrieNode root = buildTrie(words);\n    for (int i = 0; i < board.length; i++) {\n      for (int j = 0; j < board[i].length; j++) {\n        dfs(board, i, j, root, res);\n      }\n    }\n    return res;\n  }\n\n  \n  private TrieNode buildTrie(String[] words) {\n    TrieNode root = new TrieNode();\n    for (String w : words) {\n      TrieNode node = root;\n      for (char c : w.toCharArray()) {\n        int i = c - 'a';\n        if (node.next[i] == null) node.next[i] = new TrieNode();\n        node = node.next[i];\n      }\n      node.word = w;\n    }\n    return root;\n  }\n\n  \n  private void dfs(char[][] board, int i, int j, TrieNode node, List<String> res) {\n    char c = board[i][j];\n    if (c == '#' || node.next[c - 'a'] == null) return;\n    node = node.next[c - 'a'];\n    if (node.word != null) { // Found one\n      res.add(node.word);\n      node.word = null; // De-dup\n    }\n\n    board[i][j] = '#'; // Mark as visited\n    if (i > 0) dfs(board, i - 1, j, node, res);\n    if (j > 0) dfs(board, i, j - 1, node, res);\n    if (i < board.length - 1) dfs(board, i + 1, j, node, res);\n    if (j < board[i].length - 1) dfs(board, i, j + 1, node, res);\n    board[i][j] = c; // Reset mark\n  }\n\n  class TrieNode {\n    TrieNode[] next = new TrieNode[26];\n    String word;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class ClimbingStairs {\n\n    public class Solution {\n        public int climbStairs(int n) {\n            int f1 = 1;\n            int f2 = 1;\n            for (int i = 2; i <= n; i++) {\n                int temp = f1 + f2;\n                f1 = f2;\n                f2 = temp;\n            }\n            return f2;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class SpiralMatrix2 {\n\tpublic ArrayList<Integer> spiralOrder(int[][] matrix) {\n\t\tint minX, minY, maxX, maxY, x, y;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (matrix == null || matrix.length == 0)\n\t\t\treturn list;\n\t\tminX = minY = 0;\n\t\tmaxX = matrix.length - 1;\n\t\tmaxY = matrix[0].length - 1;\n\n\t\tfor (; minX <= maxX && minY <= maxY; minX++, minY++, maxX--, maxY--) {\n\t\t\tx = minX;\n\t\t\ty = minY;\n\t\t\tlist.add(matrix[x][y]);\n\n\t\t\tif (minX == maxX) {\n\t\t\t\tfor (y += 1; y <= maxY; y++) {\n\t\t\t\t\tlist.add(matrix[x][y]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (minY == maxY) {\n\t\t\t\tfor (x += 1; x <= maxX; x++) {\n\t\t\t\t\tlist.add(matrix[x][y]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (y += 1; y <= maxY; y++) { // top\n\t\t\t\tlist.add(matrix[x][y]);\n\t\t\t\tif (y == maxY)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (x += 1; x <= maxX; x++) { // right\n\t\t\t\tlist.add(matrix[x][y]);\n\t\t\t\tif (x == maxX)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (y -= 1; y >= minY; y--) { // bottom\n\t\t\t\tlist.add(matrix[x][y]);\n\t\t\t\tif (y == minY)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (x -= 1; x > minX; x--) { // left\n\t\t\t\tlist.add(matrix[x][y]);\n\t\t\t\tif (x == minX + 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head==null||head.next==null) {\n            return head;\n        }else {\n            int val=head.val;\n            head.val=head.next.val;\n            head.next.val=val;\n            head.next.next=swapPairs(head.next.next);\n        }\n        return head;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MinimumWindowSubstring2 {\n\tpublic String minWindow(String S, String T) {\n\t\tif (S == null || T == null)\n\t\t\treturn null;\n\t\tif (S.length() == 0 || T.length() == 0 || S.length() < T.length())\n\t\t\treturn \"\";\n\t\tHashMap<Character, Integer> needFind = new HashMap<Character, Integer>();\n\t\tHashMap<Character, Integer> alreadyFind = new HashMap<Character, Integer>();\n\n\t\tfor (int i = 0; i < T.length(); i++) {\n\t\t\talreadyFind.put(T.charAt(i), 0);\n\t\t\tif (needFind.containsKey(T.charAt(i))) {\n\t\t\t\tneedFind.put(T.charAt(i), needFind.get(T.charAt(i)) + 1);\n\t\t\t} else {\n\t\t\t\tneedFind.put(T.charAt(i), 1);\n\t\t\t}\n\t\t}\n\t\tint minStart = -1;\n\t\tint minEnd = S.length();\n\t\tint start = 0;\n\t\tint len = 0;\n\t\tfor (int i = 0; i < S.length(); i++) {\n\t\t\tif (alreadyFind.containsKey(S.charAt(i))) {\n\t\t\t\talreadyFind.put(S.charAt(i), alreadyFind.get(S.charAt(i)) + 1);\n\n\t\t\t\tif (alreadyFind.get(S.charAt(i)) <= needFind.get(S.charAt(i)))\n\t\t\t\t\tlen++;\n\n\t\t\t\tif (len == T.length()) {\n\t\t\t\t\twhile (!needFind.containsKey(S.charAt(start))\n\t\t\t\t\t\t\t|| alreadyFind.get(S.charAt(start)) > needFind.get(S.charAt(start))) {\n\t\t\t\t\t\tif (needFind.containsKey(S.charAt(start)))\n\t\t\t\t\t\t\talreadyFind.put(S.charAt(start), alreadyFind.get(S.charAt(start)) - 1);\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i - start < minEnd - minStart) {\n\t\t\t\t\t\tminStart = start;\n\t\t\t\t\t\tminEnd = i;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (minStart == -1) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn S.substring(minStart, minEnd + 1);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<List<Integer>> threeSum(int[] num) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        Arrays.sort(num);\n        int N = num.length;\n        for (int i = 0; i < N-2 && num[i] <= 0; ++i)\n        {\n            if (i > 0 && num[i] == num[i-1])\n                continue; // avoid duplicates\n            int twosum = 0 - num[i];\n            int l = i + 1, r = N - 1;\n            while (l < r)\n            {\n                int sum = num[l] + num[r];\n                if (sum < twosum) ++l;\n                else if (sum > twosum) --r;\n                else {\n                    ArrayList<Integer> tmp = new ArrayList<Integer>();\n                    tmp.add(num[i]); tmp.add(num[l]); tmp.add(num[r]);\n                    res.add(tmp);\n                    ++l; --r;\n                    while (l < r && num[l] == num[l-1]) ++l;  // avoid duplicates\n                    while (l < r && num[r] == num[r+1]) --r;  // avoid duplicates\n                }\n            }\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "class LongestCommonPrefix {\n\n    public static void main(String[] args) {\n\n    }\n\n    \n    public static String longestCommonPrefix(String[] strs) {\n        for (int i = strs.length - 2; i >= 0; i--) {\n            strs[i] = commonPrefix(strs[i + 1], strs[i]);\n        }\n        return strs[0];\n    }\n\n    \n    private static String commonPrefix(String a, String b) {\n        StringBuilder pref = new StringBuilder();\n        int lenA = a.length();\n        int lenB = b.length();\n        int i = 0;\n        while (i < lenA && i < lenB) {\n            if (a.charAt(i) == b.charAt(i)) pref.append(a.charAt(i));\n            else break;\n            i++;\n        }\n        return pref.toString();\n    }\n\n    \n    public String longestCommonPrefix2(String[] strs) {\n        if (strs == null) return null;\n        if (strs.length == 0) return \"\";\n        if (strs.length == 1) return strs[0];\n\n        String word = strs[0];\n        int prefixLength = word.length();\n\n        for (int i = 1; i < strs.length; ++i) {\n            String nextWord = strs[i];\n            prefixLength = Math.min(prefixLength, nextWord.length());\n            for (int j = 0; j < prefixLength; ++j)\n                if (word.charAt(j) != nextWord.charAt(j)) {\n                    prefixLength = j;\n                    break;\n                }\n        }\n\n        return word.substring(0, prefixLength);\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class HIndex2Test {\n\n    @DataProvider(name = \"examples\")\n    public Object[][] getExamples() {\n        return new Object[][]{\n                new Object[]{new int[0], 0},\n                new Object[]{new int[]{1}, 1},\n                new Object[]{new int[]{1, 2, 3, 4, 5}, 3},\n                new Object[]{new int[]{5, 6, 7, 8, 9}, 5},\n                new Object[]{new int[]{0, 0, 0, 0, 0}, 0}\n        };\n    }\n\n    @Test(dataProvider = \"examples\")\n    public void testHIndex(int[] input, int output) {\n        HIndex2 h = new HIndex2();\n        Assert.assertEquals(h.hIndex(input), output);\n    }\n\n    @Test(dataProvider = \"examples\")\n    public void testHIndex2(int[] input, int output) {\n        HIndex2 h = new HIndex2();\n        Assert.assertEquals(h.hIndex2(input), output);\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if(matrix.length==0)\n            return 0;\n        int M=matrix.length;\n        int N=matrix[0].length;\n            \n        int[] prevRow = new int[N];\n        int[] currRow = new int[N];\n        int max_size=0;\n\n        for(int i=0;i<M;i++){\n            for(int j=0;j<N;j++)\n            \tcurrRow[j] = matrix[i][j]=='1'?prevRow[j]+1:0;\n\n        \tmax_size= Math.max(largestRectangleArea(currRow),max_size);\n        \tprevRow = currRow;\n        \tcurrRow = new int[N];\n        }\n        return max_size;        \n    }\n\n\t public int largestRectangleArea(int[] height) {\n\t        Stack<Pair> stack = new Stack<Pair>();\n\t        int max_area=0;\n\t        int pos=0;\n\n\t        for(pos=0;pos<height.length;pos++){\n\t            int start = pos;\n\t        \twhile(true){\n\t        \t\tif(stack.empty() || height[pos]>stack.peek().height)\n\t        \t\t\tstack.push(new Pair(height[pos],start));\n\t        \t\telse if(!stack.empty() && height[pos]<stack.peek().height){\n\t        \t\t\tmax_area = Math.max(max_area,stack.peek().height*(pos-stack.peek().start));\n\t        \t\t\tstart = stack.pop().start;\n\t        \t\t\tcontinue;\n\t        \t\t}\n\t        \t\tbreak;\n\t        \t}\n\n\t        }\n\n\t        while(!stack.empty()){\n\t        \tPair p = stack.pop();\n\t        \tmax_area = Math.max(max_area,p.height*(pos-p.start));//pos=height.length\n\t        }\n\t        return max_area;\n\n\t    }\n\n\t    private class Pair{\n\t    \tpublic int height;\n\t    \tpublic int start;\n\t    \tpublic Pair(int height,int start){\n\t    \t\tthis.height = height;\n\t    \t\tthis.start = start;\n\t    \t}\n\t    }\n\n}\n\n\n\n", "nl": "azheanda"}
{"code": "public class Solution {\n    public int climbStairs(int n) {\n        if(n==0)\n            return 0;\n        else\n            return climbStairs(0,n);\n        \n    }\n    \n    public int climbStairs(int level,int n){\n        if(level> n)\n            return 0;\n        else if(level==n)\n            return 1;\n        else \n            return climbStairs(level+1,n)+climbStairs(level+2,n);\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class FindMinimumInRotatedSortedArray \n{\n    public int findMin( int[] nums ) \n    {\n    \tif ( nums.length == 0 )\n    \t{\n    \t\tthrow new IllegalArgumentException(\"\");\n    \t}\n    \t\n        int start = 0;\n        int end = nums.length - 1;\n        while ( start + 1 < end )\n        {\n        \tint mid = ( end - start ) / 2 + start;\n        \tif ( nums[mid] < nums[end] )\n        \t{\n        \t\tend = mid;\n        \t}\n        \telse\n        \t{\n        \t\tstart = mid;\n        \t}        \t\n        }\n        if ( nums[start] < nums[end] )\n        {\n        \treturn nums[start];\n        }\n        else\n        {\n        \treturn nums[end];\n        }\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class TwoSum3 {\n    public int[] twoSum(int[] numbers, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < numbers.length; i++) {\n            int x = numbers[i];\n            if (map.containsKey(target - x)) {\n                int[] res = {map.get(target - x) + 1, i};\n                return res;\n            }\n            map.put(x, i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] S) {\n        return subsetsWithDup_2(S);\n    }\n    public List<List<Integer>> subsetsWithDup_1(int[] S) {\n        Arrays.sort(S);\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> path = new ArrayList<Integer>();\n        subsetsRe(S, 0, path, res);\n        return res;\n    }\n    void subsetsRe(int[] S, int start, List<Integer> path, List<List<Integer>> res) {\n        List<Integer> sub = new ArrayList<Integer>(path);\n        res.add(sub);\n        for (int i = start; i < S.length; ++i) {\n            if (i != start && S[i] == S[i-1]) continue;\n            path.add(S[i]);\n            subsetsRe(S, i + 1, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n    public List<List<Integer>> subsetsWithDup_2(int[] S) {\n        Arrays.sort(S);\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        res.add(new ArrayList<Integer>());\n        int presz = 0;\n        for (int i = 0; i < S.length; ++i) {\n            int sz = res.size();\n            for (int j = 0; j < sz; ++j) {\n                if (i == 0 || S[i] != S[i-1] || j >= presz) {\n                    List<Integer> path = new ArrayList<Integer>(res.get(j));\n                    path.add(S[i]);\n                    res.add(path);\n                }\n            }\n            presz = sz;\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class MinimumDepthofBinaryTree2 {\n\tpublic int minDepth(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn 0;\n\t\tif (root.left == null && root.right == null)\n\t\t\treturn 1;\n\t\tif (root.left == null)\n\t\t\treturn 1 + minDepth(root.right);\n\t\telse if (root.right == null)\n\t\t\treturn 1 + minDepth(root.left);\n\t\telse\n\t\t\treturn 1 + Math.min(minDepth(root.left), minDepth(root.right));\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public String addBinary(String a, String b) {\n        return decimalToBinary(binaryToDecimal(a)+binaryToDecimal(b));\n    }\n    \n    public long binaryToDecimal(String binary){\n        long deci =0;\n        for(int i=binary.length()-1;i>=0;i--)\n            if(binary.charAt(i)=='1')\n                deci += Math.pow(2,binary.length()-1-i);\n        return deci;\n    }\n    \n    public String decimalToBinary(long deci){\n        long leftover = deci;\n        String binary = \"\";\n        if(leftover==0)\n            return \"0\";\n        while(leftover>0){\n            long currentbit = leftover%2;\n            binary = currentbit+binary;\n            leftover = leftover/2;\n        }\n        return binary;\n    }\n}", "nl": "azheanda"}
{"code": "public class TwoSum {\n\n  class NumIndex {\n    int i, e;\n\n    NumIndex(int i, int e) {\n      this.i = i;\n      this.e = e;\n    }\n  }\n\n  public static void main(String[] args) {\n    int[] nums = {3, 2, 4};\n    int[] ans = new TwoSum().twoSum(nums, 6);\n    for (int i : ans) System.out.println(i);\n  }\n\n  public int[] twoSum(int[] nums, int target) {\n    List<NumIndex> list = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n      NumIndex n = new NumIndex(i, nums[i]);\n      list.add(n);\n    }\n    list.sort((o1, o2) -> Integer.compare(o1.e, o2.e));\n\n    int[] ans = new int[2];\n    for (int i = 0, j = nums.length - 1; i < j; ) {\n      NumIndex numi = list.get(i);\n      NumIndex numj = list.get(j);\n      int sum = numi.e + numj.e;\n      if (sum == target) {\n        ans[0] = numi.i;\n        ans[1] = numj.i;\n        return ans;\n      } else if (sum > target) {\n        j--;\n      } else i++;\n    }\n    return ans;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "class BestTimetoBuyandSellStock_shuna {\n\n    public static int maxProfit(int[] prices) {\n        if (prices == null || prices.length < 2) {\n            return 0;\n        }\n        int max = 0;\n        int minPrice = prices[0];\n        for (int i = 1; i < prices.length; i++) {\n            minPrice = Math.min(minPrice, prices[i]);\n            max = Math.max(max, prices[i] - minPrice);\n        }\n        return max;\n    }\n\n    public static void main(String arg[]) {\n        int[] prices = {2, 5, 8, 9, 1, 6};\n        System.out.print(maxProfit(prices));\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class TwoSum {\n  public class Num {\n    private int value;\n    private int index;\n\n    public Num(int value, int index) {\n      super();\n      this.value = value;\n      this.index = index;\n    }\n\n    public int getIndex() {\n      return index;\n    }\n\n    public void setIndex(int index) {\n      this.index = index;\n    }\n\n    public int getValue() {\n      return value;\n    }\n\n    public void setValue(int value) {\n      this.value = value;\n    }\n  }\n\n  public int[] twoSum(int[] numbers, int target) {\n    Num[] newArray = new Num[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n      newArray[i] = new Num(numbers[i], i);\n    }\n    Arrays.sort(\n        newArray,\n        new Comparator<Num>() {\n          public int compare(Num n1, Num n2) {\n            if (n1.getValue() == n2.getValue()) return 0;\n            if (n1.getValue() > n2.getValue()) return 1;\n            return -1;\n          }\n        });\n    int[] result = new int[2];\n    int i = 0, j = numbers.length - 1;\n    while (i < j) {\n      int tmp = newArray[i].getValue() + newArray[j].getValue();\n      if (tmp == target) {\n        result[0] = Math.min(newArray[i].getIndex() + 1, newArray[j].getIndex() + 1);\n        result[1] = Math.max(newArray[i].getIndex() + 1, newArray[j].getIndex() + 1);\n        break;\n      } else if (tmp > target) {\n        j--;\n      } else {\n        i++;\n      }\n    }\n    return result;\n  }\n}\n", "nl": "mengli"}
{"code": "public class TwoSum {\n\n    public class Solution {\n        public int[] twoSum(final int[] numbers, int target) {\n            List<Integer> pos = new ArrayList<Integer>();\n            for (int i = 0; i < numbers.length; i++) {\n                pos.add(i);\n            }\n            Collections.sort(pos, new Comparator<Integer>() {\n                @Override\n                public int compare(Integer o1, Integer o2) {\n                    return numbers[o1] - numbers[o2];\n                }\n            });\n\n            int i = 0;\n            int j = numbers.length - 1;\n            while (i < j) {\n                int sum = numbers[pos.get(i)] + numbers[pos.get(j)];\n                if (sum < target) {\n                    i++;\n                } else if (sum > target) {\n                    j--;\n                } else {\n                    int[] ans = new int[2];\n                    ans[0] = Math.min(pos.get(i), pos.get(j)) + 1;\n                    ans[1] = Math.max(pos.get(i), pos.get(j)) + 1;\n                    return ans;\n                }\n            }\n            return null;\n        }\n    }\n\n    public static class UnitTest {\n        @Test\n        public void test() {\n            new TwoSum().new Solution().twoSum(new int[] { 5, 75, 25 }, 100);\n        }\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode curr = dummy;\n        ListNode node1 = null;\n        ListNode node2 = null;\n        \n        while(curr.next!=null && curr.next.next!=null){\n            node1 = curr.next;            \n            node2 = node1.next;\n            ListNode next =node2.next;            \n            curr.next = node2;\n            node2.next = node1;\n            node1.next = next;            \n            curr=node1;\n        }\n        return dummy.next;\n    }\n}", "nl": "azheanda"}
{"code": "public class CourseSchedule2 {\n\n  \n  private int currentLabel;\n\n  public int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] inDegrees = new int[numCourses];\n    List<List<Integer>> adjacent = new ArrayList<>(numCourses);\n    initGraph(inDegrees, adjacent, prerequisites);\n    return bfs(inDegrees, adjacent);\n  }\n\n  \n  private void initGraph(int[] indegrees, List<List<Integer>> adjs, int[][] prerequisites) {\n    int n = indegrees.length;\n    while (n-- > 0) {\n      adjs.add(new ArrayList<>());\n    }\n    for (int[] edge : prerequisites) {\n      indegrees[edge[0]]++;\n      adjs.get(edge[1]).add(edge[0]);\n    }\n  }\n\n  \n  private int[] bfs(int[] inDegrees, List<List<Integer>> adjs) {\n    int[] order = new int[inDegrees.length];\n    Queue<Integer> queue = new ArrayDeque<>();\n    for (int i = 0; i < inDegrees.length; i++) {\n      if (inDegrees[i] == 0) { // Add all 0 in-degree node to queue first.\n        queue.offer(i);\n      }\n    }\n    int i = 0; // An index to result array.\n    while (!queue.isEmpty()) {\n      int from = queue.poll();\n      order[i++] = from; // Add it to result and update index.\n      for (int to : adjs.get(from)) { // Neighbors.\n        inDegrees[to]--;\n        if (inDegrees[to] == 0) { // If becomes 0, add to queue.\n          queue.offer(to);\n        }\n      }\n    }\n    return i == inDegrees.length ? order : new int[0];\n  }\n\n  \n  private int[] dfs(int n, List<List<Integer>> adjs) {\n    BitSet hasCycle = new BitSet(1); // Whether there is cycle in graph. Temporary mark.\n    BitSet visited = new BitSet(adjs.size()); // Whether a node is visited. Permanent mark.\n    BitSet onStack = new BitSet(adjs.size()); // Whether the node is on stack already during DFS.\n    Deque<Integer> stack = new ArrayDeque<>();\n    for (int i = adjs.size() - 1; i >= 0; i--) {\n      if (!visited.get(i) && !hasOrder(i, adjs, visited, onStack, stack)) {\n        return new int[0];\n      }\n    }\n    int[] res = new int[adjs.size()];\n    for (int i = 0; !stack.isEmpty(); i++) {\n      res[i] = stack.pop();\n    }\n    return res;\n  }\n\n  \n  private boolean hasOrder(int from, List<List<Integer>> adjs, BitSet visited, BitSet onStack, Deque<Integer> order) {\n    visited.set(from); // Mark from temporarily.\n    onStack.set(from);\n    for (int to : adjs.get(from)) {\n      if (visited.get(to) == false) { // Adjacent nodes should not be visited.\n        if (hasOrder(to, adjs, visited, onStack, order) == false) {\n          return false;\n        }\n      } else if (onStack.get(to) == true) { // Adjacent nodes should not be on stack.\n        return false;\n      }\n    }\n    onStack.clear(from);\n    order.push(from); // Push to stack finally.\n    return true;\n  }\n\n  \n  public int[] findOrder2(int numCourses, int[][] prerequisites) {\n    int[] inDegrees = new int[numCourses];\n    Map<Integer, Set<Integer>> graph = new HashMap<>();\n    for (int[] courses : prerequisites) {\n      if (!graph.containsKey(courses[1])) graph.put(courses[1], new HashSet<>());\n      graph.get(courses[1]).add(courses[0]);\n      inDegrees[courses[0]] += 1;\n    }\n\n    Queue<Integer> queue = new ArrayDeque<>();\n    for (int i = 0; i < numCourses; i++) {\n      if (inDegrees[i] == 0)\n        queue.offer(i);\n    }\n\n    int[] order = new int[numCourses];\n    int i = 0;\n    while (!queue.isEmpty()) {\n      int course = queue.poll();\n      order[i] = course;\n      i++;\n      if (graph.containsKey(course)) {\n        for (int neighbor : graph.get(course)) {\n          inDegrees[neighbor] -= 1;\n          if (inDegrees[neighbor] == 0) queue.offer(neighbor);\n        }\n      }\n    }\n    return i == numCourses ? order : new int[]{};\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class JumpGameII {\n  public int jump(int[] A) {\n    int ret = 0;\n    int last = 0;\n    int curr = 0;\n    for (int i = 0; i < A.length; ++i) {\n      if (i > last) {\n        last = curr;\n        ++ret;\n      }\n      curr = Math.max(curr, i + A[i]);\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class _78_subsets {\n    public static void main(String[] args) {\n        List<List<Integer>> subsets = subsets(new int[]{1, 2, 3});\n        for (int i = 0; i < subsets.size(); i++) {\n            Util.printList(subsets.get(i));\n        }\n        System.out.println(\"------------\");\n        List<List<Integer>> subsets2 = subsets2(new int[]{1, 2, 3});\n        for (int i = 0; i < subsets2.size(); i++) {\n            Util.printList(subsets2.get(i));\n        }\n    }\n\n    \n    public static List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> item = new ArrayList<>();\n        result.add(item);\n        generate(nums, 0, result, item);\n        return result;\n    }\n\n    private static void generate(int[] nums,\n                                 int index,\n                                 List<List<Integer>> result,\n                                 List<Integer> item) {\n        if (index >= nums.length) {\n            return;\n        }\n        item.add(nums[index]);\n        result.add(new ArrayList<>(item));\n        generate(nums, index + 1, result, item);\n        item.remove(new Integer(nums[index]));\n        generate(nums, index + 1, result, item);\n    }\n\n    \n    public static List<List<Integer>> subsets2(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 0; i < 1 << nums.length; i++) {\n            List<Integer> item = new ArrayList<>();\n            for (int j = 0; j < nums.length; j++) {\n                if ((i & (1 << j)) != 0) {\n                    item.add(nums[j]);\n                }\n            }\n            result.add(item);\n        }\n        return result;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Solution {\n    \n    public int canCompleteCircuit(int[] gas, int[] cost) {\n    \tif (gas == null || cost == null || gas.length == 0 || cost.length == 0) {\n    \t\treturn -1;\n    \t}\n    \tint start = 0;\n    \tint remain = 0;\n    \tint total = 0;\n    \tfor (int i = 0; i < gas.length; i++) {\n    \t\tremain += gas[i] - cost[i];\n    \t\tif (remain < 0) {\n    \t\t\tremain = 0;\n    \t\t\tstart = i + 1;\n    \t\t} \n    \t\ttotal += gas[i] - cost[i];\n    \t}\n    \tif (total < 0) {\n    \t\treturn -1;\n    \t}\n    \treturn start;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class Permutations \n{\n    public List<List<Integer>> permute( int[] nums ) \n    {\n    \tList<List<Integer>> allPerms = new LinkedList<>();\n    \tLinkedList<Integer> onePerm = new LinkedList<>();\n    \tboolean[] isUsed = new boolean[nums.length];\n    \tgeneratePermutation( allPerms, onePerm, nums, isUsed );    \t\n    \treturn allPerms;\n    }\n    \n    public void generatePermutation( List<List<Integer>> allPerms, LinkedList<Integer> onePerm, int[] nums, boolean[] isUsed )\n    {\n    \tif ( onePerm.size() == nums.length )\n    \t{\n    \t\tallPerms.add( new LinkedList<>( onePerm ) );\n    \t\treturn;\n    \t}\n    \t\n    \tfor ( int i = 0; i < nums.length; i++ )\n    \t{\n    \t\tif ( !isUsed[i] )\n    \t\t{\n    \t\t\tisUsed[i] = true;\n    \t\t\tonePerm.addLast( nums[i] );\n    \t\t\tthis.generatePermutation( allPerms, onePerm, nums, isUsed );\n    \t\t\tonePerm.removeLast();\n    \t\t\tisUsed[i] = false;\n    \t\t}\n    \t}\n    }\n    \n    public static void main( String[] args )\n    {\n    \t\n    }\n    \n    @Test\n    public void test()\n    {\n    \tSystem.out.println( permute( new int[]{ 1, 2, 3 } ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "class CombinationSum {\n\n  \n  public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    if (candidates == null || candidates.length == 0) {\n      return Collections.emptyList();\n    }\n    final List<List<Integer>> res = new ArrayList<>();\n    Arrays.sort(candidates);\n    helper(candidates, target, 0, new ArrayList<>(), res);\n    return res;\n  }\n\n  \n  private void helper(int[] candidates, int target, int pos, List<Integer> comb, List<List<Integer>> res) {\n    if (target == 0) {\n      res.add(new ArrayList<>(comb)); // dereference\n      return;\n    }\n    for (int i = pos; i < candidates.length; i++) {\n      int newTarget = target - candidates[i];\n      if (newTarget >= 0) {\n        comb.add(candidates[i]);\n        helper(candidates, newTarget, i, comb, res); // note i\n        comb.remove(comb.size() - 1);\n      } else {\n        break; // too big\n      }\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public double findMedianSortedArrays(int A[], int B[]) { \n        return findMedianHelper(A, B, Math.max(0, (A.length-B.length)/2), Math.min(A.length-1,(A.length+B.length)/2));// don't really understand this line\n    }\n\n    public double findMedianHelper(int A[], int B[], int l, int r) {\n        int m= A.length;\n        int n= B.length;\n        \n        if (l > r) \n            return findMedianHelper2(B, A, Math.max(0, (n-m)/2), Math.min(n-1, (m+n)/2));\n        int i = (l+r)/2;\n        int j = (m+n)/2-i;\n\n        assert(i >= 0 && i <= m && j >= 0 && j <= n);\n        int Ai_1 = ((i == 0) ? Integer.MIN_VALUE : A[i-1]);\n        int Bj_1 = ((j == 0) ? Integer.MIN_VALUE : B[j-1]);\n        int Ai = ((i == m) ? Integer.MAX_VALUE : A[i]);\n        int Bj = ((j == n) ? Integer.MAX_VALUE : B[j]);\n\n        if (Ai < Bj_1) return findMedianHelper2(A,B,i+1,r);\n        if (Ai > Bj) return findMedianHelper2(A,B,l,i-1);\n\n        if (((m+n) % 2) == 1) return A[i];\n        return (Math.max(Ai_1, Bj_1) + Ai) / 2.0;\n    }\n\n\n}\n", "nl": "azheanda"}
{"code": "public class Solution {\n    public List<String[]> solveNQueens(int n) {\n        List<String[]> res = new ArrayList<String[]>();\n        List<char[]> sol = new ArrayList<char[]>();\n        solveNQueensRe(n, 0, 0, 0, sol, res);\n        return res;\n    }\n    public void solveNQueensRe(int n, int row, int ld, int rd, List<char[]> sol, List<String[]> res) {\n        if (row == (1<<n) -1 ) {\n            String[] temp = new String[n];\n            for (int i = 0; i < n; ++i) \n                temp[i] = String.valueOf(sol.get(i)); \n            res.add(temp);\n            return;\n        }\n        int avail = ~(row | ld | rd);\n        for (int i = n -1; i >= 0; --i) {\n            int pos = 1 << i;\n            if ((int)(avail & pos) != 0) {\n                char[] str = new char[n];\n                Arrays.fill(str, '.');\n                str[i] = 'Q';\n                sol.add(str);\n                solveNQueensRe(n, row | pos, (ld|pos)<<1, (rd|pos)>>1, sol, res);\n                sol.remove(sol.size()-1);\n            }\n        }\n    }  \n}", "nl": "leetcoders"}
{"code": "public class MaximumSubarray3 {\n\tpublic int maxSubArray(int[] A) {\n\t\treturn divide(A, 0, A.length - 1);\n\t}\n\tpublic int divide(int A[], int low, int high) {\n\t\tif (low == high)\n\t\t\treturn A[low];\n\t\tif (low == high - 1)\n\t\t\treturn Math.max(A[low] + A[high], Math.max(A[low], A[high]));\n\t\tint mid = (low + high) / 2;\n\t\tint lmax = divide(A, low, mid - 1);\n\t\tint rmax = divide(A, mid + 1, high);\n\t\tint mmax = A[mid];\n\t\tint tmp = mmax;\n\t\tfor (int i = mid - 1; i >= low; i--) {\n\t\t\ttmp += A[i];\n\t\t\tif (tmp > mmax)\n\t\t\t\tmmax = tmp;\n\t\t}\n\t\ttmp = mmax;\n\t\tfor (int i = mid + 1; i <= high; i++) {\n\t\t\ttmp += A[i];\n\t\t\tif (tmp > mmax)\n\t\t\t\tmmax = tmp;\n\t\t}\n\t\treturn Math.max(mmax, Math.max(lmax, rmax));\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MergeKSortedLists \n{\n    public ListNode mergeKLists(ListNode[] lists) \n    {\n    \tif ( lists.length == 0 )\n    \t{\n    \t\treturn null;\n    \t}\n\n    \tPriorityQueue<ListNode> minQueue = new PriorityQueue<>( ( o1, o2 ) -> ( o1.val - o2.val ) );\n    \tfor ( ListNode listHead : lists )\n    \t{\n    \t\tif ( listHead != null )\n    \t\t{\n    \t\t\tminQueue.offer( listHead );\n    \t\t}\n    \t}\n    \t\n    \tListNode resultHead = new ListNode( 0 );    \t\n    \tListNode resultTail = resultHead;\n    \twhile ( !minQueue.isEmpty( ) )\n    \t{\n    \t\tListNode qHead = minQueue.remove( );\n    \t\tif ( qHead.next != null )\n    \t\t{\n    \t\t\tminQueue.add( qHead.next );\n    \t\t}\n    \t\tresultTail.next = qHead;\n    \t\tresultTail = qHead;\n    \t}\n    \t\n    \treturn resultHead.next;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class CourseSchedule {\n  private Map<Integer, List<Integer>> graph;\n  private BitSet visited;\n  private Queue<Integer> toposorted;\n\n  public static void main(String[] args) throws Exception {\n    int[][] pre = {{1, 0}};\n    System.out.println(new CourseSchedule().canFinish(2, pre));\n  }\n\n  public boolean canFinish(int numCourses, int[][] prerequisites) {\n    graph = new HashMap<>();\n    visited = new BitSet();\n    toposorted = new ArrayDeque<>();\n    for (int[] children : prerequisites) {\n      graph.putIfAbsent(children[0], new ArrayList<>());\n      graph.get(children[0]).add(children[1]);\n    }\n    graph.keySet().stream().filter(v -> !visited.get(v)).forEach(this::dfs);\n\n    visited.clear();\n\n    while (!toposorted.isEmpty()) {\n      int v = toposorted.poll();\n      if (visited.get(v)) return false;\n      relax(v);\n    }\n    return true;\n  }\n\n  \n  private void relax(int v) {\n    visited.set(v);\n    List<Integer> children = graph.get(v);\n    if (children != null) {\n      for (int c : children) visited.set(c);\n    }\n  }\n\n  \n  private void dfs(int v) {\n    visited.set(v);\n    List<Integer> children = graph.get(v);\n    if (children != null) {\n      for (int c : children) if (!visited.get(c)) dfs(c);\n    }\n    toposorted.offer(v);\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class ValidNumber\n{\n    public boolean isNumber( String s )\n    {\n        int left = 0;\n        while ( left < s.length() && Character.isWhitespace( s.charAt( left ) ) )\n        {\n        \tleft++;\n        }\n        if ( left >= s.length() )\n        {\n        \treturn false;\n        }\n        int right = s.length() - 1;\n        while ( right >= left && Character.isWhitespace( s.charAt( right ) ) )\n        {\n        \tright--;\n        }\n        if ( s.charAt( left ) == '+' || s.charAt( left ) == '-' )\n        {\n        \tleft++;\n        }\n        \n        boolean isDigit = false;\n        boolean isDot = false;\n        boolean isExp = false;\n        while ( left <= right )\n        {\n        \tchar c = s.charAt( left );\n        \tif ( Character.isDigit( c ) )\n        \t{\n        \t\tisDigit = true;\n        \t}\n        \telse if ( c == '.' )\n        \t{\n        \t\tif ( isExp || isDot )\n        \t\t{\n        \t\t\treturn false;\n        \t\t}\n        \t\tisDot = true;\n        \t}\n        \telse if ( c == 'e' )\n        \t{\n        \t\tif ( isExp || !isDigit )\n        \t\t{\n        \t\t\treturn false;\n        \t\t}\n        \t\tisExp = true;\n        \t\tisDigit = false;\n        \t}\n        \telse if ( c == '+' || c == '-' )\n        \t{\n        \t\tif ( s.charAt( left - 1 ) != 'e' )\n        \t\t{\n        \t\t\treturn false;\n        \t\t}\n        \t}\n        \telse\n        \t{\n        \t\treturn false;\n        \t}\n        \tleft++;\n        }\n        return isDigit;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> rst = new ArrayList<>();\n        if (root == null) {\n            return rst;\n        }\n        if (root.left == null && root.right == null) {\n            rst.add(root.val);\n            return rst;\n        }\n        List<Integer> left = inorderTraversal(root.left);\n        List<Integer> right = inorderTraversal(root.right);\n        \n        rst.addAll(left);\n        rst.add(root.val);\n        rst.addAll(right);\n        return rst;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    \n    public boolean isPalindrome(String s) {\n    \tif (s == null || s.length() == 0) {\n    \t\treturn true;\n    \t}\n    \tint start = 0;\n    \tint end = s.length() - 1;\n    \ts = s.toLowerCase();\n    \twhile (start < end) {\n    \t\twhile (start < s.length() && \n    \t\t\t(s.charAt(start) < '0' || (s.charAt(start) > '9' && s.charAt(start) < 'a') || s.charAt(start) > 'z') ) {\n    \t\t\tstart++;\n    \t\t}\n    \t\twhile (end >= 0 && \n    \t\t\t(s.charAt(end) < '0' || (s.charAt(end) > '9' && s.charAt(end) < 'a') || s.charAt(end) > 'z')) {\n    \t\t\tend--;\n    \t\t}\n    \t\tif (start < end && s.charAt(start) != s.charAt(end)) {\n    \t\t\treturn false;\n    \t\t}\n    \t\tstart++;\n    \t\tend--;\n    \t}\n    \treturn true;\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class BinaryTreePaths\n{\n    public List<String> binaryTreePaths(TreeNode root )\n    {\n        return new ArrayList<>();\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int begin=0;\n        int end=nums.length-1;\n        int a=(begin+end)/2;\n        int[] answer=new int[2];\n        while (nums[a]!=target) {\n            if(begin==end){\n                answer[0]=-1;\n                answer[1]=-1;\n                return answer;\n            }\n        if (nums[a]>target) {\n                if (a==end) {\n                    end--;\n                }else {\n                    end=a;\n                }\n                \n            }else {\n                if (a==begin) {\n                    begin++;\n                }else {\n                    begin=a;\n                }\n                \n            }\n            a=(begin+end)/2;\n        }\n        int bb=0;\n        int be=a;\n        int ba=(bb+be)/2;\n            while (!(nums[ba]==target&&(ba==0||nums[ba-1]!=target))) {\n            if (nums[ba]>=target) {\n                if (ba==be) {\n                    be--;\n                }else {\n                    be=ba;\n                }\n            }else {\n                if (ba==bb) {\n                    bb++;\n                }else {\n                    bb=ba;\n                }\n            }\n            ba=(bb+be)/2;\n        }\n        int eb=a;\n        int ee=nums.length-1;\n        int ea=(eb+ee)/2;\nwhile (!(nums[ea]==target&&(ea==nums.length-1||nums[ea+1]!=target))) {\n            if (nums[ea]<=target) {\n                if (ea==eb) {\n                    eb++;\n                }else {\n                    eb=ea;\n                }\n            }else {\n                if (ea==ee) {\n                    ee--;\n                }else {\n                    ee=ea;\n                }\n                }\n            ea=(eb+ee)/2;\n        }\n             answer[0]=ba;\n                answer[1]=ea;\n        return answer;\n    }\n}", "nl": "corpsepiges"}
{"code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int index = 1;\n        for (int i = 2; i < nums.length; i++) {\n            if (nums[i] != nums[index] || (nums[i] == nums[index] && nums[i] != nums[index - 1])) {\n                index++;\n                nums[index] = nums[i];\n            }\n        }\n        return index + 1;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class TwoSum \n{\n    public int[] twoSum( int[] nums, int target )\n    {\n        return new int[0];\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class MinimumWindowSubstring {\n    public static String minWindow(String s, String t) {\n        if(s.length() == 0 || t.length() ==0 || s.length() < t.length()) {\n            return \"\";\n        }\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n        for(char c : t.toCharArray()) {\n            map.put(c, (map.containsKey(c) ? map.get(c) : 0) + 1);\n        }\n        int left = 0;\n        int count = 0;\n        int minStart = 0;\n        int minLength = s.length() + 1;\n        for(int right = 0; right < s.length(); right++) {\n            if(map.containsKey(s.charAt(right))) {\n                map.put(s.charAt(right), map.get(s.charAt(right)) - 1);\n                if(map.get(s.charAt(right)) >= 0) { \n                    count++;\n                }\n                while(count == t.length()) {\n                    if((right - left + 1) < minLength) {\n                        minStart = left;\n                        minLength = right - left + 1;\n                    }\n                    if(map.containsKey(s.charAt(left))) {\n                        map.put(s.charAt(left), map.get(s.charAt(left)) + 1 );\n                        if(map.get(s.charAt(left)) > 0) {\n                            count--;\n                        }\n                    }\n                    left++;\n                }\n            }\n        }\n        if(minLength == s.length()+1) {\n            return \"\";\n        }\n        return s.substring(minStart, minStart + minLength);\n    }\n\n    public static void main(String[] args) {\n        System.out.print(minWindow(\"ADOBECODEBANC\", \"ABC\"));\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int firstMissingPositive_1(int[] A) {\n        for(int i=0;i<A.length;i++)\n            if(A[i]<=0) A[i]=A.length+2;\n        for(int i=0;i<A.length;i++)\n        {\n            if(Math.abs(A[i])<A.length+1)\n            {\n                int cur = Math.abs(A[i])-1;\n                A[cur] = -Math.abs(A[cur]);\n            }\n        }\n        for(int i=0;i<A.length;i++)\n            if(A[i]>0) return i+1;\n        return A.length+1;\n    }\n    int firstMissingPositive_2(int A[], int n) {\n        for(int i=0;i<n;i++){\n            while(A[i]>=1&&A[i]<=n&&A[i]!=A[A[i]-1]) {\n                int tmp = A[i];\n                A[i] = A[tmp - 1];\n                A[tmp - 1] = tmp;\n            }\n        }\n        int i=0;\n        for(i=0;i<n;i++){\n            if(A[i]!=i+1) break;\n        }\n        return i+1;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public double findMedianSortedArrays_1(int A[], int B[]) {\n        int m = A.length, n = B.length;\n        int total = n + m, m1=0, m2=0, i=0, j=0;\n        for (int k = 1; k <= total/2 + 1; ++k) {\n            int a = (i==m) ? Integer.MAX_VALUE : A[i];\n            int b = (j==n) ? Integer.MAX_VALUE : B[j];\n            m1 = m2;\n            m2 = Math.min(a,b);\n            if (a > b) ++j;\n            else ++i;\n        }\n        if ((total&1) == 1) return m2;\n        else return (m1+m2)/2.0;\n    }\n    public double findMedianSortedArrays_2(int A[], int B[]) {\n        int m = A.length, n = B.length;\n        int total = m + n;\n        int k = total / 2;\n        if ((total&1) == 1) return findKth(A,B,k+1,0,m-1,0,n-1);\n        else return (findKth(A,B,k,0,m-1,0,n-1)+findKth(A,B,k+1,0,m-1,0,n-1))/2.0;\n    }\n    public double findKth(int A[], int B[], int k, int astart, int aend, int bstart, int bend) {\n        int alen = aend - astart + 1;\n        int blen = bend - bstart + 1;\n        if (alen > blen) return findKth(B,A,k, bstart, bend, astart, aend);\n        if (alen == 0) return B[bstart + k - 1];\n        if (k == 1) return Math.min(A[astart],B[bstart]);\n        int sa = Math.min(alen, k/2), sb = k- sa;\n        if (A[astart+sa-1] == B[bstart+sb-1]) return A[astart+sa-1];\n        else if (A[astart+sa-1] > B[bstart+sb-1]) return findKth(A,B,k - sb,astart,aend,bstart+sb,bend);\n        else return findKth(A,B,k - sa,astart+sa,aend,bstart,bend);\n    }\n    \n}\n", "nl": "leetcoders"}
{"code": "public class Solution {\n    \n    public long houseRobber(int[] A) {\n    \tif (A == null || A.length == 0) {\n    \t\treturn 0;\n    \t} else if (A.length == 1) {\n    \t    return A[0];\n    \t}\n    \tint n = A.length; \n    \tlong[] dp = new long[n];\n    \tdp[0] = A[0];\n    \tdp[1] = Math.max(A[0], A[1]);\n\n    \tfor (int i = 2; i < n; i++) {\n    \t\tdp[i] = Math.max(dp[i-1], dp[i-2] + A[i]);\n    \t}\n\n    \treturn dp[n - 1];\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public UndirectedGraphNode cloneGraph_1(UndirectedGraphNode node) {\n        HashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n        return cloneGraphRe(node, map);\n    }\n    public UndirectedGraphNode cloneGraphRe(UndirectedGraphNode node, HashMap<UndirectedGraphNode, UndirectedGraphNode> map) {\n        if (node == null) return null;\n        if (map.containsKey(node) == true) {\n            return map.get(node);\n        }\n        UndirectedGraphNode newnode = new UndirectedGraphNode(node.label);\n        map.put(node, newnode);\n        for (UndirectedGraphNode cur : node.neighbors) {\n            newnode.neighbors.add(cloneGraphRe(cur, map));\n        }\n        return newnode;\n    }\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        HashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n        Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n        if (node == null) return null;\n        queue.offer(node);\n        map.put(node, new UndirectedGraphNode(node.label));\n        while (queue.isEmpty() == false) {\n            UndirectedGraphNode cur = queue.poll();\n            for (UndirectedGraphNode neighbor : cur.neighbors) {\n                if (map.containsKey(neighbor) == false) {\n                    UndirectedGraphNode newnode = new UndirectedGraphNode(neighbor.label);\n                    map.put(neighbor, newnode);\n                    queue.offer(neighbor);\n                }\n                map.get(cur).neighbors.add(map.get(neighbor));\n            }\n        }\n        return map.get(node);\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    \n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int start = 0;\n        int end = row * col - 1;\n        int mid;\n\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            int num = matrix[mid/col][mid%col];\n            if (target == num) {\n                return true;\n            } else if (num < target) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n\n        return (matrix[start/col][start%col] == target || matrix[end/col][end%col] == target);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public boolean exist(char[][] board, String word) {\n        if (word==null||word.length()==0||board==null||board.length==0) {\n            return false;\n        }\n        char[] ch=word.toCharArray();\n        int length=ch.length;\n        int m=board.length;\n        int n=board[0].length;\n        boolean[][] flag=new boolean[m][n];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[i].length; j++) {\n                if (board[i][j]==ch[0]&&f(board,ch,0,i,j,length,m,n,flag)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public boolean f(char[][] board,char[] ch,int level,int x,int y,int length,int m,int n,boolean[][] flag){\n        if (level==length) {\n            return true;\n        }\n        if (x<0||x>=m||y<0||y>=n||flag[x][y]||board[x][y]!=ch[level]) {\n            return false;\n        }\n        flag[x][y]=true;\n        if (f(board,ch,level+1,x+1,y,length,m,n,flag)) {\n            return true;\n        }\n        if (f(board,ch,level+1,x-1,y,length,m,n,flag)) {\n            return true;\n        }\n        if (f(board,ch,level+1,x,y+1,length,m,n,flag)) {\n            return true;\n        }\n        if (f(board,ch,level+1,x,y-1,length,m,n,flag)) {\n            return true;\n        }\n        flag[x][y]=false;\n        return false;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> threeSum(int[] numbers) {\n        ArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();\n        if (numbers == null && numbers.length <= 2) {// Length at least >= 3\n            return rst;\n        }\n        Arrays.sort(numbers);//Sort in order to handle duplicates\n        for (int i = numbers.length - 1; i >= 2; i--) {// i >=2 because at least 3 element in result; starting from end, ensures non-descending order\n            if (i < numbers.length - 1 && numbers[i] == numbers[i + 1]) {\n                continue;//The case of numbers[i + 1]: should have already covered all possibilities of the case numbers[i], so safe to skip\n            }\n            ArrayList<ArrayList<Integer>> twoSum = calTwoSum(numbers, i - 1, 0 - numbers[i]);//Pick the 3rd element numbers[i]\n            for (int j = 0; j < twoSum.size(); j++) {//Find two sum of rest-front elements. Cross add them with numbers[i]\n                twoSum.get(j).add(numbers[i]);\n            }\n            rst.addAll(twoSum);\n        }\n        return rst;\n    }\n    public ArrayList<ArrayList<Integer>> calTwoSum(int[] num, int end, int target) {\n        ArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();\n        int left = 0;\n        int right = end;\n        while (left < right) {\n            if (num[left] + num[right] == target) {\n                ArrayList<Integer> match = new ArrayList<Integer>();\n                match.add(num[left]);\n                match.add(num[right]);\n                rst.add(match);\n                left++;\n                right--;\n                while (left < right && num[left] == num[left - 1]) {\n                    left++;\n                }\n                while (left < right && num[right] == num[right + 1]) {\n                    right--;\n                }\n            } else if (num[left] + num[right] < target) {//Since int[] num is sorted: move L to right-side to get larger value.\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return rst;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class MajorityElement\n{\n    public int majorityElement( int[] nums )\n    {\n    \tif ( nums.length == 0 )\n    \t{\n    \t\tthrow new IllegalArgumentException(\"\");\n    \t}\n    \t\n    \tint candidate = nums[0];\n    \tint candidateFreq = 1;\n    \tfor ( int i = 1; i < nums.length; i++ )\n    \t{\n    \t\tif ( candidateFreq == 0 )\n    \t\t{\n    \t\t\tcandidate = nums[i];\n    \t\t\tcandidateFreq = 1;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tif ( candidate == nums[i] )\n    \t\t\t{\n    \t\t\t\tcandidateFreq++;\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tcandidateFreq--;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn candidate;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class _139_wordBreak {\n    public static void main(String[] args) {\n        _139_wordBreak wordBreak = new _139_wordBreak();\n        System.out.println(wordBreak.wordBreak(\"leetcode\", Arrays.asList(\"leet\", \"code\")));\n        System.out.println(wordBreak.wordBreak(\"applepenapple\", Arrays.asList(\"apple\", \"pen\")));\n        System.out.println(wordBreak.wordBreak(\"catsandog\", Arrays.asList(\"cats\", \"dog\", \"sand\", \"and\", \"cat\")));\n        System.out.println(wordBreak.wordBreak2(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\", Arrays.asList(\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\")));\n    }\n\n    \n    public boolean wordBreak(String s, List<String> wordDict) {\n        HashMap<String, Boolean> map = new HashMap<>();\n        for (int i = 0; i < wordDict.size(); i++) {\n            map.put(wordDict.get(i), true);\n        }\n        LinkedList<String> findList = new LinkedList<>();\n        boolean lastMatch = false;\n        int si = 0, ei = 1;\n        while (si < s.length()) {\n            if (ei > s.length()) {\n                if (lastMatch) break;   //\u7039\u5c7d\u53cf\u9356\u5f52\u53a4\u93b4\u612c\u59db\n                if (findList.size() == 0) break;  //\u7039\u5c7d\u53cf\u93c8\ue045\u58d8\u9352\n                ei = si + 1;\n                String lastStr = findList.removeLast();\n                si = si - lastStr.length();\n                continue;\n            }\n            String substring = s.substring(si, ei);\n            if (map.getOrDefault(substring, false)) {//\u9356\u5f52\u53a4\u6d93\u5a41\u7c21\n                si = ei;\n                ei++;\n                lastMatch = true;\n                findList.add(substring);\n            } else {\n                ei++;\n                lastMatch = false;\n            }\n        }\n\n        return lastMatch;\n    }\n\n    \n    public boolean wordBreak2(String s, List<String> wordDict) {\n        int n = s.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class SortList {\n    public ListNode sortList(ListNode head) {\n\t\tif (head == null || head.next == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tListNode fast = head;\n\t\tListNode slow = head;\n\n\t\twhile (fast.next != null) {\n\t\t\tfast = fast.next.next;\n\t\t\tif (fast == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tslow = slow.next;\n\t\t}\n\n\t\tListNode right = slow.next;\n\t\tslow.next = null;\n\n\t\tListNode left = sortList(head);\n\t\tright = sortList(right);\n\n\t\treturn merge(left, right);\n    }\n    \n    public ListNode merge(ListNode left, ListNode right) {\n    \tMergeTwoSortedLists helper = new MergeTwoSortedLists();\n    \treturn helper.mergeTwoLists(left, right);\n    }\n    \n    public void printList(ListNode node) {\n\t\twhile (node != null) {\n\t\t\tSystem.out.print(node.val + \"->\");\n\t\t\tnode = node.next;\n\t\t}\n\t\tSystem.out.println(\" \");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSortList slt = new SortList();\n\t\tListNode n1 = new ListNode(8);\n\t\tListNode n2 = new ListNode(5);\n\t\tListNode n3 = new ListNode(3);\n\t\tListNode n4 = new ListNode(4);\n\t\tn1.next = n2;\n\t\tn2.next = n3;\n\t\tn3.next = n4;\n\t\t\n\t\tSystem.out.println(\"Before sort:\");\n\t\tslt.printList(n1);\n\t\t\n\t\tListNode res = slt.sortList(n1);\n\t\tSystem.out.println(\"After sort:\");\n\t\tslt.printList(res);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode output = new ListNode(-1);\n        \n        while (head != null) {\n            final ListNode node = new ListNode(head.val);\n            if (output.next == null || node.val <= output.next.val) {\n                node.next = output.next;\n                output.next = node;\n            } else {\n                ListNode moveNode = output.next;\n                while(moveNode.next != null && node.val > moveNode.next.val) {\n                    moveNode = moveNode.next;\n                }\n                node.next = moveNode.next;\n                moveNode.next = node;\n            }\n            head = head.next;\n        }\n        \n        return output.next;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class SingleNumber2 {\n\n  public int singleNumber(int[] nums) {\n    int ones = 0, twos = 0;\n    for (int i = 0; i < nums.length; i++) {\n      ones = (ones ^ nums[i]) & ~twos;\n      twos = (twos ^ nums[i]) & ~ones;\n    }\n    return ones;\n  }\n\n}", "nl": "FreeTymeKiyan"}
{"code": "public class LengthofLastWord {\n\n    public class Solution {\n        public int lengthOfLastWord(String s) {\n            int i = s.length() - 1;\n            while (i >= 0 && s.charAt(i) == ' ') {\n                i--;\n            }\n            if (i < 0) {\n                return 0;\n            }\n            int len = 0;\n            while (i >= 0 && s.charAt(i) != ' ') {\n                len++;\n                i--;\n            }\n            return len;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class JumpGame {\n  \n  public static void main(String[] args) throws Exception {\n    int[] nums = {1, 2, 1, 0, 4};\n    System.out.println(new JumpGame().canJump(nums));\n  }\n\n  public boolean canJump(int[] nums) {\n    if (nums.length == 0) return false;\n    int min = nums.length - 1, max = nums.length - 1;\n    for (int i = nums.length - 2; i >= 0; i--) {\n      if ((nums[i] + i) >= min) min = i;\n    }\n    return (min == 0);\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class UniquePaths {\n\tpublic int uniquePaths(int m, int n) {\n\t\tif (m == 1 || n == 1)\n\t\t\treturn 1;\n\t\treturn uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int reverse(int x) {\n        long res = 0;\n        while (x != 0) {\n            res = res * 10 + Long.valueOf( x % 10 );\n            x = x / 10;\n        }\n        if (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) return 0;\n        return (int) res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int[] twoSum(int[] nums, int target) {\n    \tint[] rst = new int[2];\n        if (nums == null || nums.length <= 1) {\n        \treturn rst;\n        }\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; i++) {\n        \tint remaining = target - nums[i];\n        \tif (!map.containsKey(remaining)) {\n        \t\tmap.put(nums[i], i);\n        \t} else {\n        \t\trst[0] = map.get(remaining) + 1;\n        \t\trst[1] = i + 1;\n        \t\tbreak;\n        \t}\n        }\n        return rst;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class CourseSchedule3 {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        ArrayList[] graph = new ArrayList[numCourses];\n        for (int i = 0; i < numCourses; i++)\n            graph[i] = new ArrayList();\n\n        boolean[] visited = new boolean[numCourses];\n        for (int i = 0; i < prerequisites.length; i++) {\n            graph[prerequisites[i][1]].add(prerequisites[i][0]);\n        }\n\n        for (int i = 0; i < numCourses; i++) {\n            if (!dfs(graph, visited, i))\n                return false;\n        }\n        return true;\n    }\n\n    private boolean dfs(ArrayList[] graph, boolean[] visited, int course) {\n        if (visited[course])\n            return false;\n        else\n            visited[course] = true;\n\n        for (int i = 0; i < graph[course].size(); i++) {\n            if (!dfs(graph, visited, (int) graph[course].get(i)))\n                return false;\n        }\n        visited[course] = false;\n        return true;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int largestRectangleArea(int[] height) {\n        int[] area = new int[height.length];\n        int t=0;\n        Stack<Integer> stack = new Stack<Integer>();\n\n        for(int i=0;i<height.length;i++){\n          while(!stack.empty() && height[i]<=height[stack.peek()])\n                stack.pop();\n          \n          if(stack.empty())\n            t = -1;\n          else\n            t = stack.peek();\n\n          area[i] = i-t-1;\n          stack.push(i);\n        }\n\n        while(!stack.empty())\n          stack.pop();\n\n        for(int i=height.length-1;i>=0;i--){\n          while(!stack.empty() && height[i]<=height[stack.peek()])\n                stack.pop();\n          \n          if(stack.empty())\n            t = height.length;\n          else\n            t = stack.peek();\n\n          area[i] += t-i-1;\n          stack.push(i);\n        }\n\n        int max = 0;  \n        for (int i=0; i<area.length; i++)  {  \n            area[i] = height[i] * (area[i] + 1);  \n            if (area[i] > max)  \n              max = area[i];  \n        }  \n          \n        return max;  \n    }\n}\n ", "nl": "azheanda"}
{"code": "public class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> res = new ArrayList<String>();\n        dfs(s, new String(), 0, 0, res);\n        return res;\n    }\n    public void dfs(String s, String ip, int start, int step, List<String> res) {\n        if (step == 4 && start == s.length()) {\n            res.add(ip);\n        }\n        if (step == 4) return;\n        if(s.length()-start>(4-step)*3) return ;\n        if(s.length()-start<4-step) return ;\n        if (ip.length() != 0) ip+=\".\";\n        int num = 0;\n        for (int i = start; i < start + 3 && i < s.length(); ++i) {\n            num =  num*10 + s.charAt(i) - '0';\n            if (num > 255) break;\n            ip += s.charAt(i);\n            dfs(s, ip, i + 1, step + 1, res);\n            if (num == 0) break;\n        }\n    }\n}", "nl": "leetcoders"}
{"code": "public class WordLadder {\n\n  \npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n  if (wordList == null || wordList.size() == 0) {\n    return 0;\n  }\n\n  Set<String> dict = new HashSet<>(wordList);\n  Queue<String> queue = new ArrayDeque<>();\n  queue.add(beginWord);\n  dict.remove(beginWord); // Remove from set as visited.\n  int length = 0;\n\n  while (!queue.isEmpty()) {\n    length++;\n    for (int i = queue.size(); i > 0; i--) {\n      String word = queue.poll();\n      if (word.equals(endWord)) {\n        return length;\n      }\n      for (int j = 0; j < word.length(); j++) {\n        for (char c = 'a'; c <= 'z'; c++) { // Generate neighbors.\n          char[] chars = word.toCharArray();\n          if (chars[j] == c) { // Skip same character.\n            continue;\n          }\n          chars[j] = c;\n          String nextWord = new String(chars);\n          if (dict.contains(nextWord)) { // Valid transform.\n            queue.add(nextWord);\n            dict.remove(nextWord);\n          }\n        }\n      }\n    }\n\n  }\n  return 0; // No valid transformation, return 0.\n}\n\n  \n  public int ladderLengthB(String beginWord, String endWord, List<String> wordList) {\n    int pathLength = 2;\n\n    Set<String> start = new HashSet<>();\n    Set<String> end = new HashSet<>();\n    start.add(beginWord);\n    end.add(endWord);\n    Set<String> dict = new HashSet<>(wordList);\n    dict.remove(beginWord);\n    dict.remove(endWord);\n\n    while (!start.isEmpty()) {\n      if (start.size() > end.size()) {\n        Set<String> temp = start;\n        start = end;\n        end = temp;\n      }\n      Set<String> next = new HashSet<>();\n      for (String cur : start) {\n        char[] strArray = cur.toCharArray();\n        for (int i = 0; i < strArray.length; i++) {\n          char old = strArray[i];\n          for (char c = 'a'; c <= 'z'; c++) {\n            strArray[i] = c;\n            String str = String.valueOf(strArray);\n            if (end.contains(str)) {\n              return pathLength;\n            }\n            if (dict.contains(str)) {\n              next.add(str);\n              dict.remove(str);\n            }\n          }\n          strArray[i] = old;\n        }\n      }\n      start = next;\n      pathLength++;\n    }\n    return 0;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> combinationSum(int[] candidates, int target) {\n        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n        if(candidates.length==0)\n            return result;\n        \n        Arrays.sort(candidates);\n        \n        int size = target>candidates[candidates.length-1]? target+1:candidates[candidates.length-1]+1;\n        \n        Vector<ArrayList<ArrayList<Integer>>> dp = new Vector<ArrayList<ArrayList<Integer>>>(size);\n        for(int i=0;i<size;i++)\n            dp.add(new ArrayList<ArrayList<Integer>>());\n        for(int i=0;i<candidates.length;i++){\n            ArrayList<Integer> list = new ArrayList<Integer>();\n            list.add(candidates[i]);\n            dp.get(candidates[i]).add(list);\n        }\n        \n        \n        for(int j=candidates[0];j<dp.size();j++)\n            for(int i=candidates.length-1;i>=0;i--)\n                if(j-candidates[i]>=0 && dp.get(j-candidates[i])!=null)\n                    for(ArrayList<Integer> list : dp.get(j-candidates[i]))\n                        if(list.get(list.size()-1)<=candidates[i]){\n                            ArrayList<Integer> combo = new ArrayList<Integer>(list);\n                            combo.add(candidates[i]);\n                            dp.get(j).add(combo);\n                        }                     \n        return dp.get(target);   \n    }\n}", "nl": "azheanda"}
{"code": "class Solution {\n    private String LEFT = \"(\";\n    private String RIGHT = \")\";\n    public List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n        if (n == 0) {\n            return result;\n        }\n        dfs(result, new StringBuffer(), n, n);\n        return result;\n    }\n    \n    private void dfs(List<String> result, StringBuffer sb, int numL, int numR) {\n        if (numL == 0 && numR == 0) {\n            result.add(sb.toString());\n            return;\n        }\n        if (numL > 0) {\n            dfs(result, sb.append(LEFT), numL - 1, numR);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        if (numR > 0 && numL < numR) { // hardcheck/validation\n            dfs(result, sb.append(RIGHT), numL, numR - 1);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public boolean wordBreak(String s, Set<String> wordDict) {\n        return f(s,wordDict,new HashMap<String, Boolean>());\n    }\n    public boolean f(String s, Set<String> wordDict,Map<String, Boolean> map){\n        if (s==null||s.length()==0) {\n            return true;\n        }\n        if (map.get(s)!=null) {\n            return map.get(s);\n        }else {\n            for (int i = 0; i < s.length(); i++) {\n                String str=s.substring(0,i+1);\n                boolean flag=false;\n                for (String test : wordDict) {\n                    if (str.equals(test)) {\n                        flag=true;\n                        if (f(s.substring(i+1,s.length()),wordDict,map)) {\n                            return true;\n                        }\n                    }\n                }\n                map.put(str, flag);\n            }\n            return false;\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class GasStation {\n\n    public class Solution {\n        public int canCompleteCircuit(int[] gas, int[] cost) {\n            int start = 0;\n            while (start < gas.length) {\n                int end = start;\n                int rest = 0;\n                do {\n                    rest += gas[end] - cost[end];\n                    end = (end + 1) % gas.length;\n                    if (rest < 0) {\n                        if (end <= start) {\n                            return -1;\n                        }\n                        break;\n                    }\n                } while (end != start);\n                if (end == start) {\n                    return start;\n                }\n                start = end;\n            }\n            return -1;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public int jump(int[] A) {\n        int n = A.length;\n        int last = 0, cur = 0, res = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i > last) {\n                res++;\n                last = cur;\n                if (cur >= n - 1) return res;\n            }\n            cur = Math.max(cur, i + A[i]);\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "class SearchInRotatedSortedArray2 {\n\n  \n  public boolean search(int[] nums, int target) {\n    if (nums == null || nums.length == 0) return false;\n    int l = 0;\n    int h = nums.length - 1;\n    while (l <= h) {\n      int m = l + (h - l) / 2;\n      if (nums[m] == target) return true;\n      if (nums[l] == nums[m] && nums[m] == nums[h]) { // [1, 3, 1, 1, 1] OR [1, 1, 1, 3, 1]\n        l++;\n        h--;\n      } else if (nums[l] == nums[m]) {\n        l = m + 1;\n      } else if (nums[m] == nums[h]) {\n        h = m - 1;\n      } else if (nums[l] < nums[m]) { // [l, m] sorted.\n        if (nums[l] <= target && target < nums[m]) {\n          h = m - 1;\n        } else {\n          l = m + 1;\n        }\n      } else if (nums[l] > nums[m]) { // [m, r] sorted.\n        if (nums[m] < target && target <= nums[h]) {\n          l = m + 1;\n        } else {\n          h = m - 1;\n        }\n      }\n    }\n    return false;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        return f(candidates, target, new HashMap<Integer, List<List<Integer>>>());\n    }\n    public List<List<Integer>> f(int[] candidates, int target,HashMap<Integer, List<List<Integer>>> map){\n        if (map.get(target)==null) {\n            List<List<Integer>> ans=new ArrayList<List<Integer>>();\n            if (target<candidates[0]) {\n                return ans;\n            }\n            for (int i = 0; i < candidates.length; i++) {\n                int k=candidates[i];\n                if (k<target) {\n                    List<List<Integer>> list=f(candidates,target-k,map);\n                    if (list!=null&&list.size()!=0) {\n                        for (int j = 0; j < list.size(); j++) {\n                            if (list.get(j).get(0)>=k) {\n                                List<Integer> l=new ArrayList<Integer>();\n                                l.add(k);\n                                l.addAll(list.get(j));\n                                ans.add(l);\n                            }\n                        }\n                    }\n                }else if (k==target) {\n                    List<Integer> l=new ArrayList<Integer>();\n                    l.add(k);\n                    ans.add(l);\n                }else {\n                    break;\n                }\n            }\n            map.put(target, ans);\n            return ans;\n        }\n        return map.get(target);\n    }\n}", "nl": "corpsepiges"}
{"code": "public class ConstructBinaryTreefromInorderandPostorderTraversal {\n\n    public class Solution {\n        private TreeNode buildTree(Map<Integer, Integer> inorder, int b1,\n                int[] postorder, int b2, int len) {\n            if (len == 0) {\n                return null;\n            }\n            TreeNode node = new TreeNode(postorder[b2 + len - 1]);\n            int i = inorder.get(node.val);\n            node.left = buildTree(inorder, b1, postorder, b2, i - b1);\n            node.right = buildTree(inorder, i + 1, postorder, b2 + i - b1, len\n                    - i + b1 - 1);\n            return node;\n        }\n\n        public TreeNode buildTree(int[] inorder, int[] postorder) {\n            assert inorder != null && postorder != null\n                    && inorder.length == postorder.length;\n            Map<Integer, Integer> inorderNodes = new HashMap<Integer, Integer>();\n            for (int i = 0; i < inorder.length; i++) {\n                inorderNodes.put(inorder[i], i);\n            }\n            return buildTree(inorderNodes, 0, postorder, 0, inorder.length);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Permutations {\n\n    public class Solution {\n        private void swap(int[] num, int i, int j) {\n            int temp = num[i];\n            num[i] = num[j];\n            num[j] = temp;\n        }\n\n        private void reverse(int[] num, int begin, int end) {\n            end--;\n            while (begin < end) {\n                swap(num, begin++, end--);\n            }\n        }\n\n        private boolean nextPermutation(int[] num) {\n            if (num.length <= 1) {\n                return false;\n            }\n            int i = num.length - 1;\n            while (true) {\n                i--;\n                if (num[i] < num[i + 1]) {\n                    int j = num.length;\n                    while (num[i] >= num[--j]) {\n                    }\n                    swap(num, i, j);\n                    reverse(num, i + 1, num.length);\n                    return true;\n                }\n                if (i == 0) {\n                    reverse(num, 0, num.length);\n                    return false;\n                }\n            }\n        }\n\n        public ArrayList<ArrayList<Integer>> permute(int[] num) {\n            Arrays.sort(num);\n            ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n            do {\n                ArrayList<Integer> l = new ArrayList<Integer>();\n                for (int n : num) {\n                    l.add(n);\n                }\n                ans.add(l);\n            } while (nextPermutation(num));\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public void rotate_1(int[][] matrix) {\n        int n = matrix.length;\n        if (n <= 1) return;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                int tmp = matrix[i][j];\n                matrix[i][j]=matrix[j][i];\n                matrix[j][i]=tmp;\n            }\n        }\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                int tmp = matrix[i][j];\n                matrix[i][j]=matrix[i][n-1-j];\n                matrix[i][n-1-j] = tmp;\n            }\n        }\n    }\n    public void rotate_2(int[][] matrix) {\n        int n = matrix.length;\n        if (n <= 1) return;\n        int level = 0;\n        while (level < n / 2) {\n            for (int i = level; i < n - 1 - level; ++i) {\n                int tmp = matrix[i][level];\n                matrix[i][level] = matrix[n - 1 - level][i];\n                matrix[n - 1 - level][i] = matrix[n - 1 - i][n - 1 - level];\n                matrix[n - 1 - i][n - 1 - level] = matrix[level][n - 1 - i];\n                matrix[level][n - 1 - i] = tmp;\n            }\n            ++level;\n        }\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if(inorder.length==0||postorder.length==0||inorder.length!=postorder.length)\n            return null;\n        return buildTreeRe(inorder,0,inorder.length-1,postorder,0,postorder.length-1); \n    }\n    public TreeNode buildTreeRe(int[] inorder,int s1,int e1, int[] postorder, int s2,int e2){\n        if(e2<s2) return null;\n        if(s2==e2) return new TreeNode(postorder[e2]);\n        int j=-1;\n        for(int i=s1;i<=e1;i++){\n            if(inorder[i]==postorder[e2]){\n                j=i;\n                break;\n            }\n        }\n        int left_len = j-s1;\n        TreeNode root = new TreeNode(postorder[e2]);\n        root.left = buildTreeRe(inorder,s1,j-1,postorder,s2,s2+left_len-1);\n        root.right = buildTreeRe(inorder,j+1,e1,postorder,s2+left_len,e2-1);\n        return root;\n    }\n}", "nl": "leetcoders"}
{"code": "public class MergekSortedLists5 {\n\tpublic ListNode mergeKLists(List<ListNode> lists) {\n\t\t\n\n\t\tfor (int i = lists.size() - 1; i >= 0; i--) {\n\t\t\tif (lists.get(i) == null) {\n\t\t\t\tlists.remove(i);\n\t\t\t}\n\t\t}\n\n\t\tListNode tail = null, list = null;\n\t\twhile (!lists.isEmpty()) {\n\t\t\tListNode p = lists.get(0);\n\t\t\tArrayList<Integer> rm = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < lists.size(); i++) {\n\t\t\t\tListNode node = lists.get(i);\n\t\t\t\tif (node.val < p.val) {\n\t\t\t\t\tp = node;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = lists.size() - 1; i >= 0; i--) {\n\t\t\t\tif (lists.get(i).val == p.val) {\n\t\t\t\t\trm.add(Integer.valueOf(i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < rm.size(); j++) {\n\t\t\t\tint index = rm.get(j).intValue();\n\t\t\t\tListNode q = lists.get(index);\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = q;\n\t\t\t\t} else {\n\t\t\t\t\ttail.next = q;\n\t\t\t\t}\n\t\t\t\ttail = q;\n\t\t\t\tq = q.next;\n\t\t\t\tif (q == null) {\n\t\t\t\t\tlists.remove(index);\n\t\t\t\t} else {\n\t\t\t\t\tlists.remove(index);\n\t\t\t\t\tlists.add(q);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class GrayCode {\n  public ArrayList<Integer> grayCode(int n) {\n    ArrayList<Integer> result = new ArrayList<Integer>();\n    if (n == 0) {\n      result.add(0);\n      return result;\n    }\n    ;\n    result.add(0);\n    result.add(1);\n    for (int i = 1; i < n; i++) {\n      ArrayList<Integer> tmp = new ArrayList<Integer>(result);\n      Integer a = 1 << i;\n      for (int k = result.size() - 1; k >= 0; k--) {\n        tmp.add(result.get(k) + a);\n      }\n      result = tmp;\n    }\n    return result;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public List<String> generateParenthesis(int n) {\n    \tList<String> rst = new ArrayList<String>();\n    \tif (n <= 0) {\n    \t\treturn rst;\n    \t}  \n    \tArrayList<String> list = new ArrayList<String>();\n    \thelper(rst, list, 0, 0, n);\n    \t\n    \treturn rst;\n    }\n\n    public void helper(List<String> rst, ArrayList<String> list, \n    \tint left, int right, int n) {\n    \tif (left == n && right == n) {\n    \t\tStringBuffer sb = new StringBuffer();\n    \t\tfor (String s : list) {\n    \t\t\tsb.append(s);\n    \t\t}\n    \t\trst.add(sb.toString());\n    \t\treturn;\n    \t}\n    \tif (left < n) {\n    \t\tlist.add(\"(\");\n    \t\thelper(rst, list, left + 1, right, n);\n    \t\tlist.remove(list.size() - 1);\n    \t}\n    \tif (right < left) {\n    \t\tlist.add(\")\");\n    \t\thelper(rst, list, left, right + 1, n);\n    \t\tlist.remove(list.size() - 1);\n    \t}\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class MaximumDepthofBinaryTree {\n\n    public class Solution {\n        public int maxDepth(TreeNode root) {\n            if (root == null) {\n                return 0;\n            }\n            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean hasCycle(ListNode head) {  \n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n\n        while (slow != fast) {//Compare their reference address\n            if (fast == null || fast.next == null) {//travel till the end\n                return false;//no cycle\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class PlusOne\n{\n\n    public int[] plusOne(int[] digits) \n    {\n        return new int[0];\n    }\n\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null)\n            return true;\n        else if(p!=null && q !=null)\n            return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        else\n            return false;\n    }\n}", "nl": "azheanda"}
{"code": "public class TrappingRainWater\n{\n    public int trap( int[] height )\n    {\n    \tStack<Integer> decSeq = new Stack<>();\n    \tint totalWater = 0;\n    \tfor ( int i = 0; i < height.length; i++ )\n    \t{\n    \t\tif ( decSeq.isEmpty() \n    \t\t\t\t|| height[decSeq.peek()] > height[i] )\n    \t\t{\n    \t\t\tdecSeq.push( i );\n    \t\t}\n    \t\telse\n    \t\t{   \n\t    \t\twhile ( decSeq.size() > 1 && height[decSeq.peek()] < height[i] )\n\t    \t\t{\n\t    \t\t\tint currIndex = decSeq.pop();\n\t    \t\t\ttotalWater += ( Math.min( height[decSeq.peek()], height[i] ) - height[currIndex] ) * ( i - decSeq.peek() - 1 );\n\t    \t\t}\n\t    \t\t\n\t    \t\tif ( decSeq.size() == 1 && height[decSeq.peek()] <= height[i] )\n\t    \t\t{\n\t    \t\t\tdecSeq.pop();\n\t    \t\t}\n\t    \t\tdecSeq.push( i );\t    \t\t\t\t\n    \t\t}\n    \t}\n    \treturn totalWater;\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertEquals( 6, trap( new int[]{ 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1} ) );\n    \tassertEquals( 7, trap( new int[]{ 3, 1, 1, 1, 2, 4}) );\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class ValidParentheses {\n\tpublic boolean isValid(String s) {\n\t\tif (s.length() == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tStack<Character> st = new Stack<Character>();\n\t\tst.push(s.charAt(0));\n\n\t\tfor (int i = 1; i < s.length(); ++i) {\n\t\t\tif (!st.empty() && isMatch(st.peek(), s.charAt(i))) {\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.push(s.charAt(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(st.empty()) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic boolean isMatch(char s, char p) {\n\t\tif ((s == '(' && p == ')') || (s == '{' && p == '}')\n\t\t\t\t|| (s == '[' && p == ']')) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tValidParentheses slt = new ValidParentheses();\n\t\tString s = \"(]\";\n\t\tSystem.out.println(slt.isValid(s));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int index = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[index]) {\n                nums[index + 1] = nums[i];\n                index++;\n            }\n        }\n        return index + 1;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class L001_Two_Sum {\n\n\tpublic int[] twoSum(int[] nums, int target) {\n\n\t\tif (nums == null || nums.length <= 1) {\n\t\t\treturn new int[2];\n\t\t}\n\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tmap.put(target - nums[i], i);\n\t\t}\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tInteger v = map.get(nums[i]);\n\n\t\t\tif (v != null && v != i) {\n\t\t\t\treturn new int[] { i + 1, v + 1 };\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if ((p != null && q == null) || (p == null && q != null)) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}", "nl": "leetcoders"}
{"code": "public class PlusOne {\n\n  public int[] plusOne(int[] digits) {\n    for (int i = digits.length - 1; i >= 0; i--) {\n      digits[i] = 1 + digits[i];\n      if (digits[i] == 10) { // Carry.\n        digits[i] = 0;\n      } else { // No carry, just return.\n        return digits;\n      }\n    }\n    int[] ans = new int[digits.length + 1];\n    ans[0] = 1;\n    for (int i = 0; i < digits.length; i++) {\n      ans[i + 1] = digits[i];\n    }\n    return ans;\n  }\n\n  public int[] plusOneB(int[] digits) {\n    int count = digits.length;\n    while (count > 0) {\n      digits[count - 1] = digits[count - 1] + 1;\n      if (digits[count - 1] > 9) {\n        digits[count - 1] = 0;\n      } else {\n        return digits;\n      }\n      count--;\n    }\n    int[] result = new int[digits.length + 1];\n    result[0] = 1;\n    for (int i = 1; i < digits.length; i++) {\n      result[i] = digits[i - 1];\n    }\n    return result;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class LongestPalindromicSubstring {\n\tpublic  String longestPalindrome(String s) {\n\t\tif (s.isEmpty()) \n\t\t\treturn null;\n\t\tif (s.length() == 1) \n\t\t\treturn s;\n\t\tString longest = s.substring(0, 1);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tString tmp = helper(s, i, i);\n\t\t\tif (tmp.length() > longest.length()) {\n\t\t\t\tlongest = tmp;\n\t\t\t}\n\t \n\t\t\ttmp = helper(s, i, i + 1);\n\t\t\tif (tmp.length() > longest.length()) {\n\t\t\t\tlongest = tmp;\n\t\t\t}\n\t\t}\n\t\treturn longest;\n\t}\n\tpublic String helper(String s, int begin, int end) {\n\t\twhile (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) == s.charAt(end)) {\n\t\t\tbegin--;\n\t\t\tend++;\n\t\t}\n\t\treturn s.substring(begin + 1, end);\n\t}\n}", "nl": "gaohannk"}
{"code": "public class Solution {\n    public String longestPalindrome_1(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int idx = 0, maxLen = 0;\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i + k < n; ++i) {\n                if (k == 0 || k == 1) dp[i][i+k] = (s.charAt(i) == s.charAt(i+k));\n                else dp[i][i+k] = (s.charAt(i) == s.charAt(i+k)) ? dp[i+1][i+k-1] : false;\n                if (dp[i][i+k] == true && (k+1) > maxLen) {\n                    idx = i; maxLen = k + 1;\n                }\n            }\n        }\n        return s.substring(idx, idx + maxLen);\n    }\n    public String longestPalindrome_2(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[2][n];\n        int idx = 0, maxLen = 0;\n        int cur = 1, last = 0;\n        for (int i = 0; i < n; ++i) {\n            cur = cur + last - (last = cur);\n            for (int j = i; j >=0; --j) {\n                if (j == i || j == i - 1)\n                    dp[cur][j] = (s.charAt(i) == s.charAt(j));\n                else dp[cur][j] = (s.charAt(i) == s.charAt(j)) && dp[last][j + 1];\n                if (dp[cur][j] && (i - j + 1) > maxLen) {\n                    idx = j; maxLen = i - j + 1;\n                }\n            }\n        }\n        return s.substring(idx, idx + maxLen);\n    }\n    public String longestPalindrome_3(String s) {\n        int n = s.length();\n        int idx = 0, maxLen = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= 1; ++j) {\n                boolean isP = true;\n                for (int k = 0; i - k >= 0 && i + j + k < n && isP; ++k) {\n                    isP = (s.charAt(i - k) == s.charAt(i + j + k));\n                    if (isP && (j + 1 + k*2) > maxLen) {\n                        idx = i - k; maxLen = j + 1 + k*2;\n                    }\n                }\n            }\n        }\n        return s.substring(idx, idx + maxLen);\n    }\n    public String longestPalindrome_4(String s) {\n        int n = s.length();\n        int idx = 0, maxLen = 0;\n        StringBuffer sb = new StringBuffer();\n        sb.append('^');\n        for (int i = 0; i < n; ++i) {\n            sb.append('#');\n            sb.append(s.charAt(i));\n        }\n        sb.append(\"#$\");\n        n = 2 * n + 3;\n        int mx = 0, id = 0;\n        int[] p = new int[n];\n        Arrays.fill(p,0);\n        for (int i = 1; i < n - 1; ++i) {\n            p[i] = (mx > i) ? Math.min(p[2 * id - i], mx - i) : 0;\n            while (sb.charAt(i + 1 + p[i]) == sb.charAt(i - 1 - p[i])) ++p[i];\n            if (i + p[i] > mx) {\n                id = i; mx = i + p[i];\n            }\n            if (p[i] > maxLen) {\n                idx = i; maxLen = p[i];\n            }\n        }\n        idx = (idx - maxLen - 1) / 2;\n        return s.substring(idx, idx + maxLen);\n    }\n    public String longestPalindrome_5(String s) {\n        int n = s.length();\n        int idx = 0, maxLen = 0;\n        int mx = 0, id = 0;\n        int[] p = new int[2*n+1];\n        Arrays.fill(p,0);\n        for (int i = 0; i < 2*n+1; ++i) {\n            p[i] = (mx > i) ? Math.min(p[2*id-i], mx - i) : 0;\n            int left = i - 1 - p[i],  right = i + 1 + p[i];\n            while (left>=0 && right <= 2*n) {\n                if (left % 2 == 0 || s.charAt(left/2) == s.charAt(right/2)) {\n                    ++p[i];\n                } else break;\n                --left;\n                ++right;\n            }\n            if (i + p[i] > mx) {\n                id = i; mx = i + p[i];\n            }\n            if (p[i] > maxLen) {\n                idx = i; maxLen = p[i];\n            }\n        }\n        idx = (idx - maxLen) / 2;\n        return s.substring(idx, idx + maxLen);\n    }\n}", "nl": "leetcoders"}
{"code": "public class L033_Search_in_Rotated_Sorted_Array {\n\n\tpublic int search(int[] nums, int target) {\n\n\t\tint l = 0, r = nums.length - 1;\n\n\t\twhile (l <= r) {\n\n\t\t\tint m = (l + r) / 2;\n\n\t\t\tif (nums[m] == target)\n\t\t\t\treturn m;\n\t\t\tif (nums[l] < nums[m]) {\n\t\t\t\tif (target <= nums[m] && target >= nums[l])\n\t\t\t\t\tr = m - 1;\n\t\t\t\telse\n\t\t\t\t\tl = m + 1;\n\t\t\t} else if (nums[l] > nums[m]) {\n\t\t\t\tif (target >= nums[l] || target <= nums[m])\n\t\t\t\t\tr = m - 1;\n\t\t\t\telse\n\t\t\t\t\tl = m + 1;\n\t\t\t} else\n\t\t\t\tl++;\n\t\t}\n\t\treturn -1;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class CountAndSay \n{\n    public String countAndSay(int n) \n    {\n        return \"\";\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class AddTwoNumbers2 {\n\n    \n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        int length1 = getLength(l1);\n        int length2 = getLength(l2);\n        ListNode head = new ListNode(1);\n        head.next = (length1 >= length2) ? addLists(l1, l2, length1 - length2) : addLists(l2, l1, length2 - length1);\n        if (head.next != null && head.next.val > 9) {\n            head.next.val = head.next.val % 10;\n            return head;\n        }\n        return head.next;\n    }\n\n    private ListNode addLists(ListNode l1, ListNode l2, int offset) {\n        if (l1 == null) { // The longer list is null, then both are null.\n            return null;\n        }\n        ListNode currentNode = (offset == 0) ? new ListNode(l1.val + l2.val) : new ListNode(l1.val);\n        ListNode nextNode = (offset == 0) ? addLists(l1.next, l2.next, 0) : addLists(l1.next, l2, offset - 1);\n        if (nextNode != null && nextNode.val > 9) {\n            currentNode.val += 1;\n            nextNode.val %= 10;\n        }\n        currentNode.next = nextNode;\n        return currentNode;\n    }\n\n    private int getLength(ListNode node) {\n        int count = 0;\n        while (node != null) {\n            count++;\n            node = node.next;\n        }\n        return count;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class UniqueBinarySearchTrees {\n  int[] dp;\n\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(new UniqueBinarySearchTrees().numTrees(5));\n  }\n\n  public int numTrees(int n) {\n    dp = new int[n + 1];\n    dp[0] = 1;\n    return dp(n);\n  }\n\n  private int dp(int n) {\n    if (dp[n] != 0) return dp[n];\n    for (int i = 1; i <= n; i++) {\n      dp[n] += dp(n - i) * dp(n - (n - i) - 1);\n    }\n    return dp[n];\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class LongestCommonPrefix \n{\n    public String longestCommonPrefix(String[] strs) \n    {\n        return \"\";\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "class Solution {\n    public boolean isNumber(String s) {\n        if (s == null) return false;\n        s = s.trim();\n        if (s.length() == 0) return false;\n        int i = 0;\n        char[] ss = s.toCharArray();\n        if (ss[i] == '+' || ss[i] == '-') i++;\n        boolean isNum = false, isDot = false, isExp = false;\n        for (; i < s.length(); i++) {\n            char c = ss[i];\n            if (Character.isDigit(c)) {\n                isNum = true;\n            } else if (c == '.') {\n                if (isDot || isExp) return false; // . or e exists already, return false\n                isDot = true;\n            } else if (c == 'e') {\n                if (isExp || !isNum) return false; // e exists, or if no integer ahead of e, return false\n                isExp = true;\n                isNum = false; // can start re-count integer\n            } else if (c == '+' || c == '-') {\n                if (i >= 1 && s.charAt(i - 1) != 'e') return false;\n            } else {\n                return false;\n            }\n        }\n\n        return isNum;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class InsertionSortList {\n\tpublic ListNode insertionSortList(ListNode head) {\n\t\tif (head == null || head.next == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tListNode node = head;\n\t\tListNode cur = null;\n\t\t\n\t\twhile (node.next != null) {\n\t\t\tcur = node.next;\n\t\t\t\n\t\t\tif (cur.val >= node.val) {  // in the end \n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tnode.next = cur.next;  // delete the node\n\n\t\t\tif (cur.val <= head.val) {  // in the beginning \n\t\t\t\tcur.next = head;\n\t\t\t\thead = cur;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tListNode pos = findInsertPos(head, cur);\n\n\t\t\tcur.next = pos.next;\n\t\t\tpos.next = cur;\n\t\t}\n\n\t\treturn head;\n\t}\n\n\tListNode findInsertPos(ListNode head, ListNode node) {  // not in the beginning or end\n\t\tListNode pos = head;\n\t\twhile (head != null && head.val < node.val) {\n\t\t\tpos = head;\n\t\t\thead = head.next;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\tpublic void printList(ListNode node) {\n\t\twhile (node != null) {\n\t\t\tSystem.out.print(node.val + \"->\");\n\t\t\tnode = node.next;\n\t\t}\n\t\tSystem.out.println(\" \");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInsertionSortList slt = new InsertionSortList();\n\t\tListNode n1 = new ListNode(1);\n\t\tListNode n2 = new ListNode(4);\n\t\tListNode n3 = new ListNode(0);\n\t\tListNode n4 = new ListNode(3);\n\t\tn1.next = n2;\n\t\tn2.next = n3;\n\t\tn3.next = n4;\n\n\t\tslt.printList(n1);\n\t\tListNode res = slt.insertionSortList(n1);\n\t\tslt.printList(res);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class SingleNumber {\n  public int singleNumber(int[] A) {\n    int ret = A[0];\n    for (int i = 1; i < A.length; i++) {\n      ret ^= A[i];\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class MinimumDepthofBinaryTree {\n\n    public class Solution {\n        public int minDepth(TreeNode root) {\n            if (root == null) {\n                return 0;\n            }\n            int l = minDepth(root.left);\n            int r = minDepth(root.right);\n            if (l == 0) {\n                return r + 1;\n            }\n            if (r == 0) {\n                return l + 1;\n            }\n            return Math.min(l, r) + 1;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class L089_Gray_Code {\n\n\tpublic List<Integer> grayCode(int n) {\n\n\t\tList<Integer> rt = new ArrayList<Integer>();\n\n\t\tif (n < 0) {\n\t\t\treturn rt;\n\t\t}\n\n\t\tfor (int i = 0; i < Math.pow(2, n); i++) {\n\t\t\trt.add((i >> 1) ^ i);\n\t\t}\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class L104_Maximum_Depth_of_Binary_Tree {\n\n\tpublic int maxDepth(TreeNode root) {\n\n\t\tif (root == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint nLeft = maxDepth(root.left);\n\t\tint nRight = maxDepth(root.right);\n\n\t\treturn nLeft > nRight ? (nLeft + 1) : (nRight + 1);\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Powxn {\n\tpublic double pow(double x, int n) {\n\t\tif (n == 0)\n\t\t\treturn 1.0;\n\t\tif (x == 0.)\n\t\t\treturn 0.0;\n\t\tif (n < 0) {\n\t\t\tn = -n;\n\t\t\tx = 1. / x;\n\t\t}\n\t\tdouble temp = pow(x, n / 2);\n\t\treturn n % 2 == 0 ? temp * temp : temp * temp * x;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0] == null || grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m][n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = grid[i][j];\n                    continue;\n                } \n                int fromUp = i == 0 ? Integer.MAX_VALUE : dp[i - 1][j];\n                int fromLeft = j == 0 ? Integer.MAX_VALUE : dp[i][j - 1];\n                dp[i][j] = Math.min(fromUp, fromLeft) + grid[i][j];\n                \n            }\n        }\n        \n        return dp[m - 1][n - 1];\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Subsets {\n\tpublic ArrayList<ArrayList<Integer>> subsets(int[] S) {\n\t\tif (S == null)\n\t\t\treturn null;\n\t\tArrays.sort(S);\n\t\tArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < S.length; i++) {\n\t\t\tArrayList<ArrayList<Integer>> temp = new ArrayList<ArrayList<Integer>>();\n\t\t\t\n\t\t\tfor (ArrayList<Integer> a : result) {\n\t\t\t\ttemp.add(new ArrayList<Integer>(a));\n\t\t\t}\n\t\t\t\n\t\t\tfor (ArrayList<Integer> a : temp) {\n\t\t\t\ta.add(S[i]);\n\t\t\t} \n\t\t\t\n\t\t\tArrayList<Integer> single = new ArrayList<Integer>();\n\t\t\tsingle.add(S[i]);\n\t\t\ttemp.add(single); \n\t\t\tresult.addAll(temp);\n\t\t} \n\t\tresult.add(new ArrayList<Integer>());\n\t\t\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ImplementStrStr {\n  public static void main(String[] args) throws Exception {\n    System.out.println(new ImplementStrStr().strStr(\"AABB\", \"\"));\n  }\n\n  public int strStr(String haystack, String needle) {\n    if (haystack.isEmpty() && needle.isEmpty()) return 0;\n    if (needle.isEmpty()) return 0;\n    for (int i = 0, l = haystack.length(); i < l; i++) {\n      if (haystack.charAt(i) == needle.charAt(0)) {\n        if (isEqual(haystack, needle, i)) return i;\n      }\n    }\n    return -1;\n  }\n\n  private boolean isEqual(String haystack, String needle, int i) {\n    int hL = haystack.length();\n    int nL = needle.length();\n    int j = 0;\n    while (i < hL && j < nL) {\n      if (haystack.charAt(i) != needle.charAt(j)) return false;\n      i++;\n      j++;\n    }\n    return j >= nL;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class UniqueBinarySearchTrees {\n\tpublic int numTrees(int n) {\n\t\tint[] count = new int[n + 1];\n\t\tcount[0] = 1;\n\t\tcount[1] = 1;\n\t\tfor (int i = 2; i < n + 1; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcount[i] += count[j] * count[i - j - 1];\n\t\t\t}\n\t\t}\n\t\treturn count[n];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class DecodeWays2Test {\n\n    private static final Map<String, Integer> EXAMPLES = Map.of(\n            \"0\", 0,\n            \"1\", 1,\n            \"1*\", 18,\n            \"**\", 96,\n            \"***\", 999,\n            \"*1*1*0\", 404,\n            \"**********1111111111\", 133236775, // Test overflow.\n            \"********************\", 104671669 // Test overflow.\n    );\n\n    @Test\n    public void testNumDecodings() {\n        DecodeWays2 d = new DecodeWays2();\n        for (Map.Entry<String, Integer> e : EXAMPLES.entrySet()) {\n            System.out.println(\"Input is: \" + e.getKey());\n            Assert.assertEquals(d.numDecodings(e.getKey()), e.getValue().intValue());\n            Assert.assertEquals(d.numDecodings2(e.getKey()), e.getValue().intValue());\n        }\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SearchA2DMatrix \n{\n    public boolean searchMatrix(int[][] matrix, int target) \n    {\n    \tif ( matrix.length == 0 \n    \t\t\t|| matrix[0].length == 0 )\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint rowIndex = findLastSmallerRowHead( matrix, target );\n    \tif ( rowIndex == -1 )\n    \t{\n    \t\treturn false;\n    \t}\n    \tint colIndex = binarySearch( matrix, rowIndex, target );\n    \tif ( colIndex == -1 )\n    \t{\n    \t\treturn false;\n    \t}\n    \telse\n    \t{\n    \t\treturn true;\n    \t}\n    }\n    \n    private int binarySearch( int[][] matrix, int rowIndex, int target )\n    {\n    \tint start = 0;\n    \tint end = matrix[0].length - 1;\n    \twhile ( start + 1 < end )\n    \t{\n    \t\tint mid = ( end - start ) / 2 + start;\n    \t\tif ( matrix[rowIndex][mid] < target )\n    \t\t{\n    \t\t\tstart = mid + 1;\n    \t\t}\n    \t\telse if ( matrix[rowIndex][mid] > target )\n    \t\t{\n    \t\t\tend = mid - 1;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\treturn mid;\n    \t\t}\n    \t}\n    \t\n    \tif ( matrix[rowIndex][start] == target )\n    \t{\n    \t\treturn start;\n    \t}\n    \telse if ( matrix[rowIndex][end] == target )\n    \t{\n    \t\treturn end;\n    \t}\n    \telse\n    \t{\n    \t\treturn -1;\n    \t}\n    }\n    \n    \n    private int findLastSmallerRowHead( int[][] matrix, int target )\n    {\n    \tint start = 0;\n    \tint end = matrix.length - 1;\n    \twhile ( start + 1 < end )\n    \t{\n    \t\tint mid = ( end - start ) / 2 + start;\n    \t\tif ( matrix[mid][0] <= target )\n    \t\t{\n    \t\t\tstart = mid;\n    \t\t}\n    \t\telse //if ( matrix[mid][0] > target )\n    \t\t{\n    \t\t\tend = mid - 1;\n    \t\t}\n    \t}\n    \t\n    \tif ( matrix[end][0] <= target )\n    \t{\n    \t\treturn end;\n    \t}\n    \telse if ( matrix[start][0] <= target )\n    \t{\n    \t\treturn start;\n    \t}\n    \telse\n    \t{\n    \t\treturn -1;\n    \t}\n    }   \n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public boolean isValidBST(TreeNode root) {\n        if (root==null) {\n            return true;\n        }\n        List<Integer> list=inorder(root,new ArrayList<Integer>());\n        if (list.size()<2) {\n            return true;\n        }\n        for (int i = 0; i < list.size()-1; i++) {\n            if (list.get(i)>=list.get(i+1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public List<Integer> inorder(TreeNode root,List<Integer> list){  \n        if (root!=null) {  \n            list=inorder(root.left,list);  \n            list.add(root.val);  \n            list=inorder(root.right,list);  \n        }  \n        return list;  \n    }  \n}", "nl": "corpsepiges"}
{"code": "class Solution {\n    public String minWindow(String s, String t) {\n        if (s == null || t == null || s.length() < t.length()) {\n            return \"\";\n        }\n        int end = 0;\n        int length = Integer.MAX_VALUE;\n        String rst = \"\";\n\n        int[] source = new int[256];\n        int[] target = new int[256];\n        for (char c : t.toCharArray()) {\n            target[c]++;\n        }\n\n        for (int i = 0; i < s.length(); i++){\n            while (end < s.length() && !valid(source, target)) {\n                source[s.charAt(end)]++;\n                end++;\n            }\n            if (valid(source, target)) {\n                if (end - i < length) {\n                    length = Math.min(length, end - i);\n                    rst = s.substring(i, end);\n                }\n            }\n            source[s.charAt(i)]--;\n        }\n        return rst;\n    }\n    \n    \n    private boolean valid(int[] source, int[] target) {\n        for (int i = 0; i < 256; i++) {\n            if (source[i] < target[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class MergeSortedArray {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        \n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class DecodeWays {\n\n  \n  public int numDecodings(String s) {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n    int pre = 1; // Previous decode ways. Initialized as 1 cuz d(2) = d(1) + d(0) if decode-able.\n    int cur = s.charAt(0) == '0' ? 0 : 1; // Current decode ways. Initialized according to first character.\n    for (int i = 2; i <= s.length(); i++) { // i is the length of the string.\n      int oneD = Integer.valueOf(s.substring(i - 1, i)); // Last 1 digit.\n      int twoD = Integer.valueOf(s.substring(i - 2, i)); // Last 2 digits.\n      int temp = cur; // IMPORTANT! Store current value temporarily. Otherwise cur will be updated.\n      cur = (oneD != 0 ? cur : 0) + (10 <= twoD && twoD <= 26 ? pre : 0);\n      pre = temp;\n    }\n    return cur;\n  }\n\n  \n  public int numDecodings2(String s) {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n    int len = s.length();\n    int[] ways = new int[len + 1];\n    ways[0] = 1; // Think about ways[2] when code2 is valid, ways[0] should be 1.\n    ways[1] = s.charAt(0) == '0' ? 0 : 1;\n    for (int i = 2; i <= len; i++) {\n      int oneDigit = Integer.valueOf(s.substring(i - 1, i));\n      int twoDigits = Integer.valueOf(s.substring(i - 2, i));\n      ways[i] = (oneDigit != 0 ? ways[i - 1] : 0) + (10 <= twoDigits && twoDigits <= 26 ? ways[i - 2] : 0);\n    }\n    return ways[len];\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "class Solution {\n    \n    public ArrayList<ArrayList<Integer>> subsetsWithDup(ArrayList<Integer> S) {\n    \tArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();\n    \tif (S == null || S.size() == 0) {\n    \t\treturn rst;\n    \t}\n    \tCollections.sort(S);\n    \tQueue<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();\n    \tArrayList<Integer> list = new ArrayList<Integer>();\n    \tqueue.offer(new ArrayList<Integer>(list));\n    \trst.add(new ArrayList<Integer>(list));\n    \t\n    \tfor (int i = 0; i < S.size(); i++) {\n    \t\tint num = S.get(i);\n    \t\tint size = queue.size();\n    \t\twhile(size > 0) {\n\t    \t\tlist = queue.poll();\n\t    \t\tlist.add(num);\n\t    \t\tif (!rst.contains(list)) {\n\t    \t\t\trst.add(new ArrayList<Integer>(list));\n\t    \t\t}\n\t    \t\tqueue.offer(new ArrayList<Integer>(list));\n\t    \t\tlist.remove(list.size() - 1);\n\t    \t\tqueue.offer(new ArrayList<Integer>(list));\n\t    \t\tsize--;\n\t    \t}\n    \t}\n    \treturn rst;\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class FirstMissingPositive {\n\n    public class Solution {\n        public int firstMissingPositive(int[] A) {\n            int n = A.length;\n            for (int i = 0; i < n; i++) {\n                if (A[i] <= 0) {\n                    A[i] = n + 1;\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                int temp = Math.abs(A[i]);\n                if (temp <= n && A[temp - 1] > 0) {\n                    A[temp - 1] = -A[temp - 1];\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (A[i] > 0) {\n                    return i + 1;\n                }\n            }\n            return n + 1;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean isMatch_1(String s, String p) {\n        if (p.length() == 0) return s.length() == 0;\n        if (p.length() == 1) {\n            if (s.length() != 1) return false;\n            return (s.charAt(0) == p.charAt(0)) || (p.charAt(0) == '.');\n        }\n        if (s.length() != 0 && (p.charAt(0) == s.charAt(0) || (p.charAt(0) == '.'))) {\n            if (p.charAt(1) == '*')\n                return isMatch(s.substring(1),p) || isMatch(s, p.substring(2));\n            return isMatch(s.substring(1), p.substring(1));\n        }\n        return p.charAt(1) == '*' && isMatch(s, p.substring(2));\n    }\n    public boolean isMatch_2(String s, String p) {\n        if (p.length() == 0) return s.length() == 0;\n        int sLen = s.length(), pLen = p.length();\n        boolean[][] dp = new boolean[sLen + 1][pLen + 1];\n        dp[0][0] = true;\n        for (int i = 2; i <= pLen; ++i) {\n            dp[0][i] = dp[0][i-2] && p.charAt(i-1) == '*';\n        }\n        for (int i = 1; i <= sLen; ++i) {\n            for (int j = 1; j <= pLen; ++j) {\n                char ch1 = s.charAt(i-1), ch2 = p.charAt(j-1);\n                if (ch2 != '*') dp[i][j] = dp[i-1][j-1] && (ch1 == ch2 || ch2 == '.');\n                else {\n                    dp[i][j] = dp[i][j-2];\n                    if (ch1 == p.charAt(j-2) || p.charAt(j-2) == '.')\n                        dp[i][j] = dp[i][j] | dp[i-1][j];\n                }\n            }\n        }\n        return dp[sLen][pLen];\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int numDecodings(String s) {\n        if(s.length()==0 || s.charAt(0)=='0')\n            return 0;\n        for(int i=1;i<s.length();i++)\n            if((s.charAt(i-1)>'2'||s.charAt(i-1)=='0') && s.charAt(i)=='0')\n                return 0;\n        \n        \n        int[] dp = new int[s.length()+1];\n        dp[0] =1;\n        dp[1] =1;\n        \n        for(int i=2;i<s.length()+1;i++){    \n            if(s.charAt(i-1)=='0')\n                dp[i] = dp[i-2];\n            else if(s.charAt(i-2)=='1' || (s.charAt(i-2)=='2' && s.charAt(i-1)<='6'))\n                dp[i]=dp[i-1]+dp[i-2];\n            else\n                dp[i]=dp[i-1];\n        }\n        return dp[s.length()];\n    }\n}", "nl": "azheanda"}
{"code": "public class RemoveDuplicatesfromSortedListII3 {\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\t\tif (head == null || head.next == null)\n\t\t\treturn head;\n\n\t\tListNode dummy = new ListNode(0);\n\t\tdummy.next = head;\n\t\thead = dummy;\n\n\t\twhile (head.next != null && head.next.next != null) {\n\t\t\tif (head.next.val == head.next.next.val) {\n\t\t\t\tint val = head.next.val;\n\t\t\t\twhile (head.next != null && head.next.val == val) {\n\t\t\t\t\thead.next = head.next.next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thead = head.next;\n\t\t\t}\n\t\t}\n\n\t\treturn dummy.next;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n   \n    public ArrayList<Integer> preorderTraversal(TreeNode root) {\n        ArrayList<Integer> rst = new ArrayList<Integer>();\n        if (root == null) {\n            return rst;\n        }\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            if (node != null) {\n                rst.add(node.val);\n                stack.push(node.right);\n                stack.push(node.left);\n            }\n        }\n        return rst;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public void rotate(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return;\n        }\n        int width = matrix.length;\n        for (int i = 0; i < width/2; i++) {\n            for (int j = 0; j < Math.ceil(width/2.0); j++) {\n               int temp = matrix[i][j];\n               matrix[i][j] = matrix[width - 1 - j][i];\n               matrix[width - 1 - j][i] = matrix[width - 1 - i][width - 1 - j];\n               matrix[width - 1 - i][width - 1 - j] = matrix[j][width - 1 - i];\n               matrix[j][width - 1 - i] = temp;\n            }\n        }\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class CombinationSum4\n{\n    public int combinationSum4( int[] nums, int target ) \n    {\n    \tif ( nums == null || nums.length == 0 || target <= 0 )\n    \t{\n    \t\treturn 0;\n    \t}\n    \t\n    \tint[] numCombs = new int[target+1];\n    \tnumCombs[0] = 1;\n    \tfor ( int i = 1; i <= target; i++ )\n    \t{\n    \t\tfor ( int num : nums )\n    \t\t{\n    \t\t\tif ( i - num >= 0 )\n    \t\t\t{\n    \t\t\t\tnumCombs[i] += numCombs[i-num];\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn numCombs[target];\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class TwoSum {\n    public int[] twoSum(int[] numbers, int target) {\n    \tint[] num = numbers.clone();\n        Arrays.sort(num);\n        \t\n        int length = numbers.length;\n        int left = 0;\n        int right = length - 1;\n        int sum = 0;\n        \n        ArrayList<Integer> index = new ArrayList<Integer>();\n        \n        while(left < right)\n        {\n        \tsum = num[left] + num[right];\n        \t\n            if(sum == target)\n            {\n            \tfor(int i = 0; i < length; ++i)\n            \t{\n            \t\tif(numbers[i] == num[left])\n            \t\t{\n            \t\t\tindex.add(i+1);\n            \t\t}\n            \t\telse if(numbers[i] == num[right])\n            \t\t{\n            \t\t\tindex.add(i+1);\n            \t\t}\n            \t\tif(index.size() == 2)\n            \t\t{\n            \t\t\tbreak;\n            \t\t}\n            \t}\n                break;\n            }\n            else if(sum > target)\n            {\n                --right;\n            }\n            else\n            {\n                ++left;\n            }\n        }\n        \n        int[] result = new int[2];\n   \n        result[0] = index.get(0);\n        result[1] = index.get(1);\n        \n        return result;\n    }\n    \n    public static void main(String[] args)\n    {\n    \tTwoSum slt = new TwoSum();\n    \t\n    \tint[] numbers = {0, 4, 3, 0};\n    \tint[] index = new int[2]; \t\n    \tindex = slt.twoSum(numbers, 0);\n    \t\n    \tSystem.out.println(\"index1 = \" + index[0] + \", index2 = \" + index[1]);\n    }\n}\n", "nl": "lilong-dream"}
{"code": "class Solution {\n    public int reverse(int x) {\n        int result = 0;\n\n        while (x != 0) {\n            int tail = x % 10;\n            int newResult = result * 10 + tail;\n            if ((newResult - tail) / 10 != result) return 0; // check overflow. If newResult overflow, it won't resolve back to result\n            result = newResult;\n            x = x / 10;\n        }\n\n        return result;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class SwapNodesinPairs {\n\tpublic class Solution {\n\t\tpublic ListNode swapPairs(ListNode head) {\n\t\t\tif (head == null)\n\t\t\t\treturn null;\n\t\t\tif (head.next == null)\n\t\t\t\treturn head;\n\t\t\tListNode cur = head;\n\t\t\tListNode temp = cur.next;\n\t\t\tcur.next = temp.next;\n\t\t\ttemp.next = cur;\n\t\t\thead = temp;\n\t\t\twhile (cur.next != null && cur.next.next != null) {\n\t\t\t\tswapNode(cur, cur.next, cur.next.next);\n\t\t\t\tcur = cur.next.next;\n\t\t\t}\n\t\t\treturn head;\n\t\t}\n\n\t\tpublic void swapNode(ListNode cur, ListNode next1, ListNode next2) {\n\t\t\tcur.next = next2;\n\t\t\tnext1.next = next2.next;\n\t\t\tnext2.next = next1;\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public void sortColors(int[] A) {\n        int p=-1,r=A.length;\n        for(int q=0;q<r;q++){\n            if(A[q]==0){\n                p++;\n                swap(A,p,q);\n            }else if(A[q]==2){\n                r--;\n                swap(A,r,q);\n                q--;   // This is because when q hits a 2, the A[r] I swap it with is an unknown value. So I let \"q--\",then next loop will check that value.\n            }\n        }       \n    }\n    \n    public void swap(int[] A,int i,int j){\n        int temp = A[i];\n        A[i]=A[j];\n        A[j] = temp;\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public boolean canJump(int[] A) {\n        int i=0;\n        int range= 0;\n        \n        while(i<=range){\n            range = Math.max(range,i+A[i]);\n            if(range>=A.length-1)\n                return true;\n            i++;\n        }\n        return false;\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class LongestPalindromicSubstring\n{\n\tpublic String longestPalindrome( String s )\n\t{\n        if ( s == null || s.length() == 0 )\n        {\n        \treturn \"\";\n        }\n        \n        int longest = 1;\n        int longestStart = 0;\n        int longestEnd = 0;\n        \n        for ( int i = 0; i < s.length(); i++ )\n        {\n        \tfor ( int left = i-1, right = i + 1; left >= 0 && right < s.length() && s.charAt( left ) == s.charAt( right ); left--, right++ )\n        \t{\n        \t\tif ( right - left + 1 > longest )\n        \t\t{\n        \t\t\tlongest = right - left + 1;\n        \t\t\tlongestStart = left;\n        \t\t\tlongestEnd = right;\n        \t\t}\n        \t}\n        }\n        \n        for ( int i = 1; i < s.length(); i++ )\n        {\n        \tfor ( int left = i - 1, right = i; left >= 0 && right < s.length() && s.charAt( left ) == s.charAt( right ); left--, right++ )\n        \t{\n        \t\tif ( right - left + 1 > longest )\n        \t\t{\n        \t\t\tlongest = right - left + 1;\n        \t\t\tlongestStart = left;\n        \t\t\tlongestEnd = right;\n        \t\t}\n        \t}\n        }\n       \n        return s.substring( longestStart, longestEnd + 1 );\n    }\t\t\n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length<3) {\n            return nums.length;\n        }\n        boolean flag=true;\n        int k=0;\n        int t=nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            t=nums[i-1];\n            nums[i-k]=nums[i];\n            if (nums[i]==t) {\n                if (flag) {\n                    flag=false;\n                }else {\n                    k++;\n                }\n            }else {\n                flag=true;\n            }\n        }\n        return nums.length-k;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class ValidPalindrome {\n  public static void main(String[] args) throws Exception {\n    System.out.println(new ValidPalindrome().isPalindrome(\"989 \"));\n  }\n\n  public boolean isPalindrome(String s) {\n    if (s == null || s.isEmpty()) return true;\n    s = s.toLowerCase();\n    for (int i = 0, j = s.length() - 1; i < j; ) {\n      char f = s.charAt(i);\n      char l = s.charAt(j);\n      if (!(f >= 'a' && f <= 'z') && !(f >= '0' && f <= '9')) {\n        i++;\n        continue;\n      }\n      if (!(l >= 'a' && l <= 'z') && !(l >= '0' && l <= '9')) {\n        j--;\n        continue;\n      }\n      if (f != l) return false;\n      i++;\n      j--;\n    }\n    return true;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    \n    public int removeDuplicates(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int i = 0;\n        int j = 0;\n        for (i = 0; i < nums.length; i++) {\n            if (nums[j] != nums[i]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "public class PlusOne {\n\tpublic int[] plusOne(int[] digits) {\n\t\tint carry = 1;\n\t\tfor (int i = digits.length - 1; i >= 0; i--) {\n\t\t\tint sum = digits[i] + carry;\n\t\t\tdigits[i] = sum % 10;\n\t\t\tcarry = sum / 10;\n\t\t\tif (sum < 10)\n\t\t\t\treturn digits;\n\t\t}\n\t\tif (carry == 1) {\n\t\t\tint[] res = new int[digits.length + 1];\n\t\t\tres[0] = 1;\n\t\t\tfor (int i = 1; i < res.length; i++)\n\t\t\t\tres[i] = digits[i - 1];\n\t\t\treturn res;\n\t\t}\n\t\treturn digits;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class SameTree2 {\n\tpublic boolean isSameTree(TreeNode p, TreeNode q) {\n\t\tif (p == null && q == null)\n\t\t\treturn true;\n\t\tif (p == null && q != null || p != null && q == null)\n\t\t\treturn false;\n\t\tStack<TreeNode> stack1= new Stack<TreeNode>();\n\t\tStack<TreeNode> stack2= new Stack<TreeNode>();\n\t\tstack1.add(p);\n\t\tstack2.add(q);\n\t\twhile(stack1.isEmpty()==false&&stack2.isEmpty()==false){\n\t\t\tif(stack1.peek().val!=stack2.peek().val)\n\t\t\t\treturn false;\n\t\t\tTreeNode temp1=stack1.pop();\n\t\t\tTreeNode temp2=stack2.pop();\n\t\t\tif(temp1.left!=null&&temp2.left!=null){\n\t\t\t\tstack1.push(temp1.left);\n\t\t\t\tstack2.push(temp2.left);\n\t\t\t}\n\t\t\tif(temp1.left!=null&&temp2.left==null||temp1.left==null&&temp2.left!=null)\n\t\t\t\treturn false;\n\t\t\tif(temp1.right!=null&&temp2.right!=null){\n\t\t\t\tstack1.push(temp1.right);\n\t\t\t\tstack2.push(temp2.right);\n\t\t\t}\n\t\t\tif(temp1.right!=null&&temp2.right==null||temp1.right==null&&temp2.right!=null)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> list = new ArrayList<String>();\n        String a = \"(\";\n        list.add(a);\n        for (int i = 1; i <= 2 * n - 1; i++) {\n            int size = list.size();\n            for (int j = 0; j < size; j++) {\n                String s = list.get(j);\n                int use = 0;\n                int have = 0;\n                for (int k = 0; k < s.length(); k++) {\n                    if (s.substring(k, k + 1).equals(\"(\")) {\n                        use++;\n                        have++;\n                    }\n                    if (s.substring(k, k + 1).equals(\")\")) {\n                        have--;\n                    }\n                }\n                if (use == n) {\n                    s += \")\";\n                    list.add(s);\n                } else if (have == 0) {\n                    s += \"(\";\n                    list.add(s);\n                } else {\n                    String sa = s + \"(\";\n                    String sb = s + \")\";\n                    list.add(sa);\n                    list.add(sb);\n                }\n            }\n            for (int j = size - 1; j >= 0; j--) {\n                list.remove(j);\n            }\n        }\n\n        return list;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class WordLadder {\n\tpublic int ladderLength(String start, String end, Set<String> dict) {\n\t\tif (start.equals(end))\n\t\t\treturn 0;\n\t\tQueue<String> words = new LinkedList<String>();\n\t\tQueue<Integer> steps = new LinkedList<Integer>();\n\t\tSet<String> unused = new HashSet<String>(dict);\n\t\tunused.remove(start);\n\t\twords.add(start);\n\t\tsteps.add(Integer.valueOf(0));\n\n\t\twhile (!words.isEmpty()) {\n\t\t\tString word = words.remove();\n\t\t\tint step = steps.remove().intValue();\n\t\t\tfor (int i = 0; i < word.length(); i++) {\n\t\t\t\tfor (char ch = 'a'; ch <= 'z'; ch++) {\n\t\t\t\t\tString newly = word.substring(0, i) + ch + word.substring(i + 1);\n\t\t\t\t\tif (newly.equals(end)) {\n\t\t\t\t\t\treturn step + 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (!newly.equals(word) && unused.contains(newly)) {\n\t\t\t\t\t\twords.add(newly);\n\t\t\t\t\t\tsteps.add(Integer.valueOf(step + 1));\n\t\t\t\t\t\tunused.remove(newly); // NOTE: put this argument here\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<Character>();\n       \n        for(int i=0;i<s.length();i++){\n            char cchar = s.charAt(i);\n        \tif(cchar=='(' || cchar=='[' || cchar=='{')\n        \t\tstack.push(cchar);\n        \telse if(!stack.empty() && (stack.peek() == cchar-1 ||stack.peek()==cchar-2))\n        \t\tstack.pop();\n        \telse \n        \t\treturn false;\n        }\n        \n        return stack.empty();\n    }\n}", "nl": "azheanda"}
{"code": "public class L094_Binary_Tree_Inorder_Traversal {\n\n\tList<Integer> rt = new ArrayList<Integer>();\n\n\tpublic List<Integer> inorderTraversal(TreeNode root) {\n\n\t\trt.clear();\n\t\tinorder(root);\n\t\treturn rt;\n\t}\n\n\tvoid inorder(TreeNode node) {\n\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tinorder(node.left);\n\t\trt.add(node.val);\n\t\tinorder(node.right);\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class ConstructBinaryTreefromInorderandPostorderTraversal {\n\tpublic TreeNode buildTree(int[] inorder, int[] postorder) {\n\t\tif (inorder.length == 0 && postorder.length == 0)\n\t\t\treturn null;\n\t\tint index = 0;\n\t\tfor (int i = 0; i < inorder.length; i++) {\n\t\t\tif (inorder[i] == postorder[postorder.length - 1]) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTreeNode root = new TreeNode(inorder[index]);\n\t\tint[] inorder1 = Arrays.copyOfRange(inorder, 0, index);\n\t\tint[] inorder2 = Arrays.copyOfRange(inorder, index + 1, inorder.length);\n\t\tint[] postorder1 = Arrays.copyOfRange(postorder, 0, index);\n\t\tint[] postorder2 = Arrays.copyOfRange(postorder, index, inorder.length - 1);\n\t\troot.left = buildTree(inorder1, postorder1);\n\t\troot.right = buildTree(inorder2, postorder2);\n\t\treturn root;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class _2_addTwoNumbers {\n\n    public static void main(String[] args) {\n        ListNode l1 = new ListNode(2);\n        l1.next = new ListNode(4);\n        l1.next.next = new ListNode(3);\n        ListNode l2 = new ListNode(5);\n        l2.next = new ListNode(6);\n        l2.next.next = new ListNode(4);\n\n        _2_addTwoNumbers addTwoNumbers = new _2_addTwoNumbers();\n        ListNode listNode = addTwoNumbers.addTwoNumbers(l1, l2);\n        Util.printListNode(listNode);\n    }\n\n    \n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyNode = new ListNode(0);\n        ListNode dummyNext = dummyNode;\n        ListNode l1Next = l1;\n        ListNode l2Next = l2;\n        int addNext = 0;\n        while (l1Next != null || l2Next != null) {\n            int v1 = l1Next != null ? l1Next.val : 0;\n            int v2 = l2Next != null ? l2Next.val : 0;\n\n            int add = v1 + v2 + addNext;\n            ListNode addNode = new ListNode(add % 10);\n            addNext = add / 10;\n            dummyNext.next = addNode;\n            dummyNext = addNode;\n            l1Next = l1Next != null ? l1Next.next : null;\n            l2Next = l2Next != null ? l2Next.next : null;\n        }\n        if (addNext != 0) {\n            ListNode addNode = new ListNode(addNext);\n            dummyNext.next = addNode;\n        }\n\n        return dummyNode.next;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class SubsetsII {\n  \n  public static void main(String[] args) throws Exception {\n    int[] n = {1, 2, 3};\n    List<List<Integer>> result = new SubsetsII().subsetsWithDup(n);\n  }\n\n  public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    result.add(new ArrayList<>()); // empty subset\n    int start = 0, newStart = 0;\n    Arrays.sort(nums);\n    for (int i = 0, l = nums.length; i < l; i++) {\n      newStart = result.size();\n      if (i == 0 || nums[i] != nums[i - 1]) {\n        start = 0;\n      }\n      for (int j = start, resLen = result.size(); j < resLen; j++) {\n        List<Integer> newList = new ArrayList<>(result.get(j));\n        newList.add(nums[i]);\n        result.add(newList);\n      }\n      start = newStart;\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Permutations3 {\n\tpublic ArrayList<ArrayList<Integer>> permute(int[] num) {\n\t\tArrayList<ArrayList<Integer>> res= new ArrayList<ArrayList<Integer>>();\n\t\tif (num == null || num.length == 0) \n\t\t\treturn res;\n\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\thelper(res, list, num);\n\t\treturn res;\n\t}\n\n\tpublic void helper(ArrayList<ArrayList<Integer>> res, ArrayList<Integer> list, int[] num) {\n\t\tif (list.size() == num.length) {\n\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < num.length; i++) {\n\t\t\tif (list.contains(num[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist.add(num[i]);\n\t\t\thelper(res, list, num);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class NextPermutation \n{\n    public void nextPermutation(int[] nums) \n    {\n        \n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<List<String>> sumList=new ArrayList<List<String>>();\n        int length=maxWidth;\n        List<String> list=new ArrayList<String>();\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].length()<=length) {\n                list.add(words[i]);\n                length-=(words[i].length()+1);\n            }else {\n                sumList.add(list);\n                list=new ArrayList<String>();\n                length=maxWidth;\n                i--;\n            }\n        }\n        if (list.size()!=0) {\n            sumList.add(list);\n        }\n        List<String> ans=new ArrayList<String>();\n        for (int i = 0; i < sumList.size()-1; i++) {\n            List<String> l=sumList.get(i);\n            if (l.size()==1) {\n                StringBuffer sb=new StringBuffer();\n                sb.append(l.get(0));\n                for (int j = 0; j < maxWidth-l.get(0).length(); j++) {\n                    sb.append(\" \");\n                }\n                System.out.println(\"sb.toString()=\"+sb.toString());\n                ans.add(sb.toString());\n            }else {\n                int totalSpace=maxWidth;\n                for (int j = 0; j < l.size(); j++) {\n                    totalSpace-=l.get(j).length();\n                }\n                int eachSpace=totalSpace/(l.size()-1);\n                int extraSpace=totalSpace-eachSpace*(l.size()-1);\n                StringBuffer sb=new StringBuffer();\n                for (int j = 0; j < l.size()-1; j++) {\n                    sb.append(l.get(j));\n                    for (int k = 0; k < eachSpace; k++) {\n                        sb.append(\" \");\n                    }\n                    if (j<extraSpace) {\n                        sb.append(\" \");\n                    }\n                }\n                sb.append(l.get(l.size()-1));\n                ans.add(sb.toString());\n            }\n        }\n        List<String> l=sumList.get(sumList.size()-1);\n        StringBuffer sb=new StringBuffer();\n        for (int i = 0; i < l.size()-1; i++) {\n            sb.append(l.get(i));\n            sb.append(\" \");\n        }\n        sb.append(l.get(l.size()-1));\n        int tt=sb.toString().length();\n        for (int j = 0; j < maxWidth-tt; j++) {\n            sb.append(\" \");\n        }\n        ans.add(sb.toString());\n        return ans;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public boolean isNumber(String s) {\n        s=s.trim();\n        if(s==\"\")\n        \treturn false;\n\n        for(int i=0;i<s.length();i++){\n\n        }\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public ListNode findMiddle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n    \n    public ListNode merge(ListNode left, ListNode right) {\n        ListNode dummy = new ListNode(0);\n        ListNode head = dummy;\n        while (left != null && right != null) {\n            if (left.val < right.val) {\n                head.next = left;\n                left = left.next;\n            } else {\n                head.next = right;\n                right = right.next;\n            }\n            head = head.next;\n        }\n        if (left != null) {\n            head.next = left;\n        } else if (right != null){\n            head.next = right;\n        }\n        return dummy.next;\n    }\n    \n    \n    public ListNode sortList(ListNode head) {  \n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode mid = findMiddle(head);\n        ListNode left = sortList(mid.next);\n        mid.next = null;\n        ListNode right = sortList(head);\n        return merge(left, right);\n    }\n    \n\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public boolean isPalindrome(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        final String str = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n        int start = 0;\n        int end = str.length() - 1;\n        while (start < end) {\n            if (str.charAt(start) != str.charAt(end)) {\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class _146_LRUCache {\n\n    public static void main(String[] args) {\n        LRUCache cache = new LRUCache(2);\n        cache.put(1, 1);\n        cache.put(2, 2);\n        System.out.println(cache.get(1));       // \u6769\u65bf\u6d16  1\n        cache.put(3, 3);    // \u7487\u30e6\u6437\u6d63\u6ec0\u7d30\u6d63\u57ae\u7df1\u7035\u55db\u631c 2 \u6d63\u6ec3\u7c3e\n        System.out.println(cache.get(2));       // \u6769\u65bf\u6d16 -1 (\u93c8\ue045\u58d8\u9352)\n        cache.put(4, 4);    // \u7487\u30e6\u6437\u6d63\u6ec0\u7d30\u6d63\u57ae\u7df1\u7035\u55db\u631c 1 \u6d63\u6ec3\u7c3e\n        System.out.println(cache.get(1));       // \u6769\u65bf\u6d16 -1 (\u93c8\ue045\u58d8\u9352)\n        System.out.println(cache.get(3));       // \u6769\u65bf\u6d16  3\n        System.out.println(cache.get(4));       // \u6769\u65bf\u6d16  4\n    }\n\n    public static class LRUCache {\n\n        private LinkedHashMap<Integer, Integer> map;\n        private int max;\n        private int cur;\n\n        public LRUCache(int capacity) {\n            max = capacity;\n            this.map = new LinkedHashMap(0, 0.75f, true);\n        }\n\n        public int get(int key) {\n            Integer integer = map.get(key);\n            if (integer == null) {\n                return -1;\n            }\n            return integer;\n        }\n\n        public void put(int key, int value) {\n            Integer put = map.put(key, value);\n            cur++;\n            if (put != null) {\n                cur--;\n            }\n            if (cur > max) {\n                Integer elder = getElder();\n                if (elder != null) {\n                    map.remove(elder);\n                    cur--;\n                }\n            }\n        }\n\n        private Integer getElder() {\n            return map.entrySet().iterator().next().getKey();\n        }\n    }\n}\n\n", "nl": "pphdsny"}
{"code": "public class HouseRobber2 {\n\tpublic int rob(int[] num) {\n\t\tif (num == null || num.length == 0)\n\t\t\treturn 0;\n\t\tint len = num.length;\n\t\tif (len == 1)\n\t\t\treturn num[0];\n\t\tif (len == 2)\n\t\t\treturn Math.max(num[0], num[1]);\n\t\tint[] dp = new int[len];\n\t\tdp[0] = num[0];\n\t\tdp[1] = Math.max(num[0], num[1]);\n\t\tdp[2] = Math.max(dp[0] + num[2], dp[1]);\n\t\tfor (int i = 3; i < len; i++) {\n\t\t\tint temp = Math.max(dp[i - 3] + num[i], dp[i - 2] + num[i]);\n\t\t\tdp[i] = Math.max(temp, dp[i - 1]);\n\n\t\t}\n\t\treturn dp[len - 1];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class SearchForARange {\n\tpublic int[] searchRange(int[] A, int target) {\n\t\tint left = 0;\n\t\tint right = A.length - 1;\n\n\t\tint[] result = { -1, -1 };\n\n\t\twhile (left <= right) {\n\t\t\tint mid = (left + right) / 2;\n\n\t\t\tif (A[mid] > target) {\n\t\t\t\tright = mid - 1;\n\t\t\t} else if (A[mid] < target) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tresult[0] = mid;\n\t\t\t\tresult[1] = mid;\n\n\t\t\t\tint i = mid - 1;\n\t\t\t\twhile (i >= 0 && A[i] == target) {\n\t\t\t\t\tresult[0] = i;\n\t\t\t\t\t--i;\n\t\t\t\t}\n\n\t\t\t\ti = mid + 1;\n\t\t\t\twhile (i < A.length && A[i] == target) {\n\t\t\t\t\tresult[1] = i;\n\t\t\t\t\t++i;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint[] A = { 1, 3, 4, 5, 5 };\n\n\t\tSearchForARange slt = new SearchForARange();\n\t\tint[] result = slt.searchRange(A, 5);\n\t\tSystem.out.println(result[0] + \" \" + result[1]);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": " public class Solution {\n    public int ladderLength(String start, String end, Set<String> dict) {\n        Queue<String> cur = new LinkedList<String>();\n        if(start.compareTo(end) == 0) return 0;\n        cur.offer(start);\n        int depth = 1;\n        Set<String> visited = new HashSet<String>();\n        while (cur.isEmpty() == false) {\n            Queue<String> queue = new LinkedList<String>();\n            while(cur.isEmpty() == false) {\n                String str = cur.poll();\n                char[] word = str.toCharArray();\n                for (int i = 0; i < word.length; ++i) {\n                    char before = word[i];\n                    for (char ch = 'a'; ch <= 'z'; ++ch) {\n                        word[i] = ch;\n                        String temp = new String(word);\n                        if (end.compareTo(temp) == 0) return depth + 1;\n                        if (dict.contains(temp) == true && visited.contains(temp) == false) {\n                            queue.offer(temp);\n                            visited.add(temp);\n                        }\n                    }\n                    word[i] = before;\n                }\n            }\n            cur = queue;\n            ++depth;\n        }\n        return 0;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> list=new ArrayList<Integer>();\n        return postorder(root,list);\n    }\n    public List<Integer> postorder(TreeNode root,List<Integer> list){\n        if (root==null) {\n            return list;\n        }\n        list=postorder(root.left,list);\n        list=postorder(root.right, list);\n        list.add(root.val);\n        return list;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class L169_Majority_Element {\n\n\tpublic int majorityElement(int[] nums) {\n\n\t\tint m = nums[0];\n\t\tint c = 1;\n\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif (m == nums[i]) {\n\t\t\t\tc++;\n\t\t\t} else if (c > 1) {\n\t\t\t\tc--;\n\t\t\t} else {\n\t\t\t\tm = nums[i];\n\t\t\t}\n\t\t}\n\n\t\treturn m;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class L021_Merge_Two_Sorted_Lists {\n\n\tpublic static class ListNode {\n\t\tint val;\n\t\tListNode next;\n\n\t\tListNode(int x) {\n\t\t\tval = x;\n\t\t}\n\t}\n\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\n\t\tif (l1 == null && l2 == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (l1 == null) {\n\t\t\treturn l2;\n\t\t}\n\n\t\tif (l2 == null) {\n\t\t\treturn l1;\n\t\t}\n\n\t\tListNode p = new ListNode(0);\n\t\tListNode head = p;\n\n\t\twhile (l1 != null && l2 != null) {\n\n\t\t\tif (l1.val < l2.val) {\n\t\t\t\tp.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t} else {\n\t\t\t\tp.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t}\n\n\t\tif (l1 != null) {\n\t\t\tp.next = l1;\n\t\t} else {\n\t\t\tp.next = l2;\n\t\t}\n\n\t\treturn head.next;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class RestoreIPAddresses {\n\n    public class Solution {\n        private String toAddr(ArrayList<Integer> solution) {\n            String addr = \"\";\n            addr += solution.get(0);\n            addr += \".\";\n            addr += solution.get(1);\n            addr += \".\";\n            addr += solution.get(2);\n            addr += \".\";\n            addr += solution.get(3);\n            return addr;\n        }\n\n        private void search(String s, int begin, ArrayList<Integer> solution,\n                ArrayList<String> solutions) {\n            if (begin == s.length() && solution.size() == 4) {\n                solutions.add(toAddr(solution));\n                return;\n            }\n            if (s.length() - begin > (4 - solution.size()) * 3) {\n                return;\n            }\n            if (s.length() - begin < 4 - solution.size()) {\n                return;\n            }\n            int num = 0;\n            for (int i = begin; i < Math.min(begin + 3, s.length()); i++) {\n                num = num * 10 + s.charAt(i) - '0';\n                if (num < 256) {\n                    solution.add(num);\n                    search(s, i + 1, solution, solutions);\n                    solution.remove(solution.size() - 1);\n                }\n                if (num == 0) {\n                    break;\n                }\n            }\n        }\n\n        public ArrayList<String> restoreIpAddresses(String s) {\n            ArrayList<String> solutions = new ArrayList<String>();\n            search(s, 0, new ArrayList<Integer>(), solutions);\n            return solutions;\n        }\n    }\n\n    public static class UnitTest {\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class L207_Course_Schedule {\n\n\tpublic static boolean canFinish(int numCourses, int[][] prerequisites) {\n\n\t\tif (prerequisites == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint len = prerequisites.length;\n\t\tif (numCourses <= 0 || len == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tint[] pCounter = new int[numCourses];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tpCounter[prerequisites[i][0]]++;\n\t\t}\n\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tif (pCounter[i] == 0) {\n\t\t\t\tqueue.add(i);\n\t\t\t}\n\t\t}\n\n\t\tint numNoPre = queue.size();\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint top = queue.remove();\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (prerequisites[i][1] == top) {\n\t\t\t\t\tpCounter[prerequisites[i][0]]--;\n\t\t\t\t\tif (pCounter[prerequisites[i][0]] == 0) {\n\t\t\t\t\t\tnumNoPre++;\n\t\t\t\t\t\tqueue.add(prerequisites[i][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn numNoPre == numCourses;\n\t}\n\n\tpublic static boolean canFinish2(int numCourses, int[][] prerequisites) {\n\n\t\tif (prerequisites == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint len = prerequisites.length;\n\t\tif (numCourses <= 0 || len == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tint[] visit = new int[numCourses];\n\n\t\tHashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>>();\n\n\t\tfor (int[] p : prerequisites) {\n\t\t\tif (map.containsKey(p[1])) {\n\t\t\t\tmap.get(p[1]).add(p[0]);\n\t\t\t} else {\n\t\t\t\tArrayList<Integer> l = new ArrayList<Integer>();\n\t\t\t\tl.add(p[0]);\n\t\t\t\tmap.put(p[1], l);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tif (!canFinishDFS(map, visit, i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static boolean canFinishDFS(\n\t\t\tHashMap<Integer, ArrayList<Integer>> map, int[] visit, int i) {\n\n\t\tif (visit[i] == -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (visit[i] == 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\tvisit[i] = -1;\n\n\t\tif (map.containsKey(i)) {\n\t\t\tfor (int j : map.get(i)) {\n\t\t\t\tif (!canFinishDFS(map, visit, j)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvisit[i] = 1;\n\n\t\treturn true;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class FlattenBinaryTreetoLinkedList {\n\n    public class Solution {\n        private TreeNode flattenTree(TreeNode root) {\n            if (root == null) {\n                return null;\n            }\n            TreeNode tail = root;\n            TreeNode right = root.right;\n            if (root.left != null) {\n                tail = flattenTree(root.left);\n                root.right = root.left;\n                tail.right = right;\n                root.left = null;\n            }\n            if (right != null) {\n                tail = flattenTree(right);\n            }\n            return tail;\n        }\n\n        public void flatten(TreeNode root) {\n            flattenTree(root);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int x=matrix.length-1;\n        int y=0;\n        while (x>=0&&y<matrix[x].length) {\n            if (matrix[x][y]==target) {\n                return true;\n            }\n            if (matrix[x][y]>target) {\n                x--;\n            }else {\n                y++;\n            }\n        }\n        return false;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class RemoveDuplicatesfromSortedList {\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\t\tif (head == null || head.next == null)\n\t\t\treturn head;\n\n\t\tListNode prev = head;\n\t\tListNode p = head.next;\n\t\twhile (p != null) {\n\t\t\tif (p.val == prev.val) {\n\t\t\t\tprev.next = p.next;\n\t\t\t\tp = p.next;\n\t\t\t} else {\n\t\t\t\tprev = p;\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class CombinationSum4 {\n\n  \n  public int combinationSum4(int[] nums, int target) {\n    int[] comb = new int[target + 1];\n    comb[0] = 1;\n    for (int i = 1; i < comb.length; i++) {\n      for (int j = 0; j < nums.length; j++) {\n        if (i - nums[j] >= 0) { // Array's not sorted. Need to check each number.\n          comb[i] += comb[i - nums[j]];\n        }\n      }\n    }\n    return comb[target];\n  }\n\n  \n  public int combinationSum4TopDown(int[] nums, int target) {\n    int[] dp = new int[target + 1];\n    Arrays.fill(dp, -1);\n    return helper(nums, target, dp);\n  }\n\n  private int helper(int[] nums, int target, int[] dp) {\n    if (target == 0) {\n      return 1;\n    }\n    if (dp[target] != -1) {\n      return dp[target];\n    }\n    int res = 0;\n    for (int i = 0; i < nums.length; i++) {\n      if (target >= nums[i]) {\n        res += helper(nums, target - nums[i], dp);\n      }\n    }\n    dp[target] = res;\n    return res;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices.length <= 1) {\n            return 0;\n        }\n        int[] change = new int[prices.length - 1];\n        for (int i = 0; i < change.length; i++) {\n            change[i] = prices[i + 1] - prices[i];\n        }\n        int sum = 0;\n        int s = 0;\n        int begin = 0;\n        int end = 0;\n        for (int i = 0; i < change.length; i++) {\n            s += change[i];\n            if (s < 0) {\n                s = 0;\n                begin = i + 1;\n                end = i + 1;\n            }\n            if (change[i] > 0) {\n                end = i;\n            }\n            if (s > sum) {\n                sum = s;\n            }\n\n        }\n        return sum;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i]>nums[j]) {\n                    int temp=nums[i];\n                    nums[i]=nums[j];\n                    nums[j]=temp;\n                }\n            }\n        }\n        int[] n=new int[nums.length];\n        int sum=1;\n        for (int i = 0; i < n.length; i++) {\n            n[i]=sum;\n            sum*=2;\n        }\n        List<List<Integer>> answer=new ArrayList<List<Integer>>();\n        for (int i = 0; i < sum; i++) {\n            List<Integer> list=new ArrayList<Integer>();\n            for (int j = 0; j < nums.length; j++) {\n                if ((i/n[j])%2==1) {\n                    list.add(nums[j]);\n                }\n            }\n            answer.add(list);\n        }\n        return answer;\n    }\n}", "nl": "corpsepiges"}
{"code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) {\n            return 0;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] heightMap = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == '0') {\n                    heightMap[i][j] = 0;\n                } else {\n                    heightMap[i][j] = i == 0 ? 1 : heightMap[i - 1][j] + 1;\n                }\n            }\n        }\n        \n        int maxArea = 0;\n        for (int i = 0; i < m; i++) {\n            maxArea = Math.max(maxArea, findLargestRectInHistogram(heightMap[i]));\n        }\n\n        return maxArea;\n    }\n    \n    private int findLargestRectInHistogram(int[] height) {\n        Stack<Integer> stack = new Stack<>();\n        int m = height.length;\n        int max = 0;\n        for (int i = 0; i <= m; i++) {\n            int currHeight = i == m ? -1 : height[i];\n            while (!stack.isEmpty() && currHeight <= height[stack.peek()]) {\n                int peekHeight = height[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                max = Math.max(max, peekHeight * width);\n            }\n            stack.push(i);\n        }\n        return max;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "class CombinationSum2 {\n  public static void main(String[] args) {\n    int[] candidates = {10, 1, 2, 7, 6, 1, 5};\n    int tar = 8;\n    List<List<Integer>> solution = new CombinationSum2().dfs(candidates, tar);\n    for (List<Integer> l : solution) System.out.println(l.toString());\n  }\n\n  public List<List<Integer>> dfs(int[] num, int target) {\n    if (num == null || num.length == 0) {\n      return Collections.emptyList();\n    }\n    final List<List<Integer>> res = new ArrayList<>();\n    Arrays.sort(num);\n    dfs(num, target, 0, new ArrayList<>(), res);\n    return res;\n  }\n\n  \n  public void dfs(int[] num, int target, int index, List<Integer> comb, List<List<Integer>> result) {\n    if (target == 0) {\n      result.add(new ArrayList<>(comb));\n      return;\n    }\n\n    for (int i = index; i < num.length; i++) {\n      int newTarget = target - num[i];\n      if (newTarget >= 0) {\n        comb.add(num[i]);\n        dfs(num, newTarget, i + 1, comb, result);\n        comb.remove(comb.size() - 1);\n      } else {\n        break;\n      }\n      while (i < num.length - 1 && num[i] == num[i + 1]) {\n        i++; // Move i to the end of the duplicates\n      }\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class UniqueBinarySearchTrees {\n\tpublic int numTrees(int n) {\n\t\tint[] num = new int[n + 1];\n\t\tnum[0] = 1;\n\t\tnum[1] = 1;\n\n\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\t\tnum[i] += num[j - 1] * num[i - j];\n\t\t\t}\n\t\t}\n\n\t\treturn num[n];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tUniqueBinarySearchTrees slt = new UniqueBinarySearchTrees();\n\t\tint res = slt.numTrees(3);\n\t\tSystem.out.println(res);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode cur = dummy;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int sum = carry;\n            if (l1 != null) {\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            carry = sum/10;\n            sum = sum%10;\n            ListNode node = new ListNode(sum);\n            cur.next = node;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}", "nl": "leetcoders"}
{"code": "class Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> rst = new ArrayList<>();\n        if (root == null) {\n            return rst;\n        }\n        rst.addAll(postorderTraversal(root.left));\n        rst.addAll(postorderTraversal(root.right));\n        rst.add(root.val);\n\n        return rst;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class BinaryTreePostorderTraversal2 {\n\tpublic List<Integer> postorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (root == null)\n\t\t\treturn list;\n\t\thelper(root, list);\n\t\treturn list;\n\t}\n\n\tpublic void helper(TreeNode root, ArrayList<Integer> list) {\n\t\tif (root != null) {\n\t\t\thelper(root.left, list);\n\t\t\thelper(root.right, list);\n\t\t\tlist.add(root.val);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class CloneGraph {\n\n  \n  public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n    if (node == null) return null;\n    Map<Integer, UndirectedGraphNode> map = new HashMap<>();\n    return dfs(node, map);\n  }\n\n  \n  private UndirectedGraphNode dfs(UndirectedGraphNode node, Map<Integer, UndirectedGraphNode> cloned) {\n    if (cloned.containsKey(node.label)) {\n      return cloned.get(node.label);\n    }\n    cloned.put(node.label, new UndirectedGraphNode(node.label));\n    for (int i = 0; i < node.neighbors.size(); i++) {\n      cloned.get(node.label).neighbors.add(dfs(node.neighbors.get(i), cloned));\n    }\n    return cloned.get(node.label);\n  }\n\n  \n  public UndirectedGraphNode cloneGraph2(UndirectedGraphNode node) {\n    if (node == null) {\n      return null;\n    }\n    Queue<UndirectedGraphNode> q = new ArrayDeque<>();\n    Map<Integer, UndirectedGraphNode> cloned = new HashMap<>(); // Cloned graph nodes.\n    q.offer(node);\n    cloned.put(node.label, new UndirectedGraphNode(node.label));\n    while (!q.isEmpty()) {\n      UndirectedGraphNode cur = q.poll();\n      if (!cloned.containsKey(cur.label))\n        cloned.put(cur.label, new UndirectedGraphNode(cur.label)); // Put in map to set as visited.\n      if (cur.neighbors != null) {\n        for (UndirectedGraphNode n : cur.neighbors) {\n          if (!cloned.containsKey(n.label)) { // Add all unvisited neighbors to the queue.\n            q.offer(n);\n            cloned.put(n.label, new UndirectedGraphNode(n.label));\n          }\n          cloned.get(cur.label).neighbors.add(cloned.get(n.label));\n        }\n      }\n    }\n    return cloned.get(node.label);\n  }\n\n  class UndirectedGraphNode {\n    int label;\n    List<UndirectedGraphNode> neighbors;\n\n    UndirectedGraphNode(int x) {\n      label = x;\n      neighbors = new ArrayList<>();\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SqrtX {\n\n    public class Solution {\n        public int sqrt(int a) {\n            double x = 1.0;\n            while (Math.abs(x * x - a) > 10E-6) {\n                x = (x + a / x) / 2;\n            }\n            return (int) x;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public int jump(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int n = nums.length;\n        int start = 0, end = 0, steps = 0;\n        while (end < n - 1) {\n            steps++; //Cound step everytime when pEnd is moving to the farthest.\n            int farthest = 0;\n            for (int i = start; i <= end; i++) {\n                farthest = Math.max(farthest, i + nums[i]);\n                if (farthest >= n - 1) {\n                    return steps;\n                }\n            }\n            start = end + 1;\n            end = farthest;\n        }\n        return 0;  //This is the case where no solution can be found.\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class RemoveDuplicatesfromSortedListII {\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn head;\n\t\tListNode helper = new ListNode(0);\n\t\thelper.next = head;\n\t\tListNode pre = helper;\n\t\tListNode cur = head;\n\t\twhile (cur != null) {\n\t\t\twhile (cur.next != null && pre.next.val == cur.next.val) \n\t\t\t\tcur = cur.next;\n\t\t\tif (pre.next == cur) {\n\t\t\t\tpre = pre.next;\n\t\t\t} else {\n\t\t\t\tpre.next = cur.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn helper.next;\n\t}\n}\n\n\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        Comparator<Interval> comp =  new Comparator<Interval>(){  \n            public int compare(Interval a,  Interval b) {  \n                if(a.start < b.start) {  \n                    return -1;  \n                }else if(a.start > b.start){  \n                    return 1;  \n                } else {\n                    if (a.end < b.end) return -1;\n                    else if (a.end > b.end) return 1;\n                    return 0;  \n                }  \n            }  \n        };\n        ArrayList<Interval> res = new ArrayList<Interval>();\n        int N = intervals.size();\n        if (N <= 1) return intervals;\n        Collections.sort(intervals, comp);\n        Interval last = intervals.get(0);\n        for (int i = 0; i < N; ++i) {\n            if (intervals.get(i).start > last.end) {\n                res.add(last);\n                last = intervals.get(i);\n            } else {\n                last.end = Math.max(last.end, intervals.get(i).end);\n            }\n        }\n        res.add(last);\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class SortColors {\n\tpublic void sortColors(int[] A) {\n\t\tint red = 0, white = 0, blue = 0;\n\t\tfinal int RED = 0, WHITE = 1, BLUE = 2;\n\t\tint i;\n\t\tfor (i = 0; i < A.length; i++) {\n\t\t\tif (A[i] == RED)\n\t\t\t\tred++;\n\t\t\tif (A[i] == WHITE)\n\t\t\t\twhite++;\n\t\t\tif (A[i] == BLUE)\n\t\t\t\tblue++;\n\t\t}\n\t\ti = 0;\n\t\twhile (i < A.length) {\n\t\t\tif (red-- != 0)\n\t\t\t\tA[i++] = 0;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (i < A.length) {\n\t\t\tif (white-- != 0)\n\t\t\t\tA[i++] = 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (i < A.length) {\n\t\t\tif (blue-- != 0)\n\t\t\t\tA[i++] = 2;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class InsertInterval2 {\n\tpublic ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n\t\tArrayList<Interval> result = new ArrayList<Interval>();\n\t\tfor (Interval interval : intervals) {\n\t\t\tif (interval.end < newInterval.start) {\n\t\t\t\tresult.add(interval);\n\t\t\t} else if (interval.start > newInterval.end) {\n\t\t\t\tresult.add(newInterval);\n\t\t\t\tnewInterval = interval;        // \u95c8\u70b2\u7236\u5bb8\u0443\ue6fe\n\t\t\t} else if (interval.end >= newInterval.start || interval.start <= newInterval.end) {\n\t\t\t\tnewInterval = new Interval(Math.min(interval.start, newInterval.start), Math.max(newInterval.end,\n\t\t\t\t\t\tinterval.end));\n\t\t\t}\n\t\t}\n\t\tresult.add(newInterval);             // \u93c8\u935a\u5e9d\u7af4\u6d93\ue043\u7bc3\u95b2\u5d85\u5f54\u93c3\u8bb9\u7d1d\u6d93\u5a41\u7af4\u6d93\ue044\u60ca\u941c\ue219\u7d8b\u93c3\u72b3\u7876\u5a23\u8bf2\u59de\u9422\u71b8\u579a\u9428\u5235ewInterval\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L065_Valid_Number {\n\n\tpublic boolean isNumber(String s) {\n\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tchar[] chars = s.toCharArray();\n\t\tint start = 0, end = chars.length - 1;\n\n\t\twhile ((start < end) && chars[start] == ' ') {\n\t\t\tstart++;\n\t\t}\n\t\twhile ((start < end) && chars[end] == ' ') {\n\t\t\tend--;\n\t\t}\n\n\t\tif (chars[start] == ' ') {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean dot = false;\n\t\tboolean num = false;\n\t\tboolean ex = false;\n\n\t\tfor (int i = start; i <= end; i++) {\n\n\t\t\tchar c = chars[i];\n\n\t\t\tif (c >= '0' && c <= '9') {\n\t\t\t\tnum = true;\n\t\t\t} else if (c == 'e') {\n\t\t\t\tif (ex)\n\t\t\t\t\treturn false;\n\t\t\t\tif (!num)\n\t\t\t\t\treturn false;\n\n\t\t\t\tex = true;\n\t\t\t\tnum = false;\n\t\t\t\tdot = false;\n\t\t\t} else if (c == '.') {\n\t\t\t\tif (dot) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdot = true;\n\t\t\t} else if (c == '+' || c == '-') {\n\t\t\t\tif (num || dot) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn num;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class JumpGameII {\n  \n  public static void main(String[] args) throws Exception {}\n\n  public int jump(int[] nums) {\n    int step = 0;\n    int e = 0, max = 0;\n    for (int i = 0; i < nums.length - 1; i++) {\n      max = Math.max(max, i + nums[i]);\n      if (i == e) {\n        step++;\n        e = max;\n      }\n    }\n    return step;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class AddTwoNumbers {\n\n    public class Solution {\n        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n            ListNode head = null;\n            ListNode prev = null;\n            int carry = 0;\n            while (l1 != null || l2 != null) {\n                int i1 = l1 == null ? 0 : l1.val;\n                int i2 = l2 == null ? 0 : l2.val;\n                int sum = i1 + i2 + carry;\n                ListNode node = new ListNode(sum % 10);\n                carry = sum / 10;\n                if (prev == null) {\n                    head = prev = node;\n                } else {\n                    prev.next = node;\n                    prev = node;\n                }\n                if (l1 != null) {\n                    l1 = l1.next;\n                }\n                if (l2 != null) {\n                    l2 = l2.next;\n                }\n            }\n            if (carry > 0) {\n                prev.next = new ListNode(carry);\n            }\n            return head;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public void rotate(int[][] matrix) {\n        if (matrix == null || matrix[0].length == 0) {\n            return;\n        }\n        int n = matrix.length;\n        for (int i = 0; i < n / 2; i++){\n            for (int j = 0; j < n; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - 1 - i][j];//(n-1) is end index, then, matrix[(n-1) - i] means the Symmetry element opposed item matrix[i]\n                matrix[n - 1 - i][j] = temp;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {//Skip j = i, which is the diagnal. It's not necessary, so we do j = i + 1\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class RotateList {\n  public ListNode rotateRight(ListNode head, int n) {\n    if (head == null) return head;\n    int length = 1;\n    ListNode last = head;\n    while (last.next != null) {\n      last = last.next;\n      length++;\n    }\n    n = n % length;\n    if (n == 0) return head;\n    int steps = length - n;\n    ListNode start = new ListNode(0);\n    start.next = head;\n    while (steps > 0) {\n      start = start.next;\n      steps--;\n    }\n    ListNode ret = start.next;\n    start.next = null;\n    last.next = head;\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class MaximalRectangle\n{\n    public int minDistance(String word1, String word2) \n    {\n        return 0;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class TwoSum {\n\n    \n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> indices = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int n = target - nums[i];\n            if (indices.containsKey(n)) {\n                return new int[]{indices.get(n), i};\n            }\n            indices.put(nums[i], i);\n        }\n        return new int[]{-1, -1};\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class L067_Add_Binary {\n\n\tpublic static String addBinary(String a, String b) {\n\n\t\tif (a == null || b == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tchar[] ca = a.toCharArray();\n\t\tchar[] cb = b.toCharArray();\n\n\t\tint n = Math.max(ca.length, cb.length);\n\n\t\tint[] s = new int[n + 1];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] += toInt(ca, ca.length - 1 - i) + toInt(cb, cb.length - 1 - i);\n\t\t\ts[i + 1] = s[i] / 2;\n\t\t\ts[i] %= 2;\n\t\t}\n\n\t\tString result = \"\";\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tresult = result + s[i];\n\t\t}\n\n\t\tif (s[n] == 1) {\n\t\t\tresult = \"1\" + result;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static int toInt(char c) {\n\t\tif (c >= '0') {\n\t\t\treturn c - '0';\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static int toInt(char[] chars, int index) {\n\t\tif (index >= 0 && index < chars.length) {\n\t\t\treturn toInt(chars[index]);\n\t\t}\n\t\treturn 0;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Subsets {\n  \n  public static void main(String[] args) throws Exception {\n    int[] n = {1, 2, 3};\n    List<List<Integer>> result = new Subsets().subsets(n);\n  }\n\n  public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    result.add(new ArrayList<>()); // empty subset\n    for (int i = 0, l = nums.length; i < l; i++) {\n      for (int j = 0, resLen = result.size(); j < resLen; j++) {\n        List<Integer> newList = new ArrayList<>(result.get(j));\n        newList.add(nums[i]);\n        result.add(newList);\n      }\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class GrayCode \n{\n    public List<Integer> grayCode(int n)\n    {\n        return new ArrayList<>();\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root==null) {\n            return false;\n        }\n        boolean flag1=false;\n        if (root.val==sum&&root.left==null&&root.right==null) {\n            return true;\n        }\n        if (root.left!=null) {\n            flag1=hasPathSum(root.left, sum-root.val);\n        }\n        if (flag1) {\n            return true;\n        }\n        if (root.right!=null) {\n            return hasPathSum(root.right, sum-root.val);\n        }\n        return false;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public int maxSubArray(int[] A) {\n        if (A == null || A.length == 0) {\n            return 0;\n        }\n        int[] sum = new int[A.length];\n        sum[0] = A[0];\n        int max = sum[0];\n        for (int i = 1; i < sum.length; i++) {\n            sum[i] = Math.max(A[i], sum[i - 1] + A[i]);\n            max = Math.max(max, sum[i]);\n        }\n        return max;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int longestValidParentheses(String s) {\n        int length=s.length();\n        if (length==0) {\n            return 0;\n        }\n        int ans=0;\n        char[] c=s.toCharArray();\n        int[] vals=new int[length];\n        for (int i = length-2; i >= 0; i--) {\n            if (c[i]=='(') {\n                int t=i+1+vals[i+1];\n                if (t<length&&c[t]==')') {\n                    vals[i]=vals[i+1]+2;\n                    vals[i]+=((t+1<length)?vals[t+1]:0);\n                    ans=ans<vals[i]?vals[i]:ans;\n                }\n            }\n        }\n        return ans;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class SearchforaRange {\n\tpublic int[] searchRange(int[] A, int target) {\n\t\tint mid = 0;\n\t\tint start = 0, end = A.length - 1;\n\t\tint[] index = { -1, -1 };\n\t\tboolean flag = true;\n\t\twhile (start <= end) {\n\t\t\tmid = (start + end) >> 1;\n\t\t\tif (A[mid] == target) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (A[mid] > target)\n\t\t\t\tend = mid - 1;\n\t\t\telse\n\t\t\t\tstart = mid + 1;\n\t\t}\n\t\tif (flag)\n\t\t\treturn index;\n\t\tint right = mid;\n\t\twhile (right < A.length && A[right] == target)\n\t\t\tright++;\n\t\tint left = mid;\n\t\twhile (left >= 0 && A[left] == target)\n\t\t\tleft--;\n\t\tindex[0] = left + 1;\n\t\tindex[1] = right - 1;\n\t\treturn index;\n\t}\n\n}\n", "nl": "gaohannk"}
{"code": "public class MaximumDepthOfBinaryTree {\n  public int maxDepth(TreeNode root) {\n    if (root == null) return 0;\n    int ret = 1;\n    int currentLevel = 1;\n    int nextLevel = 0;\n    Queue<TreeNode> queue = new LinkedList<TreeNode>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      TreeNode node = queue.remove();\n      currentLevel--;\n      if (node.left != null) {\n        queue.add(root.left);\n        nextLevel++;\n      }\n      if (node.right != null) {\n        queue.add(root.right);\n        nextLevel++;\n      }\n      if (currentLevel == 0) {\n        if (nextLevel != 0) {\n          ret++;\n        }\n        currentLevel = nextLevel;\n        nextLevel = 0;\n      }\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class GenerateParentheses2 {\n\tpublic class Solution {\n\t\tpublic List<String> generateParenthesis(int n) {\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tString str = \"\";\n\t\t\tgenerateParenthesis(1, 0, n, str + \"(\", list);\n\t\t\treturn list;\n\t\t}\n\t\tpublic void generateParenthesis(int left, int right, int n, String str,\n\t\t\t\tList<String> list) {\n\t\t\tif (left + right == 2 * n)\n\t\t\t\tlist.add(str);\n\t\t\tif (left < n) \n\t\t\t\tgenerateParenthesis(left + 1, right, n, str + \"(\", list);\t\t\t\n\t\t\tif (right < left) \n\t\t\t\tgenerateParenthesis(left, right + 1, n, str + \")\", list);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Subsets2 {\n\tpublic ArrayList<ArrayList<Integer>> subsets(int[] S) {\n\t\tArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<Integer> tmp = new ArrayList<Integer>();\n\t\tArrays.sort(S);\n\t\tres.add(tmp);\n\t\tdfs(res, tmp, S, 0);\n\t\treturn res;\n\t}\n\n\tpublic void dfs(ArrayList<ArrayList<Integer>> res, ArrayList<Integer> tmp, int[] S, int pos) {\n\t\tfor (int i = pos; i <= S.length - 1; i++) {\n\t\t\ttmp.add(S[i]);\n\t\t\tres.add(new ArrayList<Integer>(tmp));\n\t\t\tdfs(res, tmp, S, i + 1);\n\t\t\ttmp.remove(tmp.size() - 1);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ValidateBinarySearchTree {\n\n  TreeNode pred = null;\n\n  \n  public boolean isValidBST(TreeNode root) {\n    if (root == null) {\n      return true;\n    }\n    TreeNode temp = null;\n    if (root.left != null) {\n      temp = root.left;\n      while (temp.right != null) {\n        temp = temp.right;\n      }\n      if (temp.val >= root.val) {\n        return false;\n      }\n    }\n    if (root.right != null) {\n      temp = root.right;\n      while (temp.left != null) {\n        temp = temp.left;\n      }\n      if (temp.val <= root.val) {\n        return false;\n      }\n    }\n    return isValidBST(root.left) && isValidBST(root.right);\n  }\n\n  \n  public boolean isValidBST2(TreeNode root) {\n    if (root == null) {\n      return true;\n    }\n    if (!isValidBST2(root.left)) {\n      return false;\n    }\n    if (pred != null && pred.val >= root.val) {\n      return false;\n    }\n    pred = root; // A bit of anti-pattern, using a field value.\n    if (!isValidBST2(root.right)) {\n      return false;\n    }\n    return true;\n  }\n\n  \n  public boolean isValidBST3(TreeNode root) {\n    return isValidBST3(root, Integer.MIN_VALUE - 1, Integer.MAX_VALUE + 1);\n  }\n\n  private boolean isValidBST3(TreeNode root, long min, long max) {\n    return root == null ||\n        root.val > min && root.val < max && isValidBST3(root.left, min, root.val) && isValidBST3(root.right, root.val, max);\n  }\n\n  \n  public boolean isValidBST4(TreeNode root) {\n    if (root == null) {\n      return true;\n    }\n    List<Integer> values = new ArrayList<>();\n    inOrderTraversal(root, values);\n    for (int i = 0; i < values.size() - 1; i++) {\n      if (values.get(i) >= values.get(i + 1)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private void inOrderTraversal(TreeNode root, List<Integer> res) {\n    if (root == null) {\n      return;\n    }\n    inOrderTraversal(root.left, res);\n    res.add(root.val);\n    inOrderTraversal(root.right, res);\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class RotateList {\n\n    public class Solution {\n        public ListNode rotateRight(ListNode head, int n) {\n            if (head == null) {\n                return head;\n            }\n            int k = n;\n            int listSize = 0;\n            ListNode end = head;\n            while (k > 0) {\n                end = end.next;\n                k--;\n                listSize++;\n                if (end == null) {\n                    k = n % listSize;\n                    end = head;\n                    while (k > 0) {\n                        end = end.next;\n                        k--;\n                    }\n                    break;\n                }\n            }\n            if (head == end) {\n                return head;\n            }\n            ListNode start = head;\n            while (end.next != null) {\n                end = end.next;\n                start = start.next;\n            }\n            end.next = head;\n            head = start.next;\n            start.next = null;\n            return head;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    \n    public TreeNode sortedListToBST(ListNode head) {  \n        if (head == null) {\n            return null;\n        } else if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        \n        ListNode mid = findMiddle(head);\n        TreeNode root = new TreeNode(mid.next.val);\n        TreeNode right = sortedListToBST(mid.next.next);\n        mid.next = null;\n        TreeNode left = sortedListToBST(head);\n       \n        root.left = left;\n        root.right = right;\n        return root;\n    }\n    \n    \n    public ListNode findMiddle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class AddBinary {\n  public String addBinary(String a, String b) {\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n    int da = 0;\n    int db = 0;\n    int adv = 0;\n    StringBuffer result = new StringBuffer();\n    while (i >= 0 && j >= 0) {\n      da = a.charAt(i--) == '0' ? 0 : 1;\n      db = b.charAt(j--) == '0' ? 0 : 1;\n      int d = da + db + adv;\n      result.append(d % 2 == 0 ? '0' : '1');\n      adv = d >> 1;\n    }\n    if (i >= 0) {\n      while (i >= 0) {\n        da = a.charAt(i--) == '0' ? 0 : 1;\n        int d = da + adv;\n        result.append(d % 2 == 0 ? '0' : '1');\n        adv = d >> 1;\n      }\n    } else if (j >= 0) {\n      while (j >= 0) {\n        db = b.charAt(j--) == '0' ? 0 : 1;\n        int d = db + adv;\n        result.append(d % 2 == 0 ? '0' : '1');\n        adv = d >> 1;\n      }\n    }\n    if (adv == 1) {\n      result.append('1');\n    }\n    return result.reverse().toString();\n  }\n}\n", "nl": "mengli"}
{"code": "public class SwapNodesinPairs {\n\n    public class Solution {\n        public ListNode swapPairs(ListNode head) {\n            ListNode first = head;\n            ListNode pre = null;\n            while (first != null && first.next != null) {\n                ListNode second = first.next;\n                if (pre == null) {\n                    head = second;\n                } else {\n                    pre.next = second;\n                }\n                pre = first;\n                first.next = second.next;\n                second.next = first;\n                first = first.next;\n            }\n            return head;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class L114_Flatten_Binary_Tree_to_Linked_List {\n\n\tTreeNode prev;\n\n\tvoid preorder(TreeNode root) {\n\n\t\tif (root == null)\n\t\t\treturn;\n\n\t\tTreeNode left = root.left;\n\t\tTreeNode right = root.right;\n\n\t\tif (prev != null) {\n\t\t\tprev.right = root;\n\t\t\tprev.left = null;\n\t\t}\n\n\t\tprev = root;\n\n\t\tpreorder(left);\n\t\tpreorder(right);\n\t}\n\n\tpublic void flatten(TreeNode root) {\n\t\tprev = null;\n\t\tpreorder(root);\n\t}\n\n}", "nl": "LjyYano"}
{"code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle == null || needle.length() == 0) {\n            return 0;\n        }\n        if (needle.length() > haystack.length()) {\n            return -1;\n        }\n        int n = haystack.length();\n        int m = needle.length();\n        for (int i = 0; i < n; i++) {\n            if (n - i < m) {\n                return -1;\n            }\n            if (haystack.charAt(i) != needle.charAt(0)) {\n                continue;\n            }\n            \n            if (haystack.substring(i, i + m).equals(needle)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node == null || node.neighbors.size() == 0) {\n            return node;\n        }\n\n        HashMap<UndirectedGraphNode, UndirectedGraphNode> map = \n            new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n        Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n\n        queue.offer(node);\n        while (!queue.isEmpty()) {\n            UndirectedGraphNode curr = queue.poll();\n            UndirectedGraphNode newNode;\n            if (!map.containsKey(curr)) {\n                map.put(curr, new UndirectedGraphNode(curr.label));\n            }\n            UndirectedGraphNode newNode = map.get(curr);\n            for (UndirectedGraphNode neighbor : curr.neighbors) {\n                UndirectedGraphNode newNeighbor;\n                if (!map.containsKey(neighbor)) {\n                    map.put(neighbor, new UndirectedGraphNode(neighbor.label));\n                }\n                newNeighbor = map.get(neighbor);\n\n                newNode.neighbors.add(newNeighbor);\n            }//end for\n\n        }//end while\n\n        return map.get(node);        \n    }\n}\n\n  \n\n\n\n", "nl": "awangdev"}
{"code": "public class CourseSchedule {\n\n    public class Solution {\n        public boolean canFinish(int numCourses, int[][] prerequisites) {\n            Map<Integer, List<Integer>> outNodes = new HashMap<Integer, List<Integer>>();\n            int[] inDegree = new int[numCourses];\n            Set<Integer> courses = new HashSet<Integer>(numCourses);\n            for (int i = 0; i < numCourses; i++) {\n                courses.add(i);\n                outNodes.put(i, new ArrayList<Integer>());\n            }\n            for (int[] edge : prerequisites) {\n                int from = edge[1];\n                int to = edge[0];\n                inDegree[to]++;\n                List<Integer> nodes = outNodes.get(from);\n                nodes.add(to);\n            }\n            while (!courses.isEmpty()) {\n                List<Integer> toRemoved = new ArrayList<Integer>();\n                for (int course : courses) {\n                    if (inDegree[course] == 0) {\n                        toRemoved.add(course);\n                        for (int node : outNodes.get(course)) {\n                            inDegree[node]--;\n                        }\n                    }\n                }\n                if (toRemoved.isEmpty()) {\n                    return false;\n                }\n                courses.removeAll(toRemoved);\n            }\n            return true;\n        }\n    }\n\n}\n\n", "nl": "zsxwing"}
{"code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        s = s.trim();\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == ' ') {\n                return s.length() - i - 1;\n            }\n        }\n\n        return s.length();\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class HIndex {\n\tpublic static int hIndex(int[] citations) {\n\t\tArrays.sort(citations);\n\t\tif (citations.length == 0)\n\t\t\treturn 0;\n\t\tif (citations.length == 1)\n\t\t\treturn citations[0] >= 1 ? 1 : 0;\n\t\tint h = 1;\n\t\tfor (int i = citations.length - 1; i >= 0; i--) {\n\t\t\tif (h > citations[i])\n\t\t\t\treturn h - 1;\n\t\t\th++;\n\t\t}\n\t\treturn h-1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = { 1,12,15 };\n\t\tSystem.out.println(hIndex(a));\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MaximumSubarray\n{\n    public int maxSubArray( int[] nums )\n    {\n    \tif ( nums == null || nums.length == 0 )\n    \t{\n    \t\tthrow new IllegalArgumentException(\"\");\n    \t}\n    \t\n    \tint localMaxSum = nums[0];\n    \tint globalMaxSum = nums[0];\n    \tfor ( int i = 1; i < nums.length; i++ )\n    \t{\n    \t\tlocalMaxSum = Math.max( localMaxSum + nums[i], nums[i] );\n    \t\tglobalMaxSum = Math.max( globalMaxSum, localMaxSum );\n    \t}\n    \treturn globalMaxSum;\n    }\n    \n    @Test\n    public void test()\n    {    \t\n    \tassertEquals( 6, maxSubArray( new int[]{ 4, -1, 2, 1 } ) );\n    \t\n    \tassertEquals( -1, maxSubArray( new int[]{ -5, -1, -2, -3 } ) );    \t\n    \tassertEquals( 10, maxSubArray( new int[]{ 4, 3, 2, 1 } ) );\n\n    \tassertEquals( 4, maxSubArray( new int[]{ 4 } ) );\n    \tassertEquals( 0, maxSubArray( new int[]{ } ) );\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class AddTwoNumbers {\n  public static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n\n  public static void main(String[] args) {\n    ListNode node = new ListNode(2);\n    node.next = new ListNode(4);\n    node.next.next = new ListNode(4);\n\n    ListNode node1 = new ListNode(5);\n    node1.next = new ListNode(6);\n    node1.next.next = new ListNode(6);\n\n    ListNode result = new AddTwoNumbers().addTwoNumbers(node, node1);\n  }\n\n  private ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    if (l1 == null && l2 == null) return null;\n    ListNode first = l1;\n    ListNode second = l2;\n    int carry = 0;\n    ListNode head = new ListNode(0);\n    ListNode prev = head;\n    while (first != null && second != null) {\n      int q = (first.val + second.val + carry) / 10;\n      int r = (first.val + second.val + carry) % 10;\n      carry = q;\n      ListNode node = new ListNode(r);\n      prev.next = node;\n      prev = node;\n      first = first.next;\n      second = second.next;\n    }\n\n    while (first != null) {\n      int q = (first.val + carry) / 10;\n      int r = (first.val + carry) % 10;\n      carry = q;\n      ListNode node = new ListNode(r);\n      prev.next = node;\n      prev = node;\n      first = first.next;\n    }\n\n    while (second != null) {\n      int q = (second.val + carry) / 10;\n      int r = (second.val + carry) % 10;\n      carry = q;\n      ListNode node = new ListNode(r);\n      prev.next = node;\n      prev = node;\n      second = second.next;\n    }\n\n    if (carry != 0) prev.next = new ListNode(carry);\n\n    return head.next;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public int longestValidParentheses_1(String s) {\n        Stack<Integer> stk = new Stack<Integer>();\n        int res = 0, count = 0;\n        for(int i = 0; i < s.length(); ++i) {\n            if (s.charAt(i) == '(') {\n                stk.push(count);\n                count = 0;\n            } else if (stk.empty() == false) {\n                count += (1 + stk.pop());\n                res = Math.max(res, count);\n            } else {\n                count = 0;\n            }\n        }\n        return res * 2;\n    }\n    public int longestValidParentheses_2(String s) {\n        int n = s.length();\n        if (n <= 1) return 0;\n        int res = 0;\n        int[] f = new int[n];\n        for(int i=n-2;i>=0;i--){\n            int match = i + f[i+1] + 1;\n            if(match<n&&s.charAt(i)=='('&&s.charAt(match)==')'){\n                f[i]=f[i+1]+2;\n                if(match+1<n) f[i]+=f[match+1];\n            }\n            res = Math.max(res,f[i]);\n        }\n        return res;\n    }\n    public int longestValidParentheses(String s) {\n        int counter = 0, val = 0, res = 0;\n        for (int i = 0; i < s.length(); ++i) {\n            counter += s.charAt(i) == '(' ? 1 : -1;\n            if (counter < 0) {\n                val = counter = 0;\n                continue;\n            }\n            val += s.charAt(i) == '(' ? 0 : 2;\n            res = counter == 0 ? Math.max(res, val) : res;\n        }\n        val = counter = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            counter += s.charAt(i) == ')' ? 1 : -1;\n            if (counter < 0) {\n                val = counter = 0;\n                continue;\n            }\n            val += s.charAt(i) == ')' ? 0 : 2;\n            res = counter == 0 ? Math.max(res, val) : res;\n        }\n        return res;\n    }\n}\n\n\n\n", "nl": "leetcoders"}
{"code": "public class CourseSchedule {\n\n  \n  public boolean canFinish(int numCourses, int[][] prerequisites) {\n    if (numCourses <= 0) {\n      return false;\n    }\n    int[] inDegrees = new int[numCourses];\n    for (int[] p : prerequisites) {\n      inDegrees[p[0]]++;\n    }\n    Queue<Integer> queue = new ArrayDeque<>();\n    for (int i = 0; i < inDegrees.length; i++) {\n      if (inDegrees[i] == 0) {\n        queue.offer(i);\n      }\n    }\n    int count = 0;\n    while (!queue.isEmpty()) {\n      int c = queue.poll(); // Dequeue node and add to result.\n      count++;\n      for (int[] p : prerequisites) {\n        if (c == p[1]) { // Remove c from graph.\n          inDegrees[p[0]]--; // Reduce in-degree.\n          if (inDegrees[p[0]] == 0) {\n            queue.offer(p[0]);\n          }\n        }\n      }\n    }\n    return count == numCourses;\n  }\n\n  \n  public boolean canFinishB(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> graph = new ArrayList<>(numCourses);\n    for (int i = 0; i < numCourses; i++) {\n      graph.add(new ArrayList<>());\n    }\n    boolean[] visited = new boolean[numCourses];\n    for (int i = 0; i < prerequisites.length; i++) {\n      graph.get(prerequisites[i][1]).add(prerequisites[i][0]);\n    }\n\n    for (int i = 0; i < numCourses; i++) {\n      if (!dfs(graph, visited, i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  \n  private boolean dfs(List<List<Integer>> graph, boolean[] visited, int course) {\n    if (visited[course]) { // Cycle detected.\n      return false;\n    }\n    visited[course] = true; // Set temp mark.\n    for (int n : graph.get(course)) {\n      if (!dfs(graph, visited, n)) {\n        return false;\n      }\n    }\n    visited[course] = false; // Reset temp mark.\n    return true;\n  }\n\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class CourseSchedule\n{\n    public boolean canFinish(int numCourses, int[][] prerequisites) \n    {\n    \tif ( numCourses < 0 )\n    \t{\n    \t\tthrow new IllegalArgumentException(\"\");\n    \t}\n    \t\n    \tMap<Integer, Set<Integer>> graph = new HashMap<>();\n    \tfor ( int i = 0; i < numCourses; i++ )\n    \t{\n    \t\tgraph.put( i, new HashSet<>() );\n    \t}\n    \tfor ( int[] edge : prerequisites )\n    \t{\n    \t\tgraph.get( edge[1] ).add( edge[0] );\n    \t}\n    \t\n    \tSet<Integer> discovered = new HashSet<>();\n    \tSet<Integer> visited = new HashSet<>();\n    \tfor ( Integer vertex : graph.keySet() )\n    \t{\n    \t\tif ( !visited.contains( vertex ) )\n    \t\t{\n    \t\t\tif ( topoSort( graph, vertex, discovered, visited ) )\n    \t\t\t{\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn true;\n    }\n    \n    \n    private boolean topoSort ( Map<Integer, Set<Integer>> graph, Integer startNode, Set<Integer> discovered, Set<Integer> visited )\n    {\n    \tdiscovered.add( startNode );\n    \tfor ( Integer neighbor : graph.get( startNode ) )\n    \t{\n    \t\tif ( !discovered.contains( neighbor ) )\n    \t\t{\n    \t\t\tif ( topoSort( graph, neighbor, discovered, visited ) )\n    \t\t\t{\n    \t\t\t\treturn true;\n    \t\t\t}\n    \t\t}\n    \t\telse if ( discovered.contains( neighbor ) \n    \t\t\t\t&& !visited.contains( neighbor ) )\n    \t\t{\n    \t\t\treturn true;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\t;\n    \t\t}\n    \t}\n    \tvisited.add( startNode );\n    \treturn false;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "class SortList {\n\n  \n  public ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode tail = head;\n    int len = 0;\n    while (tail != null) {\n      tail = tail.next;\n      len++;\n    }\n    ListNode dummy = new ListNode(Integer.MIN_VALUE);\n    dummy.next = head;\n    head = mergeSort(dummy, head, len);\n    return head;\n  }\n\n  \n  private ListNode mergeSort(ListNode preHead, ListNode head, int len) {\n    if (head == null || len <= 1) return head;\n    int left = len / 2;\n    int right = len - left;\n    head = mergeSort(preHead, head, left);\n    ListNode pMid = head;\n    for (int i = 0; i < left - 1; i++) pMid = pMid.next;\n    mergeSort(pMid, pMid.next, right);\n    ListNode pre1 = preHead;\n    ListNode p1 = head;\n    ListNode pre2 = pMid;\n    ListNode p2 = pMid.next;\n    if (p1.val > p2.val) head = p2; // switch head\n    while (left > 0 && right > 0) {\n      if (p1.val > p2.val) {\n        pre2.next = p2.next; // insert p2 before p1\n        p2.next = p1;\n        pre1.next = p2;\n        pre1 = p2;\n        p2 = pre2.next;\n        right--;\n      } else {\n        pre1 = p1;\n        p1 = p1.next;\n        left--;\n      }\n    }\n    return head;\n  }\n\n  class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class ReverseWordsinaString {\n\tpublic String reverseWords(String s) {\n\t\tStack<String> stack = new Stack<String>();\n\t\ts.trim();\n\t\tint p = 0, q = 0;\n\t\twhile (p < s.length()) {\n\t\t\twhile (q < s.length() && s.charAt(q) == ' ')\n\t\t\t\tq++;\n\t\t\tp = q;\n\t\t\twhile (q < s.length() && s.charAt(q) != ' ')\n\t\t\t\tq++;\n\t\t\tstack.push(s.substring(p, q));\n\t\t\tp = q;\n\t\t}\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\twhile (!stack.empty()) {\n\t\t\tString top = stack.pop();\n\t\t\tbuf.append(top);\n\t\t\tbuf.append(' ');\n\t\t}\n\t\treturn buf.toString().trim();\n\t}\n\t\n}\n", "nl": "gaohannk"}
{"code": "public class MergeTwoSortedLists {\n\n    public class Solution {\n        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n            ListNode head = null;\n            ListNode pre = null;\n            while (l1 != null && l2 != null) {\n                if (l1.val <= l2.val) {\n                    if (head == null) {\n                        head = l1;\n                    } else {\n                        pre.next = l1;\n                    }\n                    pre = l1;\n                    l1 = l1.next;\n                } else {\n                    if (head == null) {\n                        head = l2;\n                    } else {\n                        pre.next = l2;\n                    }\n                    pre = l2;\n                    l2 = l2.next;\n                }\n            }\n            if (l1 != null) {\n                if (head == null) {\n                    head = l1;\n                } else {\n                    pre.next = l1;\n                }\n            }\n            if (l2 != null) {\n                if (head == null) {\n                    head = l2;\n                } else {\n                    pre.next = l2;\n                }\n            }\n            return head;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class NQueens {\n\n    public class Solution {\n        private boolean isValid(int row, int column, ArrayDeque<Integer> columns) {\n            int r = 0;\n            for (int c : columns) {\n                if (c == column || Math.abs(c - column) == Math.abs(r - row)) {\n                    return false;\n                }\n                r++;\n            }\n            return true;\n        }\n\n        private String[] toSolution(ArrayDeque<Integer> columns) {\n            int n = columns.size();\n            String[] s = new String[n];\n            int row = 0;\n            for (int column : columns) {\n                String line = \"\";\n                for (int i = 0; i < n; i++) {\n                    if (i != column) {\n                        line += '.';\n                    } else {\n                        line += 'Q';\n                    }\n                }\n                s[row++] = line;\n            }\n            return s;\n        }\n\n        private void search(int row, int n, ArrayDeque<Integer> columns,\n                ArrayList<String[]> ans) {\n            if (row == n) {\n                ans.add(toSolution(columns));\n                return;\n            }\n            for (int i = 0; i < n; i++) {\n                if (isValid(row, i, columns)) {\n                    columns.offerLast(i);\n                    search(row + 1, n, columns, ans);\n                    columns.removeLast();\n                }\n            }\n        }\n\n        public ArrayList<String[]> solveNQueens(int n) {\n            ArrayList<String[]> ans = new ArrayList<String[]>();\n            search(0, n, new ArrayDeque<Integer>(), ans);\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public List<List<Integer>> combinationSum2(int[] num, int target) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        Arrays.sort(num);\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        combinationSumRe(num, target, 0, path, res);\n        return res;\n    }\n    void combinationSumRe(int[] candidates, int target, int start, ArrayList<Integer> path, List<List<Integer>> res) {\n        if (target == 0) {\n            ArrayList<Integer> p = new ArrayList<Integer>(path);\n            res.add(p);\n            return;\n        }\n        for (int i = start; i < candidates.length && target >= candidates[i]; ++i) {\n            if (i!=start && candidates[i-1] == candidates[i]) continue;\n            path.add(candidates[i]);\n            combinationSumRe(candidates, target-candidates[i], i+1, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}", "nl": "leetcoders"}
{"code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        PriorityQueue<ListNode> queue = new PriorityQueue<>(Comparator.comparing(node -> node.val));\n        for (int i = 0; i < lists.length; i++) {\n            if (lists[i] != null) {\n                queue.offer(lists[i]);\n            }\n        }\n        if (queue.isEmpty()) return null;\n        \n        ListNode dummy = new ListNode(0);\n        ListNode head = dummy;\n        while (!queue.isEmpty()) {\n            ListNode node = queue.poll();\n            if (node.next != null) {\n                queue.offer(node.next);\n            }\n            head.next = node; // link\n            head = head.next;\n        }\n        return dummy.next;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class TextJustification {\n\n    public class Solution {\n        private void appendSpace(StringBuilder line, int space) {\n            for (int i = 0; i < space; i++) {\n                line.append(' ');\n            }\n        }\n\n        public ArrayList<String> fullJustify(String[] words, int L) {\n            ArrayList<String> ans = new ArrayList<String>();\n            if (words.length == 0) {\n                return ans;\n            }\n            int begin = 0;\n            int len = words[0].length();\n            int current = 1;\n            while (current < words.length) {\n                if (len + words[current].length() + 1 <= L) {\n                    len += words[current].length() + 1;\n                } else {\n                    int wordCount = current - begin;\n                    int padding = L - len + wordCount - 1;\n                    StringBuilder line = new StringBuilder();\n                    if (wordCount == 1) {\n                        line.append(words[begin]);\n                        appendSpace(line, padding);\n                    } else {\n                        int slotSize = padding / (wordCount - 1);\n                        int moreSlotCount = padding % (wordCount - 1);\n                        for (int i = 0; i < moreSlotCount; i++) {\n                            line.append(words[begin + i]);\n                            appendSpace(line, slotSize + 1);\n                        }\n                        for (int i = moreSlotCount; i < wordCount - 1; i++) {\n                            line.append(words[begin + i]);\n                            appendSpace(line, slotSize);\n                        }\n                        line.append(words[current - 1]);\n                    }\n                    ans.add(line.toString());\n                    begin = current;\n                    len = words[current].length();\n                }\n                current++;\n            }\n            StringBuilder line = new StringBuilder();\n            for (int i = begin; i < words.length - 1; i++) {\n                line.append(words[i]);\n                line.append(' ');\n            }\n            line.append(words[words.length - 1]);\n            appendSpace(line, L - len);\n            ans.add(line.toString());\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class NQueens {\n\tpublic ArrayList<String[]> solveNQueens(int n) {\n\t\tArrayList<String[]> res = new ArrayList<String[]>();\n\t\thelper(n, 0, new int[n], res);\n\t\treturn res;\n\t}\n\tprivate void helper(int n, int row, int[] columnForRow, ArrayList<String[]> res) {\n\t\tif (row == n) {\n\t\t\tString[] item = new String[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tStringBuilder strRow = new StringBuilder();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (columnForRow[i] == j)\n\t\t\t\t\t\tstrRow.append('Q');\n\t\t\t\t\telse\n\t\t\t\t\t\tstrRow.append('.');\n\t\t\t\t}\n\t\t\t\titem[i] = strRow.toString();\n\t\t\t}\n\t\t\tres.add(item);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcolumnForRow[row] = i;\n\t\t\tif (check(row, columnForRow)) \n\t\t\t\thelper(n, row + 1, columnForRow, res);\n\t\t}\n\t}\n\t\n\tprivate boolean check(int row, int[] columnForRow) {\n\t\tfor (int i = 0; i < row; i++) {\n\t\t\tif (columnForRow[row] == columnForRow[i] || Math.abs(columnForRow[row] - columnForRow[i]) == row - i)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ImplementStrStr {\n\tpublic String strStr(String haystack, String needle) {\n\t\tif (needle != null && needle.isEmpty()) {\n\t\t\treturn haystack;\n\t\t}\n\n\t\tint len1 = haystack.length();\n\t\tint len2 = needle.length();\n\t\tif (len1 < len2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (int i = 0; i <= len1 - len2; ++i) {\n\t\t\tint j = 0;\n\t\t\tint k = i;\n\t\t\twhile (j < len2 && needle.charAt(j) == haystack.charAt(k)) {\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tif (j == len2) {\n\t\t\t\treturn haystack.substring(i);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tImplementStrStr slt = new ImplementStrStr();\n\t\tSystem.out.println(slt.strStr(\"abcdabc\", \"d\"));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if (validateInput(numCourses, prerequisites)) {\n            return true;\n        }\n        List[] edges = new ArrayList[numCourses];\n        int[] inDegree = new int[numCourses]; \n        \n        for (int i = 0; i < numCourses; i++) {\n            edges[i] = new ArrayList<>();\n            inDegree[0] = 0;// though, 0 by default\n        }\n        \n        for (int[] prerequisite : prerequisites) {\n            edges[prerequisite[1]].add(prerequisite[0]);\n            inDegree[prerequisite[0]]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n        \n        int count = 0;\n        while (!queue.isEmpty()) {\n            int startNode = (int)queue.poll();\n            count++;\n            for (int i = 0; i < edges[startNode].size(); i++) {\n                int childNode = (int) edges[startNode].get(i);\n                inDegree[childNode]--;\n                if (inDegree[childNode] == 0) {\n                    queue.add(childNode);\n                }\n            }\n        }\n        \n        return count == numCourses;\n    }\n\n    private boolean validateInput(int numCourses, int[][] prerequisites) {\n        return numCourses == 0 || prerequisites == null || prerequisites.length == 0\n            || prerequisites[0] == null || prerequisites[0].length == 0;\n    }\n}", "nl": "awangdev"}
{"code": "public class WordBreak {\n    public boolean wordBreak(String s, Set<String> dict) {\n        boolean[] t = new boolean[s.length() + 1];\n        t[0] = true; // set first to be true, why?\n\n        for (int i = 0; i <= s.length(); i++) {\n            if (!t[i])\n                continue;\n            for (String a : dict) {\n                int end = i + a.length();\n                if (end <= s.length() && !t[end] && s.substring(i, end).equals(a))\n                    t[end] = true;\n            }\n        }\n        return t[s.length()];\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class Permutations {\n  \n  public static void main(String[] args) throws Exception {\n    int[] nums = {1, 2, 3};\n    List<List<Integer>> result = new Permutations().permute(nums);\n  }\n\n  public List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    nextPermutation(0, nums, result);\n    return result;\n  }\n\n  private void nextPermutation(int i, int[] nums, List<List<Integer>> result) {\n    if (i == nums.length - 1) {\n      List<Integer> list = new ArrayList<>();\n      for (int n : nums) list.add(n);\n      result.add(list);\n    } else {\n      for (int j = i, l = nums.length; j < l; j++) {\n        int temp = nums[j];\n        nums[j] = nums[i];\n        nums[i] = temp;\n        nextPermutation(i + 1, nums, result);\n        temp = nums[j];\n        nums[j] = nums[i];\n        nums[i] = temp;\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public List<Integer> grayCode(int n) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        for (int i = 0; i < 1 << n; ++i)\n            res.add((int)((i >> 1) ^ i));\n        return res;     \n    }\n}", "nl": "leetcoders"}
{"code": "public class RemoveDuplicatesFromSortedArrayII \n{\n    public int removeDuplicates( int[] nums ) \n    {\n        if ( nums.length <= 2 )\n        {\n        \treturn nums.length;\n        }\n        \n        int count = 1;\n        int validPos = 0;\n        for ( int i = 1; i < nums.length; i++ )\n        {        \t\n        \tif ( nums[i] == nums[validPos] \n        \t\t\t&& count == 2 )\n        \t{\n        \t\tcontinue;\n        \t}\n        \t\n        \tif ( nums[i] == nums[validPos] )\n        \t{\n        \t\tcount++;\n        \t}\n        \telse\n        \t{\n        \t\tcount = 1;\n        \t}\n\n        \tvalidPos++;\n        \tnums[validPos] = nums[i];        \t\t\n        }\n        \n        return validPos + 1;\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class L024_Swap_Nodes_in_Pairs {\n\n\tpublic static class ListNode {\n\t\tint val;\n\t\tListNode next;\n\n\t\tListNode(int x) {\n\t\t\tval = x;\n\t\t}\n\t}\n\n\tpublic ListNode swapPairs(ListNode head) {\n\n\t\tif (head == null || head.next == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tListNode fakeHead = new ListNode(0);\n\t\tfakeHead.next = head;\n\n\t\tListNode p1 = fakeHead;\n\t\tListNode p2 = head;\n\n\t\twhile (p2 != null && p2.next != null) {\n\t\t\tListNode nextStart = p2.next.next;\n\t\t\tp2.next.next = p2;\n\t\t\tp1.next = p2.next;\n\t\t\tp2.next = nextStart;\n\t\t\tp1 = p2;\n\t\t\tp2 = p2.next;\n\t\t}\n\n\t\treturn fakeHead.next;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class MinimumPathSum {\n\tpublic int mindistPathSum(int[][] grid) {\n\t\tint row = grid.length;\n\t\tint col = grid[0].length;\n\t\tint[][] mindist = new int[row][col];\n\t\tmindist[0][0] = grid[0][0];\n\t\tfor (int i = 1; i < row; i++) {\n\t\t\tmindist[i][0] = mindist[i - 1][0] + grid[i][0];\n\t\t}\n\t\tfor (int i = 1; i < col; i++) {\n\t\t\tmindist[0][i] = mindist[0][i - 1] + grid[0][i];\n\t\t}\n\t\tfor (int i = 1; i < row; i++) {\n\t\t\tfor (int j = 1; j < col; j++) {\n\t\t\t\tmindist[i][j] = Math.min(mindist[i - 1][j], mindist[i][j - 1]) + grid[i][j];\n\t\t\t}\n\t\t}\n\t\treturn mindist[row - 1][col - 1];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class RemoveDuplicatesFromSortedList2 {\n  public static void main(String[] args) {\n    ListNode head = buildTestList1();\n    printList(head);\n    printList(deleteDuplicates(head));\n    System.out.println(\"---\");\n    head = buildTestList2();\n    printList(head);\n    printList(deleteDuplicates(head));\n    System.out.println(\"---\");\n  }\n\n  static ListNode buildTestList1() {\n    ListNode head = new ListNode(1);\n    ListNode second = new ListNode(2);\n    ListNode third = new ListNode(3);\n    ListNode forth = new ListNode(3);\n    ListNode fifth = new ListNode(4);\n    ListNode sixth = new ListNode(4);\n    ListNode seventh = new ListNode(5);\n    head.next = second;\n    second.next = third;\n    third.next = forth;\n    forth.next = fifth;\n    fifth.next = sixth;\n    sixth.next = seventh;\n    return head;\n  }\n\n  static ListNode buildTestList2() {\n    ListNode head = new ListNode(1);\n    ListNode second = new ListNode(1);\n    ListNode third = new ListNode(1);\n    ListNode forth = new ListNode(2);\n    ListNode fifth = new ListNode(3);\n    head.next = second;\n    second.next = third;\n    third.next = forth;\n    forth.next = fifth;\n    return head;\n  }\n\n  static void printList(ListNode head) {\n    while (head != null) {\n      System.out.print(head.val + \"->\");\n      head = head.next;\n    }\n    System.out.println(\"NULL\");\n  }\n\n  \n  public static ListNode deleteDuplicates(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    ListNode dummyHead = new ListNode(0); // dummy head\n    dummyHead.next = head;\n    ListNode pre = dummyHead; // two pointers\n    ListNode cur = head;\n    while (cur != null) {\n      while (cur.next != null && cur.val == cur.next.val) cur = cur.next; // skip\n      if (pre.next == cur) pre = pre.next; // no dups\n      else pre.next = cur.next; // cur moved\n      cur = cur.next; // update current\n    }\n    return dummyHead.next;\n  }\n\n  public static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class ValidNumber3 {\n\tpublic boolean isNumber(String s) {\n\t\tif (s.trim().isEmpty())\n\t\t\treturn false;\n\t\tString regex = \"[-+]?(\\\\d+\\\\.?|\\\\.\\\\d+)\\\\d*(e[-+]?\\\\d+)?\";\n\t\tif (s.trim().matches(regex))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class GasStation {\n\n  \n  public int canCompleteCircuit(int[] gas, int[] cost) {\n    int restGas = 0; // gas remain for current trip\n    int previous = 0; // negative gas for previous trips\n    int start = 0; // start index of current trip\n    for (int i = 0; i < gas.length; i++) {\n      restGas += gas[i] - cost[i];\n      if (restGas < 0) {\n        previous += restGas; // gas needed for previous trips\n        restGas = 0; // reset restGas\n        start = i + 1; // set start index to next station\n      }\n    }\n    return previous + restGas >= 0 ? start : -1;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class MedianofTwoSortedArrays {\n\n    public class Solution {\n\n        private int findKth(int A[], int m, int B[], int n, int k) {\n            if (m == 0) {\n                return B[k - 1];\n            }\n            if (n == 0) {\n                return A[k - 1];\n            }\n            if (m + n == k) {\n                return Math.max(A[m - 1], B[n - 1]);\n            }\n            if (m > n) {\n                return findKth(B, n, A, m, k);\n            }\n            int x = Math.min(m, k / 2 + 1);\n            int y = k + 1 - x;\n            if (A[x - 1] < B[y - 1]) {\n                return findKth(A, m, B, y - 1, k);\n            } else if (A[x - 1] > B[y - 1]) {\n                return findKth(A, x - 1, B, n, k);\n            } else {\n                return A[x - 1];\n            }\n        }\n\n        public double findMedianSortedArrays(int A[], int B[]) {\n            int n = A.length + B.length;\n            if (n % 2 == 1) {\n                return findKth(A, A.length, B, B.length, n / 2 + 1);\n            }\n            return (findKth(A, A.length, B, B.length, n / 2) +\n                    findKth(A, A.length, B, B.length, n / 2 + 1)) / 2.0;\n        }\n    }\n\n    public static class UnitTest {\n\n        @Test\n        public void testFindMedianSortedArrays() {\n            Solution s = new MedianofTwoSortedArrays().new Solution();\n            assertEquals(2.5, s.findMedianSortedArrays(new int[]{3, 4}, new int[]{1, 2}), 1E-6);\n        }\n    }\n}\n", "nl": "zsxwing"}
{"code": "class Solution {\n    \n    public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n        if (intervals == null || intervals.size() == 0 || newInterval == null) {\n            if (newInterval != null) {\n                intervals.add(newInterval);\n            }\n            return intervals;\n        }\n        int start = newInterval.start;\n        int front = -1;\n        for (int i = 0; i < intervals.size(); i++) {\n            if (intervals.get(i).start <= start) {\n                front = i;\n            }\n        }\n        if (front == -1) {\n            intervals.add(0, newInterval);\n        }\n        intervals.add(front + 1, newInterval);\n     \n        Interval pre = intervals.get(0);\n        Interval curr = null;\n        for (int i = 1; i < intervals.size(); i++) {\n            curr = intervals.get(i);\n            if (pre.end >= curr.start) {\n                pre.end = pre.end > curr.end ? pre.end : curr.end;\n                intervals.remove(i);\n                i--;\n            } else {\n                pre = curr;\n            }\n        }\n    \n        return intervals;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public boolean isSymmetric(TreeNode root) {       \n        if(root==null)\n            return true;\n        return isSymmetric(root.left,root.right);\n    }\n    \n    public boolean isSymmetric(TreeNode left, TreeNode right){\n        if(left!=null && right!=null)\n            return left.val==right.val && isSymmetric(left.right,right.left) && \n                isSymmetric(left.left,right.right);\n        return left ==null && right ==null;     \n    }\n}\n\n", "nl": "azheanda"}
{"code": "public class DecodeWays {\n\n    public class Solution {\n        public int numDecodings(String s) {\n            if (s == null || s.isEmpty()) {\n                return 0;\n            }\n            int[] dp = new int[s.length() + 1];\n            dp[0] = 1;\n            dp[1] = s.charAt(0) == '0' ? 0 : 1;\n            for (int i = 1; i < s.length(); i++) {\n                dp[i + 1] = s.charAt(i) == '0' ? 0 : dp[i];\n                if (s.charAt(i - 1) == '1'\n                        || (s.charAt(i - 1) == '2' && s.charAt(i) <= '6')) {\n                    dp[i + 1] += dp[i - 1];\n                }\n            }\n            return dp[s.length()];\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTree(inorder,0,inorder.length-1,postorder,0,postorder.length-1);\n    }\n\n\n    public TreeNode buildTree(int[] inorder, int i, int j, int[] postorder, int p, int q){\n        if(i>j)\n            return null;\n        \n        if(i==j && p==q)\n    \t\treturn new TreeNode(postorder[q]);\n\n    \tTreeNode root = new TreeNode(postorder[q]);\n\n    \tint idx =-1;\n    \tfor(int x=i;x<=j;x++)\n    \t\tif(inorder[x]==postorder[q]){\n    \t\t\tidx = x;\n    \t\t\tbreak;\n    \t\t}\n\n    \tTreeNode leftChild = buildTree(inorder,i,idx-1,postorder,p,p+idx-i-1);\n    \tTreeNode rightChild = buildTree(inorder,idx+1,j,postorder,p+idx-i,q-1);\n\n    \troot.left = leftChild;\n    \troot.right = rightChild;\n    \treturn root;\n    }\n}", "nl": "azheanda"}
{"code": "public class TrappingRainWater {\n  public int trap(int A[], int n) {\n    if (n <= 2) return 0;\n\n    int[] lmh = new int[n];\n    lmh[0] = 0;\n    int maxh = A[0];\n    for (int i = 1; i < n; ++i) {\n      lmh[i] = maxh;\n      if (maxh < A[i]) maxh = A[i];\n    }\n    int trapped = 0;\n    maxh = A[n - 1];\n    for (int i = n - 2; i > 0; --i) {\n      int left = lmh[i];\n      int right = maxh;\n      int container = Math.min(left, right);\n      if (container > A[i]) {\n        trapped += container - A[i];\n      }\n      if (maxh < A[i]) maxh = A[i];\n    }\n    return trapped;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public int firstMissingPositive(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i]!=i+1) {\n                if (nums[i]<=nums.length&&nums[i]>0&&nums[nums[i]-1]!=nums[i]) {\n                    int k=nums[nums[i]-1];\n                    nums[nums[i]-1]=nums[i];\n                    nums[i]=k;\n                    i--;\n                }\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i]!=i+1) {\n                return i+1;\n            }\n        }\n        return nums.length+1;\n    \n        \n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public int reverse(int x) {\n        String str=String.valueOf(x);\n        String r=\"\";\n        int re=0;\n        if (x<0) {\n            for (int i = str.length()-1; i >0 ; i--) {\n                r+=str.substring(i,i+1);\n            }\n            r=\"-\"+r;\n        }else {\n            for (int i = str.length()-1; i >-1 ; i--) {\n                r+=str.substring(i,i+1);\n            }\n        }\n            try {\n            re=Integer.parseInt(r);\n            \n        } catch (Exception e) {\n        \n        }\n        return re;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class ValidateBinarySearchTree {\n\tpublic boolean isValidBST(TreeNode root) {\n\t\treturn isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t}\n\n\tpublic boolean isValidBST(TreeNode root, int min, int max) {\n\t\tif (root == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn root.val > min && root.val < max\n\t\t\t\t&& isValidBST(root.left, min, root.val)\n\t\t\t\t&& isValidBST(root.right, root.val, max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tTreeNode n1 = new TreeNode(2);\n\t\tTreeNode n2 = new TreeNode(1);\n\t\tTreeNode n3 = new TreeNode(3);\n\t\tn1.left = n2;\n\t\tn1.right = n3;\n\n\t\tValidateBinarySearchTree slt = new ValidateBinarySearchTree();\n\t\tSystem.out.println(slt.isValidBST(n1));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class SortColors {\n  public void sortColors(int[] A) {\n    int length = A.length;\n    int left = -1;\n    int right = length;\n    int i = 0;\n    while (i < right) {\n      if (A[i] == 0) {\n        swap(A, ++left, i++);\n      } else if (A[i] == 2) {\n        swap(A, i, --right);\n      } else {\n        i++;\n      }\n    }\n  }\n\n  private void swap(int[] a, int i, int j) {\n    int tmp = a[i];\n    a[i] = a[j];\n    a[j] = tmp;\n  }\n}\n", "nl": "mengli"}
{"code": "public class MinStack {\n\n    private static class IntStack {\n        private int[] items = new int[16];\n        private int size = 0;\n\n        private void ensureSize(int newSize) {\n            if (items.length < newSize) {\n                int[] newItems = new int[items.length * 2];\n                System.arraycopy(items, 0, newItems, 0, items.length);\n                items = newItems;\n            }\n        }\n\n        public void push(int v) {\n            ensureSize(size + 1);\n            items[size++] = v;\n        }\n\n        public void pop() {\n            if (size == 0) {\n                throw new IllegalStateException(\"The stack is empty\");\n            }\n            size--;\n        }\n\n        public int top() {\n            if (size == 0) {\n                throw new IllegalStateException(\"The stack is empty\");\n            }\n            return items[size - 1];\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n    }\n\n    private IntStack minStack = new IntStack();\n    private IntStack stack = new IntStack();\n\n    public void push(int x) {\n        if (stack.isEmpty() || x <= minStack.top()) {\n            minStack.push(x);\n        }\n        stack.push(x);\n    }\n\n    public void pop() {\n        int x = stack.top();\n        stack.pop();\n        if (x == minStack.top()) {\n            minStack.pop();\n        }\n    }\n\n    public int top() {\n        return stack.top();\n    }\n\n    public int getMin() {\n        return minStack.top();\n    }\n\n}\n", "nl": "zsxwing"}
{"code": "public class LengthofLastWord2 {\n\tpublic int lengthOfLastWord(String s) {\n\t\tif (s != null && !s.trim().equals(\"\")) {\n\t\t\tString[] arr = s.trim().split(\" \");\n\t\t\tint length = arr[arr.length - 1].length();\n\t\t\treturn length;\n\t\t}\n\t\treturn 0;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class InsertionSortList2 {\n\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public List<String> binaryTreePaths(TreeNode root) {\n    \tList<String> rst = new ArrayList<String>();\n    \tif (root == null) {\n    \t\treturn rst;\n    \t}\n    \thelper(root, rst, new ArrayList<Integer>());\n    \treturn rst;\n    }\n\n    public void helper(TreeNode root, List<String> rst, ArrayList<Integer> list){\n    \tlist.add(root.val);\n    \tif (root.left == null && root.right == null) {\n    \t\tStringBuffer sb = new StringBuffer();\n    \t\tfor (int i = 0; i < list.size() - 1; i++) {\n    \t\t\tsb.append(list.get(i) + \"->\");\n    \t\t}\n    \t\tsb.append(list.get(list.size() - 1));\n    \t\trst.add(sb.toString());\n    \t}\n    \tif (root.left != null) {\n    \t\thelper(root.left, rst, list);\n    \t\tlist.remove(list.size() - 1);\n    \t}\n    \tif (root.right != null) {\n    \t\thelper(root.right, rst, list);\n    \t\tlist.remove(list.size() - 1);\n    \t}\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE) ;\n    }\n    public boolean dfs(TreeNode node, long min, long max) {\n        if (node == null) {\n            return true;\n        }\n        return node.val > min && node.val < max\n            && dfs(node.left, min, node.val) && dfs(node.right, node.val, max);\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class L139_Word_Break {\n\n\tpublic static boolean wordBreak(String s, Set<String> wordDict) {\n\n\t\tboolean[] P = new boolean[s.length() + 1];\n\t\tP[0] = true;\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\tif (P[j] && wordDict.contains(s.substring(j, i + 1))) {\n\t\t\t\t\tP[i + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn P[s.length()];\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1 == null && nums2 == null) {\n        \treturn 0;\n        }\n        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\n        \tpublic int compare(int x, int y){\n        \t\treturn y - x;\n        \t}\n        });\n\n        int median = Integer.MIN_VALUE;\n\n\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public void nextPermutation_1(int[] num) {\n        int last = num.length - 1;\n        int i = last;\n        while (i >0 && num[i - 1] >= num [i]) --i;\n        if (i == 0) {\n            for (int l = 0, r = last; l < r; ++l, --r) {\n                int tmp = num[l];\n                num[l] = num[r];\n                num[r] = tmp;\n            }\n            return;\n        }\n        for (int j = last; j >= i; --j) {\n            if (num[j] > num[i-1]) {\n                int tmp = num[j];\n                num[j] = num[i-1];\n                num[i-1] = tmp;\n                for (int l = i, r = last; l < r; ++l, --r) {\n                    int t = num[l];\n                    num[l] = num[r];\n                    num[r] = t;\n                }\n                return;\n            }\n        }\n    }\n    public void nextPermutation_2(int[] num) {\n        int last = num.length - 1;\n        int i = last;\n        while (i > 0 && num[i - 1] >= num [i]) --i;\n        for (int l = i, r = last; l < r; ++l, --r) {\n            num[l] = num[l] ^ num[r];\n            num[r] = num[l] ^ num[r];\n            num[l] = num[l] ^ num[r];\n        }\n        if (i == 0) {\n            return;\n        }\n        int j = i;\n        while (j <= last && num[i-1] >= num[j]) ++j;\n        num[i-1] = num[i-1] ^ num[j];\n        num[j] = num[i-1] ^ num[j];\n        num[i-1] = num[i-1] ^ num[j];\n    }\n}", "nl": "leetcoders"}
{"code": "public class BestTimetoBuyandSellStockII {\n  public int maxProfit(int[] prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n      int d = prices[i] - prices[i - 1];\n      if (d > 0) {\n        profit += d;\n      }\n    }\n    return profit;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    List<TreeNode> list=new ArrayList<TreeNode>();\n    public void flatten(TreeNode root) {\n        if (root!=null) {\n            f(root);\n            for (int i = 0; i < list.size()-1; i++) {\n                list.get(i).right=list.get(i+1);\n                list.get(i).left=null;\n            }\n            root=list.get(0);\n        }\n    }\n    public void f(TreeNode root){\n        if (root!=null) {\n            list.add(root);\n            f(root.left);\n            f(root.right);\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class JumpGameII \n{\n\t\n    @Test\n    public void test()\n    {\n    \tassertEquals( 2, jumpDP( new int[]{2, 3, 1, 1, 4} ) );\n    \tassertEquals( 0, jumpDP( new int[]{1} ) );\n    \tassertEquals( 2, jumpDP( new int[]{7, 0, 9, 6, 9, 6, 1, 7, 9, 0, 1, 2, 9, 0, 3}) );\n    }\n\n    public int jumpDP( int[] nums )\n    {\n    \tif ( nums.length == 0 )\n    \t{\n    \t\treturn 0;\n    \t}\n    \t\n        int[] minSteps = new int[nums.length];\n        Arrays.fill( minSteps, Integer.MAX_VALUE );\n        minSteps[0] = 0;\n        for ( int i = 0; i < nums.length; i++ )\n        {\n        \tfor ( int j = 1; j <= nums[i] && i + j < nums.length ; j++ )\n        \t{\n        \t\tminSteps[i+j] = Math.min( minSteps[i+j], minSteps[i] + 1 );\n        \t}\n        }\n        \n        return minSteps[nums.length-1];\n    }\n    \n}\n", "nl": "FreemanZhang"}
{"code": "public class RemoveDuplicatesFromSortedList {\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\t\tif (head == null || head.next == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tListNode pre = head;\n\t\tListNode cur = head.next;\n\n\t\twhile (cur != null) {\n\t\t\tif (cur.val != pre.val) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = cur.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (cur.next != null && cur.next.val == pre.val) {\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\n\t\t\tpre.next = cur.next;\n\t\t\tcur = pre.next;\n\t\t}\n\n\t\treturn head;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tRemoveDuplicatesFromSortedList slt = new RemoveDuplicatesFromSortedList();\n\t\tListNode n1 = new ListNode(1);\n\t\tListNode n2 = new ListNode(2);\n\t\tListNode n3 = new ListNode(3);\n\t\tn1.next = n2;\n\t\tn2.next = n3;\n\t\t\n\t\tListNode res = slt.deleteDuplicates(n1);\n\t\t\n\t\twhile(res != null) {\n\t\t\tSystem.out.print(res.val + \" \");\n\t\t\tres = res.next;\n\t\t}\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class InsertInterval {\n\n  \n  public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n    int i = 0;\n    while (i < intervals.size() && intervals.get(i).end < newInterval.start) {\n      i++;\n    }\n    while (i < intervals.size() && intervals.get(i).start <= newInterval.end) { // Compare current interval with merged new interval.\n      Interval inter = intervals.remove(i); // Remove the overlapped interval.\n      newInterval.start = Math.min(inter.start, newInterval.start);\n      newInterval.end = Math.max(inter.end, newInterval.end);\n    }\n    intervals.add(i, newInterval);\n    return intervals;\n  }\n\n  \n  public List<Interval> insertB(List<Interval> intervals, Interval newInterval) {\n    List<Interval> res = new LinkedList<>();\n    res.add(newInterval);\n    for (Interval i : intervals) {\n      int start = res.get(res.size() - 1).start; // Last interval.\n      int end = res.get(res.size() - 1).end;\n      if (i.end < start) { // i ends before last interval.\n        res.add(res.size() - 1, i); // Insert it before last interval.\n      } else if (end < i.start) { // i starts after last interval.\n        res.add(i); // Append it to last.\n      } else { // i overlaps with last interval.\n        start = Math.min(start, i.start);\n        end = Math.max(end, i.end);\n        res.set(res.size() - 1, new Interval(start, end));\n      }\n    }\n    return res;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SameTree {\n\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n\n  \n  public static void main(String[] args) throws Exception {}\n\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if ((p == null && q != null) || (p != null && q == null)) return false;\n    if (p == null && q == null) return true;\n    else {\n      boolean status = isSameTree(p.left, q.left);\n      if (!status || p.val != q.val) {\n        return false;\n      }\n      return isSameTree(p.right, q.right);\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "class LinkedListCycle {\n\n    public static void main(String[] args) {\n\n    }\n\n    \n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n\n    class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) {\n            val = x;\n            next = null;\n        }\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SearchInsertPosition2 {\n\tpublic int searchInsert(int[] A, int target) {\n\t\tint start=0, end=A.length-1;\n\t\treturn searchInsert(A,start,end,target);\n\t}\n\t\n\tpublic int searchInsert(int[] A, int start, int end,int target){\n\t\tif(start>=end){\n\t\t\tif(A[start]<target)\n\t\t\t\treturn start;\n\t\t\telse\n\t\t\t\treturn start+1;\n\t\t}\n\t\tint mid= (start+end)>>1;\n\t\tif(A[mid]==target)\n\t\t\treturn mid;\n\t\tif(A[mid]>target)\n\t\t\treturn searchInsert(A,start,mid,target);\n\t\telse\n\t\t\treturn searchInsert(A,mid+1,end,target);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    \n    public int sqrt(int x) {\n       long start = 0;\n       long end = x;\n       while (end >= start) {\n           long mid = start + (end - start) / 2;\n           if (mid * mid > x) {\n               end = mid - 1;\n           } else if (mid * mid < x) {\n               start = mid + 1;\n           } else {\n               return (int)mid;\n           }\n       }\n       return (int)end;\n    }\n}\n", "nl": "awangdev"}
{"code": "    public class Solution {\n        public int largestRectangleArea(int[] height) {\n            if(height.length==0)\n                return 0;\n                    \n            int max = 0;\n            for(int i=0;i<height.length;i++){\n                int lowest = height[i];\n                for(int j=i;j<height.length;j++){\n                        if(height[j]<lowest)\n                            lowest = height[j];\n                        int area = lowest*(j+1-i);\n                        if(area>max)\n                            max =area;\n                }\n            }\n                                \n            return max;\n        }\n    }", "nl": "azheanda"}
{"code": "public class Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        pathSumRe(root, sum, res, path);\n        return res; \n    }\n    public void pathSumRe(TreeNode root, int sum, List<List<Integer>> res, ArrayList<Integer> path)\n    {\n        if (root == null) return;\n        path.add(root.val);\n        if (root.left == null && root.right == null && root.val == sum){\n            ArrayList<Integer> tmp = new ArrayList<Integer>(path);\n            res.add(tmp);\n        }\n        pathSumRe(root.left, sum - root.val, res, path);\n        pathSumRe(root.right, sum - root.val, res, path);\n        path.remove(path.size()-1);\n    }\n}\n\n", "nl": "leetcoders"}
{"code": "public class SqrtX {\n  public static void main(String[] args) throws Exception {\n    System.out.println(new SqrtX().mySqrt(Integer.MAX_VALUE));\n  }\n\n  public int mySqrt(int x) {\n    int s = 0, e = x;\n    long ans = 0L;\n    while (s <= e) {\n      long m = s + (e - s) / 2;\n      long prod = m * m;\n      if (prod <= x) {\n        s = (int) (m + 1);\n        ans = m;\n      } else e = (int) m - 1;\n    }\n    return (int) ans;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public int uniquePaths(int m, int n) {\n        if (m==1||n==1) {\n            return 1;\n        }\n        Map<Integer,Integer> map=new HashMap<Integer, Integer>();\n        for (int i = 0; i < m; i++) {\n            map.put(i, 1);\n        }\n        for (int i = 1; i < n-1; i++) {\n            int sum=0;\n            for (int j = m-1; j >=0; j--) {\n                sum+=map.get(j);\n            }\n            int k=map.get(m-1);\n            for (int j = m-1; j >=0; j--) {\n                map.put(j, sum);\n                sum-=k;\n                if (j>1) {\n                    k=map.get(j-1);\n                }\n            }\n        }\n        int sum=0;\n        for (int i = 0; i < m; i++) {\n            sum+=map.get(i);\n        }\n        return sum;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public boolean isValid(String s) {\n        if (s == null || s.equals(\"()\") || s.equals(\"{}\") ||s.equals(\"[]\")) {\n            return true;\n        }\n        char[] arr = s.toCharArray();\n        Stack<Character> stack = new Stack<Character>();\n        stack.push(arr[0]);\n        for (int i = 1; i < s.length(); i++) {\n            if (\"({[\".indexOf(arr[i]+\"\") != -1) {\n                stack.push(arr[i]);\n                continue;\n            }\n            if (stack.isEmpty()) {\n                return false;\n            }\n            if (arr[i] == ')' && stack.peek() != '(') {\n                return false;\n            }\n            if (arr[i] == '}' && stack.peek() != '{') {\n                return false;\n            }\n            if (arr[i] == ']' && stack.peek() != '[') {\n                return false;\n            }\n            stack.pop();\n        }\n        if (!stack.isEmpty()) {\n            return false;\n        }\n        return true;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "class MajorityElement {\n\n    \n    public int majorityElement(int[] num) {\n        int maj = num[0];\n        int count = 0;\n        for (int i = 0; i < num.length && count <= num.length / 2; i++) {\n            if (count == 0) {\n                maj = num[i];\n                count++;\n            } else {\n                count = num[i] == maj ? count + 1 : count - 1;\n            }\n        }\n        return maj;\n    }\n\n    \n    public static int majorityElement2(int[] num) {\n        return -1;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class RemoveDuplicatesfromSortedList {\n\n    public class Solution {\n        public ListNode deleteDuplicates(ListNode head) {\n            if (head != null) {\n                ListNode pre = head;\n                ListNode p = pre.next;\n                while (p != null) {\n                    if (p.val == pre.val) {\n                        pre.next = p.next;\n                    } else {\n                        pre = p;\n                    }\n                    p = p.next;\n                }\n            }\n            return head;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public List<List<Integer>> levelOrder_1(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if (root == null) return res;\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\n        q.offer(root);\n        q.offer(null);\n        List<Integer> level = new ArrayList<Integer>();\n        \n        while(true) {\n            TreeNode node = q.poll();\n            if (node != null) {\n                level.add(node.val);\n                if(node.left!=null) q.offer(node.left);\n                if(node.right!=null) q.offer(node.right);\n            } else {\n                res.add(level);\n                level = new ArrayList<Integer>();\n                if(q.isEmpty()==true) break;\n                q.offer(null);\n            }\n        }\n        return res;\n    }\n    \n    public List<List<Integer>> levelOrder_2(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if (root == null) return res;\n        levelOrderRe(root, 0, res);\n        return res;\n    }\n    public void levelOrderRe(TreeNode root, int level, List<List<Integer>> res) {\n        if(root == null) return;\n        if(level == res.size()) res.add(new ArrayList<Integer>());\n        res.get(level).add(root.val);\n        levelOrderRe(root.left, level+1, res);\n        levelOrderRe(root.right,level+1, res);\n    }\n}\n", "nl": "leetcoders"}
{"code": "class UniqueBinarySearchTrees2 {\n\n  \n  public List<TreeNode> generateTrees(int n) {\n    return generateTrees(1, n);\n  }\n\n  private List<TreeNode> generateTrees(int start, int end) {\n    List<TreeNode> list = new ArrayList<TreeNode>();\n    if (start > end) { // base case\n      list.add(null);\n      return list;\n    }\n\n    List<TreeNode> left, right;\n    for (int i = start; i <= end; i++) { // pick ith node from start to end\n      left = generateTrees(start, i - 1); // list of left subtree\n      right = generateTrees(i + 1, end); // list of right subtree\n      for (TreeNode lnode : left) {\n        for (TreeNode rnode : right) {\n          \n          TreeNode root = new TreeNode(i);\n          root.left = lnode; // attach root of left subtree\n          root.right = rnode; // attach root of right subtree\n          list.add(root); // add tree to result\n        }\n      }\n    }\n    return list;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class SymmetricTree {\n\n    \n    private boolean isSymmetric(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        if (root.left == null || root.right == null) {\n            return root.left == root.right;\n        }\n        Deque<TreeNode> s = new ArrayDeque<>();\n        s.push(root.left);\n        s.push(root.right);\n        while (!s.isEmpty()) {\n            TreeNode n1 = s.pop();\n            TreeNode n2 = s.pop();\n            if (n1.val != n2.val) {\n                return false;\n            }\n            if (n1.left != null && n2.right != null) { // Both are not null.\n                s.push(n1.left);\n                s.push(n2.right);\n            } else if (n1.left != null || n2.right != null) { // Only one of them is null.\n                return false;\n            }\n            if (n1.right != null && n2.left != null) {\n                s.push(n1.right);\n                s.push(n2.left);\n            } else if (n1.right != null || n2.left != null) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    private boolean isSymmetricRec(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return dfs(root.left, root.right);\n    }\n\n    private boolean dfs(TreeNode n1, TreeNode n2) {\n        if (n1 == null || n2 == null) {\n            return n1 == n2;\n        }\n        return n1.val == n2.val && dfs(n1.left, n2.right) && dfs(n1.right, n2.left);\n    }\n\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SearchforaRange {\n\n    public class Solution {\n\n        private int lowerBound(int[] A, int left, int right, int target) {\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (A[mid] < target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            return left;\n        }\n\n        public int[] searchRange(int[] A, int target) {\n            int[] ans = new int[2];\n            int begin = lowerBound(A, 0, A.length - 1, target);\n            if (begin < A.length && A[begin] == target) {\n                ans[0] = begin;\n                ans[1] = lowerBound(A, begin + 1, A.length - 1, target + 1) - 1;\n            } else {\n                ans[0] = -1;\n                ans[1] = -1;\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class DecodeWays2 {\n\tpublic int numDecodings(String s) {\n\t\tif (s == null || s.length() == 0)\n\t\t\treturn 0;\n\t\tif (s.charAt(0) == '0')\n\t\t\treturn 0;\n\t\tint[] dp = new int[s.length() + 1];\n\t\tdp[0] = 1;\n\t\tif (isValid(s.substring(0, 1)))\n\t\t\tdp[1] = 1;\n\t\telse\n\t\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= s.length(); i++) {\n\t\t\tif (isValid(s.substring(i - 1, i)))\n\t\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (isValid(s.substring(i - 2, i)))\n\t\t\t\tdp[i] += dp[i - 2];\n\t\t}\n\t\treturn dp[s.length()];\n\t}\n\tpublic boolean isValid(String s) {\n\t\tif (s.charAt(0) == '0')\n\t\t\treturn false;\n\t\tint code = Integer.parseInt(s);\n\t\treturn code >= 1 && code <= 26;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MergekSortedLists4 {\n\tpublic ListNode mergeKLists(ArrayList<ListNode> lists) {\n\t\tif (lists == null || lists.size() == 0)\n\t\t\treturn null;\n\t\tQueue<ListNode> queue = new LinkedList<ListNode>();\n\t\tfor (ListNode node : lists) \n\t\t\tqueue.add(node);\n\t\twhile (queue.size() != 1) {\n\t\t\tListNode h1=queue.poll();\n\t\t\tListNode h2=queue.poll();\n\t\t\tqueue.add(mergeTwoLists(h1,h2));\n\t\t}\n\t\treturn queue.poll();\n\t}\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tListNode newhead = new ListNode(0);\n\t\tListNode p = newhead;\n\t\twhile (l1 != null && l2 != null) {\n\t\t\tif (l1.val > l2.val) {\n\t\t\t\tp.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t} else {\n\t\t\t\tp.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}\n\t\t\tp = p.next;\n\t\t}\n\t\tif (l1 == null)\n\t\t\tp.next = l2;\n\t\telse\n\t\t\tp.next = l1;\n\t\treturn newhead.next;\n\t}\n}", "nl": "gaohannk"}
{"code": "public class L102_Binary_Tree_Level_Order_Traversal {\n\n\tpublic List<List<Integer>> levelOrder(TreeNode root) {\n\n\t\tList<List<Integer>> rt = new ArrayList<List<Integer>>();\n\n\t\tif (root == null) {\n\t\t\treturn rt;\n\t\t}\n\n\t\tDeque<TreeNode> deque = new LinkedList<TreeNode>();\n\t\tdeque.add(root);\n\n\t\tint toBePrinted = 1;\n\t\tint nextLevel = 0;\n\n\t\tList<Integer> level = new LinkedList<Integer>();\n\n\t\twhile (!deque.isEmpty()) {\n\n\t\t\tTreeNode p = deque.poll();\n\t\t\tlevel.add(p.val);\n\t\t\ttoBePrinted--;\n\n\t\t\tif (p.left != null) {\n\t\t\t\tdeque.addLast(p.left);\n\t\t\t\tnextLevel++;\n\t\t\t}\n\n\t\t\tif (p.right != null) {\n\t\t\t\tdeque.addLast(p.right);\n\t\t\t\tnextLevel++;\n\t\t\t}\n\n\t\t\tif (toBePrinted == 0) {\n\t\t\t\ttoBePrinted = nextLevel;\n\t\t\t\tnextLevel = 0;\n\t\t\t\trt.add(new ArrayList<Integer>(level));\n\t\t\t\tlevel.clear();\n\t\t\t}\n\n\t\t}\n\n\t\treturn rt;\n\t}\n\n\tpublic List<List<Integer>> levelOrder2(TreeNode root) {\n\n\t\tList<List<Integer>> rt = new ArrayList<List<Integer>>();\n\n\t\tif (root == null) {\n\t\t\treturn rt;\n\t\t}\n\n\t\tfinal TreeNode END = new TreeNode(0);\n\n\t\tDeque<TreeNode> deque = new LinkedList<TreeNode>();\n\t\tList<Integer> level = new LinkedList<Integer>();\n\n\t\tdeque.add(root);\n\t\tdeque.add(END);\n\n\t\twhile (!deque.isEmpty()) {\n\n\t\t\tTreeNode p = deque.pop();\n\n\t\t\tif (p == END) {\n\t\t\t\trt.add(new ArrayList<Integer>(level));\n\t\t\t\tlevel.clear();\n\n\t\t\t\tif (!deque.isEmpty()) {\n\t\t\t\t\tdeque.add(END);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlevel.add(p.val);\n\n\t\t\t\tif (p.left != null) {\n\t\t\t\t\tdeque.add(p.left);\n\t\t\t\t}\n\n\t\t\t\tif (p.right != null) {\n\t\t\t\t\tdeque.add(p.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rt;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class SwapNodesInPairs4 {\n\tpublic ListNode swapPairs(ListNode head) {\n\t\tif (head == null || head.next == null)\n\t\t\treturn head;\n\t\tListNode handler = head.next;\n\n\t\tListNode p = head;\n\t\tListNode prev = new ListNode(0);\n\n\t\twhile (p != null && p.next != null) {\n\t\t\tprev.next = p.next;\n\t\t\tListNode q = p.next;\n\t\t\tp.next = q.next;\n\t\t\tq.next = p;\n\t\t\tprev = p;\n\t\t\tp = p.next;\n\t\t}\n\t\treturn handler;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class TextJustification {\n\tpublic ArrayList<String> fullJustify(String[] words, int L) {\n\t\tint len = 0;\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\tStringBuffer str = new StringBuffer();\n\t\tint preindex = 0;\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tif (len + words[i].length() + i - preindex > L) {\n\t\t\t\tint spacenum = 0;\n\t\t\t\tint extraspace = 0;\n\t\t\t\tif (i - preindex != 1) {\n\t\t\t\t\tspacenum = (L - len) / (i - preindex - 1);\n\t\t\t\t\textraspace = (L - len) % (i - preindex - 1);\n\t\t\t\t}\n\t\t\t\tstr = new StringBuffer();\n\t\t\t\tfor (int j = preindex; j < i; j++) {\n\t\t\t\t\tstr.append(words[j]);\n\t\t\t\t\tif (j < i - 1) {\n\t\t\t\t\t\tfor (int k = 0; k < spacenum; k++)\n\t\t\t\t\t\t\tstr.append(\" \");\n\t\t\t\t\t\tif (extraspace > 0)\n\t\t\t\t\t\t\tstr.append(\" \");\n\t\t\t\t\t\textraspace--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = str.length(); j < L; j++)\n\t\t\t\t\tstr.append(\" \");\n\n\t\t\t\tlist.add(str.toString());\n\t\t\t\tpreindex = i;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tlen += words[i].length();\n\t\t}\n\t\tstr = new StringBuffer();\n\t\tfor (int i = preindex; i < words.length; i++) {\n\t\t\tstr.append(words[i]);\n\t\t\tif (str.length() < L)\n\t\t\t\tstr.append(\" \");\n\t\t}\n\t\tfor (int i = str.length(); i < L; i++) {\n\t\t\tstr.append(\" \");\n\t\t}\n\t\tlist.add(str.toString());\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        Arrays.sort(nums);\n        for (int i = 2; i < nums.length; i++) {\n            if (i + 1 < nums.length && nums[i] == nums[i + 1]) {\n                continue;\n            }\n            int start = 0;\n            int end = i - 1;\n            while (start < end) {\n                if (nums[start] + nums[end] + nums[i] == 0) {\n                    result.add(Arrays.asList(nums[start], nums[end], nums[i]));\n                    start++;\n                    while (start < end && nums[start - 1] == nums[start]) { // skip duplicates\n                        start++;\n                    }\n                } else if (nums[start] + nums[end] + nums[i] < 0) {\n                    start++;\n                } else {\n                    end--;\n                }\n            }\n        }\n        return result;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class TrappingRainWater {\n\tpublic int trap(int[] A) {\n\t\tint max = 0;\n\t\tint[] max_left = new int[A.length];\n\t\tint[] max_right = new int[A.length];\n\t\tint contain = 0;\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tif (max < A[i])\n\t\t\t\tmax = A[i];\n\t\t\tmax_left[i] = max <A[i]? A[i]:max;\n\t\t}\n\t\tmax = 0;\n\t\tfor (int i = A.length - 1; i >= 0; i--) {\n\t\t\tif (max < A[i])\n\t\t\t\tmax = A[i];\n\t\t\tmax_right[i] = max;\n\t\t\tcontain += Math.min(max_left[i], max_right[i]) - A[i];\n\t\t}\n\t\treturn contain;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int begin=0;\n        int end=nums.length-1;\n        int a=(begin+end)/2;\n        if (target<nums[0]) {\n            return 0;\n        }\n        if (target>nums[nums.length-1]) {\n        return nums.length;\n        }\n        while (nums[a]!=target) {\n            if (end-1==begin&&(nums[begin]<target&&target<nums[end])) {\n                return end;\n            }\n            if (nums[a]>target) {\n                if (end==a) {\n                    end--;\n                }else {\n                    end=a;\n                }\n            }else {\n                if (begin==a) {\n                    begin++;\n                }else {\n                    begin=a;\n                }\n            }\n            a=(begin+end)/2;\n        }\n            return a;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class L014_Longest_Common_Prefix {\n\n\tpublic String longestCommonPrefix(String[] strs) {\n\n\t\tif (strs == null || strs.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (strs.length == 1) {\n\t\t\treturn strs[0];\n\t\t}\n\n\t\tString string = strs[0];\n\n\t\tfor (int i = 0; i < string.length(); i++) {\n\t\t\tfor (int j = 1; j < strs.length; j++) {\n\t\t\t\tif (!(i < strs[j].length() && string.charAt(i) == strs[j]\n\t\t\t\t\t\t.charAt(i))) {\n\t\t\t\t\treturn string.substring(0, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn string;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public void rotate(int[][] matrix) {\n        rotate(matrix,0);\n    }   \n    \n    public void rotate(int[][] matrix, int layer){\n        int n = matrix.length;\n    \tif(layer<=n/2){\n    \t\tfor(int j=layer;j<n-layer-1;j++){\n    \t\t\tswap(matrix,layer,j,j,n-layer-1);\n    \t\t\tswap(matrix,layer,j,n-layer-1,n-j-1);\n    \t\t\tswap(matrix,layer,j,n-j-1,layer);\n    \t\t}\n    \t\trotate(matrix,layer+1);\n    \t}\n    }\n\n    public void swap(int[][] matrix,int i,int j,int x,int y){\n    \tint temp = matrix[i][j];\n    \tmatrix[i][j] = matrix[x][y];\n    \tmatrix[x][y] = temp;\n    }\n}", "nl": "azheanda"}
{"code": "public class MinStack2 {\n    List<Integer> s = new LinkedList();\n    List<Integer> min = new LinkedList();\n\n    public void push(int x) {\n        if (min.isEmpty()) min.add(x);\n        else if (x <= min.get(min.size() - 1)) min.add(x);\n        s.add(x);\n    }\n\n    public void pop() {\n        if (s.size() < 1) return;\n        if (top() == min.get(min.size() - 1)) min.remove(min.size() - 1);\n        s.remove(s.size() - 1);\n    }\n\n    public int top() {\n        if (s.size() < 1) return 0;\n        return s.get(s.size() - 1);\n    }\n\n    public int getMin() {\n        return min.get(min.size() - 1);\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class AddTwoNumbers2Test {\n\n    @Test\n    public void testAddTwoNumbersWithCarry() {\n        ListNode l1 = Utils.buildLinkedList(new int[]{7, 2, 4, 3});\n        ListNode l2 = Utils.buildLinkedList(new int[]{5, 6, 4});\n        AddTwoNumbers2 a = new AddTwoNumbers2();\n        ListNode result = a.addTwoNumbers(l1, l2);\n        int[] expectedValues = new int[]{7, 8, 0, 7};\n        Assert.assertNotNull(result);\n        compare(expectedValues, result);\n    }\n\n    @Test\n    public void testNullInputs() {\n        ListNode l1 = null;\n        ListNode l2 = null;\n        AddTwoNumbers2 a = new AddTwoNumbers2();\n        Assert.assertNull(a.addTwoNumbers(l1, l2));\n\n        int[] list1 = {1, 2, 3};\n        l1 = Utils.buildLinkedList(list1);\n        ListNode result = a.addTwoNumbers(l1, l2);\n        Assert.assertNotNull(result);\n        compare(list1, result);\n\n        l2 = l1;\n        l1 = null;\n        result = a.addTwoNumbers(l1, l2);\n        Assert.assertNotNull(result);\n        compare(list1, result);\n    }\n\n    private void compare(int[] expectedValues, ListNode node) {\n        for (int value : expectedValues) {\n            Assert.assertEquals(value, node.val);\n            node = node.next;\n        }\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class GasStation {\n  \n  public static void main(String[] args) throws Exception {\n    int[] gas = {10, 20, 30, 10};\n    int[] cost = {5, 30, 10, 10};\n    System.out.println(new GasStation().canCompleteCircuit(gas, cost));\n  }\n\n  public int canCompleteCircuit(int[] gas, int[] cost) {\n    int debt = 0, sum = 0, start = 0;\n    for (int i = 0; i < gas.length; i++) {\n      sum += gas[i] - cost[i];\n      if (sum < 0) {\n        debt += sum;\n        sum = 0;\n        start = i + 1;\n      }\n    }\n    debt += sum;\n    return debt >= 0 ? start : -1;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class RemoveDuplicatesfromSortedArrayII2 {\n\tpublic int removeDuplicates(int[] A) {\n\t\tif (A.length <= 2)\n\t\t\treturn A.length;\n\t\tint prev = 1; // point to previous\n\t\tint curr = 2; // point to current\n\t\twhile (curr < A.length) {\n\t\t\tif (A[curr] == A[prev] && A[curr] == A[prev - 1]) {\n\t\t\t\tcurr++;\n\t\t\t} else {\n\t\t\t\tprev++;\n\t\t\t\tA[prev] = A[curr];\n\t\t\t\tcurr++;\n\t\t\t}\n\t\t}\n\t\treturn prev + 1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}", "nl": "leetcoders"}
{"code": "public class _85_maximalRectangle {\n\n    public static void main(String[] args) {\n        _85_maximalRectangle maximalRectangle = new _85_maximalRectangle();\n        int i = maximalRectangle.maximalRectangle(new char[][]{\n                {'1', '0', '1', '0', '0'},\n                {'1', '0', '1', '1', '1'},\n                {'1', '1', '1', '1', '1'},\n                {'1', '0', '0', '1', '0'}\n        });\n        System.out.println(i);\n    }\n\n\n    \n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        int[] left = new int[n]; // initialize left as the leftmost boundary possible\n        int[] right = new int[n];\n        int[] height = new int[n];\n\n        Arrays.fill(right, n); // initialize right as the rightmost boundary possible\n\n        int maxarea = 0;\n        for (int i = 0; i < m; i++) {\n            int cur_left = 0, cur_right = n;\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == '1') height[j]++;\n                else height[j] = 0;\n            }\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == '1') left[j] = Math.max(left[j], cur_left);\n                else {\n                    left[j] = 0;\n                    cur_left = j + 1;\n                }\n            }\n            for (int j = n - 1; j >= 0; j--) {\n                if (matrix[i][j] == '1') right[j] = Math.min(right[j], cur_right);\n                else {\n                    right[j] = n;\n                    cur_right = j;\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                maxarea = Math.max(maxarea, (right[j] - left[j]) * height[j]);\n            }\n        }\n        return maxarea;\n    }\n}\n", "nl": "pphdsny"}
{"code": "class SingleNumber {\n\n  public static void main(String[] args) {\n    int[] A = {1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7};\n    System.out.println(singleNum(A));\n    System.out.println(singleNumNoSpace(A));\n  }\n\n  \n  public static int singleNumNoSpace(int[] A) {\n    int res = 0;\n    for (int i = 0; i < A.length; i++) res ^= A[i];\n    return res;\n  }\n\n  \n  public static int singleNum(int[] A) {\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n    for (int i = 0; i < A.length; i++) {\n      if (!map.containsKey(A[i])) map.put(A[i], 1);\n      else map.remove(A[i]);\n    }\n    int res = 0;\n    for (Integer key : map.keySet()) res = key;\n    return res;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class _155_MinStack {\n    public static void main(String[] args) {\n        MinStackOther obj = new MinStackOther();\n        obj.push(Integer.MAX_VALUE);\n        obj.push(Integer.MAX_VALUE);\n        obj.push(Integer.MAX_VALUE);\n        obj.top();\n        obj.pop();\n        obj.getMin();\n        obj.pop();\n        obj.getMin();\n        obj.pop();\n        obj.push(Integer.MAX_VALUE);\n        obj.top();\n        obj.getMin();\n        obj.push(Integer.MIN_VALUE);\n        obj.top();\n        obj.getMin();\n        obj.pop();\n        System.out.println(obj.getMin());\n\n    }\n\n    public static class MinStack {\n\n        Stack<Integer> dataStack;\n        Stack<Integer> minStack;    //\u701b\u6a3b\u7621\u6d93\u6d63\u5cf1ush\u6769\u6d98\u5e53\u9428\u52ec\u6902\u934a\u6b19\u7d1d\u93c8\u704f\u5fd5\u6b91\u934a\n\n        \n        public MinStack() {\n            dataStack = new Stack<>();\n            minStack = new Stack<>();\n        }\n\n        public void push(int x) {\n            dataStack.push(x);\n            if (minStack.isEmpty()) {\n                minStack.push(x);\n            } else if (x >= minStack.peek()) {\n                minStack.push(minStack.peek());\n            } else {\n                minStack.push(x);\n            }\n        }\n\n        public void pop() {\n            dataStack.pop();\n            minStack.pop();\n        }\n\n        public int top() {\n            return dataStack.peek();\n        }\n\n        public int getMin() {\n            return minStack.peek();\n        }\n    }\n\n    \n    public static class MinStackOther {\n        int min;\n        Stack<Integer> stack;\n\n        public MinStackOther() {\n            stack = new Stack<>();\n        }\n\n        public void push(int x) {\n            if (stack.isEmpty()) {\n                stack.push(0);\n                min = x;\n            } else {\n                stack.push(x - min);//Could be negative if min value needs to change\n                if (x < min) min = x;\n            }\n        }\n\n        public void pop() {\n            if (stack.isEmpty()) return;\n\n            int pop = stack.pop();\n\n            if (pop < 0) min = min - pop;//If negative, increase the min value\n\n        }\n\n        public int top() {\n            int top = stack.peek();\n            if (top > 0) {\n                return top + min;\n            } else {\n                return (min);\n            }\n        }\n\n        public int getMin() {\n            return min;\n        }\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Solution {\n    \n    public int minPathSum(int[][] grid) {\n        \n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int row = grid.length;\n        int col = grid[0].length;\n        int[][] matrix = new int[row][col];\n        matrix[0][0] = grid[0][0];\n        for (int i = 1; i < row; i++) {\n            matrix[i][0] = matrix[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < col; j++) {\n            matrix[0][j] = matrix[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < row; i++) {\n            for (int j = 1; j < col; j++) {\n                matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1])\n                                + grid[i][j];\n            }\n        }\n        return matrix[row - 1][col - 1];\n        \n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "class Solution {\n    public int search(int[] nums, int target) {\n        if (nums == null || nums.length == 0) return -1;\n        int start = 0, end = nums.length - 1;\n        while (start + 1 < end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[start] < nums[mid]) { //Land in 1st continous section\n                if (nums[start] <= target && target <= nums[mid]) { //target in 1st section?\n                    end = mid;\n                } else {\n                    start = mid;\n                }\n            } else { //Land in 2nd continous section\n                if (nums[mid] <= target && target <= nums[end]) { //target in 2nd section?\n                    start = mid;\n                } else {\n                    end = mid;\n                }\n            }\n        }\n        if (nums[start] == target) return start;\n        if (nums[end] == target) return end;\n        \n        return -1;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    \n    public TreeNode parentNode = null;\n    public void flatten(TreeNode root) {\n    \tif (root == null) {\n    \t\treturn;\n    \t}\n\n    \tif (parentNode != null) {\n    \t\tparentNode.left = null;\n    \t\tparentNode.right = root;\n    \t}\n\n    \tparentNode = root;\n    \tTreeNode right  = root.right;\n    \tflatten(root.left);\n    \tflatten(right);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int n = s.length();\n        char[] ss = s.toCharArray();\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // 1 to help build dp, can be: no digit, means there is only 1 way to decode: no message\n        dp[1] = s.charAt(0) != '0' ? 1 : 0; // only has s.charAt(0);\n        for (int i = 2; i <= n; i++) {\n            int oneDigit = ss[i - 1] - '0';\n            if (oneDigit >= 1 && oneDigit <= 9) {\n                dp[i] += dp[i - 1];\n            }\n            int twoDigit = (ss[i - 1] - '0') + 10 * (ss[i - 2] - '0');\n            if (twoDigit >= 10 && twoDigit <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        return dp[n];\n     }\n}\n", "nl": "awangdev"}
{"code": "public class SearchInsertPosition \n{\n    public int searchInsert( int[] nums, int target )\n    {\n    \tif ( nums.length == 0 )\n    \t{\n    \t\treturn 0;\n    \t}\n    \t\n    \tint start = 0;\n    \tint end = nums.length - 1;\n    \twhile ( start + 1 < end )\n    \t{\n    \t\tint mid = ( end - start ) / 2 + start;\n    \t\tif ( nums[mid] < target )\n    \t\t{\n    \t\t\tstart = mid;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tend = mid;\n    \t\t}\n    \t}\n    \t\n    \tif ( nums[end] < target )\n    \t{\n    \t\treturn end + 1;\n    \t}\n    \telse if ( nums[start] < target \n    \t\t\t&& nums[end] >= target )\n    \t{\n    \t\treturn end;\n    \t}\n    \telse\n    \t{\n    \t\treturn start;\n    \t}\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class L007_Reverse_Integer {\n\n\tpublic int reverse(int x) {\n\n\t\tif (x == Integer.MIN_VALUE) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (x < 0) {\n\t\t\treturn -reverse(-x);\n\t\t}\n\n\t\tint rt = 0;\n\n\t\tdo {\n\n\t\t\tif (rt > (Integer.MAX_VALUE - x % 10) / 10) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\trt = rt * 10 + x % 10;\n\t\t\tx = x / 10;\n\n\t\t} while (x > 0);\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class LRUCache {\n\tprivate HashMap<Integer, DoubleLinkedListNode> map = new HashMap<Integer, DoubleLinkedListNode>();\n\tprivate DoubleLinkedListNode head;\n\tprivate DoubleLinkedListNode end;\n\tprivate int capacity;\n\tprivate int len;\n\n\tpublic LRUCache(int capacity) {\n\t\tthis.capacity = capacity;\n\t\tlen = 0;\n\t}\n\n\tpublic int get(int key) {\n\t\tif (map.containsKey(key)) {\n\t\t\tDoubleLinkedListNode latest = map.get(key);\n\t\t\tremoveNode(latest);\n\t\t\tsetHead(latest);\n\t\t\treturn latest.val;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic void removeNode(DoubleLinkedListNode node) {\n\t\tDoubleLinkedListNode cur = node;\n\t\tDoubleLinkedListNode pre = cur.pre;\n\t\tDoubleLinkedListNode post = cur.next;\n\n\t\tif (pre != null)\n\t\t\tpre.next = post;\n\t\telse \n\t\t\thead = post;\n\t\tif (post != null) \n\t\t\tpost.pre = pre;\n\t\telse \n\t\t\tend = pre;\n\t\t\n\t}\n\n\tpublic void setHead(DoubleLinkedListNode node) {\n\t\tnode.next = head;\n\t\tnode.pre = null;\n\t\tif (head != null) \n\t\t\thead.pre = node;\n\t\thead = node;\n\t\tif (end == null) \n\t\t\tend = node;\n\t}\n\n\tpublic void set(int key, int value) {\n\t\tif (map.containsKey(key)) {\n\t\t\tDoubleLinkedListNode oldNode = map.get(key);\n\t\t\toldNode.val = value;\n\t\t\tremoveNode(oldNode);\n\t\t\tsetHead(oldNode);\n\t\t} else {\n\t\t\tDoubleLinkedListNode newNode = new DoubleLinkedListNode(key, value);\n\t\t\tif (len < capacity) {\n\t\t\t\tsetHead(newNode);\n\t\t\t\tmap.put(key, newNode);\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tmap.remove(end.key);\n\t\t\t\tend = end.pre;\n\t\t\t\tif (end != null)\n\t\t\t\t\tend.next = null;\n\t\t\t\tsetHead(newNode);\n\t\t\t\tmap.put(key, newNode);\n\t\t\t}\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int minPathSum(int[][] grid) {\n        if (grid.length == 0) return Integer.MIN_VALUE;\n        int M = grid.length, N = grid[0].length;\n        int[] dp = new int[N];\n        dp[0] = grid[0][0];\n        for (int i = 1; i < N; ++i)\n            dp[i] = grid[0][i] + dp[i-1];\n        \n        for (int i = 1; i < M; ++i)\n        {\n            dp[0] += grid[i][0];\n            for (int j = 1; j < N; ++j)\n                dp[j] = Math.min(dp[j-1], dp[j]) + grid[i][j];\n        }\n        \n        return dp[N-1];  \n    }\n}", "nl": "leetcoders"}
{"code": "public class BinaryTreePaths {\n\n  \n  public List<String> binaryTreePaths(TreeNode root) {\n    List<String> paths = new ArrayList<>();\n    backtrack(root, new StringBuilder(), paths);\n    return paths;\n  }\n\n  private void backtrack(TreeNode root, StringBuilder path, List<String> paths) {\n    if (root == null) return;\n    if (root.left == null && root.right == null) { // A leaf.\n      paths.add(path.append(root.val).toString());\n      return;\n    }\n    path.append(root.val).append(\"->\"); // Arrow should be appended before reaching leaf.\n    int len = path.length();\n    backtrack(root.left, path, paths);\n    path.setLength(len); // Reset path.\n    backtrack(root.right, path, paths);\n    path.setLength(len);\n  }\n\n  \n  public List<String> binaryTreePaths2(TreeNode root) {\n    if (root == null) {\n      return Collections.emptyList();\n    }\n    List<String> paths = new ArrayList<>();\n    if (root.left == null && root.right == null) {\n      paths.add(Integer.toString(root.val));\n      return paths;\n    }\n    for (String path : binaryTreePaths2(root.left)) {\n      paths.add(root.val + \"->\" + path); // Concat root with each path.\n    }\n    for (String path : binaryTreePaths2(root.right)) {\n      paths.add(root.val + \"->\" + path);\n    }\n    return paths;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SortColors {\n\n  private static final int RED = 0;\n  private static final int WHITE = 1;\n  private static final int BLUE = 2;\n\n  \n  public void sortColors(int[] nums) {\n    int redEnd = -1; // Ending index of red\n    int whiteEnd = -1; // Ending index of white\n\n    for (int i = 0; i < nums.length; i++) {\n      int v = nums[i];\n      nums[i] = BLUE;\n      if (v == RED) {\n        nums[++whiteEnd] = WHITE; // Update white first\n        nums[++redEnd] = RED; // If there is no white yet, will overwrite white.\n      } else if (v == WHITE) {\n        nums[++whiteEnd] = WHITE;\n      }\n    }\n  }\n\n  \n  public void sortColors2(int nums[]) {\n    int redEnd = 0, blueStart = nums.length - 1;\n    for (int i = 0; i <= blueStart; i++) {\n      while (nums[i] == BLUE && i < blueStart) { // Move all BLUEs to the end.\n        swap(nums, i, blueStart--);\n      }\n      while (nums[i] == RED && i > redEnd) { // Move all REDs to the front.\n        swap(nums, i, redEnd++);\n      }\n    }\n  }\n\n  \n  public void sortColors3(int[] nums) {\n    int redEnd = 0;\n    int blueStart = nums.length - 1;\n    int i = 0;\n    while (i <= blueStart) { // i stops at blueStart, no blueStart - 1.\n      if (nums[i] == RED) {\n        swap(nums, i++, redEnd++);\n      } else if (nums[i] == BLUE) {\n        swap(nums, i, blueStart--);\n      } else {\n        i++;\n      }\n    }\n  }\n\n  private void swap(int[] nums, int i1, int i2) {\n    int temp = nums[i1];\n    nums[i1] = nums[i2];\n    nums[i2] = temp;\n  }\n\n  \n  public void sortColors4(int[] nums) {\n    int red = 0;\n    int white = 0;\n\n    for (int i = 0; i < nums.length; i++) {\n      if (nums[i] == RED) {\n        red++;\n      } else if (nums[i] == WHITE) {\n        white++;\n      }\n    }\n    for (int i = 0; i < nums.length; i++) {\n      if (i < red) {\n        nums[i] = RED;\n      } else if (i < red + white) {\n        nums[i] = WHITE;\n      } else {\n        nums[i] = BLUE;\n      }\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "class FirstMissingPositive {\n  public static void main(String[] args) {\n    int[] A = {1, 2, 0};\n    System.out.println(new FirstMissingPositive().firstMissingPositive(A));\n  }\n\n  \n  public int firstMissingPositive(int[] nums) {\n    if (nums == null || nums.length == 0) {\n      return 1;\n    }\n    int length = nums.length;\n    for (int i = 0; i < length; i++) {\n      int num = nums[i];\n      while (nums[i] <= length && nums[i] > 0 && nums[num - 1] != num) {\n        nums[i] = nums[num - 1];\n        nums[num - 1] = num;\n        num = nums[i];\n      }\n    }\n    for (int i = 0; i < length; i++) {\n      if (nums[i] != i + 1) {\n        return i + 1;\n      }\n    }\n    return length + 1; // Nothing in middle missing, return largest\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class MultiplyStrings {\n\n  \npublic String multiply(String num1, String num2) {\n  if (num1 == null || num2 == null) {\n    return \"\";\n  }\n  if (\"0\".equals(num1) || \"0\".equals(num2)) { // If one number is 0\n    return \"0\";\n  }\n  int m = num1.length(), n = num2.length();\n  int[] product = new int[m + n]; // Length is at most m + n.\n  for (int i = m - 1; i >= 0; i--) { // From right to left, from lower significant digit to higher\n    int x = num1.charAt(i) - '0';\n    for (int j = n - 1; j >= 0; j--) {\n      int mul = x * (num2.charAt(j) - '0');\n      product[i + j + 1] += mul;\n      product[i + j] += product[i + j + 1] / 10; // Carry\n      product[i + j + 1] %= 10; // i + j + 1 will cover every digit and make them < 10\n    }\n  }\n\n  final StringBuilder result = new StringBuilder();\n  for (int p : product) {\n    if (p != 0 || result.length() != 0) {\n      result.append(p);\n    }\n  }\n  return result.toString();\n}\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public ListNode swapPairs_1(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        while (cur.next != null && cur.next.next != null) {\n            ListNode node = cur.next.next;\n            cur.next.next = node.next;\n            node.next = cur.next;\n            cur.next = node;\n            cur = node.next;\n        }\n        return dummy.next;\n    }\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode first = head, second = head.next;\n        first.next = second.next;\n        second.next = first;\n        first.next = swapPairs(first.next);\n        return second;\n    }\n}", "nl": "leetcoders"}
{"code": "public class FirstMissingPositive2 {\n\tpublic int firstMissingPositive(int[] A) {\n\t\tint i = 0;\n\t\twhile (i < A.length) {\n\t\t\tif (A[i] != (i + 1) && A[i] >= 1 && A[i] <= A.length && A[A[i] - 1] != A[i]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[temp - 1];\n\t\t\t\tA[temp - 1] = temp;\t\t\n\t\t\t}else\n\t\t\t\ti++;\n\t\t}\n\t\tfor (i = 0; i < A.length; ++i)\n\t\t\tif (A[i] != (i + 1))\n\t\t\t\treturn i + 1;\n\t\treturn A.length + 1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class WordLadder {\n\n    public class Solution {\n        public int ladderLength(String start, String end, HashSet<String> dict) {\n            if (start.equals(end)) {\n                return 1;\n            }\n            List<String> queue = new ArrayList<String>();\n            int level = 1;\n            queue.add(start);\n            int begin = 0;\n            char[] endCharArray = end.toCharArray();\n            Set<String> used = new HashSet<String>();\n            used.add(start);\n            while (begin < queue.size()) {\n                int tail = queue.size();\n                for (int i = begin; i < tail; i++) {\n                    char[] word = queue.get(i).toCharArray();\n                    for (int j = 0; j < word.length; j++) {\n                        char currentChar = word[j];\n                        for (char c = 'a'; c <= 'z'; c++) {\n                            if (c == currentChar) {\n                                continue;\n                            }\n                            word[j] = c;\n                            if (Arrays.equals(word, endCharArray)) {\n                                return level + 1;\n                            }\n                            String nextWord = new String(word);\n                            if (dict.contains(nextWord)\n                                    && !used.contains(nextWord)) {\n                                used.add(nextWord);\n                                queue.add(nextWord);\n                            }\n                            word[j] = currentChar;\n                        }\n                    }\n                }\n                level++;\n                begin = tail;\n            }\n            return 0;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class PalindromePartitioning {\n  \n  public static void main(String[] args) throws Exception {\n    List<List<String>> result = new PalindromePartitioning().partition(\"aaaaaaaaaaaaaaaaaa\");\n  }\n\n  public List<List<String>> partition(String s) {\n    List<List<String>> result = new ArrayList<>();\n    doNext(0, new ArrayList<>(), s, result);\n    return result;\n  }\n\n  private void doNext(int i, List<String> row, String s, List<List<String>> result) {\n    if (i == s.length()) {\n      List<String> list = new ArrayList<>(row);\n      result.add(list);\n    } else {\n      for (int j = i, l = s.length(); j < l; j++) {\n        String sbStr = s.substring(i, j + 1);\n        if (isPalindrome(sbStr)) {\n          row.add(sbStr);\n          doNext(j + 1, row, s, result);\n          row.remove(row.size() - 1);\n        }\n      }\n    }\n  }\n\n  private boolean isPalindrome(String s) {\n    int i = 0, j = s.length() - 1;\n    while (i <= j) {\n      if (s.charAt(i) != s.charAt(j)) return false;\n      i++;\n      j--;\n    }\n    return true;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class L070_Climbing_Stairs {\n\n\tpublic int climbStairs(int n) {\n\n\t\tif (n < 0) {\n\t\t\treturn -1;\n\t\t} else if (n <= 2) {\n\t\t\treturn n;\n\t\t}\n\n\t\tint step1 = 1;\n\t\tint step2 = 2;\n\t\tint step3 = 0;\n\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tstep3 = step1 + step2;\n\t\t\tstep1 = step2;\n\t\t\tstep2 = step3;\n\t\t}\n\n\t\treturn step3;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head==null||head.next==null) {\n            return head;\n        }\n        ListNode node=head.next;\n        ListNode ans=new ListNode(head.val);\n        while (node!=null) {\n            if (node.val<=ans.val) {\n                ListNode newAns=new ListNode(node.val);\n                newAns.next=ans;\n                ans=newAns;\n            }else {\n                ListNode test=ans;\n                ListNode a=null;\n                while (test!=null&&test.val<node.val) {\n                    a=test;\n                    test=test.next;\n                }\n                ListNode insert=new ListNode(node.val);\n                a.next=insert;\n                insert.next=test;\n            }\n            node=node.next;\n        }\n        return ans;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public void sortColors(int[] nums) {\n    int t=0;\n    int b=0;\n    int e=nums.length-1;\n    boolean flag=true;\n    for (int i = 0; i < nums.length; i++) {\n            if (flag) {\n                if (nums[b]!=0) {\n                    t=b;\n                    flag=false;\n                }else {\n                    t++;\n                }\n                b++;\n            }else {\n                if (nums[e]==0) {\n                    nums[e]=nums[t];\n                    nums[t]=0;\n                    flag=true;\n                    t++;\n                }\n                e--;\n            }\n    }\n    b=t;\n    e=nums.length-1;\n    flag=true;\n     for (int i = t; i < nums.length; i++) {\n            if (flag) {\n                if (nums[b]!=1) {\n                    t=b;\n                    flag=false;\n                }\n                b++;\n            }else {\n                if (nums[e]==1) {\n                    nums[e]=nums[t];\n                    nums[t]=1;\n                    flag=true;\n                }\n                e--;\n            }\n    }\n    \n        \n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) return new String(\"\");\n        for(int i = 0;i < strs[0].length(); ++i){\n            for(int j = 1;j < strs.length; ++j){\n                if(i >= strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) \n                    return strs[0].substring(0,i);\n            }\n        }\n        return strs[0];\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    \n    public List<List<String>> partition(String s) {\n        List<List<String>> rst = new ArrayList<List<String>>();\n        if (s == null || s.length() < 0) {\n            return rst;\n        }\n        ArrayList<String> path = new ArrayList<String>();\n        helper(s, path, 0, rst);\n        return rst;\n    }\n    public boolean isPalindrome(String s){\n        int start = 0;\n        int end = s.length() - 1;\n        while (start < end) {\n            if (s.charAt(start) != s.charAt(end)) {\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n    public void helper(String s, ArrayList<String> path, int pos, \n        List<List<String>> rst) {\n        if (pos == s.length()) {\n            rst.add(new ArrayList<String>(path));\n            return;\n        }        \n        for (int i = pos + 1; i <= s.length(); i++) {//i is used in s.sbustring(pos, i), which can equal to s.length()\n            String prefix = s.substring(pos, i);\n            if (!isPalindrome(prefix)) {\n                continue;\n            }\n            path.add(prefix);\n            helper(s, path, i, rst);\n            path.remove(path.size() - 1);\n        }    \n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class ContainerWithMostWater {\n\n    public class Solution {\n        public int maxArea(int[] height) {\n            int maxArea = 0;\n            int start = 0;\n            int end = height.length - 1;\n            while (start < end) {\n                if (height[start] < height[end]) {\n                    maxArea = Math.max(maxArea, (end - start) * height[start]);\n                    start++;\n                } else {\n                    maxArea = Math.max(maxArea, (end - start) * height[end]);\n                    end--;\n                }\n            }\n            return maxArea;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class RemoveDuplicatesfromSortedArrayII {\n\tpublic int removeDuplicates(int[] A) {\n\t\tif (A == null || A.length == 0)\n\t\t\treturn 0;\n\n\t\tint pre = A[0];\n\t\tboolean flag = false;\n\t\tint count = 1;\n\t\tfor (int i = 1; i < A.length; i++) {\n\t\t\tint curr = A[i];\n\t\t\tif (curr == pre) {\n\t\t\t\tif (!flag) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tA[count++] = curr;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpre = curr;\n\t\t\t\tA[count++] = curr;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\n}\n", "nl": "gaohannk"}
{"code": "public class BinaryTreePaths {\n\tpublic List<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> res = new LinkedList<String>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (root == null)\n\t\t\treturn res;\n\t\thelper(root, res, sb);\n\t\treturn res;\n\t}\n\n\tpublic void helper(TreeNode node, List<String> res, StringBuilder sb) {\n\t\tif (node.left == null && node.right == null) {\n\t\t\tsb.append(node.val);\n\t\t\tres.add(sb.toString());\n\t\t\tsb.delete(sb.length() - String.valueOf(node.val).length(), sb.length());\n\t\t\treturn;\n\t\t} else {\n\t\t\tsb.append(node.val + \"->\");\n\t\t}\n\t\tif (node.left != null)\n\t\t\thelper(node.left, res, sb);\n\t\tif (node.right != null)\n\t\t\thelper(node.right, res, sb);\n\t\tsb.delete(sb.length() - 2 - String.valueOf(node.val).length(), sb.length());\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class NextPermutation {\n  public void nextPermutation(int[] num) {\n    int i1 = 0;\n    int i2 = 0;\n    int i = num.length - 1;\n    int j = 0;\n    while (i > 0 && num[i - 1] >= num[i]) {\n      i--;\n    }\n    if (i == 0) {\n      Arrays.sort(num);\n      return;\n    } else {\n      i1 = i - 1;\n    }\n    j = i1 + 1;\n    while (j < num.length && num[i1] < num[j]) {\n      j++;\n    }\n    i2 = j - 1;\n    int temp = num[i1];\n    num[i1] = num[i2];\n    num[i2] = temp;\n    Arrays.sort(num, i1 + 1, num.length);\n  }\n}\n", "nl": "mengli"}
{"code": "public class PalindromePartitioning {\n\tpublic ArrayList<ArrayList<String>> partition(String s) {\n\t\tArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();\n\t\tif (s == null || s.length() == 0)\n\t\t\treturn result;\n\n\t\tArrayList<String> partition = new ArrayList<String>();\n\t\taddPalindrome(s, 0, partition, result);\n\t\treturn result;\n\t}\n\n\tprivate void addPalindrome(String s, int start, ArrayList<String> partition, ArrayList<ArrayList<String>> result) {\n\t\tif (start == s.length()) {\n\t\t\tresult.add(new ArrayList<String>(partition));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = start + 1; i <= s.length(); i++) {\n\t\t\tString str = s.substring(start, i);\n\t\t\tif (isPalindrome(str)) {\n\t\t\t\tpartition.add(str);\n\t\t\t\taddPalindrome(s, i, partition, result);\n\t\t\t\tpartition.remove(partition.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isPalindrome(String str) {\n\t\tint left = 0;\n\t\tint right = str.length() - 1;\n\n\t\twhile (left < right) {\n\t\t\tif (str.charAt(left) != str.charAt(right)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tleft++;\n\t\t\tright--;\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class TwoSum {\n\n    public int[] twoSum(int[] numbers, int target) {\n        int[] ret = new int[2];\n        for (int i = 0; i < numbers.length; i++) {\n            if (numbers[i] <= target) {\n                for (int j = i + 1; j < numbers.length; j++) {\n                    if (numbers[i] + numbers[j] == target) {\n                        ret[0] = i;\n                        ret[1] = j;\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public boolean canJump(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n        int farest = 0;\n        for (int i = 0; i < nums.length; i++) {\n            farest = Math.max(farest, i + nums[i]);\n            if (farest >= nums.length - 1) {\n                return true;\n            }\n            if (farest <= i) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int hIndex(int[] citations) {\n        if (citations == null || citations.length == 0) {\n        \treturn 0;\n        }\n        Arrays.sort(citations);\n        for (int h = citations.length; h > 0; h--) {\n        \tint x = citations.length - h;\n        \tif (citations[x] >= h) {\n        \t\treturn h;\n        \t}\n        }\n        return 0;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class TextJustification {\n  public List<String> fullJustify(String[] words, int L) {\n    int wCount = 0, charCount = 0;\n    List<String> line = new ArrayList<>();\n    List<String> result = new ArrayList<>();\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0, l = words.length; i < l; i++) {\n      String next = words[i];\n      if ((L - (charCount + wCount)) >= next.length()) {\n        line.add(next);\n        charCount += next.length();\n        wCount++;\n      } else {\n        sb.append(line.get(0));\n        StringBuilder space = new StringBuilder();\n        if (line.size() > 1) {\n          int spaceCount = (L - charCount) / (wCount - 1);\n          int remaining = (L - charCount) % (wCount - 1);\n\n          for (int j = 0; j < spaceCount; j++) space.append(' ');\n\n          for (int k = 1, kl = line.size(); k < kl; k++) {\n            sb.append(space);\n            if (remaining > 0) {\n              sb.append(' ');\n              --remaining;\n            }\n            sb.append(line.get(k));\n          }\n        } else {\n          int balance = L - (charCount + (wCount - 1));\n          for (int j = 0; j < balance; j++) sb.append(' ');\n        }\n        result.add(sb.toString());\n        sb = new StringBuilder();\n        line.clear();\n        line.add(next);\n        charCount = next.length();\n        wCount = 1;\n      }\n    }\n    if (!line.isEmpty()) {\n      sb.append(line.get(0));\n      for (int i = 1, l = line.size(); i < l; i++) {\n        sb.append(' ');\n        sb.append(line.get(i));\n      }\n    }\n    int balance = L - (charCount + (wCount - 1));\n    for (int i = 0; i < balance; i++) sb.append(' ');\n    result.add(sb.toString());\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public double pow(double x, int n) {\n        if (x < 0) return (n % 2 == 0) ? pow(-x, n) : -pow(-x, n);\n        if (x == 0 || x == 1) return x;\n        if (n < 0) return 1.0 / pow(x,-n);\n        if (n == 0) return 1.0;\n        if (n == 1) return x;\n        double half = pow(x,n/2);\n        if (n % 2 == 0) return half * half;\n        else return x * half * half;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    \n    public static ListNode deleteDuplicates(ListNode head) {\n        if (head == null) {\n            return head;\n        }   \n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode node = dummyHead;\n    \n        while (node.next != null && node.next.next != null) {\n            if (node.next.val == node.next.next.val) {\n                int duplicatedVal = node.next.val;\n                while (node.next != null && node.next.val == duplicatedVal) {\n                    node.next = node.next.next;\n                }\n            } else {\n                node = node.next;\n            }\n        }\n        \n        return dummyHead.next;\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "public class RemoveDuplicatesfromSortedArray {\n  public int removeDuplicates(int[] A) {\n    if (A.length == 0) return 0;\n    else if (A.length == 1) return 1;\n    else {\n      int ret = 1;\n      int p = 0;\n      for (int p1 = 1; p1 < A.length; p1++) {\n        if (A[p1 - 1] != A[p1]) {\n          ret++;\n          A[++p] = A[p1];\n        }\n      }\n      return ret;\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public ArrayList<Integer> grayCode(int n) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        ArrayList<Integer> preres = new ArrayList<Integer>();\n\n        res.add(0);\n        if(n==0)\n            return res;\n        \n       \tres.add(1);\n        if(n==1)\n        \treturn res;\n\n        for(int i=2;i<=n;i++){\n        \tfor(Integer j:res)\n        \t\tpreres.add(j);\n        \tCollections.reverse(res);\n        \tfor(Integer j:res)\n        \t\tpreres.add((int)(j+Math.pow(2,i-1)));\n\n        \tres = preres;\n        \tpreres= new ArrayList<Integer>();\n\t\t}\n\t\treturn res;\n    }\n}", "nl": "azheanda"}
{"code": "public class ReverseWordsInAString2 {\n\n  public void reverseWords(char[] str) {\n    reverse(str, 0, str.length - 1); // Reverse the whole string first\n    int r = 0;\n    while (r < str.length) {\n      int l = r;\n      while (r < str.length && str[r] != ' ')\n        r++;\n      reverse(str, l, r - 1); // Reverse words one by one\n      r++;\n    }\n  }\n\n  private void reverse(char[] str, int l, int r) {\n    while (l < r) {\n      char tmp = str[l];\n      str[l++] = str[r];\n      str[r--] = tmp;\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class LongestCommonPrefix {\n  public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    int index = 0;\n    while (index < strs[0].length()) {\n      char c = strs[0].charAt(index);\n      for (int i = 1; i < strs.length; ++i) {\n        if (index >= strs[i].length() || strs[i].charAt(index) != c) {\n          return strs[0].substring(0, index);\n        }\n      }\n      index++;\n    }\n    return strs[0];\n  }\n}\n", "nl": "mengli"}
{"code": "public class SortList {\n\tpublic ListNode sortList(ListNode head) {\n\t\tif (head == null || head.next == null)\n\t\t\treturn head;\n\t\tListNode fast = head, slow = head;\n\t\tListNode prev = head;\n\n\t\twhile (fast != null && fast.next != null) {\n\t\t\tfast = fast.next.next;\n\t\t\tprev = slow;\n\t\t\tslow = slow.next;\n\t\t}\n\t\tprev.next = null;\n\t\tListNode left = sortList(head);\n\t\tListNode right = sortList(slow);\n\t\tListNode handler = null;\n\t\tif (left.val > right.val) {\n\t\t\thandler = right;\n\t\t\tright = right.next;\n\t\t} else {\n\t\t\thandler = left;\n\t\t\tleft = left.next;\n\t\t}\n\n\t\tListNode tail = handler;\n\n\t\twhile (right != null && left != null) {\n\t\t\tif (right.val < left.val) {\n\t\t\t\ttail.next = right;\n\t\t\t\ttail = right;\n\t\t\t\tright = right.next;\n\t\t\t} else {\n\t\t\t\ttail.next = left;\n\t\t\t\ttail = left;\n\t\t\t\tleft = left.next;\n\t\t\t}\n\t\t}\n\n\t\tif (left == null)\n\t\t\ttail.next = left;\n\t\telse\n\t\t\ttail.next = right;\n\t\treturn handler;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1){\n            return 1;\n        }\n        int s=1;\n    for (int i = 0; i <20; i++) {\n        s=(x/s)/2+s/2;\n    }\n    int k=0;\n    int answer=0;\n    for (int i = -30; i < 30; i++) {\n        k=s+i;\n        if (k*k>0&&k*k<=x) {\n            answer=k;\n        }\n    }\n    return answer;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class BinaryTreePostorderTraversal {\n  public ArrayList<Integer> postorderTraversal(TreeNode root) {\n    ArrayList<Integer> ret = new ArrayList<Integer>();\n    if (root == null) return ret;\n    Stack<TreeNode> st = new Stack<TreeNode>();\n    TreeNode p = root.right;\n    ret.add(root.val);\n    st.add(root);\n    while (!st.isEmpty()) {\n      while (p != null) {\n        ret.add(p.val);\n        st.add(p);\n        p = p.right;\n      }\n      TreeNode node = st.pop();\n      p = node.left;\n      if (p != null) {\n        ret.add(p.val);\n        st.add(p);\n        p = p.right;\n      }\n    }\n    int i = 0;\n    int j = ret.size() - 1;\n    while (i < j) {\n      int tmp = ret.get(i);\n      ret.set(i, ret.get(j));\n      ret.set(j, tmp);\n      i++;\n      j--;\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "class MinimumDepthOfBinaryTree {\n\n  \n  public int minDepth(TreeNode root) {\n    if (root == null) return 0;\n    int left = minDepth(root.left);\n    int right = minDepth(root.right);\n    if (left == 0) return right + 1;\n    if (right == 0) return left + 1;\n    return Math.min(left, right) + 1; // plus root\n  }\n\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class L090_Subsets_II {\n\n\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\n\n\t\tif (nums == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (nums.length == 0) {\n\t\t\treturn new ArrayList<List<Integer>>();\n\t\t}\n\n\t\tSet<List<Integer>> set = new HashSet<List<Integer>>();\n\n\t\tArrays.sort(nums);\n\n\t\tfor (int i = 0; i < Math.pow(2, nums.length); i++) {\n\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tint tmp = i;\n\n\t\t\tfor (int j = 0; j < nums.length; j++) {\n\t\t\t\tint bit = tmp & 1;\n\t\t\t\ttmp >>= 1;\n\t\t\t\tif (bit == 1) {\n\t\t\t\t\tlist.add(nums[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tset.add(list);\n\t\t}\n\n\t\treturn new ArrayList<List<Integer>>(set);\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class RemoveDuplicatesFromSortedArrayII {\n  public int removeDuplicates(int[] A) {\n    int length = A.length;\n    if (length < 3) return length;\n    int slow = 0, fast = 1, idx = 0;\n    while (fast < length) {\n      while (fast < length && A[fast] == A[slow]) {\n        fast++;\n      }\n      if (fast - slow <= 2) {\n        while (slow < fast) {\n          A[idx++] = A[slow++];\n        }\n      } else {\n        A[idx++] = A[slow++];\n        A[idx++] = A[slow++];\n        slow = fast;\n      }\n      fast++;\n    }\n    while (slow < length) {\n      A[idx++] = A[slow++];\n    }\n    return idx;\n  }\n}\n", "nl": "mengli"}
{"code": "public class SingleNumber\n{\n\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public ListNode mergeKLists(List<ListNode> lists) {  \n        if (lists == null || lists.size() == 0) {\n            return null;\n        }\n        PriorityQueue<ListNode> queue = \n        new PriorityQueue<ListNode>(lists.size(), new Comparator<ListNode>(){\n            public int compare(ListNode a, ListNode b){\n                return a.val - b.val;\n            }\n        });\n        \n        for (int i = 0; i < lists.size(); i++) {\n            if (lists.get(i) != null) {\n                queue.offer(lists.get(i));\n            }\n        }\n        \n        ListNode dummy = new ListNode(0);\n        ListNode node = dummy;\n        while (!queue.isEmpty()) {\n            ListNode curr = queue.poll();\n            node.next = curr;\n            \n            if (curr.next != null) {\n                queue.offer(curr.next);\n            }\n             \n            node = node.next;   \n        }\n        \n        return dummy.next;\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "public class L066_Plus_One {\n\n\tpublic int[] plusOne(int[] digits) {\n\n\t\tif (digits == null || digits.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint[] rt = new int[digits.length + 1];\n\t\tdigits[digits.length - 1]++;\n\n\t\tfor (int i = digits.length - 1; i >= 0; i--) {\n\t\t\trt[i + 1] += digits[i];\n\t\t\trt[i] += rt[i + 1] / 10;\n\t\t\trt[i + 1] %= 10;\n\t\t}\n\n\t\tif (rt[0] == 0) {\n\t\t\treturn Arrays.copyOfRange(rt, 1, rt.length);\n\t\t} else {\n\t\t\treturn rt;\n\t\t}\n\t}\n}\n", "nl": "LjyYano"}
{"code": "class Solution {\n    boolean[][] isPalin;\n    String str;\n    public List<List<String>> partition(String s) {\n        List<List<String>> rst = new ArrayList<>();\n        if (s == null || s.length() == 0) {\n            return rst;\n        }\n        isPalin = calcPalin(s);\n        str = s;\n        dfs(rst, new ArrayList<>(), 0);\n        return rst;\n    }\n    \n    private void dfs(List<List<String>> rst, List<String> list, int index) {\n        if (x == str.length()) {\n            rst.add(new ArrayList<>(list));\n            return;\n        }\n        for (int i = index + 1; i <= str.length(); i++) {\n            if (isPalin[index][i - 1]) { // \u6d94\u71bc\u6e36\u7455\u4f79\u7161\u942a\u5b2d\u569c\u97ec\ue0a3\u69f8\u6d93\u5d86\u69f8 palindrome: s.charAt(x). isPalin[i][j] \u93c4 inclusive\u9428\n                list.add(str.substring(index, i));\n                dfs(rst, list, i);\n                list.remove(list.size() - 1);\n            }\n        }\n    }\n    private boolean[][] calcPalin(String s) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n        boolean[][] isPalin = new boolean[n][n];\n        int i, j;\n        \n        for (int mid = 0; mid < n; mid++) {\n            i = j = mid;\n            while (i >= 0 && j < n && arr[i] == arr[j]) {\n                isPalin[i][j] = true;\n                i--;\n                j++;\n            }\n            \n            i = mid;\n            j = mid + 1;\n            while (i >= 0 && j < n && arr[i] == arr[j]) {\n                isPalin[i][j] = true;\n                i--;\n                j++;\n            }\n        }\n        return isPalin;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> rst = new ArrayList<List<Integer>>();\n\t    if (nums == null || nums.length == 0) {\n\t        return rst;\n\t    }\n\t    \n\t    Arrays.sort(nums);\n\t    HashSet<String> set = new HashSet<String>();\n\t    for (int i = 0; i < nums.length - 2; i++) {\n\t        int target = 0 - nums[i];\n\t        int start = i + 1;\n\t        int end = nums.length - 1;\n\t        \n\t        ArrayList<Integer> list = new ArrayList<Integer>();\n\t        while (start < end) {\n\t            if (nums[start] + nums[end] == target &&  \n\t                !set.contains(nums[i] + \",\" + nums[start] + \",\" + nums[end])) {\n\t                list.add(nums[i]);\n\t                list.add(nums[start]);\n\t                list.add(nums[end]);\n\t                rst.add(list);\n\t                set.add(nums[i] + \",\" + nums[start] + \",\" + nums[end]);\n\t                list = new ArrayList<Integer>();\n\t                start++;\n\t                end--;\n\t            } else if (nums[start] + nums[end] < target) {\n\t                start++;\n\t            } else {\n\t                end--;\n\t            }\n\t        }//end while        \n\t    }\n\t    \n\t    return rst;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int[] res = new int[2];\n        for(int i=0;i<numbers.length;i++)\n            for(int j=i+1;j<numbers.length;j++)\n        \t\tif(numbers[i]+numbers[j]==target){\n        \t\t\tres[0]=i+1;\n        \t\t\tres[1]=j+1;\n        \t\t\tbreak;\n        \t\t}\n\n        return res;\n    }\n}", "nl": "azheanda"}
{"code": "public class FirstMissingPositive\n{\n\n    public int firstMissingPositive( int[] nums ) \n    {\n        return 0;\n    }\n\n}\n", "nl": "FreemanZhang"}
{"code": "class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return dfs(root.left, root.right);\n    }\n    \n    public boolean dfs(TreeNode leftNode, TreeNode rightNode) {\n        if (leftNode == null || rightNode == null) {\n            return leftNode == null && rightNode == null;\n        }\n        return leftNode.val == rightNode.val && dfs(leftNode.left, rightNode.right) && dfs(leftNode.right, rightNode.left);\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        int[] nums=new int[n];\n        List<List<String>> ans=new ArrayList<List<String>>();\n        int i=0;\n        while (true) {\n            if (i<0) {\n                return ans;\n            }\n            if (i==n) {\n                List<String> list=new ArrayList<String>();\n                for (int j = 0; j < nums.length; j++) {\n                    StringBuffer sb=new StringBuffer();\n                    for (int k = 0; k < n; k++) {\n                        if (k!=nums[j]) {\n                            sb.append(\".\");\n                        }else {\n                            sb.append(\"Q\");\n                        }\n                    }\n                    list.add(sb.toString());\n                }\n                ans.add(list);\n                i--;\n                while (nums[i]==n) {\n                    nums[i]=0;\n                    i--;\n                }\n                nums[i]++;\n            }else {\n                if (nums[i]==n) {\n                    while (i>=0&&nums[i]==n) {\n                        nums[i]=0;\n                        i--;\n                    }\n                    if (i>=0) {\n                        nums[i]++;\n                    }\n                }else {\n                    if (f(nums,i,nums[i])) {\n                        i++;\n                    }else {\n                        nums[i]++;\n                    }\n                }\n            }\n            \n        }\n    }\n    public boolean f(int[] nums,int x,int val){\n        for (int i = 0; i < x; i++) {\n            int t=x-i;\n            if (val==nums[i]||val==nums[i]+t||val==nums[i]-t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MaximalRectangle {\n\n  \n  public static void main(String[] args) throws Exception {\n    char[][] matrix = {\n      {'1', '0', '1', '0', '0'},\n      {'1', '0', '1', '1', '1'},\n      {'1', '1', '1', '1', '1'},\n      {'1', '0', '0', '1', '0'}\n    };\n    System.out.println(new MaximalRectangle().maximalRectangle(matrix));\n  }\n\n  public int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0 || matrix[0].length == 0) return 0;\n    int[] A = new int[matrix[0].length];\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i < matrix.length; i++) {\n      for (int j = 0; j < matrix[0].length; j++) {\n        if (matrix[i][j] == '1') {\n          if (i > 0 && matrix[i - 1][j] == '1') {\n            A[j] = A[j] + 1;\n          } else {\n            A[j] = 1;\n          }\n        } else {\n          A[j] = 0;\n        }\n      }\n      max = Math.max(max, getMaxRectangle(A));\n    }\n    return max;\n  }\n\n  \n  private int getMaxRectangle(int[] heights) {\n    int maxArea = Integer.MIN_VALUE;\n    Stack<Integer> stack = new Stack<>();\n    int i = 0;\n    for (; i < heights.length; i++) {\n      while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n        int top = stack.pop();\n        int base = stack.isEmpty() ? i : i - stack.peek() - 1;\n        maxArea = Math.max(maxArea, base * heights[top]);\n      }\n      stack.push(i);\n    }\n    while (!stack.isEmpty()) {\n      int top = stack.pop();\n      int base = stack.isEmpty() ? i : i - stack.peek() - 1;\n      maxArea = Math.max(maxArea, base * heights[top]);\n    }\n    return maxArea;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class ReverseLinkedList {\n\n\tpublic ListNode reverseList(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn head;\n\t\tListNode p = head;\n\t\tListNode curr = head.next;\n\t\thead.next = null;\n\t\twhile (curr != null) {\n\t\t\tListNode next = curr.next;\n\t\t\tcurr.next = p;\n\t\t\tp = curr;\n\t\t\tcurr = next;\n\t\t}\n\t\treturn p;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int jump(int[] nums) {\n        if (nums.length==1) {\n            return 0;\n        }\n        int max=0;\n        int[] steps=new int[nums.length];\n        steps[0]=0;\n        for (int i = 0; i < nums.length-1; i++) {\n            int n=nums[i];\n            if (n+i>max) {\n                int s=steps[i];\n                for (int j = max+1; j <=n+i; j++) {\n                    if (j<steps.length) {\n                        if (steps[j]==0||steps[j]>s+1) {\n                            steps[j]=s+1;\n                        }\n                    }\n                }\n                max=n+i;\n            }\n        }\n        return steps[steps.length-1];\n    }\n}", "nl": "corpsepiges"}
{"code": "public class BinaryTreePostorderTraversal {\n\tpublic List<Integer> postorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tTreeNode node = root;\n\t\tint[] flag = new int[Integer.MAX_VALUE];\n\t\t\n\t\twhile (node != null) {\n\t\t\tstack.push(node);\n\t\t\tflag[stack.size()] = 0;\n\t\t\tnode = node.left;\n\t\t}\n\t\twhile (!stack.isEmpty()) {\n\t\t\tnode = stack.peek();\n\t\t\twhile (flag[stack.size()] == 0 && node.right != null) {\n\t\t\t\tnode=node.right;\n\t\t\t\tflag[stack.size()]=1;\n\t\t\t\twhile (node != null) {\n\t\t\t\t\tstack.push(node);\n\t\t\t\t\tflag[stack.size()] = 0;\n\t\t\t\t\tnode = node.left;\n\t\t\t\t}\n\t\t\t\tnode=stack.peek();\n\t\t\t}\n\t\t\tnode = stack.pop();\n\t\t\tlist.add(node.val);\n\t\t}\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public boolean exist(char[][] board, String word) {\n        int m = board.length;\n        if (m == 0) return false;\n        int n = board[0].length;\n        if (n == 0) return false;\n        if (word.length() == 0) return true;\n        boolean[][] visited = new boolean[m][n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == word.charAt(0) && existRe(board, i, j, word, 0, visited)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public boolean existRe(char[][] board, int i, int j, String word, int cur, boolean[][] visited) {\n        if (cur == word.length()) return true;\n        int m = board.length;\n        int n = board[0].length;\n        if (i < 0 || i >= m || j < 0 || j >= n) return false;\n        if (visited[i][j] == true || (board[i][j] != word.charAt(cur))) return false;\n        visited[i][j] = true;\n        if (existRe(board, i+1, j, word, cur+1,visited)) return true;\n        if (existRe(board, i-1, j, word, cur+1,visited)) return true;\n        if (existRe(board, i, j+1, word, cur+1,visited)) return true;\n        if (existRe(board, i, j-1, word, cur+1,visited)) return true;\n        visited[i][j] = false;\n        return false;\n    }\n}", "nl": "leetcoders"}
{"code": "public class RotateImage {\n\tpublic void rotate(int[][] matrix) {\n\t\tif (matrix == null || matrix.length == 0)\n\t\t\treturn;\n\t\tint m = matrix.length;\n\t\tint[][] result = new int[m][m];\n\t\tfor (int i = 0; i < m; i++) \n\t\t\tfor (int j = 0; j < m; j++) \n\t\t\t\tresult[j][m - 1 - i] = matrix[i][j];\n\t\tfor (int i = 0; i < m; i++) \n\t\t\tfor (int j = 0; j < m; j++) \n\t\t\t\tmatrix[i][j] = result[i][j];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> rst = new ArrayList<>();\n        if (n <= 0) return rst;\n\n        dfs(rst, new ArrayList<>(), n);\n\n        return rst;\n    }\n    private void dfs(List<List<String>> rst, List<Integer> list, int n){\n        if (list.size() == n) {\n            rst.add(createBoard(list));\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            if (validate(list, i)) {\n                list.add(i);\n                dfs(rst, list, n);\n                list.remove(list.size() - 1);\n            }\n        }\n    }\n    \n    \n    private boolean validate(List<Integer> list, int newColNum) {\n        int newRowNum = list.size(); // the new row that colNum is going to be put on\n        for (int rowNum = 0; rowNum < list.size(); rowNum++) {\n            int colNum = list.get(rowNum);\n            if (colNum == newColNum || Math.abs(rowNum - newRowNum) == Math.abs(colNum - newColNum)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n\n    private List<String> createBoard(List<Integer> list){\n        List<String> board = new ArrayList<>();\n        for (int row = 0; row < list.size(); row++) {\n            StringBuffer sb = new StringBuffer();\n            for (int col : list) {\n                if (row == col) {\n                    sb.append(\"Q\");\n                } else {\n                    sb.append(\".\");\n                }\n            }\n            board.add(sb.toString());\n        }\n        return board;\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class L240_Search_a_2D_Matrix_II {\n\n\tpublic boolean searchMatrix(int[][] matrix, int target) {\n\n\t\tif (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\n\t\tint x = 0, y = n - 1;\n\n\t\twhile (x < m && y >= 0) {\n\t\t\tif (matrix[x][y] == target) {\n\t\t\t\treturn true;\n\t\t\t} else if (matrix[x][y] < target) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class L151_Reverse_Words_in_a_String {\n\n\tpublic String reverseWords(String s) {\n\n\t\tList<String> words = Arrays.asList(s.trim().split(\" +\"));\n\n\t\tCollections.reverse(words);\n\n\t\treturn String.join(\" \", words);\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Sqrtx {\n  public int sqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    long low = 1;\n    long high = x;\n    long mid = 0;\n    while (low <= high) {\n      mid = (low + high) / 2;\n      if (mid * mid <= x && (mid + 1) * (mid + 1) > x) {\n        break;\n      }\n      if (mid * mid > x) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return new Long(mid).intValue();\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    \n    public String longestPalindrome(String s) {\n    \tif (s == null || s.length() == 0) {\n    \t\treturn s;\n    \t}\n    \tboolean isPal[][] = new boolean[s.length()][s.length()];\n    \tString maxStr = \"\";\n    \tfor (int j = 0; j < s.length(); j++) {\n    \t\tfor (int i = 0; i <= j; i++) {\n    \t\t\tif (s.charAt(i) == s.charAt(j) && (j - i <= 1 || isPal[i + 1][j - 1])) {\n    \t\t\t\tisPal[i][j] = true;\n    \t\t\t\tmaxStr = maxStr.length() > s.substring(i, j + 1).length() ? maxStr : s.substring(i, j + 1);\n    \t\t\t}\n    \t\t}\n    \t}//end for j\n    \treturn maxStr;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class InsertInterval {\n  public class IntervalCmp implements Comparator<Interval> {\n\n    @Override\n    public int compare(Interval i1, Interval i2) {\n      if (i1.start < i2.start) {\n        return -1;\n      }\n      if (i1.start == i2.start && i1.end <= i2.end) {\n        return -1;\n      }\n      return 1;\n    }\n  }\n\n  public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n    intervals.add(newInterval);\n    Interval[] arr = new Interval[intervals.size()];\n    intervals.toArray(arr);\n    Arrays.sort(arr, new IntervalCmp());\n    intervals.clear();\n    int start = arr[0].start;\n    int end = arr[0].end;\n    for (int i = 1; i < arr.length; i++) {\n      if (arr[i].start <= end) {\n        end = Math.max(end, arr[i].end);\n      } else {\n        intervals.add(new Interval(start, end));\n        start = arr[i].start;\n        end = arr[i].end;\n      }\n    }\n    intervals.add(new Interval(start, end));\n    return intervals;\n  }\n}\n", "nl": "mengli"}
{"code": "public class TwoSum2 {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[]{i, map.get(complement)};\n            }\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class L111_Minimum_Depth_of_Binary_Tree {\n\n\tpublic int minDepth(TreeNode root) {\n\n\t\tif (root == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (root.left == null && root.right == null) {\n\t\t\treturn 1;\n\t\t} else if (root.left != null && root.right == null) {\n\t\t\treturn minDepth(root.left) + 1;\n\t\t} else if (root.left == null && root.right != null) {\n\t\t\treturn minDepth(root.right) + 1;\n\t\t}\n\n\t\treturn Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class ClimbingStairs {\n\n    \n    public int climbStairs(int n) {\n        if (n <= 1) return n;\n        int last = 1, lastlast = 1;\n        int now = 0;\n        for (int i = 2; i <= n; i++) {\n            now = last + lastlast;\n            lastlast = last;\n            last = now;\n        }\n        return now;\n    }\n\n    \n    public static int climbStairs2(int n) {\n        int[] cache = new int[n + 1];\n        return helper(n, cache);\n    }\n    \n    public static int helper(int n, int[] cache) {\n        if (n < 0) return -1;\n        if (n == 0 || n == 1) return 1;\n        cache[0] = 1; \n        cache[1] = 1; \n        if (cache[n] == 0)\n            cache[n] = helper(n - 1, cache) + helper(n - 2, cache);            \n        return cache[n];\n    }\n    \n    public static int climbStairsBottomUp(int n) {\n        if (n < 0) return -1;\n        if (n == 0 || n == 1) return 1;\n        int[] cache = new int[n + 1];\n        cache[0] = 1;\n        cache[1] = 1;\n        for (int i = 2; i < cache.length; i++) {\n            cache[i] = cache[i - 1] + cache[i - 2]; // only need the last 2\n        }\n        return cache[n];\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int numTrees(int n) {\n        if(n==0) return 1;\n        int sum=0;\n        for(int i=0;i<n;i++)\n        \t\tsum+=numTrees(i)*numTrees(n-i-1);\n        return sum;\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list=new ArrayList<Integer>();\n        return preorder(root,list);\n    }\n    public List<Integer> preorder(TreeNode root,List<Integer> list){\n        if (root==null) {\n            return list;\n        }\n        list.add(root.val);\n        list=preorder(root.left,list);\n        list=preorder(root.right, list);\n        return list;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class ValidParentheses {\n\n    public class Solution {\n        public boolean isValid(String s) {\n            ArrayDeque<Character> stack = new ArrayDeque<Character>();\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (c == '(' || c == '[' || c == '{') {\n                    stack.push(c);\n                } else if (stack.isEmpty()) {\n                    return false;\n                } else {\n                    char top = stack.pop();\n                    if (c == ')' && top != '(') {\n                        return false;\n                    }\n                    if (c == ']' && top != '[') {\n                        return false;\n                    }\n                    if (c == '}' && top != '{') {\n                        return false;\n                    }\n                }\n            }\n            return stack.isEmpty();\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class SymmetricTree2 {\n\tpublic boolean isSymmetric(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn true;\n\t\treturn isSymmetric(root.left, root.right);\n\t}\n\n\tpublic boolean isSymmetric(TreeNode left, TreeNode right) {\n\t\tif (left == null && right == null)\n\t\t\treturn true;\n\t\tif (left != null && right != null) {\n\t\t\tif (left.val != right.val)\n\t\t\t\treturn false;\n\t\t\treturn isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\n\t\t} else\n\t\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n    \tif (gas == null || cost == null || gas.length == 0 || cost.length == 0) {\n    \t\treturn -1;\n    \t}\n    \tint start = 0;\n    \tint remain = 0; // remained gas\n    \tint total = 0;\n    \tfor (int i = 0; i < gas.length; i++) {\n    \t\tremain += gas[i] - cost[i];\n    \t\tif (remain < 0) {\n    \t\t\tremain = 0;\n    \t\t\tstart = i + 1; // restart\n    \t\t} \n    \t\ttotal += gas[i] - cost[i];\n    \t}\n    \tif (total < 0) {\n    \t\treturn -1;\n    \t}\n    \treturn start;\n    }\n}", "nl": "awangdev"}
{"code": "class Solution {\n    \n    public int findPeak(int[] A) {\n        int start = 1;\n        int end = A.length - 2;\n        int mid;\n        \n        while (start + 1 < end) {\n            mid = start + (end - start) / 2;\n            if (A[mid] > A[mid - 1] && A[mid] > A[mid + 1]) {\n                return mid;\n            } else if (A[mid] > A[start] && A[mid] < A[mid + 1]) {\n                start = mid;\n            } else {// this case A[start] > A[mid], so we climb backwards, all make sense\n                end = mid;\n            }\n        }//while\n        \n        if (A[start] > A[start - 1] && A[start] > A[start + 1]) {\n            return start;\n        } else {\n            return end;\n        } \n        \n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "class SpiralMatrix2 {\n  public static void main(String[] args) {\n    int[][] mat = generateMatrix(5);\n    for (int i = 0; i < mat.length; i++) {\n      for (int j = 0; j < mat[i].length; j++) {\n        System.out.print(mat[i][j] + \" \");\n      }\n      System.out.println();\n    }\n\n  }\n\n  \n  public static int[][] generateMatrix(int n) {\n    if (n <= 0) return new int[0][0];\n    int[][] ans = new int[n][n];\n    int num = 1;\n    int lv = 0;\n    while (2 * lv < n) {\n      for (int i = lv; i < n - lv; i++) ans[lv][i] = num++;\n      for (int i = lv + 1; i < n - lv; i++) ans[i][n - lv - 1] = num++;\n      for (int i = n - lv - 2; i >= lv; i--) ans[n - lv - 1][i] = num++;\n      for (int i = n - lv - 2; i >= lv + 1; i--) ans[i][lv] = num++;\n      lv++;\n    }\n    return ans;\n  }\n\n  \n  public static int[][] generateMatrixB(int n) {\n    if (n <= 0) return new int[0][0];\n    int[][] ans = new int[n][n];\n    int i = 1;\n    int startR = 0;\n    int startC = 0;\n    int endR = n - 1;\n    int endC = n - 1;\n    while (startR <= endR && startC <= endC) {\n      for (int j = startC; j <= endC; j++) ans[startR][j] = i++;\n      startR++;\n      for (int j = startR; j <= endR; j++) ans[j][endC] = i++;\n      endC--;\n      for (int j = endC; j >= startC; j--) ans[endR][j] = i++;\n      endR--;\n      for (int j = endR; j >= startR; j--) ans[j][startC] = i++;\n      startC++;\n    }\n    return ans;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class InsertInterval {\n\n    public class Solution {\n\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n            List<Interval> newIntervals = new ArrayList<Interval>();\n            for (Interval interval : intervals) {\n                if (newInterval == null || interval.end < newInterval.start) {\n                    newIntervals.add(interval);\n                } else if (interval.start > newInterval.end) {\n                    newIntervals.add(newInterval);\n                    newIntervals.add(interval);\n                    newInterval = null;\n                } else {\n                    newInterval.start = Math.min(newInterval.start, interval.start);\n                    newInterval.end = Math.max(newInterval.end, interval.end);\n                }\n            }\n            if (newInterval != null) {\n                newIntervals.add(newInterval);\n            }\n            return newIntervals;\n        }\n    }\n\n    public static class UnitTest {\n\n        @Test\n        public void testInsert() {\n            Solution s = new InsertInterval().new Solution();\n            assertEquals(\n                    Arrays.asList(new Interval(0, 0), new Interval(1, 5)),\n                    s.insert(Arrays.asList(new Interval(1, 5)), new Interval(0, 0)));\n        }\n    }\n}\n", "nl": "zsxwing"}
{"code": "class LongestPalindromicSubstring {\n\n    public static void main(String[] args) {\n        LongestPalindromicSubstring l = new LongestPalindromicSubstring();\n        String s = \"abba\";\n        System.out.println(l.longestPalindrome(s));\n    }\n\n    \n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) return \"\";\n\n        int len = s.length();\n        int max = 0; // max length\n        String res = \"\";\n\n        for (int i = 1; i <= 2 * len - 1; i++) { // skip two #s\n            int count = 1;\n            while (i - count >= 0 && i + count <= 2 * len && get(s, i - count) == get(s, i + count)) count++;\n            count--; // there will be one extra count for the outbound #\n            if (count > max) { // update max and result when longer is found\n                res = s.substring((i - count) / 2, (i + count) / 2);\n                max = count;\n            }\n        }\n\n        return res;\n    }\n\n    \n    private char get(String s, int i) {\n        if (i % 2 == 0) return '#';\n        else return s.charAt(i / 2);\n    }\n\n    \n    public String longestPalindromeB(String s) {\n        String t = preProcess(s);\n        int n = t.length();\n        int[] p = new int[n];\n        int range = 0, center = 0;\n\n        for (int i = 1; i < n - 1; i++) {\n            int mirror = 2 * center - i; // mirror of i to center\n            p[i] = range > i ? Math.min(range - i, p[mirror]) : 0;\n            while (t.charAt(i + 1 + p[i]) == t.charAt(i - 1 - p[i])) p[i]++;\n            if (i + p[i] > range) {\n                center = i;\n                range = i + p[i];\n            }\n        }\n\n        int maxLen = 0;\n        int centerIdx = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (p[i] > maxLen) {\n                maxLen = p[i];\n                centerIdx = i;\n            }\n        }\n        return s.substring((centerIdx - 1 - maxLen) / 2, (centerIdx - 1 + maxLen) / 2);\n    }\n\n    private String preProcess(String s) {\n        int n = s.length();\n        if (n == 0) return \"^$\";\n        String res = \"^\";\n        for (int i = 0; i < n; i++) {\n            res += \"#\" + s.substring(i, i + 1);\n        }\n        res += \"#$\";\n        return res;\n    }\n\n    \n    public String longestPalindromeC(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        String longest = s.substring(0, 1);\n        int len = s.length();\n        for (int i = 0; i < len - 1; i++) {\n            String s1 = expandAroundCenter(s, i, i); // expand from one char\n            if (s1.length() > longest.length()) longest = s1;\n            String s2 = expandAroundCenter(s, i, i + 1); // expand from two chars\n            if (s2.length() > longest.length()) longest = s2;\n        }\n        return longest;\n    }\n\n    \n    private String expandAroundCenter(String s, int i, int j) {\n        int l = i;\n        int r = j;\n        int n = s.length();\n        while (l >= 0 && r <= n - 1 && s.charAt(l) == s.charAt(r)) {\n            l--;\n            r++;\n        }\n        return s.substring(l + 1, r); // note the range is from l + 1 to r - 1\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class SortColors\n{\n\t@Test\n\tpublic void test()\n\t{\n\t\tint[] array = new int[]{ 1, 0 };\n\t\tsortColors( array );\n\t\tSystem.out.println( Arrays.toString( array ) );\n\t\t\n\t\tint[] array2 = new int[]{ 1, 2, 0 };\n\t\tsortColors( array2 );\n\t\tSystem.out.println( Arrays.toString( array2 ) );\n\t}\n\t\n\tprivate final static int RED = 0;\n\tprivate final static int WHITE = 1;\n\tprivate final static int BLUE = 2;\n\t\n    public void sortColors( int[] nums )\n    {\n    \tif ( nums.length  == 0 )\n    \t{\n    \t\treturn;\n    \t}\n    \tint redPointer = 0;    \t\n    \tint whitePointer = 0;\n    \tint bluePointer = nums.length - 1;\n    \twhile ( whitePointer <= bluePointer ) // where error occurs\n    \t{\n    \t\tif ( nums[whitePointer] == RED )\n    \t\t{\n    \t\t\tswap( nums, redPointer, whitePointer );\n    \t\t\tredPointer++;\n    \t\t\twhitePointer++;\n    \t\t}\n    \t\telse if ( nums[whitePointer] == WHITE )\n    \t\t{\n    \t\t\twhitePointer++;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tswap( nums, whitePointer, bluePointer );\n    \t\t\tbluePointer--;\n    \t\t}\n    \t}\n    }\n    \n    private void swap( int[] nums, int start, int end )\n    {\n    \tint buffer = nums[start];\n    \tnums[start] = nums[end];\n    \tnums[end] = buffer;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class BestTimeToBuyAndSellStock {\n\n    private BestTimeToBuyAndSellStock b;\n\n    \n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length < 2) { // Need at least 2 days to make profit.\n            return 0;\n        }\n        int max = 0; // Max profit.\n        int min = prices[0]; // Min price of previous days.\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1]) { // Maximum price may update.\n                max = Math.max(max, prices[i] - min); // Update max profit.\n            } else {\n                min = Math.min(min, prices[i]); // Update min.\n            }\n        }\n        return max;\n    }\n\n    \n    public int maxProfitB(int[] prices) {\n        if (prices == null || prices.length < 2) {\n            return 0; // need at least 2 days\n        }\n        int min = prices[0];\n        int max = 0;\n        int len = prices.length;\n        int[] history = new int[len];\n        for (int i = 0; i < len - 1; i++) {\n            min = min < prices[i] ? min : prices[i];\n            if (i > 0) { // skip first day\n                history[i] = Math.max(history[i - 1], prices[i] - min);\n                max = history[i] > max ? history[i] : max;\n            }\n        }\n        return max;\n    }\n\n    @Before\n    public void setUp() {\n        b = new BestTimeToBuyAndSellStock();\n    }\n\n    @Test\n    public void testExamples() {\n        int[] prices = {1, 4, 2};\n        Assert.assertEquals(3, b.maxProfit(prices));\n        Assert.assertEquals(3, b.maxProfitB(prices));\n    }\n\n    @After\n    public void tearDown() {\n        b = null;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int sqrt(int x) {\n        long lo = 0;\n        long hi = x;\n\n        while(hi>=lo){     \n            long mid = lo+(hi-lo)/2;\n            if(x<mid*mid)\n                hi = mid-1;      // not hi = mid\n            else\n                lo = mid+1;    \n        }\n        return (int)hi;\n    }\n}\n\n\n", "nl": "azheanda"}
{"code": "public class SortColors2 {\n\tpublic void sortColors(int[] A) {\n\t\tint redpt = 0, bluept = A.length - 1;\n\t\tint i = 0;\n\t\tfinal int RED = 0, BLUE = 2;\n\t\twhile (i <= bluept) {\n\t\t\tif (A[i] == RED) {\n\t\t\t\tswap(A, redpt, i);\n\t\t\t\tredpt++;\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t} else if (A[i] == BLUE) { // if color is BLUE, move to the end\n\t\t\t\tswap(A, bluept, i);\n\t\t\t\tbluept--;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ti++; // if color is WHITE, don't move\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void swap(int[] A, int from, int to) {\n\t\tint tmp = A[from];\n\t\tA[from] = A[to];\n\t\tA[to] = tmp;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MinimumWindowSubstring {\n\tpublic String minWindow(String S, String T) {\n\t\tif (S == null || T == null || S.length() == 0 || T.length() == 0)\n\t\t\treturn \"\";\n\t\tHashMap<Character, Integer> map = new HashMap<Character, Integer>();\n\t\tfor (int i = 0; i < T.length(); i++) {\n\t\t\tif (map.containsKey(T.charAt(i))) {\n\t\t\t\tmap.put(T.charAt(i), map.get(T.charAt(i)) + 1);\n\t\t\t} else\n\t\t\t\tmap.put(T.charAt(i), 1);\n\t\t}\n\t\tint count = 0;\n\t\tint pre = 0;\n\t\tString res = \"\";\n\t\tint minLen = S.length() + 1;\n\t\tfor (int i = 0; i < S.length(); i++) {\n\t\t\tif (map.containsKey(S.charAt(i))) {\n\t\t\t\tmap.put(S.charAt(i), map.get(S.charAt(i)) - 1);\n\t\t\t\tif (map.get(S.charAt(i)) >= 0)\n\t\t\t\t\tcount++;\n\t\t\t\twhile (count == T.length()) {\n\t\t\t\t\tif (map.containsKey(S.charAt(pre))) {\n\t\t\t\t\t\tmap.put(S.charAt(pre), map.get(S.charAt(pre)) + 1);\n\t\t\t\t\t\tif (map.get(S.charAt(pre)) > 0) {\n\t\t\t\t\t\t\tif (minLen > i - pre + 1) {\n\t\t\t\t\t\t\t\tres = S.substring(pre, i + 1);\n\t\t\t\t\t\t\t\tminLen = i - pre + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpre++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class RemoveDuplicatesFromSortedArray \n{\n    public int removeDuplicates( int[] nums )\n    {\n    \tif ( nums.length < 2 )\n    \t{\n    \t\treturn nums.length;\n    \t}\n    \t\n        int validPos = 0;\n        for ( int i = 1; i < nums.length; i++ )\n        {\n        \tif ( nums[validPos] != nums[i] )\n        \t{\n        \t\tvalidPos++;\n        \t\tnums[validPos] = nums[i];\n        \t}\n        }\n        \n        return validPos + 1;\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class L121_Best_Time_to_Buy_and_Sell_Stock {\n\n\tpublic int maxProfit(int[] prices) {\n\n\t\tif (prices.length <= 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint maxProfit = 0;\n\t\tint lowest = Integer.MAX_VALUE;\n\n\t\tfor (int v : prices) {\n\t\t\tlowest = Math.min(v, lowest);\n\t\t\tmaxProfit = Math.max(maxProfit, v - lowest);\n\t\t}\n\n\t\treturn maxProfit;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class FindMinimumInRotatedSortedArray2 {\n\n  \n  public int findMin(int[] nums) {\n    int lo = 0, hi = nums.length - 1;\n    while (lo < hi) {\n      int mid = lo + (hi - lo) / 2;\n      if (nums[mid] > nums[hi]) {\n        lo = mid + 1;\n      } else if (nums[mid] < nums[hi]) {\n        hi = mid;\n      } else {\n        hi--;\n      }\n    }\n    return nums[lo];\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class ValidParentheses {\n\tpublic boolean isValid(String s) {\n\t\tMap<Character, Character> map = new HashMap<Character, Character>();\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tmap.put('{', '}');\n\t\tmap.put('(', ')');\n\t\tmap.put('[', ']');\n\t\tif (s.length() == 0)\n\t\t\treturn true;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '{' || s.charAt(i) == '[' || s.charAt(i) == '(')\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\telse {\n\t\t\t\tif (stack.isEmpty())\n\t\t\t\t\treturn false;\n\t\t\t\tchar ch = stack.pop();\n\t\t\t\tif (map.get(ch) != s.charAt(i))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class LongestValidParentheses {\n  public int longestValidParentheses(String s) {\n    int length = s.length();\n    if (length == 0) return 0;\n    int left = 0;\n    Stack<Integer> indexs = new Stack<Integer>();\n    boolean[] record = new boolean[length];\n    for (int i = 0; i < length; i++) {\n      if (s.charAt(i) == '(') {\n        left++;\n        indexs.push(i);\n      } else if (left > 0) {\n        int idx = indexs.pop();\n        record[idx] = true;\n        record[i] = true;\n        left--;\n      }\n    }\n    int ret = 0;\n    int current = 0;\n    for (int k = 0; k < length; k++) {\n      if (record[k]) {\n        current++;\n      } else {\n        ret = current > ret ? current : ret;\n        current = 0;\n      }\n    }\n    return ret > current ? ret : current;\n  }\n}\n", "nl": "mengli"}
{"code": "public class BestTimetoBuyandSellStock {\n  public int maxProfit(int[] prices) {\n    int lowest = 0;\n    int maxProfit = 0;\n    if (prices.length > 0) {\n      lowest = prices[0];\n      for (int i = 0; i < prices.length; i++) {\n        if (lowest > prices[i]) {\n          lowest = prices[i];\n        }\n        maxProfit = Math.max(maxProfit, prices[i] - lowest);\n      }\n    }\n    return maxProfit;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return check(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    public boolean check(TreeNode node, long MIN, long MAX) {\n        if (node == null) {\n            return true;\n        }\n        if (node.val > MIN && node.val < MAX &&\n            check(node.left, MIN, node.val) &&\n            check(node.right, node.val, MAX)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class L091_Decode_Ways {\n\n\tpublic int numDecodings(String s) {\n\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint n = s.length();\n\t\tchar[] c = s.toCharArray();\n\n\t\tint[] step = new int[Math.max(n + 1, 3)];\n\n\t\tstep[0] = 1;\n\t\tstep[1] = 0;\n\n\t\tif (c[0] != '0') {\n\t\t\tstep[1] = 1;\n\t\t}\n\n\t\tfor (int i = 2; i <= n; i++) {\n\n\t\t\tstep[i] = 0;\n\n\t\t\tif (c[i - 1] != '0') {\n\t\t\t\tstep[i] += step[i - 1];\n\t\t\t}\n\n\t\t\tif (c[i - 2] != '0') {\n\t\t\t\tif ((c[i - 2] - '0') * 10 + (c[i - 1] - '0') <= 26) {\n\t\t\t\t\tstep[i] += step[i - 2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn step[n];\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class _75_sortColors {\n\n    public static void main(String[] args) {\n        _75_sortColors sortColors = new _75_sortColors();\n        int[] nums = {2, 1, 2};\n        sortColors.sortColors(nums);\n        Util.printArray(nums);\n    }\n\n    \n    public void sortColors(int[] nums) {\n        int p0 = 0, curr = 0;\n        int p2 = nums.length - 1;\n\n        int tmp;\n        while (curr <= p2) {\n            if (nums[curr] == 0) {\n                tmp = nums[p0];\n                nums[p0++] = nums[curr];\n                nums[curr++] = tmp;\n            } else if (nums[curr] == 2) {\n                tmp = nums[curr];\n                nums[curr] = nums[p2];\n                nums[p2--] = tmp;\n            } else {\n                curr++;\n            }\n        }\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Powxn2 {\n\tpublic double pow(double x, int n) {\n\t\tif (n == 0)\n\t\t\treturn 1.0;\n\t\tif (n == 2)\n\t\t\treturn x * x;\n\t\tif (n < 0) {\n\t\t\tn = -n;\n\t\t\tx = 1.0 / x;\n\t\t}\n\t\tif (n % 2 == 0)\n\t\t\treturn pow(pow(x, n / 2), 2);\n\t\telse\n\t\t\treturn x * pow(pow(x, n / 2), 2);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int findPeakElement(int[] num) {\n        int left = 0, right = num.length - 1, mid = -1;\n        while (left <= right) {\n            mid = (left + right) /2;\n            if ((mid == 0 || num[mid-1] <= num[mid]) && (mid == num.length - 1 || num[mid] >= num[mid+1]))\n                return mid;\n            if (mid > 0 && num[mid-1] > num[mid]) {\n                right = mid - 1;\n            } else if (num[mid+1] > num[mid]) {\n                left = mid + 1;\n            }\n        }\n        return mid;\n    }\n}", "nl": "leetcoders"}
{"code": "public class MinimumPathSum {\n  public int minPathSum(int[][] grid) {\n    int[][] path = new int[grid.length][grid[0].length];\n    path[0][0] = grid[0][0];\n    for (int i = 1; i < grid.length; i++) {\n      path[i][0] = path[i - 1][0] + grid[i][0];\n    }\n    for (int j = 1; j < grid[0].length; j++) {\n      path[0][j] = path[0][j - 1] + grid[0][j];\n    }\n    for (int i = 1; i < grid.length; i++)\n      for (int j = 1; j < grid[0].length; j++) {\n        path[i][j] = Math.min(path[i - 1][j], path[i][j - 1]) + grid[i][j];\n      }\n    return path[grid.length - 1][grid[0].length - 1];\n  }\n}\n", "nl": "mengli"}
{"code": "public class PlusOne {\n\tpublic int[] plusOne(int[] digits) {\n\t\tint carry = 1;\n\t\tint i = digits.length - 1;\n\n\t\tfor (; i >= 0; --i) {\n\t\t\tdigits[i] += carry;\n\n\t\t\tif (digits[i] >= 10) {\n\t\t\t\tdigits[i] -= 10;\n\t\t\t\tcarry = 1;\n\t\t\t} else {\n\t\t\t\tcarry = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i < 0) {\n\t\t\tint[] result = new int[digits.length + 1];\n\t\t\tresult[0] = 1;\n\n\t\t\tSystem.arraycopy(digits, 0, result, 1, digits.length);\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn digits;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = new int[] { 9, 9 };\n\t\tPlusOne slt = new PlusOne();\n\t\tint[] b = slt.plusOne(a);\n\t\tfor (int i = 0; i < b.length; ++i) {\n\t\t\tSystem.out.print(b[i]);\n\t\t}\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    public List<String> fullJustify(String[] words, int L) {\n        List<String> res = new ArrayList<String>();\n        int i = 0, N = words.length;\n        while (i < N) {\n            int length = words[i].length();\n            int j = i + 1;\n            while (j < N && length + words[j].length() + (j-i) <= L) {\n                length += words[j++].length();\n            }\n            StringBuilder s = new StringBuilder(words[i]);\n            boolean isLastLine = (j==N);\n            boolean oneWord = (j == i + 1);\n            int average = (isLastLine || oneWord) ? 1 : (L-length)/(j-i-1);\n            int extra = (isLastLine || oneWord) ? 0 : (L-length)%(j-i-1);\n            for (int k = i + 1; k < j; ++k) {\n                char[] tmp = new char[extra>0?average+1:average];\n                Arrays.fill(tmp, ' ');\n                s.append(tmp);\n                s.append(words[k]);\n                extra--;\n            }\n            char[] tmp = new char[L - s.length()];\n            Arrays.fill(tmp, ' ');\n            s.append(tmp);\n            res.add(s.toString());\n            i = j;\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class RestoreIPAddresses {\n  public ArrayList<String> restoreIpAddresses(String s) {\n    ArrayList<String> ips = new ArrayList<String>();\n    StringBuffer sb = new StringBuffer();\n    restoreIpAddresses(s, 0, ips, sb, 0);\n    return ips;\n  }\n\n  private void restoreIpAddresses(\n      String s, int i, ArrayList<String> ips, StringBuffer ip, int step) {\n    if ((step >= 4 && i < s.length()) || (step < 4 && i >= s.length())) return;\n    if (step >= 4 && i >= s.length()) {\n      ips.add(ip.substring(0, ip.length() - 1));\n    } else {\n      if (s.charAt(i) == '0') {\n        ip.append('0');\n        ip.append('.');\n        restoreIpAddresses(s, i + 1, ips, ip, step + 1);\n        ip.deleteCharAt(ip.length() - 1);\n        ip.deleteCharAt(ip.length() - 1);\n      } else {\n        for (int j = 1; j <= 3 && i + j <= s.length(); j++) {\n          StringBuffer nextSeg = new StringBuffer();\n          nextSeg.append(s.substring(i, i + j));\n          int n = Integer.parseInt(nextSeg.toString());\n          if (n > 0 && n <= 255) {\n            ip.append(nextSeg.toString());\n            ip.append('.');\n            restoreIpAddresses(s, i + j, ips, ip, step + 1);\n            ip.deleteCharAt(ip.length() - 1);\n            for (int k = 0; k < nextSeg.length(); k++) ip.deleteCharAt(ip.length() - 1);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class AddBinary {\n\n    public class Solution {\n        public String addBinary(String a, String b) {\n            StringBuilder re = new StringBuilder();\n            int i = a.length() - 1;\n            int j = b.length() - 1;\n            int carry = 0;\n            while (i >= 0 || j >= 0 || carry > 0) {\n                int valueA = i < 0 ? 0 : a.charAt(i) - '0';\n                int valueB = j < 0 ? 0 : b.charAt(j) - '0';\n                re.append((valueA + valueB + carry) % 2);\n                carry = (valueA + valueB + carry) / 2;\n                i--;\n                j--;\n            }\n            return re.reverse().toString();\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root==null) {\n            return true;\n        }else {\n            TreeNode p=root.left;\n            TreeNode q=root.right;\n            return isSy(p, q);\n        }\n    }\n    public boolean isSy(TreeNode p,TreeNode q){\n        if (p==null&&q==null) {\n            return true;\n        }else if (p==null||q==null) {\n            return false;\n        }\n        if (p.val!=q.val) {\n            return false;\n        }else{\n            return isSy(p.right, q.left)&&isSy(p.left, q.right);\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n        return solve (root.left, root.right);\n    }\n    public boolean solve(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return true;\n        if (t1 == null && t2 != null || t1 != null && t2 == null || t1.val != t2.val) return false;\n        return solve(t1.left, t2.right) && solve(t1.right, t2.left);\n    }\n}", "nl": "leetcoders"}
{"code": "public class _3Sum {\n\n    public class Solution {\n\n        private ArrayList<Integer> makeTriplet(int a, int b, int c) {\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            ans.add(a);\n            ans.add(b);\n            ans.add(c);\n            return ans;\n        }\n\n        private void twoSum(ArrayList<ArrayList<Integer>> ans, int a,\n                int[] num, int begin) {\n            int i = begin;\n            int j = num.length - 1;\n            while (i < j) {\n                int sum = num[i] + num[j];\n                if (sum < -a) {\n                    i++;\n                } else if (sum > -a) {\n                    j--;\n                } else {\n                    ans.add(makeTriplet(a, num[i], num[j]));\n                    do {\n                        i++;\n                    } while (i < j && num[i] == num[i - 1]);\n                    do {\n                        j--;\n                    } while (i < j && num[j] == num[j + 1]);\n                }\n            }\n        }\n\n        public ArrayList<ArrayList<Integer>> threeSum(int[] num) {\n            Arrays.sort(num);\n            ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n            for (int i = 0; i < num.length - 2; i++) {\n                if (i > 0 && num[i] == num[i - 1]) {\n                    continue;\n                }\n                twoSum(ans, num[i], num, i + 1);\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "class Solution {\n    public int majorityElement(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int majorityNum = nums[0];\n        int vote = 0;\n        for (int num : nums) {\n            vote += num == majorityNum ? 1 : -1;\n            if (vote == 0) {\n                majorityNum = num;\n                vote = 1;\n            }\n        }\n        return majorityNum;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int reverse(int x) {\n        int sign = x>=0?1:-1;\n        x = x>=0? x:-x;\n        \n        int res = 0;\n        \n        while(x!=0){\n            res *= 10;\n            res +=x%10;\n            x = x/10;            \n        }\n            \n        res = res*sign;\n        \n        return res;\n    }\n}", "nl": "azheanda"}
{"code": "public class FindMinimuminRotatedSortedArray2 {\n    public int findMin(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i + 1] < nums[i]) {\n                return nums[i + 1];\n            }\n        }\n        return nums[0];\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum=0;\n        int answer=nums[0];\n        for (int i = 0; i < nums.length; i++) {\n            sum+=nums[i];\n            if (sum>answer) {\n                answer=sum;\n            }\n            if (sum<0) {\n                sum=0;\n            }\n        }\n        return answer;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    \n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) {\n            return head;\n        }\n        int length = 0;\n        ListNode dummy = head;\n        while(dummy != null) {\n            dummy = dummy.next;\n            length++;\n        }\n        k = k % length;\n        dummy = new ListNode(0);\n        dummy.next = head;\n        head = dummy;\n        for (int i = 0; i < k; i++) {\n            head = head.next;\n        }\n        ListNode tail = dummy;\n        while (head.next != null) {\n            head = head.next;\n            tail = tail.next;\n        }\n        head.next = dummy.next;//Link old Head to the end, form circle\n        dummy.next = tail.next;//Link tail.next as new head. tail should be end point.\n        tail.next = null;//add null to end point tail\n        return dummy.next;\n    }\n}\n", "nl": "awangdev"}
{"code": "class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode dummy = pre;\n        \n        while (pre.next != null && pre.next.next != null) {\n            ListNode a = pre.next;\n            ListNode b = a.next;\n            \n            a.next = b.next;\n            b.next = a;\n            pre.next = b;\n            \n            pre = pre.next.next;\n        }\n        return dummy.next;\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> list=new ArrayList<Integer>();\n        int mb=0;\n        int nb=0;\n        int me=matrix.length;\n        if (me==0) {\n            return list;\n        }\n        int ne=matrix[0].length;\n        while (true) {\n            list=new Solution().right(matrix, mb, nb, me, ne, list);\n            mb++;\n            if (nb>ne-1||mb>me-1) {\n                return list;\n            }\n            list=new Solution().low(matrix, mb, nb, me, ne, list);\n            ne--;\n            if (nb>ne-1||mb>me-1) {\n                return list;\n            }\n            list=new Solution().left(matrix, mb, nb, me, ne, list);\n            me--;\n            if (nb>ne-1||mb>me-1) {\n                return list;\n            }\n            list=new Solution().up(matrix, mb, nb, me, ne, list);\n            nb++;\n            if (nb>ne-1||mb>me-1) {\n                return list;\n            }\n        }\n    }\n    public List<Integer> right(int[][] matrix,int mb,int nb,int me,int ne,List<Integer> list){\n        for (int i = nb; i < ne; i++) {\n            list.add(matrix[mb][i]);\n        }\n        return list;\n    }\n    public List<Integer> left(int[][] matrix,int mb,int nb,int me,int ne,List<Integer> list){\n        for (int i = ne-1; i >=nb; i--) {\n            list.add(matrix[me-1][i]);\n        }\n        return list;\n    }\n    public List<Integer> low(int[][] matrix,int mb,int nb,int me,int ne,List<Integer> list){\n        for (int i = mb; i < me; i++) {\n            list.add(matrix[i][ne-1]);\n        }\n        return list;\n    }\n    public List<Integer> up(int[][] matrix,int mb,int nb,int me,int ne,List<Integer> list){\n        for (int i = me-1; i >=mb; i--) {\n            list.add(matrix[i][nb]);\n        }\n        return list;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class HouseRobber {\n\n    private HouseRobber hr;\n\n    \n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        if (nums.length == 1) {\n            return nums[0];\n        }\n        int preMax = nums[0];\n        int max = Math.max(nums[0], nums[1]);\n        for (int i = 2; i < nums.length; i++) {\n            int temp = preMax;\n            preMax = max;\n            max = Math.max(temp + nums[i], preMax);\n        }\n        return max;\n    }\n\n    \n    public int robB(int[] nums) {\n        int preMax = 0;\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int curMax = Math.max(preMax + nums[i], max);\n            preMax = max;\n            max = curMax;\n        }\n        return max;\n    }\n\n    @Before\n    public void setUp() {\n        hr = new HouseRobber();\n    }\n\n    @Test\n    public void testInvalidInput() {\n        Assert.assertEquals(0, hr.rob(null));\n    }\n\n    @Test\n    public void testEdgeCases() {\n        int[] input = {};\n        Assert.assertEquals(0, hr.rob(input));\n        input = new int[]{1};\n        Assert.assertEquals(1, hr.rob(input));\n        input = new int[]{10};\n        Assert.assertEquals(10, hr.rob(input));\n        input = new int[]{1, 2};\n        Assert.assertEquals(2, hr.rob(input));\n        input = new int[]{2, 1};\n        Assert.assertEquals(2, hr.rob(input));\n    }\n\n    @Test\n    public void testWithExamples() {\n        int[] input = {1, 2, 3};\n        Assert.assertEquals(4, hr.rob(input));\n        input = new int[]{1, 2, 3, 4};\n        Assert.assertEquals(6, hr.rob(input));\n        input = new int[]{2, 8, 3, 6, 5};\n        Assert.assertEquals(14, hr.rob(input));\n    }\n\n    @After\n    public void tearDown() {\n        hr = null;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "class RotateList {\n  public static void main(String[] args) {\n    int n = -4;\n    System.out.println(n % 5);\n  }\n\n  \n  public static ListNode rotateRight(ListNode head, int n) {\n    if (head == null || head.next == null) return head;\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode fast = dummy, slow = dummy;\n    int len;\n    for (len = 0; fast.next != null; len++) fast = fast.next;\n    for (int j = len - n % len; j > 0; j--) slow = slow.next;\n    fast.next = dummy.next;\n    dummy.next = slow.next;\n    slow.next = null; // break linkedlist\n    return dummy.next;\n  }\n\n  \n  public ListNode rotateRightB(ListNode head, int n) {\n    if (head == null || head.next == null) return head;\n    int len = listLength(head);\n    n %= len;\n    if (n == 0) return head;\n    if (n < 0) n += len;\n    n = len - n;\n    ListNode p = new ListNode(0);\n    p.next = head;\n    while (n > 0) {\n      p = p.next;\n      n--;\n    }\n    ListNode newHead = p.next;\n    p.next = null;\n    ListNode cur = newHead;\n    while (cur.next != null) cur = cur.next;\n    cur.next = head;\n    return newHead;\n  }\n\n  int listLength(ListNode head) {\n    ListNode cur = head;\n    int res = 0;\n    while (cur != null) {\n      cur = cur.next;\n      res++;\n    }\n    return res;\n  }\n\n  static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (validate(candidates, target)) return result;\n\n        Arrays.sort(candidates); // critical to skip duplicates\n        dfs(result, new ArrayList<>(), candidates, 0, target);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> list,\n                     int[] candidates, int index, int target) {\n        for (int i = index; i < candidates.length; i++) {\n            if (i > index && candidates[i] == candidates[i - 1]) continue;\n\n            int value = candidates[i];\n            list.add(value);\n            if (target == value) result.add(new ArrayList<>(list));\n            else if (target - value > 0) dfs(result, list, candidates, i + 1, target - value);\n            list.remove(list.size() - 1); // backtrack\n        }\n    }\n\n    private boolean validate(int[] candidates, int target) {\n        return candidates == null || candidates.length == 0 || target <= 0;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class LengthofLastWord {\n  public int lengthOfLastWord(String s) {\n    int i = s.length() - 1;\n    while (i >= 0 && s.charAt(i) == ' ') {\n      i--;\n    }\n    if (i < 0) return 0;\n    int j = i;\n    while (j - 1 >= 0 && s.charAt(j - 1) != ' ') {\n      j--;\n    }\n    return i - j + 1;\n  }\n}\n", "nl": "mengli"}
{"code": "public class MinimumWindowSubstring {\n\n    \n    public String minWindow(String s, String t) {\n        int[] letters = new int[256]; // Contains negative count of letters in s, positive count of letters in t.\n        for (char c : t.toCharArray()) {\n            letters[c]++;\n        }\n        int covered = 0;\n        String window = \"\";\n        int length = s.length();\n        for (int start = 0, end = 0; end < s.length(); end++) {\n            if (letters[s.charAt(end)] > 0) { // Is a T character.\n                covered++;\n            }\n            letters[s.charAt(end)]--;\n            while (covered == t.length()) { // All characters covered.\n                int currentLength = end - start + 1;\n                if (currentLength <= length) { // Note the <= sign, as length is initialized as s.length().\n                    length = currentLength;\n                    window = s.substring(start, end + 1);\n                }\n                letters[s.charAt(start)]++;\n                if (letters[s.charAt(start)] > 0) { // Removed a character in T.\n                    covered--;\n                }\n                start++;\n            }\n        }\n        return window;\n    }\n\n    \n    public String minWindow2(String s, String t) {\n        String res = \"\";\n        int[] tCnt = new int[256]; // Assuming charset size 256.\n        for (char c : t.toCharArray()) {\n            tCnt[c]++;\n        }\n        int minLen = Integer.MAX_VALUE;\n        int count = t.length(); // Counter for whether the window is valid.\n        for (int start = 0, end = 0; end < s.length(); end++) {\n            \n            if (tCnt[s.charAt(end)]-- > 0) {\n                count--;\n            }\n\n            while (count == 0) { // If count is 0, all characters in t are matched.\n                if (end - start + 1 < minLen) {\n                    minLen = end - start + 1;\n                    res = s.substring(start, end + 1);\n                }\n                \n                if (++tCnt[s.charAt(start++)] > 0) {\n                    count++;\n                }\n            }\n        }\n        return res;\n    }\n\n    \n    public String minWindow3(String s, String t) {\n        int[] letters = new int[256];\n        for (char c : t.toCharArray()) letters[c]++;\n        int minLen = Integer.MAX_VALUE;\n        int covered = 0;\n        int head = 0;\n        char[] chs = s.toCharArray();\n        for (int start = 0, end = 0; end < s.length(); end++) {\n            if (letters[chs[end]] > 0) covered++;\n            letters[chs[end]]--;\n            while (covered == t.length()) {\n                int len = end - start + 1;\n                if (len < minLen) {\n                    minLen = len;\n                    head = start;\n                }\n                letters[chs[start]]++;\n                if (letters[chs[start]] > 0) {\n                    covered--;\n                }\n                start++;\n            }\n        }\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(head, head + minLen);\n    }\n\n    \n    private int findSubstring(String s) {\n        int[] map = new int[128];\n        int counter; // Check whether the substring is valid\n        int begin = 0, end = 0; // Two pointers, one point to tail and one head\n        int d = Integer.MAX_VALUE; // The length of substring\n\n\n        while (end < s.length()) { // Traverse s\n\n\n\n            \n\n\n\n            \n        }\n        return d;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n        \treturn false;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int start = 0;\n        int end = m * n - 1;\n        int mid;\n        int i;\n        int j;\n        while (start + 1 < end) {\n        \tmid = start + (end - start) / 2;\n        \ti = mid / n;\n        \tj = mid % n;\n        \tif (matrix[i][j] == target) {\n        \t\treturn true;\n        \t} else if (matrix[i][j] > target) {\n        \t\tend = mid;\n        \t} else {\n        \t\tstart = mid;\n        \t}\n        }\n        int s1 = start / n;\n        int s2 = start % n;\n        int e1 = end / n;\n        int e2 = end % n;\n\n        return matrix[s1][s2] == target || matrix[e1][e2] == target;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class LinkedListCycle_2 {\n    public static ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                break;\n            }\n        }\n        if (slow == fast) {\n            fast = head;\n            while (slow != fast) {\n                slow = slow.next;\n                fast = fast.next;\n            }\n            return slow;\n        } else {\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        ListNode res = new ListNode(1);\n        res.next = new ListNode(2);\n        res.next.next = new ListNode(3);\n        res.next.next.next = new ListNode(4);\n        res.next.next.next.next = new ListNode(5);\n        res.next.next.next.next.next = new ListNode(6);\n        res.next.next.next.next.next = res.next.next.next;\n        System.out.print(detectCycle(res).val);\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class SearchInRotatedSortedArray {\n\n  \npublic int search(int[] nums, int target) {\n  int lo = 0;\n  int hi = nums.length - 1;\n  while (lo <= hi) {\n    int mid = lo + (hi - lo) / 2;\n    if (nums[mid] == target) {\n      return mid;\n    }\n\n    if (nums[lo] <= nums[mid]) {\n      if (target < nums[mid] && target >= nums[lo]) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n      }\n    }\n\n    if (nums[mid] <= nums[hi]) {\n      if (target > nums[mid] && target <= nums[hi]) {\n        lo = mid + 1;\n      } else {\n        hi = mid - 1;\n      }\n    }\n  }\n  return -1;\n}\n\n  \npublic int search2(int[] nums, int target) {\n  int minIdx = findMinIdx(nums);\n  if (target == nums[minIdx]) {\n    return minIdx;\n  }\n  int len = nums.length;\n  int start = target <= nums[len - 1] ? minIdx : 0;\n  int end = target <= nums[len - 1] ? len - 1 : minIdx - 1;\n\n  while (start <= end) {\n    int mid = start + (end - start) / 2;\n    if (nums[mid] == target) {\n      return mid;\n    } else if (target > nums[mid]) {\n      start = mid + 1;\n    } else {\n      end = mid - 1;\n    }\n  }\n  return -1;\n}\n\n  \nprivate int findMinIdx(int[] nums) {\n  int lo = 0, hi = nums.length - 1;\n  while (lo < hi) { // Stop when lo == hi.\n    int mid = lo + (hi - lo) / 2;\n    if (nums[mid] > nums[hi]) { // Minimum must be in right half, excluding mid.\n      lo = mid + 1;\n    } else { // Minimum must be in left half, including mid.\n      hi = mid;\n    }\n  }\n  return lo;\n}\n}", "nl": "FreeTymeKiyan"}
{"code": "public class BinaryTreeInorderTraversal\n{\n\n    public List<Integer> inorderTraversal( TreeNode root )\n    {\n    \tList<Integer> result = new ArrayList<>();\n    \tStack<TreeNode> stack = new Stack<>();\n    \tpushAllLeftChild( root, stack );\n    \twhile ( !stack.isEmpty( ) )\n    \t{\n    \t\tTreeNode top = stack.pop( );\n    \t\tresult.add( top.val );\n    \t\tif ( top.right != null )\n    \t\t{\n    \t\t\tpushAllLeftChild( top.right, stack );\n    \t\t}\n    \t}\n    \treturn result;\n    }\n    \n    private void pushAllLeftChild( TreeNode root, Stack<TreeNode> stack )\n    {\n    \tTreeNode currNode = root;\n    \twhile ( currNode != null )\n    \t{\n    \t\tstack.push( currNode );\n    \t\tcurrNode = currNode.left;\n    \t}\n    }\n    \n    public List<Integer> inorderTraversalRecursively( TreeNode root )\n    {\n    \tList<Integer> result = new ArrayList<>();\n    \ttraverse( root, result );\n    \treturn result;\n    }\n    \n    private void traverse( TreeNode root, List<Integer> result )\n    {\n    \tif ( root == null )\n    \t{\n    \t\treturn;\n    \t}\n    \ttraverse( root.left, result );\n    \tresult.add( root.val );\n    \ttraverse( root.right, result );\n    }\n    \n    @Test\n    public void test()\n    {\n    \tTreeNode node1 = new TreeNode( 3 );\n    \tTreeNode node2 = new TreeNode( 1 );\n    \tTreeNode node3 = new TreeNode( 2 );\n    \tnode1.left = node2;\n    \tnode2.right = node3;\n    \tSystem.out.println( inorderTraversal( node1 ) );\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public void flatten(TreeNode root) {\n        if(root==null)\n            return;\n        \n        TreeNode left  = root.left;\n        TreeNode right = root.right;\n        root.left = null;\n        if(left != null){\n            root.right = left;      \t  \n            TreeNode rightmost = left;\n            while(rightmost.right!=null)\n                rightmost = rightmost.right;\n            rightmost.right =  right;\n        }else\n            root.right = right;\n       \n        flatten(left);\n        flatten(right);\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class ConvertSortedListtoBinarySearchTree {\n  public TreeNode sortedListToBST(ListNode head) {\n    return sortedListToBST(head, null);\n  }\n\n  private TreeNode sortedListToBST(ListNode start, ListNode end) {\n    if (start == end) {\n      return null;\n    } else if (start.next == end) {\n      return new TreeNode(start.val);\n    } else {\n      ListNode fast = start, slow = start;\n      while (fast.next != end && fast.next.next != end) {\n        fast = fast.next.next;\n        slow = slow.next;\n      }\n      TreeNode left = sortedListToBST(start, slow);\n      TreeNode right = sortedListToBST(slow.next, end);\n      TreeNode root = new TreeNode(slow.val);\n      root.left = left;\n      root.right = right;\n      return root;\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class MaximumSubarray {\n\tpublic int maxSubArray(int[] A) {\n\t\tint thisSum = A[0] > 0 ? A[0] : 0;\n\t\tint maxSum = A[0];\n\n\t\tfor (int i = 1; i < A.length; ++i) {\n\t\t\tthisSum += A[i];\n\t\t\tif (thisSum > maxSum) {\n\t\t\t\tmaxSum = thisSum;\n\t\t\t}\n\t\t\tif (thisSum < 0) {\n\t\t\t\tthisSum = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn maxSum;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] A = new int[] { -2, 1 }; \n\t\tMaximumSubarray slt = new MaximumSubarray();\n\t\tint result = slt.maxSubArray(A);\n\t\tSystem.out.println(result);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class _31_nextPermutation {\n\n    public static void main(String[] args) {\n        _31_nextPermutation permutation = new _31_nextPermutation();\n        int[] nums = new int[]{1, 2, 3, 4, 7, 5, 6};\n        Util.printArray(nums);\n        permutation.nextPermutation(nums);\n        Util.printArray(nums);\n        permutation.nextPermutation(nums);\n        Util.printArray(nums);\n    }\n\n    \n    public void nextPermutation(int[] nums) {\n        if (nums.length <= 1) {\n            return;\n        }\n        int pNum = nums[nums.length - 1];\n        int cIndex = -1;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            int cNum = nums[i];\n            if (cNum < pNum) {\n                cIndex = i;\n                break;\n            }\n            pNum = cNum;\n        }\n        if (cIndex == -1) {\n            Arrays.sort(nums);\n            return;\n        }\n        int rIndex = cIndex + 1;\n        for (int i = cIndex + 1; i < nums.length; i++) {\n            if (nums[i] <= nums[cIndex]) {\n                break;\n            }\n            rIndex = i;\n        }\n        int temp = nums[cIndex];\n        nums[cIndex] = nums[rIndex];\n        nums[rIndex] = temp;\n        Arrays.sort(nums, cIndex + 1, nums.length);\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class PalindromePartitioning {\n  public ArrayList<ArrayList<String>> partition(String s) {\n    ArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();\n    ArrayList<String> r = new ArrayList<String>();\n    int length = s.length();\n    boolean[][] map = new boolean[length][length];\n    findPartition(s, 0, ret, r, map);\n    return ret;\n  }\n\n  private void findPartition(\n      String s, int start, ArrayList<ArrayList<String>> ret, ArrayList<String> r, boolean[][] map) {\n    int length = s.length();\n    if (start == length && r.size() != 0) {\n      ArrayList<String> clone = new ArrayList<String>(r);\n      ret.add(clone);\n    } else {\n      for (int j = start; j < length; j++) {\n        if (start == j\n            || (j - start > 1 && s.charAt(start) == s.charAt(j) && map[start + 1][j - 1])\n            || (j - start == 1 && s.charAt(start) == s.charAt(j))) {\n          map[start][j] = true;\n          r.add(s.substring(start, j + 1));\n          findPartition(s, j + 1, ret, r, map);\n          r.remove(r.size() - 1);\n        }\n      }\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class SameTree {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if ((p == null && q != null) || (p != null && q == null)) return false;\n    if (p.val != q.val) return false;\n    else {\n      return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "class UniquePaths2 {\n    public static void main(String[] args) {\n        int[][] obstacleGrid = new int[3][3];\n        obstacleGrid[1][1] = 1;\n        System.out.println(uniquePathsWithObstacles(obstacleGrid));\n    }\n\n    \n    public static int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if (obstacleGrid == null) return 0;\n        int m = obstacleGrid.length;\n        if (m == 0) return 0;\n        int n = obstacleGrid[0].length;\n        int[][] paths = new int[m + 1][n + 1];\n\n        paths[m - 1][n] = 1;\n        for (int r = m - 1; r >= 0; r--) {\n            for (int c = n - 1; c >= 0; c--) {\n                paths[r][c] = obstacleGrid[r][c] == 1 ? 0 : paths[r + 1][c] + paths[r][c + 1];\n            }\n        }\n        return paths[0][0];\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class BinaryTreePaths\n{\n\n    public List<String> binaryTreePaths( TreeNode root ) \n    {\n        if ( root == null )\n        {\n        \treturn new ArrayList<>();\n        }\n        \n        List<StringBuilder> result = new ArrayList<>();        \n        StringBuilder path = new StringBuilder();\n        traverseTree( result, path, root );\n\n        List<String> trimmedResult = new ArrayList<>();\n        for ( StringBuilder oneResult : result )\n        {\n        \ttrimmedResult.add( oneResult.delete( 0, 2 ).toString() );\n        }\n        return trimmedResult;\n    }\n\n    private void traverseTree( List<StringBuilder> result, StringBuilder path, TreeNode root )\n    {\n    \tif ( root == null )\n    \t{\n    \t\treturn;\n    \t}\n    \t\n    \tif ( root.left == null\n    \t\t\t&& root.right == null )\n    \t{\n    \t\tint originLength = path.length();\n    \t\tpath.append(\"->\");\n    \t\tpath.append( String.valueOf( root.val ) );\n\n    \t\tresult.add( new StringBuilder( path ) );\n    \t\t\n    \t\tpath.delete( originLength, path.length() );\n    \t\treturn;\n    \t}\n    \t\n    \tint originLength = path.length();\n    \tpath.append( \"->\" );\n    \tpath.append( String.valueOf( root.val ) );\n    \tif ( root.left != null )\n    \t{\n    \t\ttraverseTree( result, path, root.left );\n    \t}\n    \tif ( root.right != null )\n    \t{\n    \t\ttraverseTree( result, path, root.right );\n    \t}\n    \tpath.delete( originLength, path.length() );\n    }\n   \n    @Test\n    public void test()\n    {\n    \tTreeNode node1 = new TreeNode( 1 );\n    \tTreeNode node2 = new TreeNode( 2 );\n    \tTreeNode node3 = new TreeNode( 3 );\n    \tTreeNode node4 = new TreeNode( 5 );\n    \tnode1.left = node2;\n    \tnode1.right = node3;\n    \tnode2.right = node4;\n    \tSystem.out.println( binaryTreePaths( node1 ) );\n    }\n    \n}\n", "nl": "FreemanZhang"}
{"code": "public class _62_uniquePaths {\n    public static void main(String[] args) {\n        System.out.println(uniquePaths(3, 2));\n        System.out.println(uniquePaths(7, 3));\n    }\n\n    public static int uniquePaths(int m, int n) {\n        if (m <= 1 || n <= 1) {\n            return 1;\n        }\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = 1;\n        }\n        for (int i = 0; i < m; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n\n        return dp[m - 1][n - 1];\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class BinaryTreeInOrderTraversal {\n\n    \n    public List<Integer> inorderTraversal(TreeNode root) {\n        if (root == null) return Collections.emptyList();\n        Deque<TreeNode> stack = new ArrayDeque<>();\n        List<Integer> values = new ArrayList<>();\n        TreeNode cur = root;\n        while (!stack.isEmpty() || cur != null) {\n            if (cur != null) {\n                stack.push(cur);\n                cur = cur.left;\n            } else {\n                cur = stack.pop();\n                values.add(cur.val);\n                cur = cur.right;\n            }\n        }\n        return values;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int maxSubArray(int[] A) {\n\n    \tint max_ending_here = 0;\n\t\tint max_so_far =Integer.MIN_VALUE;  // modification here\n\n        for(int i = 0; i < A.length; i++) {\n\t\t\tmax_ending_here =Math.max(A[i],max_ending_here+A[i]);// and here\n\t\t\tmax_so_far = Math.max(max_so_far,max_ending_here);\n\t\t}\n\n\t\treturn max_so_far;\n        \n        \n    } \n}", "nl": "azheanda"}
{"code": "public class WordLadder\n{\n\t\n\t@Test\n\tpublic void test2()\n\t{\n\t\tList<Integer> list1 = new LinkedList<>();\n\t\tSystem.out.println( list1.iterator().next() );\n\t}\n\t\n\t@Ignore\n\t@Test\n\tpublic void test()\n\t{\n\t\tSet<String> words = new HashSet<>();\n\t\twords.add( \"hot\" );\n\t\twords.add( \"dog\" );\n\t\twords.add( \"dot\" );\n\t\tassertEquals( 3, ladderLength( \"hot\", \"dog\", words ) );\n\t\t\n\t\tSet<String> words2 = new HashSet<>();\n\t\twords2.add( \"hot\" );\n\t\twords2.add( \"dog\" );\n\t\tassertEquals(  -1, ladderLength( \"hot\", \"dog\", words2 ) );\t\t\t\t\n\t}\n\t\n    public int ladderLength( String beginWord, String endWord, Set<String> wordList )\n    {    \t\n    \tif ( beginWord == null || endWord == null )\n    \t{\n    \t\tthrow new IllegalArgumentException();\n    \t}\n    \tif ( beginWord.equals( endWord ) )\n    \t{\n    \t\treturn 0;\n    \t}\n    \tif ( wordList.size() == 0 )\n    \t{\n    \t\treturn -1;\n    \t}\n    \t\n    \tSet<String> toBeVisited = new HashSet<>( wordList );\n    \ttoBeVisited.add( endWord );\n    \ttoBeVisited.remove( beginWord );\n    \tQueue<String> bfsQueue = new LinkedList<>();\n    \tbfsQueue.add( beginWord );\n    \tint level = 0;\n    \twhile ( !bfsQueue.isEmpty() )\n    \t{\n    \t\tint size = bfsQueue.size();\n    \t\tfor ( int i = 0; i < size; i++ )\n    \t\t{\n    \t\t\tString head = bfsQueue.poll();\n    \t\t\tif ( head.equals( endWord ) )\n    \t\t\t{\n    \t\t\t\treturn level + 1;\n    \t\t\t}\n    \t\t\tgenerateNextLevel( head, bfsQueue, toBeVisited );\n    \t\t}    \t\t\n\t\t\tlevel++;\n    \t}\n    \treturn 0;\n    }\n    \n    private void generateNextLevel( String currWord, Queue<String> bfsQueue, Set<String> toBeVisited )\n    {\n\t\tchar[] word = currWord.toCharArray();\n    \tfor ( int i = 0; i < currWord.length(); i++ )\n    \t{\n    \t\tchar chBeforeChange = word[i];\n    \t\tfor ( char ch = 'a'; ch <= 'z'; ch++ )\n    \t\t{\n    \t\t\tword[i] = ch;\n    \t\t\tString nextStr = new String( word );\n    \t\t\tif ( toBeVisited.contains( nextStr ) )\n    \t\t\t{\n    \t\t\t\tbfsQueue.add( nextStr );\n    \t\t\t\ttoBeVisited.remove( nextStr );\n    \t\t\t}\n    \t\t}\n    \t\tword[i] = chBeforeChange;\n    \t}\n    }\n    \n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int largestRectangleArea_1(int[] height) {\n        int res = 0;\n        for (int i = 0; i < height.length; ++i) {\n            if ((i < height.length - 1) && (height[i] <= height[i+1])) {\n                continue;\n            }\n            int minheight = height[i];\n            for (int j = i; j >= 0; --j) {\n                minheight = Math.min(minheight, height[j]);\n                res = Math.max(res, (i-j+1)*minheight);\n            }\n        }\n        return res;\n    }\n    public int largestRectangleArea(int[] height) {\n        int res = 0;\n        Stack<Integer> stk = new Stack<Integer>();\n        int i = 0;\n        while (i < height.length) {\n            if (stk.isEmpty() == true || (height[i] >= height[stk.peek()])) {\n                stk.push(i++);\n            } else {\n                int idx = stk.pop();\n                int width = stk.isEmpty() ? i : (i - stk.peek() - 1);\n                res = Math.max(res, width*height[idx]);\n            }\n        }\n        while (stk.isEmpty() == false) {\n            int idx = stk.pop();\n            int width = stk.isEmpty() ? height.length : (height.length - stk.peek() - 1);\n            res = Math.max(res, width*height[idx]);\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class BinaryTreePostorderTraversal {\n\n    public class Solution {\n        private void postorderTraversal(TreeNode root,\n                ArrayList<Integer> postorder) {\n            if (root == null) {\n                return;\n            }\n            postorderTraversal(root.left, postorder);\n            postorderTraversal(root.right, postorder);\n            postorder.add(root.val);\n        }\n\n        public ArrayList<Integer> postorderTraversal(TreeNode root) {\n            ArrayList<Integer> postorder = new ArrayList<Integer>();\n            postorderTraversal(root, postorder);\n            return postorder;\n        }\n\n        public ArrayList<Integer> postorderTraversalWithIterative(TreeNode root) {\n            ArrayList<Integer> postorder = new ArrayList<Integer>();\n            if (root == null) {\n                return postorder;\n            }\n            ArrayDeque<TreeNode> stack = new ArrayDeque<TreeNode>();\n            TreeNode pre = null;\n            stack.offerLast(root);\n            while (!stack.isEmpty()) {\n                TreeNode p = stack.peekLast();\n                if (pre == null || pre.left == p || pre.right == p) {\n                    if (p.left != null) {\n                        stack.offerLast(p.left);\n                    } else if (p.right != null) {\n                        stack.offerLast(p.right);\n                    }\n                } else if (p.left == pre) {\n                    if (p.right != null) {\n                        stack.offerLast(p.right);\n                    }\n                } else {\n                    postorder.add(p.val);\n                    stack.removeLast();\n                }\n                pre = p;\n            }\n            return postorder;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public int[] searchRange(int[] A, int target) {\n        int[] res = new int[]{-1,-1};\n        int lower = getLowerBound(A, target);\n        int upper = getUpperBound(A, target);\n        if (lower <= upper) {\n            res[0] = lower;\n            res[1] = upper;\n        }\n        return res;\n    }\n    public int getLowerBound(int[] A, int target) {\n        int l = 0, r = A.length - 1;\n        while (l <= r) {\n            int mid = (l+r) / 2;\n            if (A[mid] < target) l = mid + 1;\n            else r = mid - 1;\n        }\n        return l;\n    }\n    public int getUpperBound(int[] A, int target) {\n        int l = 0, r = A.length - 1;\n        while (l <= r) {\n            int mid = (l+r) / 2;\n            if (A[mid] <= target) l = mid + 1;\n            else r = mid - 1;\n        }\n        return r;\n    }\n}\n", "nl": "leetcoders"}
{"code": "public class MergekSortedLists {\n\n    public class Solution {\n        public ListNode mergeKLists(ArrayList<ListNode> lists) {\n            PriorityQueue<ListNode> heap = new PriorityQueue<ListNode>(10,\n                    new Comparator<ListNode>() {\n\n                        @Override\n                        public int compare(ListNode l1, ListNode l2) {\n                            return l1.val - l2.val;\n                        }\n                    });\n            for (ListNode node : lists) {\n                if (node != null) {\n                    heap.add(node);\n                }\n            }\n            ListNode head = null;\n            ListNode pre = null;\n            while (!heap.isEmpty()) {\n                ListNode top = heap.poll();\n                if (head == null) {\n                    head = top;\n                } else {\n                    pre.next = top;\n                }\n                pre = top;\n                if (top.next != null) {\n                    heap.add(top.next);\n                }\n            }\n            return head;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class L257_Binary_Tree_Paths {\n\n\tList<String> rt = new ArrayList<String>();\n\tList<Integer> path = new ArrayList<Integer>();\n\n\tpublic List<String> binaryTreePaths(TreeNode root) {\n\t\tfindPath(root);\n\t\treturn rt;\n\t}\n\n\tvoid findPath(TreeNode root) {\n\t\t\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tpath.add(root.val);\n\n\t\tif (root.left == null && root.right == null) {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(path.get(0));\n\t\t\tfor (int i = 1; i < path.size(); i++) {\n\t\t\t\tsb.append(\"->\" + path.get(i));\n\t\t\t}\n\t\t\trt.add(sb.toString());\n\t\t}\n\n\t\tfindPath(root.left);\n\t\tfindPath(root.right);\n\t\t\n\t\tpath.remove(path.size() - 1);\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class CloneGraph {\n  public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n    if (node == null) return node;\n    Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n    queue.add(node);\n    Set<UndirectedGraphNode> visited = new HashSet<UndirectedGraphNode>();\n    Map<UndirectedGraphNode, UndirectedGraphNode> map =\n        new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n    while (!queue.isEmpty()) {\n      UndirectedGraphNode n = queue.remove();\n      if (visited.contains(n)) continue;\n      visited.add(n);\n      UndirectedGraphNode clone;\n      if (!map.containsKey(n)) {\n        clone = new UndirectedGraphNode(n.label);\n        map.put(n, clone);\n      } else {\n        clone = map.get(n);\n      }\n      for (UndirectedGraphNode child : n.neighbors) {\n        queue.add(child);\n        UndirectedGraphNode cloneChild;\n        if (!map.containsKey(child)) {\n          cloneChild = new UndirectedGraphNode(child.label);\n          map.put(child, cloneChild);\n        } else {\n          cloneChild = map.get(child);\n        }\n        clone.neighbors.add(cloneChild);\n      }\n    }\n    return map.get(node);\n  }\n}\n", "nl": "mengli"}
{"code": "public class MaximalRectangle {\n\n    public class Solution {\n        private int largestRectangleArea(int[] height) {\n            ArrayDeque<Integer> p = new ArrayDeque<Integer>();\n            int i = 0;\n            int maxArea = 0;\n            while (i < height.length) {\n                if (p.isEmpty() || height[p.peekLast()] <= height[i]) {\n                    p.offerLast(i++);\n                } else {\n                    int pos = p.removeLast();\n                    maxArea = Math.max(maxArea, height[pos]\n                            * (p.isEmpty() ? i : (i - p.peekLast() - 1)));\n                }\n            }\n            return maxArea;\n        }\n\n        public int maximalRectangle(char[][] matrix) {\n            if (matrix.length == 0 || matrix[0].length == 0) {\n                return 0;\n            }\n            int m = matrix.length;\n            int n = matrix[0].length;\n            int[] height = new int[n + 1];\n            int maxArea = 0;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (matrix[i][j] == '1') {\n                        height[j]++;\n                    } else {\n                        height[j] = 0;\n                    }\n                }\n                maxArea = Math.max(maxArea, largestRectangleArea(height));\n            }\n            return maxArea;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k <= 0) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n\n        ListNode node = head;\n        int n = 1;\n        while (node.next != null) {\n            n++;\n            node = node.next;\n        }\n        ListNode endNode = node; // node.next == null\n\n        k = k % n;\n        int step = n - k - 1;\n        ListNode newTail = head; // newTail.next will be the newHead\n        while (step > 0) {\n            newTail = newTail.next;\n            step--;\n        }\n        \n        endNode.next = dummy.next; // link endNode -> original head\n        dummy.next = newTail.next; // update dummy.next = newHead, which is just newTail.next\n        newTail.next = null; // cut tail.next\n\n        return dummy.next;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int climbStairs(int n) {\n        if(n==0)\n            return 0;\n        else{\n            HashMap<Integer,Integer> cache = new HashMap<Integer,Integer>();\n            return climbStairs(0,n,cache);\n        }\n    }\n    \n    public int climbStairs(int level,int n,HashMap<Integer,Integer> cache){\n        if(level> n)\n            return 0;\n        else if(level==n)\n            return 1;\n        else {\n            int count1=0;\n            int count2=0;\n            if(cache.containsKey(level+1))\n                count1 = cache.get(level+1);\n            else{\n                count1 = climbStairs(level+1,n,cache);\n                cache.put(level+1,count1);\n            }\n            if(cache.containsKey(level+2))\n                count2 = cache.get(level+2);\n            else{\n                count2 = climbStairs(level+2,n,cache);\n                cache.put(level+2,count2);\n            }\n            \n            return count1+count2;\n        }\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class ValidPalindrome {\n\n    public class Solution {\n        public boolean isPalindrome(String s) {\n            assert s != null;\n            int start = 0;\n            int end = s.length() - 1;\n            while (start < end) {\n                if (!Character.isLetterOrDigit(s.charAt(start))) {\n                    start++;\n                } else if (!Character.isLetterOrDigit(s.charAt(end))) {\n                    end--;\n                } else if (Character.toLowerCase(s.charAt(start)) != Character\n                        .toLowerCase(s.charAt(end))) {\n                    return false;\n                } else {\n                    start++;\n                    end--;\n                }\n            }\n            return true;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class JumpGame {\n  public boolean canJump(int[] A) {\n    if (A.length <= 1) return true;\n    int curMax = 0;\n    int max = 0;\n    for (int i = 0; i < A.length - 1; i++) {\n      if (i > max) break;\n      curMax = A[i] + i;\n      if (curMax > max) {\n        max = curMax;\n      }\n      if (max >= A.length - 1) return true;\n    }\n    return false;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    \n    public int searchInsert(int[] A, int target) {\n        if (A == null || A.length == 0) {//Insert at 0 position\n            return 0;\n        }\n        int start = 0;\n        int end = A.length - 1;\n        int mid = start + (end - start)/2;\n\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            if (A[mid] == target) {\n                return mid;\n            } else if (A[mid] > target) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        \n        if (A[start] >= target) {\n            return start;\n        } else if (A[start] < target && target <= A[end]) {\n            return end;\n        } else {\n            return end + 1;\n        }\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    \n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if (inorder.length != postorder.length) {\n            return null;\n        }\n        return buildTreeHelper(inorder, 0, inorder.length - 1, \n                                postorder, 0, postorder.length - 1);\n    }\n    \n    public TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd, \n                            int[] postorder, int postStart, int postEnd){\n        if (inStart > inEnd) {\n            return null;\n        }\n        TreeNode root = new TreeNode(postorder[postEnd]);\n        int mid = findMid(inorder, inStart, inEnd, postorder[postEnd]);\n        root.left = buildTreeHelper(inorder, inStart, mid - 1, \n                    postorder, postStart, postStart + (mid - inStart) - 1);\n        root.right = buildTreeHelper(inorder, mid + 1, inEnd,\n                    postorder, postStart + (mid - inStart), postEnd - 1);\n        return root;\n    }\n    \n    public int findMid(int[] arr, int start, int end, int key) {\n        for (int i = start; i <= end; i++) {\n            if (arr[i] == key) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    \n    public ArrayList<Integer> postorderTraversal(TreeNode root) {\n        ArrayList<Integer> rst = new ArrayList<Integer>();\n        if (root == null) {\n            return rst;\n        }\n        ArrayList<Integer> right = postorderTraversal(root.right);\n        ArrayList<Integer> left = postorderTraversal(root.left);\n        rst.addAll(left);\n        rst.addAll(right);\n        rst.add(root.val);  \n        return rst;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class Searcha2DMatrix {\n  public boolean searchMatrix(int[][] matrix, int target) {\n    int length = matrix.length;\n    if (length == 0) return false;\n    int width = matrix[0].length;\n    int low = 0;\n    int high = width * length - 1;\n    while (low <= high) {\n      int mid = (low + high) / 2;\n      int x = mid / width;\n      int y = mid % width;\n      if (matrix[x][y] == target) return true;\n      else if (matrix[x][y] > target) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return false;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n\tHashMap<Integer, List<Integer>> map;\n\tint[] visited;\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if (numCourses <= 0 || prerequisites == null || prerequisites.length == 0 ||\n        \tprerequisites[0] == null || prerequisites[0].length == 0) {\n        \treturn true;\n        }\n        visited = new int[numCourses];\n        map = new HashMap<Integer, List<Integer>>();\n        for (int i = 0; i < prerequisites.length; i++) {\n        \tif (!map.containsKey(prerequisites[i][1])) {\n        \t\tmap.put(prerequisites[i][1], new ArrayList<Integer>());\n        \t}\n        \tmap.get(prerequisites[i][1]).add(prerequisites[i][0]);\n        }\n        for (int i = 0; i < prerequisites.length; i++) {\n        \tif (!dfs(prerequisites[i][0])) {\n        \t\treturn false;\n        \t}\n        }\n\n        return true;\n    }\n\n    public boolean dfs (int node) {\n    \tif (visited[node] == 1) {//has been through this path, true.\n    \t\treturn true;\n    \t}\n    \tif (visited[node] == -1) {//visiting a visited node from a deper level node, cycle\n    \t\treturn false;\n    \t}\n    \tvisited[node] = -1;\n\n    \tif (map.containsKey(node)) {\n    \t\tfor (int nextNode : map.get(node)) {\n    \t\t\tif (!dfs(nextNode)) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \tvisited[node] = 1;\n    \treturn true;\n    }\n\n}\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class PathSum3 {\n\tboolean hasPathSum(TreeNode root, int sum) {\n\t\treturn hasPathSum(root, 0, sum);\n\t}\n\n\tboolean hasPathSum(TreeNode root, int sum, int target) {\n\t\tif (root == null)\n\t\t\treturn false;\n\t\tsum += root.val;\n\t\tif (root.left == null && root.right == null) {\n\t\t\tif (sum == target)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\treturn hasPathSum(root.left, sum, target) || hasPathSum(root.right, sum, target);\n\t}\n\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public List<List<Integer>> combinationSum2(int[] num, int target) {\n        List<List<Integer>> rst = new ArrayList<List<Integer>>();\n        List<Integer> list = new ArrayList<Integer>();\n        if (num == null || num.length == 0 || target < 0) {\n            return rst;\n        }\n        Arrays.sort(num);\n        helper(rst, list, num, target, 0, 0);\n        return rst;\n    }\n    public void helper(List<List<Integer>> rst, List<Integer> list,\n                int[] num, int target, int sum, int start) {\n        if (sum == target) {\n            rst.add(new ArrayList(list));\n            return;\n        } else if (sum > target) {//Stop if greater than target\n            return;\n        }\n        int prev = -1;//Repeat detection\n        for (int i = start; i < num.length; i++) {\n            if (prev != -1 && prev == num[i]) {\n                continue;\n            }\n            list.add(num[i]);\n            sum += num[i];\n            helper(rst, list, num, target, sum, i + 1);\n            sum -= num[i];\n            list.remove(list.size() - 1);\n            prev = num[i];\n        }\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "public class CountandSay {\n\n    public class Solution {\n        public String countAndSay(int n) {\n            String ans = \"1\";\n            n--;\n            while (n > 0) {\n                n--;\n                StringBuilder builder = new StringBuilder();\n                int count = 1;\n                for (int i = 1; i < ans.length(); i++) {\n                    if (ans.charAt(i - 1) == ans.charAt(i)) {\n                        count++;\n                    } else {\n                        builder.append(count);\n                        builder.append(ans.charAt(i - 1));\n                        count = 1;\n                    }\n                }\n                builder.append(count);\n                builder.append(ans.charAt(ans.length() - 1));\n                ans = builder.toString();\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return f(head,null);\n    }\n    public TreeNode f(ListNode head,ListNode end) {\n        if (head==end) {\n            return null;\n        }\n        ListNode fast=head;\n        ListNode slow=head;\n        while (fast.next!=end&&fast.next.next!=end) {\n            fast=fast.next.next;\n            slow=slow.next;\n        }\n        TreeNode node=new TreeNode(slow.val);\n        node.right=f(slow.next,end);\n        node.left=f(head,slow);\n        return node;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class _39_combinationSum {\n\n    public static void main(String[] args) {\n        _39_combinationSum combinationSum = new _39_combinationSum();\n        List<List<Integer>> lists = combinationSum.combinationSum(new int[]{2, 3, 5}, 8);\n        for (int i = 0; i < lists.size(); i++) {\n            Util.printList(lists.get(i));\n        }\n    }\n\n    \n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> retList = new ArrayList<>();\n        Arrays.sort(candidates);\n        combinationSum(candidates, target, 0, retList, new ArrayList<>(), 0);\n\n        return retList;\n    }\n\n    private void combinationSum(int[] candidates,\n                                int target,\n                                int index,\n                                List<List<Integer>> retList,\n                                List<Integer> addList,\n                                int addSum) {\n        if (index >= candidates.length) return;\n        int n = (target - addSum) / candidates[index];\n        if (n == 0) return;\n        for (int i = 0; i <= n; i++) {\n            addList.add(candidates[index]);\n        }\n        int nSum = (n+1) * candidates[index];\n        for (int i = n; i >= 0; i--) {\n            nSum -= candidates[index];\n            addList.remove(addList.size() - 1);\n            if (nSum + addSum == target) {\n                retList.add(new ArrayList<>(addList));\n            } else if (nSum + addSum > target) {\n            } else {\n                combinationSum(candidates, target, index + 1, retList, addList, addSum + nSum);\n            }\n        }\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class TwoSum3DataStructureDesign {\n\n  public class TwoSum {\n\n    List<Integer> nums = new ArrayList<>();\n    Map<Integer, Integer> count = new HashMap<>(); // Map iterator is slow.\n\n    public void add(int number) {\n      if (!count.containsKey(number)) {\n        count.put(number, 0);\n        nums.add(number);\n      }\n      count.put(number, count.get(number) + 1);\n    }\n\n    public boolean find(int value) {\n      for (int num1 : nums) {\n        int num2 = value - num1;\n        if (!count.containsKey(num2)) {\n          continue;\n        }\n        if (num1 != num2 && count.get(num2) > 0) {\n          return true;\n        }\n        if (num1 == num2 && count.get(num2) >= 2) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class MaximumDepthofBinaryTree3 {\n    public static int maxDepth(TreeNode root) {\n        int curDep = 1;\n        int res[] = new int[1];\n        helper(root, curDep, res);\n        return res[0];\n    }\n\n    private static void helper(TreeNode root, int curDep, int[] res) {\n        if (root == null) {\n            res[0] = res[0] > curDep ? res[0] : curDep;\n            return;\n        }\n        helper(root.left, curDep + 1, res);\n        helper(root.right, curDep + 1, res);\n    }\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> rst = new ArrayList<>();\n        if (root == null) {\n            return rst;\n        }\n        rst.add(root.val);\n        rst.addAll(preorderTraversal(root.left));\n        rst.addAll(preorderTraversal(root.right));\n        return rst;\n    }\n}", "nl": "awangdev"}
{"code": "public class GenerateParentheses3 {\n\tpublic List<String> generateParenthesis(int n) {\n\t\treturn generateParenthesis(n, n, n);\n\t}\n\n\tpublic List<String> generateParenthesis(int left, int right, int n) {\n\t\tList<String> prev = new ArrayList<String>();\n\t\tList<String> result = new ArrayList<String>();\n\t\tif (left == 0 && right == 0)\n\t\t\tresult.add(\"\");\n\t\tif (left > 0) {\n\t\t\tprev = generateParenthesis(left - 1, right, n);\n\t\t\tfor (String s : prev) {\n\t\t\t\ts = \"(\" + s;\n\t\t\t\tresult.add(s);\n\t\t\t}\n\t\t}\n\t\tif (right > left) {\n\t\t\tprev = generateParenthesis(left, right - 1, n);\n\t\t\tfor (String s : prev) {\n\t\t\t\ts = \")\" + s;\n\t\t\t\tresult.add(s);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MinimumPathSum {\n\tpublic int minPathSum(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\n\t\tint[][] paths = new int[m][n];\n\n\t\tpaths[0][0] = grid[0][0];\n\n\t\tfor (int i = 1; i < m; ++i) {\n\t\t\tpaths[i][0] = paths[i - 1][0] + grid[i][0];\n\t\t}\n\n\t\tfor (int j = 1; j < n; ++j) {\n\t\t\tpaths[0][j] = paths[0][j - 1] + grid[0][j];\n\t\t}\n\n\t\tfor (int i = 1; i < m; ++i)\n\t\t\tfor (int j = 1; j < n; ++j) {\n\t\t\t\tpaths[i][j] = Math.min(paths[i - 1][j], paths[i][j - 1])\n\t\t\t\t\t\t\t+ grid[i][j];\n\t\t\t}\n\n\t\treturn paths[m - 1][n - 1];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMinimumPathSum slt = new MinimumPathSum();\n\t\tint[][] grid = new int[][] {{1, 2, 3}, {4, 5, 6}};\n\t\tint result = slt.minPathSum(grid);\n\t\tSystem.out.println(result);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class _148_sortList {\n    public static void main(String[] args) {\n        Util.printListNode(sortList(Util.generateListNodeBySize(2)));\n    }\n\n    public static ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = slow;\n        while (slow != null && fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        ListNode left = sortList(head);\n        ListNode right = sortList(slow);\n        return merge(left, right);\n    }\n\n    private static ListNode merge(ListNode left, ListNode right) {\n        ListNode dummy = new ListNode(0);\n        ListNode next = dummy;\n        while (left != null && right != null) {\n            if (left.val < right.val) {\n                next.next = left;\n                left = left.next;\n            } else {\n                next.next = right;\n                right = right.next;\n            }\n            next = next.next;\n        }\n        if (left != null) {\n            next.next = left;\n        }\n        if (right != null) {\n            next.next = right;\n        }\n        return dummy.next;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Solution {\n    public boolean canJump(int[] nums) {\n        if (nums == null || nums.length <= 1) {\n            return true;\n        }\n        int farest = 0;\n        for (int i = 0; i < nums.length; i++) {\n            farest = Math.max(farest, nums[i] + i);\n            if (farest >= nums.length - 1) {\n                return true;\n            }\n            if (farest <= i) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class MergeIntervals\n{\n    public List<Interval> merge( List<Interval> intervals )\n    {\n    \tif ( intervals == null || intervals.size() == 0 )\n    \t{\n    \t\treturn intervals;\n    \t}\n\n    \tList<Interval> result = new ArrayList<>();\n    \tCollections.sort( intervals, ( o1, o2 ) -> ( o1.start - o2.start ) );\n    \t\n    \tIterator<Interval> iterator = intervals.iterator();\n    \tInterval curr = iterator.next();\n    \twhile ( iterator.hasNext() )\n    \t{\n    \t\tInterval next = iterator.next();\n    \t\tif ( isOverlap( curr, next ) )\n    \t\t{\n    \t\t\tcurr = new Interval( Math.min( curr.start, next.start ), Math.max( curr.end, next.end ));\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tresult.add( curr );\n    \t\t\tcurr = next;\n    \t\t}\n    \t}    \t\n    \t\n    \tresult.add( curr );\n    \treturn result;\n    }\n    \n    private boolean isOverlap( Interval o1, Interval o2 )\n    {\n    \tif ( o1.start > o2.end || o2.start > o1.end )\n    \t{\n    \t\treturn false;\n    \t}\n    \telse\n    \t{\n    \t\treturn true;\n    \t}\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int trap_1(int[] A) {\n        int n = A.length;\n        if (n == 0) return 0;\n        int[] maxLeft = new int[n];\n        int[] maxRight = new int[n];\n        maxLeft[0] = A[0];\n        maxRight[n - 1] = A[n - 1];\n        for (int i = 1; i < n; ++i) {\n            maxLeft[i] = Math.max(maxLeft[i - 1], A[i]);\n            maxRight[n - 1 - i] = Math.max(maxRight[n - i], A[n - 1 - i]);\n        }\n        \n        int res = 0;\n        for (int i = 1; i < n; ++i) {\n            res += Math.min(maxLeft[i], maxRight[i]) - A[i];\n        }\n        return res;\n    }\n    public int trap(int[] A) {\n        int n = A.length, res = 0;\n        if (n <= 2) return 0;\n        int maxLeft = A[0];\n        int maxRight = A[n - 1];\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            if (maxLeft <= maxRight) {\n                res += Math.max(0, maxLeft - A[left]);\n                maxLeft = Math.max(maxLeft, A[left]);\n                ++left;\n            } else {\n                res += Math.max(0, maxRight - A[right]);\n                maxRight = Math.max(maxRight, A[right]);\n                --right;\n            }\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int searchInsert(int[] A, int target) {\n        int lo = 0, hi = A.length-1, mid = hi/2;\n\n        while(lo<=hi){\n            mid = (lo+hi)/2;\n            if(target == A[mid])\n                return mid;\n            else if(target > A[mid])\n                lo = mid+1;\n            else\n                hi = mid-1;         \n        }\n        return lo;\n\n    }\n}\n\n\n", "nl": "azheanda"}
{"code": "public class Solution {\n    \n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int start = 0;\n        int end = row * col - 1;\n        int mid;\n\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            int num = matrix[mid/col][mid%col];\n            if (target == num) {\n                return true;\n            } else if (num < target) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n\n        return (matrix[start/col][start%col] == target || matrix[end/col][end%col] == target);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class ValidateBinarySearchTree {\n  public boolean isValidBST(TreeNode root) {\n    if (root == null) return true;\n    return validate(root.left, Integer.MIN_VALUE, root.val)\n        && validate(root.right, root.val, Integer.MAX_VALUE);\n  }\n\n  private boolean validate(TreeNode root, int min, int max) {\n    if (root == null) return true;\n    if (root.val > min && root.val < max) {\n      return validate(root.left, min, root.val) && validate(root.right, root.val, max);\n    } else {\n      return false;\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1);\n        while (head != null) {\n            ListNode temp = head.next;\n            head.next = dummy.next;\n            dummy.next = head;\n            head = temp;\n        }\n        return dummy.next;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        Queue<TreeNode> tree1 = new LinkedList<TreeNode>();\n\t\tQueue<TreeNode> tree2 = new LinkedList<TreeNode>();\n\t\ttree1.offer(p);\n\t\ttree2.offer(q);\n\n\t\twhile(tree1.peek()!=null || tree2.peek()!=null){\n\t\t\tTreeNode t1 = tree1.poll();\n\t\t\tTreeNode t2 = tree2.poll();\n\t\t\tif(t1!=null && t2!=null && t1.val == t2.val && ((t1.left==null)==(t2.left==null)) &&((t1.right==null)==(t2.right==null))) {\n\t\t\t\tif(t1.left!=null){\n\t\t\t\t\ttree1.offer(t1.left);\n\t\t\t\t\ttree2.offer(t2.left);\n\t\t\t\t}\n\t\t\t\tif(t1.right!=null){\n\t\t\t\t\ttree1.offer(t1.right);\n\t\t\t\t\ttree2.offer(t2.right);\n\t\t\t\t}\n\t\t\t}else\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n    }\n}", "nl": "azheanda"}
{"code": "public class MedianOfTwoSortedArrays\n{\n\n\tpublic double findMedianSortedArrays( int[] nums1, int[] nums2 )\n\t{\n\t\tint total = nums1.length + nums2.length;\n\t\tif ( total % 2 == 0 )\n\t\t{\n\t\t\treturn ( findKth( total / 2 + 1, nums1, nums2, 0, 0 ) + findKth( total / 2, nums1, nums2, 0, 0 ) ) / 2.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn findKth( total / 2 + 1, nums1, nums2, 0, 0 );\n\t\t}\n\t}\n\n\tpublic int findKth( int k, int[] nums1, int[] nums2, int s1, int s2 )\n\t{\n\t\tif ( s1 >= nums1.length )\n\t\t\treturn nums2[s2 + k - 1];\n\n\t\tif ( s2 >= nums2.length )\n\t\t\treturn nums1[s1 + k - 1];\n\n\t\tif ( k == 1 )\n\t\t\treturn Math.min( nums1[s1], nums2[s2] );\n\n\t\tint m1 = s1 + k / 2 - 1;\n\t\tint m2 = s2 + k / 2 - 1;\n\n\t\tint mid1 = m1 < nums1.length ? nums1[m1] : Integer.MAX_VALUE;\n\t\tint mid2 = m2 < nums2.length ? nums2[m2] : Integer.MAX_VALUE;\n\n\t\tif ( mid1 < mid2 )\n\t\t{\n\t\t\treturn findKth( k - k / 2, nums1, nums2, m1 + 1, s2 );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn findKth( k - k / 2, nums1, nums2, s1, m2 + 1 );\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void test()\n\t{\n\t\tassertEquals( 2.0, findMedianSortedArrays( new int[]{1, 3}, new int[]{2} ));\n\t\tassertEquals( 2.5, findMedianSortedArrays( new int[]{1, 2}, new int[]{3, 4} ));\n\t}\n}\n", "nl": "FreemanZhang"}
{"code": "class LinkedListCycle2 {\n    public static void main(String[] args) {\n\n    }\n\n    \n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        boolean hasCycle = false;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                hasCycle = true;\n                break;\n            }\n        }\n        if (!hasCycle) return null;\n        slow = head;\n        while (slow != fast) { // move x steps further\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n    class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) {\n            val = x;\n            next = null;\n        }\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class NextPermutation {\n\tpublic void nextPermutation(int[] num) {\n\t\tif (num.length <= 1)\n\t\t\treturn;\n\t\tfor (int i = num.length - 2; i >= 0; i--) {\n\t\t\tif (num[i] < num[i + 1]) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = num.length - 1; j >= i; j--)\n\t\t\t\t\tif (num[i] < num[j])\n\t\t\t\t\t\tbreak;\n\t\t\t\tswap(num, i, j);\n\t\t\t\tArrays.sort(num, i + 1, num.length);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < num.length / 2; i++) {\n\t\t\tswap(num, i, num.length-1-i);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tprivate static void swap(int[] num, int i, int j) {\n\t\tint temp = num[i];\n\t\tnum[i] = num[j];\n\t\tnum[j] = temp;\t\t\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class SwapNodesinPairs {\n  public ListNode swapPairs(ListNode head) {\n    if (head == null) return null;\n    else if (head.next == null) {\n      return head;\n    } else {\n      ListNode nextList = swapPairs(head.next.next);\n      ListNode tmp = head.next;\n      head.next = nextList;\n      tmp.next = head;\n      return tmp;\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public boolean exist(char[][] board, String word) {\n    \tif (word == null || word.length() == 0) {\n    \t\treturn true;\n    \t}\n    \tif (board == null) {\n    \t\treturn false;\n    \t}\n    \t\n    \tfor (int i = 0; i < board.length; i++) {\n    \t\tfor (int j = 0; j < board[0].length; j++) {\n    \t\t\tif (board[i][j] == word.charAt(0)) {\n    \t\t\t\tboolean rst = search(board, word, i, j, 0);\n    \t\t\t\tif (rst) {\n    \t\t\t\t\treturn true;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn false;\n    }\n\n    public boolean search(char[][] board, String word, int i, int j, int start) {\n    \tif (start == word.length()) {\n    \t\treturn true;\n    \t}\n    \tif (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(start)) {\n    \t\treturn false;\n    \t}\n    \tboard[i][j] = '#';\n    \tboolean rst = search(board, word, i, j - 1, start + 1)\n    \t|| search(board, word, i, j + 1, start + 1)\n    \t|| search(board, word, i + 1, j, start + 1)\n     \t|| search(board, word, i - 1, j, start + 1);   \n     \tboard[i][j] = word.charAt(start);\n    \treturn rst;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return head;\n        int n = 1;\n        ListNode tail = head, cur = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            ++n;\n        }\n        k = k % n;\n        if (k == 0) return head;\n        for (int i = 0; i < n - k - 1; ++i) \n            cur = cur.next;\n        ListNode newHead = cur.next;\n        tail.next = head;\n        cur.next = null;\n        return newHead;\n    }\n}", "nl": "leetcoders"}
{"code": "public class BinaryTreePreorderTraversal3 {\n\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tTreeNode node = root;\n\t\twhile (!stack.isEmpty() || node != null) {\n\t\t\twhile (node != null) {\n\t\t\t\tlist.add(node.val);\n\t\t\t\tstack.push(node);\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t\tnode = stack.pop();\n\t\t\tnode = node.right;\n\t\t}\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int[] nextPermutation(int[] nums) {\n        if (nums == null || nums.length == 0) return nums;\n        \n        int k = -1;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            if (nums[i] < nums[i + 1]) {\n                k = i;\n                break;\n            }\n        }\n        if (k == -1) {\n            return reverse(0, nums.length - 1, nums);\n        }\n        int bigIndex = -1;\n        for (int i = nums.length - 1; i >= 0; i--) {\n            if (nums[i] > nums[k]) {\n                bigIndex = i;\n                break;\n            }\n        }\n        swap(nums, k, bigIndex);\n\n        return reverse(k + 1, nums.length - 1, nums);\n    }\n\n    private void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n\n    private int[] reverse(int start, int end, int[] nums) {\n        for (int i = start, j = end; i < j; i++,j--) {\n            swap(nums, i, j);\n        }\n        return nums;\n    }\n}\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class ReverseWordsinaString {\n\n    public class Solution {\n        public String reverseWords(String s) {\n            String[] tokens = s.split(\" +\");\n            StringBuilder r = new StringBuilder();\n            boolean isFirst = true;\n            for (int i = tokens.length - 1; i >= 0; i--) {\n                String token = tokens[i];\n                if (token.isEmpty()) {\n                    continue;\n                }\n                if (isFirst) {\n                    isFirst = false;\n                } else {\n                    r.append(' ');\n                }\n                r.append(token);\n            }\n            return r.toString();\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class AddTwoNumbers\n{\n    public ListNode addTwoNumbers( ListNode l1, ListNode l2 ) \n    {\n        ListNode resultHead = new ListNode( 0 );\n        ListNode resultTail = resultHead;\n        int carry = 0;\n        \n        while ( l1 != null || l2 != null )\n        {\n        \tif ( l1 != null )\n        \t{\n        \t\tcarry += l1.val;\n        \t\tl1 = l1.next;\n        \t}\n        \tif ( l2 != null )\n        \t{\n        \t\tcarry += l2.val;\n        \t\tl2 = l2.next;\n        \t}\n        \t\n        \tListNode newNode = new ListNode( carry % 10 );\n        \tresultTail.next = newNode;        \t\n        \tresultTail = newNode;\n        \t\n        \tcarry = carry / 10;\n        }\n        \n        if ( carry == 1 )\n        {\n        \tresultTail.next = new ListNode( 1 );\n        }\n        \n        return resultHead.next;\n    }\n    \n    \n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newList = null;\n\n        while (head != null) {\n            ListNode temp = head.next;\n            head.next = newList;\n            newList = head;\n            head = temp;\n        }\n        return newList;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class JumpGame2 {\n\tpublic boolean canJump(int[] nums) {\n\t\tint reachable = 0;\n\t\tfor (int i=0; i<nums.length; ++i) {\n\t\t\tif (i > reachable) return false;\n\t\t\treachable = Math.max(reachable, i + nums[i]);\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class InsertionSortList {\n\tpublic ListNode insertionSortList(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn null;\n\t\tListNode helper = new ListNode(0);\n\t\tListNode pre = helper;\n\t\tListNode cur = head;\n\t\twhile (cur != null) {\n\t\t\tpre = helper;\n\t\t\twhile (pre.next != null && pre.next.val <= cur.val) {\n\t\t\t\tpre = pre.next;\n\t\t\t}\n\t\t\t\n\t\t\tListNode next = cur.next;\n\t\t\tcur.next = pre.next;\n\t\t\tpre.next = cur;\n\t\t\tcur = next;\n\t\t}\n\t\treturn helper.next;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Combinations {\n\tpublic ArrayList<ArrayList<Integer>> combine(int n, int k) {\n\t\tArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tcombinehelper(n, 1, k, list, res);\n\t\treturn res;\n\t}\n\n\tpublic void combinehelper(int n, int start, int k, ArrayList<Integer> list, ArrayList<ArrayList<Integer>> res) {\n\t\tif (list.size() == k) {\n\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = start; i <= n; i++) {\n\t\t\tlist.add(i);\n\t\t\tcombinehelper(n, i + 1, k, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public List<Interval> insert_1(List<Interval> intervals, Interval newInterval) {\n        List<Interval> res = new ArrayList<Interval>();\n        boolean inserted = false;\n        for (Interval it : intervals) {\n            if (inserted || it.end < newInterval.start) {\n                res.add(it);\n            } else if (it.start > newInterval.end) {\n                res.add(newInterval);\n                res.add(it);\n                inserted = true;\n            } else {\n                newInterval.start = Math.min(newInterval.start, it.start);\n                newInterval.end = Math.max(newInterval.end, it.end);\n            }\n        }\n        if (inserted == false) res.add(newInterval);\n        return res;\n    }\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        List<Interval> res = new ArrayList<Interval>();\n        int n = intervals.size();\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (intervals.get(mid).start > newInterval.start) right = mid - 1;\n            else left = mid + 1;\n        }\n        int idxStart = right;\n        left = 0; right = n - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (intervals.get(mid).end < newInterval.end) left = mid + 1;\n            else right = mid - 1;\n        }\n        int idxEnd = left;\n        if (idxStart >= 0 && newInterval.start <= intervals.get(idxStart).end) {\n            newInterval.start = intervals.get(idxStart--).start;\n        }\n        if (idxEnd < n && newInterval.end >= intervals.get(idxEnd).start) {\n            newInterval.end = intervals.get(idxEnd++).end;\n        }\n        for (int i = 0; i <= idxStart; ++i) {\n            res.add(intervals.get(i));\n        }\n        res.add(newInterval);\n        for (int i = idxEnd; i < n; ++i) {\n            res.add(intervals.get(i));\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class MajorityElement2 {\n\n  public List<Integer> majorityElement(int[] nums) {\n    if (nums == null || nums.length == 0) {\n      return Collections.EMPTY_LIST;\n    }\n    int num1 = 0;\n    int count1 = 0;\n    int num2 = 0;\n    int count2 = 0;\n    List<Integer> res = new ArrayList<>();\n    for (int n : nums) {\n      if (n == num1) {\n        count1++;\n      } else if (n == num2) {\n        count2++;\n      } else if (count1 == 0) {\n        num1 = n;\n        count1 = 1;\n      } else if (count2 == 0) {\n        num2 = n;\n        count2 = 1;\n      } else {\n        count1--;\n        count2--;\n      }\n    }\n    count1 = 0;\n    count2 = 0;\n    for (int n : nums) {\n      if (n == num1) {\n        count1++;\n      } else if (n == num2) {\n        count2++;\n      }\n    }\n    if (count1 > nums.length / 3) {\n      res.add(num1);\n    }\n    if (count2 > nums.length / 3) {\n      res.add(num2);\n    }\n    return res;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class LengthOfLastWord {\n\n  public int lengthOfLastWord(String s) {\n    s = s.trim();\n    char space = ' ';\n    if (s.indexOf(space) == -1) return s.length(); // No space\n    int len = s.length();\n    for (int i = len - 1; i >= 0; i--) {\n      if (s.charAt(i) == ' ' && i != len - 1) {\n        return len - 1 - i;\n      }\n    }\n    return 0;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int level = matrix.length-1;\n        for(int i=0;i<matrix.length;i++){\n    \t\tif(target<matrix[i][0]){\n    \t\t\tlevel = i-1; \n    \t\t\tbreak;\n    \t\t}\n        }\n\n    \tif(level>=0)\n    \t\treturn Arrays.binarySearch(matrix[level],target)<0?false:true;\n    \telse \n    \t\treturn false;\n    }\n\n}", "nl": "azheanda"}
{"code": "public class PathSum2 {\n\tpublic boolean hasPathSum(TreeNode root, int sum) {\n\t\tif (root == null)\n\t\t\treturn false;\n\t\tQueue<TreeNode> nodes = new LinkedList<TreeNode>();\n\t\tQueue<Integer> values = new LinkedList<Integer>();\n\t\t\n\t\tnodes.add(root);\n\t\tvalues.add(root.val);\n\n\t\twhile (!nodes.isEmpty()) {\n\t\t\tTreeNode curr = nodes.poll();\n\t\t\tint sumValue = values.poll();\n\n\t\t\tif (curr.left == null && curr.right == null && sumValue == sum) \n\t\t\t\treturn true;\n\n\t\t\tif (curr.left != null) {\n\t\t\t\tnodes.add(curr.left);\n\t\t\t\tvalues.add(sumValue + curr.left.val);\n\t\t\t}\n\n\t\t\tif (curr.right != null) {\n\t\t\t\tnodes.add(curr.right);\n\t\t\t\tvalues.add(sumValue + curr.right.val);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n    public boolean exist(char[][] board, String word) {\n        if (board == null || board.length == 0 || board[0] == null || board[0].length == 0\n            || word == null || word.length() == 0) {\n            return false;\n        }\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (word.charAt(0) == board[i][j] && dfs(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean dfs(char[][] board, String word, int x, int y, int index) {\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length\n            || board[x][y] != word.charAt(index) || board[x][y] == '#') {\n            return false;\n        }\n        if (index == word.length() - 1) {\n            return true;\n        }\n        board[x][y] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            if (dfs(board, word, x + dx[i], y + dy[i], index + 1)) {\n                return true;\n            }\n        }\n        board[x][y] = word.charAt(index);\n        return false;\n    }\n    \n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle == null || needle.length() == 0) {\n            return 0;\n        } \n        \n        int i = 0;\n        int j = 0;\n        \n        for (i = 0; i < haystack.length() - needle.length() + 1; i++) {\n                for (j = 0; j < needle.length(); j++) {\n                    if (haystack.charAt(i + j) != needle.charAt(j)) {\n                        break;\n                    }\n                }\n                if (j == needle.length()) {\n                    return i;\n                }\n        }\n        return -1;\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public int maxArea(int[] height) {\n        int left=0;\n        int right=height.length-1;\n        int ans=(right-left)*Math.min(height[left], height[right]);\n        while (right>left) {\n            int water=(right-left)*Math.min(height[left], height[right]);\n            if (water>ans) {\n                ans=water;\n            }\n            if (height[left]<height[right]) {\n                left++;\n            }else {\n                right--;\n            }\n        }\n        return ans;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MedianofTwoSortedArrays {\n\tpublic double findMedianSortedArrays(int A[], int B[]) {\n\t\tint Alen = A.length;\n\t\tint Blen = B.length;\n\t\tint mid = (Alen + Blen) / 2;\n\t\tif ((Alen + Blen) % 2 == 0) {\n\t\t\treturn (findKth(A, B, mid - 1, 0, Alen - 1, 0, Blen - 1) + findKth(A, B, mid, 0, Alen - 1, 0, Blen - 1)) / 2;\n\t\t} else {\n\t\t\treturn findKth(A, B, mid, 0, Alen - 1, 0, Blen - 1);\n\t\t}\n\t}\n\tpublic static double findKth(int[] a, int[] b, int k, int astart, int aend, int bstart, int bend) {\n\t\tint alength = aend - astart + 1;\n\t\tint blength = bend - astart + 1;\n\t\tif (alength == 0)\n\t\t\treturn b[bstart + k];\n\t\tif (blength == 0)\n\t\t\treturn a[astart + k];\n\t\tif (k == 0)\n\t\t\treturn a[astart] < b[bstart] ? a[astart] : b[bstart];\n\t\tint amid = alength * k / (alength + blength);\n\t\tint bmid = k - amid-1;\n\t\tamid = amid + astart;\n\t\tbmid = bmid + bstart;\n\t\tif (a[amid] > b[bmid]) {\n\t\t\tk = k - (bmid - bstart + 1);\n\t\t\taend = amid;\n\t\t\tbstart = bmid + 1;\n\t\t} else {\n\t\t\tk = k - (amid - astart + 1);\n\t\t\tbend = bmid;\n\t\t\tastart = amid + 1;\n\t\t}\n\t\treturn findKth(a, b, k, astart, aend, bstart, bend);\n\t}\n}", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int maxSubArray(int[] A) {\n        return maxSubArray(A,0,A.length-1); \n    } \n    \n    public int maxSubArray(int[] A,int l, int r){\n        int leftSum=Integer.MIN_VALUE,rightSum=Integer.MIN_VALUE,sum=0;\n               \n        if(l==r)   //base case\n            return A[l];\n            \n        int mid = (l+r)/2;\n        int maxLeftSum = maxSubArray(A,l,mid);\n        int maxRightSum = maxSubArray(A,mid+1,r);\n        \n        for(int i=mid;i>=l;i--){   // Note:this part is subtle.\n            sum+=A[i];             // The code in the brackets is equivalent to one line of code:\n            if(sum>leftSum)        // leftSum = (sum+=A[i])>leftSum?sum:leftSum; // the parentheses are needed because the operator order of += is lower than ?: \n                leftSum =sum;      \n        }\n        sum=0;\n        for(int i=mid+1;i<=r;i++){\n            sum+=A[i];\n            if(sum>rightSum)\n                rightSum=sum;\n        }\n       \n        return Math.max(Math.max(maxLeftSum,maxRightSum),rightSum+leftSum);\n               \n    }\n\n    \n}", "nl": "azheanda"}
{"code": "public class L015_3Sum {\n\n\tpublic List<List<Integer>> threeSum(int[] nums) {\n\n\t\tif (nums == null || nums.length < 3) {\n\t\t\treturn new ArrayList<List<Integer>>();\n\t\t}\n\n\t\tSet<List<Integer>> set = new HashSet<List<Integer>>();\n\n\t\tArrays.sort(nums);\n\n\t\tfor (int start = 0; start < nums.length; start++) {\n\n\t\t\tif (start != 0 && nums[start - 1] == nums[start]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint mid = start + 1, end = nums.length - 1;\n\n\t\t\twhile (mid < end) {\n\n\t\t\t\tint sum = nums[start] + nums[mid] + nums[end];\n\n\t\t\t\tif (sum == 0) {\n\n\t\t\t\t\tList<Integer> tmp = new ArrayList<Integer>();\n\t\t\t\t\ttmp.add(nums[start]);\n\t\t\t\t\ttmp.add(nums[mid]);\n\t\t\t\t\ttmp.add(nums[end]);\n\t\t\t\t\tset.add(tmp);\n\n\t\t\t\t\twhile (++mid < end && nums[mid - 1] == nums[mid])\n\t\t\t\t\t\t;\n\t\t\t\t\twhile (--end > mid && nums[end + 1] == nums[end])\n\t\t\t\t\t\t;\n\t\t\t\t}\n\n\t\t\t\telse if (sum < 0) {\n\t\t\t\t\tmid++;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tend--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new ArrayList<List<Integer>>(set);\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Combinations {\n\n  \n  public List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> res = new ArrayList<>();\n    backtrack(res, n, k, 1, new ArrayList<>());\n    return res;\n  }\n\n  \n  private void backtrack(List<List<Integer>> res, int n, int k, int start, List<Integer> comb) {\n    if (k == 0) {\n      res.add(new ArrayList<>(comb));\n      return;\n    }\n\n    for (int i = start; i <= n; i++) {\n      comb.add(i);\n      backtrack(res, n, k - 1, i + 1, comb);\n      comb.remove(comb.size() - 1);\n    }\n  }\n\n  \n  public List<List<Integer>> combineB(int n, int k) {\n    List<List<Integer>> res = new ArrayList<>();\n    combineB(n, k, new ArrayList<>(), res);\n    return res;\n  }\n\n  \n  private void combineB(int n, int k, List<Integer> comb, List<List<Integer>> result) {\n    if (k == 0) {\n      result.add(comb);\n      return;\n    }\n    if (n <= k) { // Choose all.\n      for (int i = n; i > 0; i--) {\n        comb.add(i);\n      }\n      result.add(comb);\n      return;\n    }\n    List<Integer> combWithN = new ArrayList<>(comb);\n    combWithN.add(n);\n    combineB(n - 1, k - 1, combWithN, result);\n    combineB(n - 1, k, comb, result);\n  }\n\n  @Test\n  public void testExamples() {\n    List<List<Integer>> lists = combine(4, 2);\n    for (List<Integer> l : lists) {\n      System.out.println(l.toString());\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class WordLadder2 {\n\tpublic int ladderLength(String start, String end, Set<String> dict) {\n\t\tif (start.equals(end))\n\t\t\treturn 0;\n\t\tQueue<String> queue = new LinkedList<String>();\n\t\tqueue.add(start);\n\t\tint level = 0;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tString cur = queue.remove();\n\t\t\t\tif (cur.equals(end)) {\n\t\t\t\t\treturn level + 1;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < cur.length(); j++) {\n\t\t\t\t\tchar[] word = cur.toCharArray();\n\t\t\t\t\tfor (char ch = 'a'; ch < 'z'; ch++) {\n\t\t\t\t\t\tword[j] = ch;\n\t\t\t\t\t\tString check = new String(word);\n\t\t\t\t\t\tif (!check.equals(cur) && dict.contains(check)) {\n\t\t\t\t\t\t\tqueue.add(check);\n\t\t\t\t\t\t\tdict.remove(check);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevel++;\n\t\t}\n\t\treturn 0;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class _32_longestValidParentheses {\n\n    public static void main(String[] args) {\n        _32_longestValidParentheses parentheses = new _32_longestValidParentheses();\n        System.out.println(parentheses.longestValidParentheses(\"(()\"));\n        System.out.println(parentheses.longestValidParentheses(\")()())\"));\n        System.out.println(parentheses.longestValidParentheses(\"()()\"));\n        System.out.println(parentheses.longestValidParentheses2(\")()())()()(\"));\n    }\n\n    \n    public int longestValidParentheses(String s) {\n        int retCount = 0;\n        Stack stack = new Stack();\n        int count;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                stack.push(c);\n            } else {\n                count = 0;\n                boolean isMatch = false;\n                while (!stack.isEmpty()) {\n                    Object peek = stack.peek();\n                    if (peek instanceof Integer) {\n                        count += (Integer) peek;\n                        stack.pop();\n                    } else {\n                        char peekC = (char) peek;\n                        if (peekC == ')' || isMatch) break;\n                        isMatch = true;\n                        count += 2;\n                        stack.pop();\n                    }\n                }\n                retCount = Math.max(retCount, count);\n                stack.push(count);\n                if (!isMatch) {\n                    stack.push(c);\n                }\n            }\n        }\n        return retCount;\n    }\n\n    \n    public int longestValidParentheses2(String s) {\n        if (s == null || s.equals(\"\"))\n            return 0;\n        int maxlen = 0;\n        int[] dp = new int[s.length()];\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) == ')') {\n                if (i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                    dp[i] = dp[i - 1] + 2;\n                }\n                if (i - dp[i] >= 0 && dp[i - dp[i]] > 0) {\n                    dp[i] += dp[i - dp[i]];\n                }\n                maxlen = dp[i] > maxlen ? dp[i] : maxlen;\n            }\n        }\n        return maxlen;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Solution {\n    public double myPow(double x, int n) {\n        if (n==0) {\n            return 1.0;\n        }\n        boolean flag=true;\n        if (n<0) {\n            n=0-n;\n            flag=false;\n        }\n        boolean slag=true;\n        if (x<0) {\n            x=0-x;\n            if (n%2!=0) {\n                slag=false;\n            }\n        }\n        if (x==1.0) {\n            return slag?1.0:-1.0;\n        }\n        double answer=1.0;\n        for (int i = 0; i < n; i++) {\n            answer*=x;\n            if (answer==0.0) {\n                return answer;\n            }\n        }\n        return flag?(slag?answer:-answer):(slag?1/answer:-1/answer);\n    }\n}", "nl": "corpsepiges"}
{"code": "public class PathSum {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null) return false;\n    if (root.left == null && root.right == null && root.val == sum) return true;\n    boolean l = root.left != null ? hasPathSum(root.left, sum - root.val) : false;\n    boolean r = root.right != null ? hasPathSum(root.right, sum - root.val) : false;\n    return l || r;\n  }\n}\n", "nl": "mengli"}
{"code": "class Solution {\n    \n    public ArrayList<ArrayList<Integer>> permute(ArrayList<Integer> nums) {\n        ArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();\n        if (nums == null || nums.size() == 0) {\n            return rst;\n        }\n        Queue<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();\n        ArrayList<Integer> list;\n        for (int num : nums) {\n            list = new ArrayList<Integer>();\n            list.add(num);\n            queue.offer(new ArrayList<Integer>(list));\n        }\n\n        while (!queue.isEmpty()) {\n            list = queue.poll();\n            if (list.size() == nums.size()) {\n                rst.add(new ArrayList<Integer>(list));\n                continue;\n            }\n            for (int i = 0; i < nums.size(); i++) {\n                if (!list.contains(nums.get(i))) {\n                    list.add(nums.get(i));\n                    queue.offer(new ArrayList<Integer>(list));\n                    list.remove(list.size() - 1);\n                }\n            }\n        }\n\n        return rst;\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Subsets {\n\n    public class Solution {\n        public ArrayList<ArrayList<Integer>> subsets(int[] S) {\n            Arrays.sort(S);\n            ArrayList<ArrayList<Integer>> subsets = new ArrayList<ArrayList<Integer>>();\n            for (int i = 0; i < 1 << S.length; i++) {\n                ArrayList<Integer> subset = new ArrayList<Integer>();\n                int n = i;\n                int idx = 0;\n                while (n > 0) {\n                    if ((n & 1) == 1) {\n                        subset.add(S[idx]);\n                    }\n                    n >>= 1;\n                    idx++;\n                }\n                subsets.add(subset);\n            }\n            return subsets;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class ReverseInteger {\n\tpublic int reverse(int x) {\n\t\tint result = 0;\n\n\t\tint flag = 0;\n\t\tif (x < 0) {\n\t\t\tflag = 1;\n\t\t\tx = -x;\n\t\t}\n\n\t\tint lastDigit = 0;\n\t\t\n\t\twhile (x > 0) {\n\t\t\tlastDigit = x - x / 10 * 10;\n\t\t\tresult = result * 10 + lastDigit;\n\t\t\tx /= 10;\n\t\t}\n\n\t\tif (flag == 1) {\n\t\t\tresult = -result;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tReverseInteger slt = new ReverseInteger();\n\n\t\tint x = 10;\n\t\tint res = slt.reverse(x);\n\t\tSystem.out.print(res);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1 == null || num2 == null) {\n            return \"\";\n        } else if (num1.length() == 0 || num2.length() == 0) {\n            return num1.length() == 0 ? num2 : num1;\n        } else if (num1.equals(\"0\") || num2.equals(\"0\")) {\n            return \"0\";\n        }\n        num1 = new StringBuffer(num1).reverse().toString();\n        num2 = new StringBuffer(num2).reverse().toString();\n     \n        int[] product = new int[num1.length() + num2.length()];\n        \n        for (int i = 0; i < num1.length(); i++) {\n        \tint a = num1.charAt(i) - '0';\n            for (int j = 0; j < num2.length(); j++) {\n            \tint b = num2.charAt(j) - '0';\n                product[i + j] += a * b;\n            }\n        }\n        \n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < product.length; i++) {\n           \tint number = product[i] % 10;\n           \tint carrier = product[i] / 10;\n           \tsb.append(number);\n            if (i < product.length - 1) {\n                product[i + 1] += carrier;\n            } \n        }\n        sb.reverse();\n        while (sb.length() > 0 && sb.charAt(0) == '0') {\n        \tsb.deleteCharAt(0);\n        }\n\n        return sb.toString();    \n    }\n}\n\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class SymmetricTree {\n\n    public class Solution {\n        private boolean isSymmetric(TreeNode left, TreeNode right) {\n            if (left == null && right == null) {\n                return true;\n            }\n            if (left == null || right == null) {\n                return left == right;\n            }\n            return left.val == right.val && isSymmetric(left.left, right.right)\n                    && isSymmetric(left.right, right.left);\n        }\n\n        public boolean isSymmetric(TreeNode root) {\n            if (root == null) {\n                return true;\n            }\n            return isSymmetric(root.left, root.right);\n        }\n    }\n\n    public class SolutionWithIterative {\n        public boolean isSymmetric(TreeNode root) {\n            if (root == null) {\n                return true;\n            }\n            LinkedList<TreeNode> lefts = new LinkedList<TreeNode>();\n            LinkedList<TreeNode> rights = new LinkedList<TreeNode>();\n            lefts.add(root.left);\n            rights.add(root.right);\n            while (!lefts.isEmpty() && !rights.isEmpty()) {\n                TreeNode left = lefts.poll();\n                TreeNode right = rights.poll();\n                if (left == null && right == null) {\n                    continue;\n                }\n                if (left == null || right == null) {\n                    return false;\n                }\n                if (left.val != right.val) {\n                    return false;\n                }\n                lefts.add(left.left);\n                lefts.add(left.right);\n                rights.add(right.right);\n                rights.add(right.left);\n            }\n            return lefts.isEmpty() && rights.isEmpty();\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class WordSearch {\n\tpublic boolean exist(char[][] board, String word) {\n\t\tif (board == null || board.length == 0 || word == null || word.length() == 0)\n\t\t\treturn false;\n\t\tboolean[][] checker = new boolean[board.length][board[0].length];\n\n\t\tfor (int row = 0; row < board.length; row++) {\n\t\t\tfor (int col = 0; col < board[0].length; col++) {\n\t\t\t\tif (isFind(checker, board, word, 0, row, col)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isFind(boolean[][] checker, char[][] board, String word, int i, int row, int col) {\n\t\tif (board[row][col] != word.charAt(i) || checker[row][col])\n\t\t\treturn false;\n\n\t\tchecker[row][col] = true;\n\t\tif (i == word.length() - 1)\n\t\t\treturn true;\n\t\tif (row - 1 >= 0 && isFind(checker, board, word, i + 1, row - 1, col))\n\t\t\treturn true;\n\t\tif (row + 1 < board.length && isFind(checker, board, word, i + 1, row + 1, col))\n\t\t\treturn true;\n\t\tif (col - 1 >= 0 && isFind(checker, board, word, i + 1, row, col - 1))\n\t\t\treturn true;\n\t\tif (col + 1 < board[0].length && isFind(checker, board, word, i + 1, row, col + 1))\n\t\t\treturn true;\n\t\tchecker[row][col] = false;\n\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    boolean isValidBSTRe(TreeNode root, long left, long right)\n    {\n        if(root == null) return true;\n        return left < root.val && root.val < right &&\n                isValidBSTRe(root.left,left,root.val) \n                && isValidBSTRe(root.right, root.val, right);\n    }\n    public boolean isValidBST_1(TreeNode root) {\n        if (root == null) return true;\n        return isValidBSTRe(root, (long)Integer.MIN_VALUE - 1, (long)Integer.MAX_VALUE + 1);\n    }\n    boolean isValidBST(TreeNode root) {\n        long[] val = new long[1];\n        val[0] = (long)Integer.MIN_VALUE - 1;\n        return inorder(root, val);\n    }\n    boolean inorder(TreeNode root, long[] val) {\n        if (root == null) return true;\n        if (inorder(root.left, val) == false) \n            return false;\n        if (root.val <= val[0]) return false;\n        val[0] = root.val;\n        return inorder(root.right, val);\n    }\n}\n", "nl": "leetcoders"}
{"code": "public class ImplementStrStr {\n  public String strStr(String haystack, String needle) {\n    int i = 0;\n    int len1 = haystack.length();\n    int len2 = needle.length();\n    if (len1 == 0 && len2 == 0) return \"\";\n    for (; i < len1; i++) {\n      int a = i;\n      int b = 0;\n      boolean match = true;\n      while (b < len2) {\n        if (a >= len1 || haystack.charAt(a) != needle.charAt(b)) {\n          match = false;\n          break;\n        } else {\n          a++;\n          b++;\n        }\n      }\n      if (match) return haystack.substring(i);\n    }\n    return null;\n  }\n}\n", "nl": "mengli"}
{"code": "public class SubsetsII {\n  public ArrayList<ArrayList<Integer>> subsetsWithDup(int[] num) {\n    ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();\n    ArrayList<ArrayList<Integer>> lastLevel = null;\n    ret.add(new ArrayList<Integer>());\n    Arrays.sort(num);\n    for (int i = 0; i < num.length; i++) {\n      ArrayList<ArrayList<Integer>> tmp = new ArrayList<ArrayList<Integer>>();\n      ArrayList<ArrayList<Integer>> prev = i == 0 || num[i] != num[i - 1] ? ret : lastLevel;\n      for (ArrayList<Integer> s : prev) {\n        ArrayList<Integer> newSet = new ArrayList<Integer>(s);\n        newSet.add(num[i]);\n        tmp.add(newSet);\n      }\n      ret.addAll(tmp);\n      lastLevel = tmp;\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class MergeTwoSortedLists {\n  public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode head = new ListNode(0);\n    ListNode cur = head;\n    while (l1 != null && l2 != null) {\n      if (l1.val <= l2.val) {\n        cur.next = l1;\n        l1 = l1.next;\n      } else {\n        cur.next = l2;\n        l2 = l2.next;\n      }\n      cur = cur.next;\n    }\n    if (l1 != null) {\n      cur.next = l1;\n    } else {\n      cur.next = l2;\n    }\n    return head.next;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n    \tList<List<Integer>> rst = new ArrayList<List<Integer>>();\n        if (root == null) {\n        \treturn rst;\n        }\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n\t    \tint size = queue.size();//Becareful with fixed size\n\t    \tList<Integer> list = new ArrayList<Integer>();\n\t    \tfor (int i = 0; i < size; i++) {\n\t    \t\tTreeNode node = queue.poll();\n\t\t    \tlist.add(node.val);\n\t\t    \tif (node.left != null) {\n\t\t    \t\tqueue.offer(node.left);\n\t\t    \t}\n\t\t    \tif (node.right != null) {\n\t\t    \t\tqueue.offer(node.right);\n\t\t    \t}\n\t    \t}\n\t    \trst.add(list);\n        }\n        return rst;\n    }\n}\n\n\n\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class LinkedListCycle {\n\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode fast = head.next, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (wordList == null || !wordList.contains(endWord)) {\n            return 0;\n        }\n\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(beginWord);\n        Set<String> words = new HashSet<>(wordList);\n\n        int count = 1;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            count++;\n            for (int i = 0; i < size; i++) {\n                String word = queue.poll();\n                List<String> candidates = transform(words, word);\n                for (String candidate: candidates) {\n                    if (endWord.equals(candidate)) {\n                        return count;\n                    }\n                    queue.offer(candidate);\n                }\n            }\n        }// END WHILE\n\n        return 0;\n    }\n\n    private List<String> transform(Set<String> words, String word) {\n        List<String> candidates = new ArrayList<>();\n        StringBuffer sb = new StringBuffer(word);\n        for (int i = 0; i < sb.length(); i++) {\n            char temp = sb.charAt(i);\n            for (char c = 'a'; c <= 'z'; c++) {\n                if (temp == c) {\n                    continue;\n                }\n                sb.setCharAt(i, c);\n                String newWord = sb.toString();\n                if (words.remove(newWord)) {\n                    candidates.add(newWord);\n                }\n            }\n            sb.setCharAt(i, temp);\n        }    \n        return candidates;\n    }\n}", "nl": "awangdev"}
{"code": "public class RegularExpressionMatching2 {\n\tpublic boolean isMatch(String s, String p) {\n\t\tif (s.length() == 0 && p.length() == 0)\n\t\t\treturn true;\n\t\tif (p.length() == 0)\n\t\t\treturn false;\n\t\tboolean[][] res = new boolean[s.length() + 1][p.length() + 1];\n\t\tres[0][0] = true;\n\t\tfor (int j = 0; j < p.length(); j++) {\n\t\t\tif (p.charAt(j) == '*') {\n\t\t\t\tif (j > 0 && res[0][j - 1])\n\t\t\t\t\tres[0][j + 1] = true;\n\t\t\t\tif (j < 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (p.charAt(j - 1) != '.') {\n\t\t\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\t\t\tif (res[i + 1][j] || j > 0 && res[i + 1][j - 1] || i > 0 && j > 0 && res[i][j + 1]\n\t\t\t\t\t\t\t\t&& s.charAt(i) == s.charAt(i - 1) && s.charAt(i - 1) == p.charAt(j - 1))\n\t\t\t\t\t\t\tres[i + 1][j + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint i = 0;\n\t\t\t\t\twhile (j > 0 && i < s.length() && !res[i + 1][j - 1] && !res[i + 1][j])\n\t\t\t\t\t\ti++;\n\t\t\t\t\tfor (; i < s.length(); i++) {\n\t\t\t\t\t\tres[i + 1][j + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\t\tif (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')\n\t\t\t\t\t\tres[i + 1][j + 1] = res[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res[s.length()][p.length()];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MaximalRectangle2 {\n\tpublic int maximalRectangle(char[][] matrix) {\n\t\tif (matrix.length == 0)\n\t\t\treturn 0;\n\t\tint height[] = new int[matrix[0].length];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < matrix.length; i++) {\n\t\t\tfor (int j = 0; j < matrix[0].length; j++) {\n\t\t\t\tif (matrix[i][j] == '1')\n\t\t\t\t\theight[j]++;\n\t\t\t\telse {\n\t\t\t\t\theight[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = i + 1; k > 0; k--) {\n\t\t\t\tfor (int l = matrix[0].length - 1; l > 0; l--) {\n\t\t\t\t\tfor (int j = 0; j < matrix[0].length - l; j++) {\n\t\t\t\t\t\tboolean flag = true;\n\t\t\t\t\t\tfor (int m = j; m < j + l; m++) {\n\t\t\t\t\t\t\tif (height[m] < k) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tint area = k * k;\n\t\t\t\t\t\t\tres = res > area ? res : area;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ReverseInteger {\n\n    public class Solution {\n        public int reverse(int x) {\n            if (x == Integer.MIN_VALUE) {\n                return 0;\n            }\n            boolean negative = x < 0;\n            if (negative) {\n                x = -x;\n            }\n            int y = 0;\n            while (x != 0) {\n                int mod = x % 10;\n                if (y > (Integer.MAX_VALUE - mod) / 10) {\n                    return 0;\n                }\n                y = y * 10 + mod;\n                x /= 10;\n            }\n            return negative ? -y : y;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Powxn {\n\tpublic double pow(double x, int n) {\n\t\tif (n < 0) {\n\t\t\treturn 1.0 / power(x, -n);\n\t\t} else {\n\t\t\treturn power(x, n);\n\t\t}\n\t}\n\n\tpublic double power(double x, long n) {\n\t\tif (n == 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tdouble tmp = power(x, n / 2);\n\n\t\tif ((n & 0x01) == 1) {\n\t\t\treturn tmp * tmp * x;\n\t\t} else {\n\t\t\treturn tmp * tmp;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tPowxn slt = new Powxn();\n\t\t\n\t\tSystem.out.println(slt.pow(2, 4));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class L083_Remove_Duplicates_from_Sorted_List {\n\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\n\t\tif (head == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (head.next == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tListNode node = head;\n\n\t\twhile (node.next != null) {\n\n\t\t\tif (node.val != node.next.val) {\n\t\t\t\tnode = node.next;\n\t\t\t} else {\n\t\t\t\twhile (node.next != null && node.val == node.next.val) {\n\t\t\t\t\tnode.next = node.next.next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn head;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class LengthofLastWord {\n\tpublic int lengthOfLastWord(String s) {\n\t\tString ss = s.trim();\n\t\treturn ss.length() - 1 - ss.lastIndexOf(' ');\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int maxArea(int[] height) {\n        int max = 0 , left=0,right= height.length-1;\n        while(left<right){\n            int d = Math.min(height[left],height[right]);\n            int area = d*(right-left);\n            if(area>max)\n                max = area;\n            \n            if(d == height[left])\n                while(left<height.length && height[left]<=d)\n                    left++;            \n            else\n                while(right>=0 && height[right]<=d)\n                    right--;\n        }  \n        return max;\n    }\n}", "nl": "azheanda"}
{"code": "public class ValidNumber\n{\n\n    public boolean isNumber(String s) \n    {\n        return true;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class RemoveDuplicatesfromSortedArrayII {\n\n    public class Solution {\n        public int removeDuplicates(int[] A) {\n            int len = 0;\n            boolean twice = false;\n            for (int i = 0; i < A.length; i++) {\n                if (i == 0 || A[i] != A[i - 1]) {\n                    twice = false;\n                    A[len++] = A[i];\n                } else if (!twice) {\n                    A[len++] = A[i];\n                    twice = true;\n                }\n            }\n            return len;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class NextPermutation {\n\n    public class Solution {\n        private void swap(int[] num, int i, int j) {\n            int temp = num[i];\n            num[i] = num[j];\n            num[j] = temp;\n        }\n\n        private void reverse(int[] num, int begin, int end) {\n            end--;\n            while (begin < end) {\n                swap(num, begin++, end--);\n            }\n        }\n\n        public void nextPermutation(int[] num) {\n            if (num.length <= 1) {\n                return;\n            }\n            int i = num.length - 1;\n            while (i > 0) {\n                i--;\n                if (num[i] < num[i + 1]) {\n                    int j = num.length;\n                    while (num[--j] <= num[i]) {\n                    }\n                    swap(num, i, j);\n                    reverse(num, i + 1, num.length);\n                    return;\n                }\n            }\n            reverse(num, 0, num.length);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class InsertInterval {\n\tpublic ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n\t\tArrayList<Interval> result = new ArrayList<Interval>();\n\t\tint i = 0;\n\t\tfor (i = 0; i < intervals.size(); i++) {\n\t\t\tif (intervals.get(i).end < newInterval.start) {\n\t\t\t\tresult.add(intervals.get(i));\n\t\t\t} else if (intervals.get(i).start > newInterval.end) {\n\t\t\t\tresult.add(newInterval);\n\t\t\t\tbreak;\n\t\t\t} else if (intervals.get(i).end >= newInterval.start || intervals.get(i).start <= newInterval.end) {\n\t\t\t\tnewInterval = new Interval(Math.min(intervals.get(i).start, newInterval.start), Math.max(\n\t\t\t\t\t\tnewInterval.end, intervals.get(i).end));\n\t\t\t}\n\t\t}\n\t\tif (i == intervals.size())\n\t\t\tresult.add(newInterval);\n\t\tfor (; i < intervals.size(); i++)\n\t\t\tresult.add(intervals.get(i));\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L141_Linked_List_Cycle {\n\n\tpublic boolean hasCycle(ListNode head) {\n\n\t\tif (head == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tListNode slow = head;\n\t\tListNode fast = head.next;\n\n\t\twhile (fast != null) {\n\n\t\t\tif (fast.next == null || fast.next.next == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (slow == fast) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfast = fast.next.next;\n\t\t\tslow = slow.next;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class CountAndSay {\n\n  \npublic String countAndSay(int n) {\n  String res = \"1\";\n  while (n > 1) {\n    StringBuilder s = new StringBuilder();\n    for (int i = 0, j = i; i < res.length(); i = j) {\n      while (j < res.length() && res.charAt(i) == res.charAt(j)) {\n        j++;\n      }\n      s.append(j - i).append(res.charAt(i));\n    }\n    res = s.toString();\n    n--;\n  }\n  return res;\n}\n}", "nl": "FreeTymeKiyan"}
{"code": "class NQueens {\n  int limit, total; // limit is all ones, total is # of rows\n  String[] strings; // for a solution\n  List<String[]> res; // solutions\n  StringBuilder sb; // for a row\n  List<Integer> indices; // store solution\n\n  \n  public List<String[]> solveNQueens(int n) {\n    res = new ArrayList<String[]>();\n    if (n <= 0) return res;\n    total = n;\n    strings = new String[n];\n    sb = new StringBuilder();\n    for (int i = 0; i < n; i++) sb.append(\".\");\n    indices = new ArrayList<Integer>();\n    limit = (1 << n) - 1;\n    dfs(0, 0, 0);\n    return res;\n  }\n\n  \n  public void dfs(int h, int r, int l) {\n    if (h == limit) {\n      for (int i = indices.size() - 1; i >= 0; i--) {\n        int gap = h - indices.get(i); // last position\n        h = indices.get(i);\n        int n = 0;\n        while (gap > 0) {\n          n++;\n          gap >>= 1;\n        }\n        StringBuilder ans = new StringBuilder(sb);\n        ans.setCharAt(n - 1, 'Q'); // note n - 1\n        strings[i] = ans.toString();\n      }\n      res.add(strings); // add to result\n      strings = new String[total]; // reset strings\n      return;\n    }\n    indices.add(h); // add then remove\n    int pos = limit & (~(h | r | l)); // set unsaved pos to zero, note ~\n    while (pos != 0) {\n      int p = pos & (-pos); // rightmost 1\n      pos -= p; // note how to place a queen\n      dfs(h + p, (r + p) << 1, (l + p) >> 1);\n    }\n    indices.remove(indices.size() - 1); // remove added h\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    \n    public int searchInsert(int[] A, int target) {\n        if (A == null || A.length == 0) {//Insert at 0 position\n            return 0;\n        }\n        int start = 0;\n        int end = A.length - 1;\n        int mid = start + (end - start)/2;\n\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            if (A[mid] == target) {\n                return mid;\n            } else if (A[mid] > target) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        \n        if (A[start] >= target) {\n            return start;\n        } else if (A[start] < target && target <= A[end]) {\n            return end;\n        } else {\n            return end + 1;\n        }\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        int s = newInterval.start;\n        int e = newInterval.end;\n        if (intervals.size()==0) {\n            intervals.add(newInterval);\n            return intervals;\n        }\n        List<Interval> answerList = new ArrayList<Interval>();\n        int ns=0;\n        int ne=0;\n        boolean beginFlag=true;\n        boolean endFlag=true;\n        for (int i = 0; i < intervals.size(); i++) {\n            if (endFlag&&beginFlag) {\n                if (intervals.get(i).start>=s) {\n                    ns=s;\n                    beginFlag=false;\n                }else if (intervals.get(i).end>=s) {\n                    if (intervals.get(i).end>=e) {\n                        endFlag=false;\n                    }else {\n                        ns=intervals.get(i).start;\n                        beginFlag=false;\n                    }\n                }\n            }\n            if (endFlag&&!beginFlag) {\n                if (intervals.get(i).start>e) {\n                    ne=e;\n                    answerList.add(new Interval(ns,ne));\n                    endFlag=false;\n                    beginFlag=true;\n                }else if(intervals.get(i).start==e){\n                    ne=intervals.get(i).end;\n                    answerList.add(new Interval(ns,ne));\n                    endFlag=false;\n                    beginFlag=true;\n                    continue;\n                }else if(intervals.get(i).end>=e){\n                    ne=intervals.get(i).end;\n                    answerList.add(new Interval(ns,ne));\n                    endFlag=false;\n                    beginFlag=true;\n                    continue;\n                }else if(i==intervals.size()-1){\n                    ne=e;\n                    answerList.add(new Interval(ns,ne));\n                    return answerList;\n                }\n            }\n            if (beginFlag) {\n                answerList.add(intervals.get(i));\n            }\n        }\n        if (endFlag) {\n            answerList.add(newInterval);\n        }\n        return answerList;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class SearchForARange {\n  public static void main(String[] args) throws Exception {\n    int[] test = {\n      5, 7, 7, 8, 8, 10, 10, 10, 10, 18, 19, 20, 21, 21, 21, 21, 22, 23, 28, 28, 90, 101, 101, 101,\n      200, 200, 200, 200, 200, 200\n    };\n    int[] result = new SearchForARange().searchRange(test, 200);\n    for (int i : result) System.out.print(i + \" \");\n  }\n\n  public int[] searchRange(int[] nums, int target) {\n    int low = findIndex(nums, target, true);\n    int high = findIndex(nums, target, false);\n    int[] result = new int[2];\n    result[0] = low;\n    result[1] = high;\n    return result;\n  }\n\n  \n  private int findIndex(int[] nums, int target, boolean isLowerIndex) {\n    int result = -1;\n    int s = 0, e = nums.length - 1;\n    while (s <= e) {\n      int m = s + (e - s) / 2;\n      if (nums[m] == target) {\n        result = m;\n        if (isLowerIndex)\n          e = m - 1; // if searching for the lower index then search the lower bound,\n        else s = m + 1;\n      } else if (nums[m] < target) {\n        s = m + 1;\n      } else e = m - 1;\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class MultiplyStrings {\n\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(new MultiplyStrings().multiply(\"00\", \"0000\"));\n  }\n\n  public String multiply(String num1, String num2) {\n    if ((num1.length() == 1 && num1.equals(\"0\")) || (num2.length() == 1 && num2.equals(\"0\")))\n      return \"0\";\n    if (num1.length() < num2.length()) return multiply(num2, num1);\n    String temp2 = \"\", trail = \"\";\n    int carry = 0;\n    for (int i = 0; i < num1.length(); i++) {\n      temp2 += \"0\";\n    }\n    for (int i = num1.length() - 1; i >= 0; i--) {\n      String temp1 = \"\";\n      for (int j = num2.length() - 1; j >= 0; j--) {\n        int prod =\n            Integer.parseInt(String.valueOf(num2.charAt(j)))\n                * Integer.parseInt(String.valueOf(num1.charAt(i)));\n        prod += carry;\n        temp1 = (prod % 10) + temp1;\n        carry = (prod / 10);\n      }\n      if (carry > 0) {\n        temp1 = String.valueOf(carry) + temp1;\n        carry = 0;\n      }\n      String temp3 = add(temp1, temp2);\n      temp2 = temp3.substring(0, temp3.length() - 1);\n      trail = temp3.substring(temp3.length() - 1, temp3.length()) + trail;\n    }\n    return temp2 + trail;\n  }\n\n  private String add(String s1, String s2) {\n    String result = \"\";\n    int carry = 0;\n    int i = s1.length() - 1, j = s2.length() - 1;\n    for (; i >= 0 || j >= 0; i--, j--) {\n      int l = (i >= 0) ? Integer.parseInt(String.valueOf(s1.charAt(i))) : 0;\n      int r = (j >= 0) ? Integer.parseInt(String.valueOf(s2.charAt(j))) : 0;\n      int sum = l + r + carry;\n      carry = sum / 10;\n      result = sum % 10 + result;\n    }\n    if (carry > 0) {\n      result = carry + result;\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class LRUCache {\n    private LinkedHashMap<Integer, Integer> map;\n\n    @SuppressWarnings(\"serial\")\n    public LRUCache(final int capacity) {\n        assert capacity > 0;\n        map = new LinkedHashMap<Integer, Integer>(16, 0.75f, true) {\n            protected boolean removeEldestEntry(\n                    Map.Entry<Integer, Integer> eldest) {\n                return size() > capacity;\n            }\n        };\n    }\n\n    public int get(int key) {\n        Integer value = map.get(key);\n        if (value == null) {\n            return -1;\n        }\n        return value;\n    }\n\n    public void set(int key, int value) {\n        map.put(key, value);\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MergeKSortedLists {\n  public static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n\n  \n  public static void main(String[] args) throws Exception {\n    ListNode node2 = new ListNode(-1);\n    ListNode node3 = new ListNode(5);\n    ListNode node4 = new ListNode(11);\n\n    ListNode node6 = new ListNode(6);\n    ListNode node10 = new ListNode(10);\n\n    \n\n    node2.next = node3;\n    node3.next = node4;\n\n    node6.next = node10;\n\n    \n    ListNode[] list = new ListNode[4];\n    list[0] = null;\n    list[1] = node2;\n    list[2] = null;\n    list[3] = node6;\n    ListNode result = new MergeKSortedLists().mergeKLists(list);\n  }\n\n  public ListNode mergeKLists(ListNode[] lists) {\n    if (lists.length == 0) return null;\n    if (lists.length == 1) return lists[0];\n    return merge(lists, 0, lists.length - 1);\n  }\n\n  private ListNode merge(ListNode[] lists, int s, int e) {\n    if (s == e) return lists[s];\n    int m = s + (e - s) / 2;\n    ListNode left = merge(lists, s, m);\n    ListNode right = merge(lists, m + 1, e);\n    ListNode prev, temp;\n    ListNode headNode = new ListNode(0);\n    headNode.next = left;\n    prev = headNode;\n    if (left == null && right == null) return null;\n    else if (left == null) return right;\n    else if (right == null) return left;\n    while (left != null && right != null) {\n      if (left.val > right.val) {\n        temp = right;\n        right = right.next;\n        prev.next = temp;\n        temp.next = left;\n        prev = prev.next;\n      } else {\n        left = left.next;\n        prev = prev.next;\n      }\n    }\n    if (left == null && right != null) prev.next = right;\n    return headNode.next;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class ValidParentheses {\n  public boolean isValid(String s) {\n    int len = s.length();\n    if (len == 0) return true;\n    Stack<Character> st = new Stack<Character>();\n    st.add(s.charAt(0));\n    int i = 1;\n    while (i < len) {\n      switch (s.charAt(i)) {\n        case '(':\n          st.add('(');\n          break;\n        case ')':\n          if (!st.empty() && st.peek() == '(') {\n            st.pop();\n          } else {\n            return false;\n          }\n          break;\n        case '{':\n          st.add('{');\n          break;\n        case '}':\n          if (!st.empty() && st.peek() == '{') {\n            st.pop();\n          } else {\n            return false;\n          }\n          break;\n        case '[':\n          st.add('[');\n          break;\n        case ']':\n          if (!st.empty() && st.peek() == '[') {\n            st.pop();\n          } else {\n            return false;\n          }\n          break;\n      }\n      i++;\n    }\n    return st.empty();\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i]<nums[j]) {\n                    int temp=nums[i];\n                    nums[i]=nums[j];\n                    nums[j]=temp;\n                }\n            }\n        }\n        int[] n=new int[nums.length];\n        int sum=1;\n        for (int i = n.length-1; i >=0;i--) {\n            n[i]=sum;\n            sum*=2;\n        }\n        List<List<Integer>> answer=new ArrayList<List<Integer>>();\n        for (int i = 0; i < sum; i++) {\n            List<Integer> list=new ArrayList<Integer>();\n            for (int j = nums.length-1; j >=0 ; j--) {\n                if ((i/n[j])%2==1) {\n                    list.add(nums[j]);\n                }\n            }\n            answer.add(list);\n        }\n        Map<List<Integer>, Integer> map=new HashMap<List<Integer>, Integer>();\n        for (int i = 0; i < answer.size(); i++) {\n            if (map.get(answer.get(i))==null) {\n                map.put(answer.get(i), 1);\n            }else {\n                answer.remove(i);\n                i--;\n            }\n        }\n        return answer;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class CombinationSum4Test {\n\n    @DataProvider(name = \"examples\")\n    public Object[][] generateExamples() {\n        int[] nums = {1, 2, 3};\n        return new Object[][]{\n                new Object[]{nums, 4, 7},\n                new Object[]{nums, 6, 24}\n        };\n    }\n\n    @Test(description = \"Test examples on bottom-up implementation.\", dataProvider = \"examples\")\n    public void testCombinationSum4(int[] nums, int target, int output) {\n        CombinationSum4 c = new CombinationSum4();\n        Assert.assertEquals(c.combinationSum4(nums, target), output);\n    }\n\n    @Test(description = \"Test examples on top-down implementation.\", dataProvider = \"examples\")\n    public void testCombinationSum4TopDown(int[] nums, int target, int output) {\n        CombinationSum4 c = new CombinationSum4();\n        Assert.assertEquals(c.combinationSum4TopDown(nums, target), output);\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int x = row - 1;\n        int y = 0;\n        \n        while (x >= 0 && y < col) {\n            if (matrix[x][y] < target) {\n                y++;\n            } else if (matrix[x][y] > target) {\n                x--;\n            } else {//matrix[x][y] == target\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int maxArea(int[] heights) {\n    \tif (heights == null || heights.length == 0) {\n    \t\treturn 0;\n    \t}\n    \tint left = 0;\n    \tint right = heights.length - 1;\n    \tint maxWater = Integer.MIN_VALUE;\n    \twhile (left < right) {\n    \t    int lowWall = heights[left] < heights[right] ? heights[left] : heights[right];\n    \t\tmaxWater = Math.max(maxWater, (right - left) * lowWall);\n    \t\tif (heights[left] < heights[right]) {\n    \t\t\tleft++;\n    \t\t} else {\n    \t\t\tright--;\n    \t\t}\n    \t}\n    \treturn maxWater;\n    }\n}", "nl": "awangdev"}
{"code": "public class LongestCommonPrefix {\n\tpublic String longestCommonPrefix(String[] strs) {\n\t\tif (strs != null && strs.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tfor (int i = 0; i < strs[0].length(); ++i) {\n\t\t\tfor (int j = 1; j < strs.length; ++j) {\n\t\t\t\tif (strs[j].length() <= i || strs[j].charAt(i) != strs[0].charAt(i)) {\n\t\t\t\t\treturn strs[0].substring(0, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn strs[0];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tString[] strs = { \"abc\", \"acd\", \"ade\" };\n\n\t\tLongestCommonPrefix slt = new LongestCommonPrefix();\n\t\tSystem.out.println(slt.longestCommonPrefix(strs));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "class TrappingRainWater {\n    public static void main(String[] args) {\n\n    }\n\n    \n    public int trap(int[] A) {\n        if (A == null || A.length == 0) return 0;\n        int l = 0;\n        int r = A.length - 1;\n        int level = 0;\n        int all = 0;\n        int block = 0;\n\n        while (l <= r) { // note l <= r to include the last block\n            int curLevel = Math.min(A[l], A[r]);\n            if (curLevel > level) {\n                all += (curLevel - level) * (r - l + 1);\n                level = curLevel;\n            }\n            if (A[l] < A[r]) block += A[l++];\n            else block += A[r--];\n        }\n        return all - block;\n    }\n\n    public int trap2(int[] height) {\n        int n = height.length;\n\n        if (n < 3) return 0;\n\n        int left = 0, right = n - 1, highest = 0, water = 0;\n        while (left < right) {\n            int curr = height[left] < height[right] ? height[left++] : height[right--];\n            if (curr < highest) {\n                water += highest - curr;\n            } else {\n                highest = curr; // update highest level\n            }\n        }\n\n        return water;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class GenerateParentheses {\n\n    public class Solution {\n        private void generateParenthesis(ArrayList<String> ans, char[] s,\n                int left, int right, int n) {\n            if (left == n) {\n                Arrays.fill(s, left + right, n << 1, ')');\n                ans.add(new String(s));\n                return;\n            }\n            s[left + right] = '(';\n            generateParenthesis(ans, s, left + 1, right, n);\n            if (left > right) {\n                s[left + right] = ')';\n                generateParenthesis(ans, s, left, right + 1, n);\n            }\n        }\n\n        public ArrayList<String> generateParenthesis(int n) {\n            ArrayList<String> ans = new ArrayList<String>();\n            generateParenthesis(ans, new char[n << 1], 0, 0, n);\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "class PathSum {\n\n  \n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null) return false; // root == null\n    sum -= root.val; // update sum\n    return root.left == null && root.right == null && sum == 0 || hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n  }\n\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n\n}", "nl": "FreeTymeKiyan"}
{"code": "public class L162_Find_Peak_Element {\n\n\tpublic int findPeakElement(int[] nums) {\n\n\t\tint low = 0;\n\t\tint high = nums.length - 1;\n\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (nums[mid] > nums[mid + 1]) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class BinaryTreeLevelOrderTraversal {\n\n  \n  private List<List<Integer>> levelOrder(TreeNode root) {\n    if (root == null) {\n      return Collections.EMPTY_LIST;\n    }\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n    List<List<Integer>> levels = new ArrayList<>();\n    while (!queue.isEmpty()) {\n      List<Integer> values = new ArrayList<>();\n      for (int i = queue.size(); i > 0; i--) {\n        TreeNode n = queue.poll();\n        values.add(n.val); // Add current node's value to current level's values list.\n        if (n.left != null) {\n          queue.add(n.left);\n        }\n        if (n.right != null) {\n          queue.add(n.right);\n        }\n      }\n      levels.add(values);\n    }\n    return levels;\n  }\n\n  \n  public List<List<Integer>> levelOrder2(TreeNode root) {\n    List<List<Integer>> res = new ArrayList<>();\n    dfs(root, 0, res);\n    return res;\n  }\n\n  \n  public void dfs(TreeNode root, int level, List<List<Integer>> res) {\n    if (root == null) {\n      return;\n    }\n    if (res.size() <= level) {\n      res.add(new ArrayList<>());\n    }\n    res.get(level).add(root.val);\n    dfs(root.left, level + 1, res);\n    dfs(root.right, level + 1, res);\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class MinimumDepthofBinaryTree {\n  public int minDepth(TreeNode root) {\n    if (root == null) return 0;\n    if (root.left == null && root.right == null) return 1;\n    else {\n      int leftDepth = root.left != null ? minDepth(root.left) : Integer.MAX_VALUE;\n      int rightDepth = root.right != null ? minDepth(root.right) : Integer.MAX_VALUE;\n      return Math.min(leftDepth, rightDepth) + 1;\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length()==0) {\n            return 0;\n        }\n        for (int i = 0; i <haystack.length()-needle.length()+1; i++) {\n            if (haystack.substring(i,i+needle.length()).equals(needle)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class SwapNodesInPairs3 {\n\tpublic ListNode swapPairs(ListNode head) {\n\t\tif (head == null || head.next == null)\n\t\t\treturn head;\n\n\t\tListNode p = head, q = head.next;\n\t\tp.next = swapPairs(q.next);\n\t\thead = q;\n\t\tq.next = p;\n\t\treturn head;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    \n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n        int profit = 0;\n        int start = 0;\n        int peek = 0;\n        while (start < prices.length - 1) {\n            peek = start + 1;\n            while (peek < prices.length && prices[peek - 1] <= prices[peek]) {\n                peek++;\n            }\n            profit += prices[peek - 1] - prices[start];\n            start = peek;\n        }\n        return profit;\n    }\n};\n\n\n   ", "nl": "awangdev"}
{"code": "public class WordLadder2Test {\n\n    @DataProvider(name = \"examples\")\n    public Object[][] getExamples() {\n        return new Object[][]{\n                new Object[]{\"hit\", \"cog\", Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"),\n                        List.of(List.of(\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"), List.of(\"hit\", \"hot\", \"lot\", \"log\", \"cog\"))},\n                new Object[]{\"a\", \"c\", Arrays.asList(\"a\", \"b\", \"c\"), List.of(List.of(\"a\", \"c\"))},\n                new Object[]{\"red\", \"tax\", Arrays.asList(\"ted\", \"tex\", \"red\", \"tax\", \"tad\", \"den\", \"rex\", \"pee\"),\n                        List.of(List.of(\"red\", \"ted\", \"tad\", \"tax\"), List.of(\"red\", \"ted\", \"tex\", \"tax\"), List.of(\"red\", \"rex\", \"tex\", \"tax\"))}\n        };\n    }\n\n    @Test(dataProvider = \"examples\")\n    public void testFindLadders(String beginWord, String endWord, List<String> dict, List<List<String>> expected) {\n        WordLadder2 w = new WordLadder2();\n        List<List<String>> ladders = w.findLadders(beginWord, endWord, dict);\n        Assert.assertEquals(ladders, expected);\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class NQueens {\n  public ArrayList<String[]> solveNQueens(int n) {\n    ArrayList<String[]> ret = new ArrayList<String[]>();\n    if (n == 0) return ret;\n    StringBuffer line = new StringBuffer();\n    for (int i = 0; i < n; i++) {\n      line.append('.');\n    }\n    StringBuffer[] sol = new StringBuffer[n];\n    for (int i = 0; i < n; i++) {\n      sol[i] = new StringBuffer(line.toString());\n    }\n    boolean[] cols = new boolean[n];\n    int[] row = new int[n];\n    findSolutions(n, 0, ret, sol, row, cols);\n    return ret;\n  }\n\n  private void findSolutions(\n      int n, int start, ArrayList<String[]> ret, StringBuffer[] sol, int[] row, boolean[] cols) {\n    if (start == n) {\n      String[] newSol = new String[n];\n      for (int i = 0; i < n; i++) {\n        newSol[i] = sol[i].toString();\n      }\n      ret.add(newSol);\n    } else {\n      for (int i = 0; i < n; i++) {\n        if (cols[i]) continue;\n        boolean ok = true;\n        for (int j = 0; j < start; j++) {\n          if (Math.abs(start - j) == Math.abs(i - row[j])) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) {\n          cols[i] = true;\n          sol[start].setCharAt(i, 'Q');\n          row[start] = i;\n          findSolutions(n, start + 1, ret, sol, row, cols);\n          row[start] = 0;\n          sol[start].setCharAt(i, '.');\n          cols[i] = false;\n        }\n      }\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class ValidNumber {\n  public boolean isNumber(String s) {\n    StringBuffer sb = new StringBuffer(s.trim());\n    int i = sb.length() - 1;\n    while (i >= 0 && sb.charAt(i) == ' ') {\n      i--;\n    }\n    sb.delete(i + 1, sb.length());\n    s = sb.toString();\n    int length = s.length();\n    if (length == 0) return false;\n    i = 0;\n    int start = 0;\n    if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n      i++;\n      start++;\n    }\n    for (; i < length; i++) {\n      char c = s.charAt(i);\n      if (c == 'e' || c == 'E') {\n        return isDouble(s.substring(start, i)) && isDigitals(s.substring(i + 1, s.length()));\n      } else if (c != '.' && (c < '0' || c > '9')) {\n        return false;\n      }\n    }\n    return isDouble(s.substring(start));\n  }\n\n  private boolean isDouble(String s) {\n    int length = s.length();\n    if (length == 0 || ((s.charAt(0) == '-' || s.charAt(0) == '+') && length == 1)) return false;\n    int i = 0, start = 0;\n    if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n      i++;\n      start++;\n    }\n    for (; i < length; i++) {\n      char c = s.charAt(i);\n      if (c == '.') {\n        if (i == start && s.length() - i - 1 == 0) return false;\n        boolean left = i == start ? true : isDigitals(s.substring(0, i));\n        boolean right = s.length() - i - 1 == 0 ? true : isDigitals(s.substring(i + 1, s.length()));\n        return left && right;\n      } else if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean isDigitals(String s) {\n    int length = s.length();\n    if (length == 0 || ((s.charAt(0) == '-' || s.charAt(0) == '+') && length == 1)) return false;\n    int i = 0;\n    if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n      i++;\n    }\n    for (; i < length; i++) {\n      char c = s.charAt(i);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    \n    public int jump(int[] A) {\n        if (A == null || A.length == 0) {\n            return 0;\n        }\n        int pStart = 0;\n        int pEnd = 0;\n        int steps = 0;\n        while (pEnd < A.length - 1) {\n            steps++;    //Cound step everytime when pEnd is moving to the farthest.\n            int farthest = 0;\n            for (int i = pStart; i <= pEnd; i++) {\n                farthest = Math.max(farthest, i + A[i]);\n                if (farthest >= A.length - 1) {\n                    return steps;\n                }\n            }\n            pStart = pEnd + 1;\n            pEnd = farthest;\n        }\n        return -1;  //This is the case where no solution can be found.\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Permutations {\n\tpublic ArrayList<ArrayList<Integer>> permute(int[] num) {\n\t\tArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n\t\tresult.add(new ArrayList<Integer>());\n\t\tfor (int i = 0; i < num.length; i++) {\n\t\t\tArrayList<ArrayList<Integer>> current = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (ArrayList<Integer> l : result) {\n\t\t\t\tfor (int j = 0; j < l.size() + 1; j++) {\n\t\t\t\t\tl.add(j, num[i]);\n\t\t\t\t\t new ArrayList<Integer>(l);\n\t\t\t\t\tcurrent.add(new ArrayList<Integer>(l));\n\t\t\t\t\tl.remove(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = new ArrayList<ArrayList<Integer>>(current);\n\t\t}\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < numbers.length; ++i) {\n            int b = target - numbers[i];\n            if (map.get(b) != null) {\n                return new int[]{map.get(b),i+1};\n            } else map.put(numbers[i],i+1);\n        }\n        return null;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices==null || prices.length==0)\n            return 0;        \n        int maxProfit = 0;\n       \n        for(int i=1;i<prices.length;i++){\n        \tif(prices[i]>prices[i-1])    \t\n    \t\t\tmaxProfit += prices[i]-prices[i-1];\n        }\n\n        return maxProfit;\n    }\n}", "nl": "azheanda"}
{"code": "public class AddBinary\n{\n    public String addBinary( String a, String b )\n    {\n    \tif ( a == null || b == null )\n    \t{\n    \t\tthrow new IllegalArgumentException();\n    \t}\n    \t    \t\n    \tStringBuilder result = new StringBuilder();\n    \t\n    \tint carry = 0;\n    \tfor ( int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j-- )\n    \t{\n    \t\tint aVal = i >= 0 ? a.charAt( i ) - '0' : 0;\n    \t\tint bVal = j >= 0 ? b.charAt( j ) - '0' : 0;\n    \t\tint sum = aVal + bVal + carry;\n    \t\tresult.append( sum % 2 );\n    \t\tcarry = sum / 2;\n    \t}\n    \t\n    \tif ( carry == 1 )\n    \t{\n    \t\tresult.append( 1 );\n    \t}\n    \t\n    \treturn result.reverse().toString();\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        for (int i = m-1; i >=0; i--) {\n            nums1[i+nums1.length-m]=nums1[i];\n        }\n        int a=nums1.length-m;\n        int b=0;\n        for (int i = 0; i < m+n; i++) {\n            if (a==nums1.length) {\n                nums1[i]=nums2[b];\n                b++;\n            }else if (b==n||nums1[a]<nums2[b]) {\n                nums1[i]=nums1[a];\n                a++;\n            }else {\n                nums1[i]=nums2[b];\n                b++;\n            }\n            \n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MaximalRectangle {\n\n  \n  public int maximalRectangle(char[][] matrix) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[] left = new int[n];\n    int[] right = new int[n];\n    int[] height = new int[n];\n    Arrays.fill(right, n);\n    int max = 0;\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (matrix[i][j] == '1') {\n          height[j]++;\n        } else {\n          height[j] = 0;\n        }\n      }\n      int leftBound = 0; // Index of leftmost 1 of current row.\n      for (int j = 0; j < n; j++) {\n        if (matrix[i][j] == '1') {\n          left[j] = Math.max(left[j], leftBound);\n        } else {\n          left[j] = 0;\n          leftBound = j + 1;\n        }\n      }\n      int rightBound = n; // Index + 1 of rightmost 1 of current row.\n      for (int j = n - 1; j >= 0; j--) {\n        if (matrix[i][j] == '1') {\n          right[j] = Math.min(right[j], rightBound);\n        } else {\n          right[j] = n; // Like reset. Make sure right[j] >= curRight.\n          rightBound = j;\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        max = Math.max(max, (right[j] - left[j]) * height[j]);\n      }\n    }\n    return max;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Subsets3 {\n\tpublic ArrayList<ArrayList<Integer>> subsets(int[] S) {\n\t\tArrays.sort(S);\n\t\tArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n\t\tresult.add(new ArrayList<Integer>());\n\t\tfor (int i = 0; i < S.length; i++) {\n\t\t\tfor (int j = 0; j <  result.size(); j++) {\n\t\t\t\tArrayList<Integer> temp = new ArrayList<Integer>(result.get(j));\n\t\t\t\ttemp.add(S[i]);\n\t\t\t\tresult.add(temp);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int removeDuplicates(int[] A) {\n        int i=2;   // modification here\n\n        while(i<A.length){\n            if(A[i]>A[i-1] || A[i]>A[i-2]) // and here \n                i++;\n            else{\n                if(A[i-1]>=A[A.length-1] && A[i-2]>=A[A.length-1])  // here \n                    return i;\n                \n                for(int j=i+1;j<A.length;j++)\n                    if(A[j]>A[i-1] || A[j]>A[i-2]){  // here    \n                        swap(A,i,j);\n                        break;\n                    }            \n            }\n        }   \n        return A.length;\n    }\n    \n    public void swap(int[] A,int i,int j){\n        int temp = A[i];\n        A[i] = A[j];\n        A[j] = temp;\n    }\n}", "nl": "azheanda"}
{"code": "public class CombinationSumII {\n  \n  public static void main(String[] args) throws Exception {\n    int[] candidates = {1, 1, 2, 2};\n    List<List<Integer>> result = new CombinationSumII().combinationSum2(candidates, 4);\n  }\n\n  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    Arrays.sort(candidates);\n    List<List<Integer>> result = new ArrayList<>();\n    combination(0, target, candidates, new ArrayList<>(), result);\n    return result;\n  }\n\n  private void combination(\n      int i, int target, int[] candidates, List<Integer> row, List<List<Integer>> result) {\n    if (target == 0) {\n      result.add(new ArrayList<>(row));\n    } else if (target > 0) {\n      for (int j = i, l = candidates.length; j < l; j++) {\n        if (j > i && candidates[j] == candidates[j - 1]) continue;\n        row.add(candidates[j]);\n        combination(j + 1, target - candidates[j], candidates, row, result);\n        row.remove(row.size() - 1);\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public int trap(int[] A) {\n\n        int area = 0;\n        int n = A.length;\n        int[] R = new int[n];\n        int[] L = new int[n];\n\n           int rmax=0,lmax=0;\n\n       \tfor(int i=0;i<n;i++){\n       \t\tL[i] = lmax;\n       \t\tif(lmax < A[i])\n       \t\t\tlmax = A[i];\n\n       \t\tR[n-i-1] = rmax;\n       \t\tif(rmax < A[n-i-1])\n       \t\t\trmax = A[n-i-1];\n       \t}\n\n       \tfor(int i=0;i<n;i++)\n       \t\tif(A[i]<Math.min(R[i],L[i]))\n       \t\t\tarea += Math.min(R[i],L[i])-A[i];\n\n       \treturn area;\n\n\n    }\n\n}", "nl": "azheanda"}
{"code": "public class FindMinimuminRotatedSortedArray {\n\n    public class Solution {\n        public int findMin(int[] num) {\n            assert (num.length > 0);\n            int left = 0;\n            int right = num.length - 1;\n            while (left < right) {\n                if (num[left] < num[right]) {\n                    return num[left];\n                }\n                int mid = left + (right - left) / 2;\n                if (num[left] <= num[mid]) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            return num[left];\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> rst = new ArrayList<>();\n\t    if (root == null) {\n            return rst;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> list = new ArrayList<>();\n            while (size > 0) {\n                size--;\n                TreeNode node = queue.poll();\n                list.add(node.val);\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n            }\n            rst.add(list);\n        }\n\t    return rst;\n    }\n}", "nl": "awangdev"}
{"code": "public class SameTree {\n\tpublic boolean isSameTree(TreeNode p, TreeNode q) {\n\t\tif (p == null && q == null) {\n\t\t\treturn true;\n\t\t} else if (p == null || q == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn p.val == q.val && isSameTree(p.left, q.left)\n\t\t\t\t&& isSameTree(p.right, q.right);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tTreeNode n1 = new TreeNode(1);\n\t\tTreeNode n2 = new TreeNode(1);\n\t\tn1.left = n2;\n\n\t\tTreeNode n3 = new TreeNode(1);\n\t\tTreeNode n4 = new TreeNode(1);\n\t\tn3.right = n4;\n\n\t\tSameTree slt = new SameTree();\n\t\tSystem.out.println(slt.isSameTree(n1, n3));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null) return minDepth(root.right) + 1;\n        if (root.right == null) return minDepth(root.left) + 1;\n        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n    }\n}", "nl": "leetcoders"}
{"code": "public class ClimbingStairs {\n    public int climbStairs(int n) {\n        if (n == 1) return 1;\n        if (n == 2) return 2;\n        return climbStairs(n - 1) + climbStairs(n - 2);\n    }\n\n    public int climbStairs2(int n) {\n        int memo[] = new int[n + 1];\n        return climb_Stairs(n, memo);\n    }\n\n    public int climb_Stairs(int n, int memo[]) {\n        if (n == 1) return 1;\n        if (n == 2) return 2;\n        if (memo[n] > 0)\n            return memo[n];\n        memo[n] = climb_Stairs(n - 1, memo) + climb_Stairs(n - 2, memo);\n        return memo[n];\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class BinaryTreePreorderTraversal \n{\n    public List<Integer> preorderTraversalMethod1(TreeNode root) \n    {\n     \tList<Integer> result = new ArrayList<>();\n    \tif ( root == null )\n    \t{\n    \t\treturn result;\n    \t}\n    \t\n    \tStack<TreeNode> preorderStack = new Stack<>();\n    \tpreorderStack.push( root );\n    \twhile ( !preorderStack.isEmpty() )\n    \t{\n    \t\tTreeNode stackTop = preorderStack.pop();\n    \t\tresult.add( stackTop.val );\n    \t\tif ( stackTop.right != null )\n    \t\t{\n    \t\t\tpreorderStack.push( stackTop.right );\n    \t\t}\n    \t\tif ( stackTop.left != null )\n    \t\t{\n    \t\t\tpreorderStack.push( stackTop.left );\n    \t\t}\n    \t}\n    \treturn result;       \n    }\n    \n    public List<Integer> preorderTraversalMethod2( TreeNode root ) \n    {\n     \tList<Integer> result = new ArrayList<>();\n    \tif ( root == null )\n    \t{\n    \t\treturn result;\n    \t}\n    \t\n    \tStack<TreeNode> preorderStack = new Stack<>();\n    \tpushAllLeftChildren( root, preorderStack, result );\n    \t\n    \twhile ( !preorderStack.isEmpty() )\n    \t{\n    \t\tTreeNode top = preorderStack.pop();\n    \t\tif ( top.right != null )\n    \t\t{\n    \t\t\tpushAllLeftChildren( top.right, preorderStack, result );\n    \t\t}\n    \t}\n    \treturn result;\n    }\n        \n    private void pushAllLeftChildren( TreeNode root, Stack<TreeNode> preorderStack, List<Integer> result )\n\t{\n\t\tTreeNode currNode = root;\n\t\twhile ( currNode != null )\n\t\t{\n\t\t\tresult.add( currNode.val );\n\t\t\tpreorderStack.push( currNode );\n\t\t\tcurrNode = currNode.left;\n\t\t}\n\t}\n}", "nl": "FreemanZhang"}
{"code": "public class SearchInsertPosition {\n\tpublic int searchInsert(int[] A, int target) {\n\t\tint mid = 0;\n\t\tint start = 0, end = A.length - 1;\n\t\tboolean flag = true;\n\t\twhile (start <= end) {\n\t\t\tmid = (start + end) >> 1;\n\t\t\tif (A[mid] == target) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (A[mid] > target)\n\t\t\t\tend = mid - 1;\n\t\t\telse\n\t\t\t\tstart = mid + 1;\n\t\t}\n\t\tif (flag)\n\t\t\tif (A[mid] > target)\n\t\t\t\treturn mid;\n\t\t\telse\n\t\t\t\treturn mid + 1;\n\t\treturn mid;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ReverseInteger\n{\n\n    public int reverse(int x) \n    {\n        return 0;\n    }\n\n}\n", "nl": "FreemanZhang"}
{"code": "public class MergeIntervals {\n\n    public class Solution {\n        public ArrayList<Interval> merge(ArrayList<Interval> intervals) {\n            Collections.sort(intervals, new Comparator<Interval>() {\n\n                @Override\n                public int compare(Interval i1, Interval i2) {\n                    if (i1.start == i2.start) {\n                        return i1.end - i2.end;\n                    }\n                    return i1.start - i2.start;\n                }\n\n            });\n\n            ArrayList<Interval> ans = new ArrayList<Interval>();\n            Interval newInterval = null;\n            for (Interval i : intervals) {\n                if (newInterval == null) {\n                    newInterval = new Interval(i.start, i.end);\n                } else {\n                    if (newInterval.end < i.start) {\n                        ans.add(newInterval);\n                        newInterval = new Interval(i.start, i.end);\n                    } else {\n                        newInterval.end = Math.max(newInterval.end, i.end);\n                    }\n                }\n            }\n            if (newInterval != null) {\n                ans.add(newInterval);\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class RemoveDuplicatesfromSortedArray {\n    public int removeDuplicates(int[] A) {\n    \tif(A.length == 0) {\n    \t\treturn 0;\n    \t}\n    \tif(A.length == 1) {\n    \t\treturn 1;\n    \t}\n    \t\n        int index = 0;\n        for(int i = 1; i < A.length; ++i) {\n        \tif(A[i] != A[index]) {\n        \t\t++index;\n        \t\tA[index] = A[i];\n        \t}\n        }\n        \n        return index + 1;\n    }\n    \n    public static void main(String[] args) {\n    \tRemoveDuplicatesfromSortedArray slt = new RemoveDuplicatesfromSortedArray();\n    \tint[] A = {1, 1, 2, 3, 4, 4, 5};\n    \tint len = slt.removeDuplicates(A);\n    \tSystem.out.println(len);\n    \tfor(int i = 0; i < len; ++i) {\n    \t\tSystem.out.print(A[i] + \" \");\n    \t}\n    }\n}\n\n", "nl": "lilong-dream"}
{"code": "public class L206_Reverse_Linked_List {\n\n\tpublic ListNode reverseList(ListNode head) {\n\n\t\tif (head == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (head.next == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\tListNode tail = head.next;\n\t\tListNode reversed = reverseList(head.next);\n\n\t\ttail.next = head;\n\t\thead.next = null;\n\n\t\treturn reversed;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class CountandSay {\n    public String countAndSay(int n) {\n        String str = \"1\";\n        while (n-- > 1)\n            str = next_seq(str);\n        return str;\n    }\n\n    public String next_seq(String str) {\n        StringBuffer nextstr = new StringBuffer();\n        int count = 1;\n        int i;\n        for (i = 1; i < str.length(); i++) {\n            if (str.charAt(i) == str.charAt(i - 1)) {\n                count++;\n            } else {\n                nextstr.append(count).append(str.charAt(i - 1));\n                count = 1;\n            }\n        }\n        nextstr.append(count).append(str.charAt(i - 1));\n        return nextstr.toString();\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class BinaryTreeInorderTraversal {\n\n    public class Solution {\n        public ArrayList<Integer> inorderTraversal(TreeNode root) {\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            TreeNode p = root;\n            while (p != null) {\n                if (p.left == null) {\n                    ans.add(p.val);\n                    p = p.right;\n                } else {\n                    TreeNode temp = p.left;\n                    while (temp.right != null && temp.right != p) {\n                        temp = temp.right;\n                    }\n                    if (temp.right == null) {\n                        temp.right = p;\n                        p = p.left;\n                    } else {\n                        ans.add(p.val);\n                        temp.right = null;\n                        p = p.right;\n                    }\n                }\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean canJump(int[] A) {\n        if(A.length==0)\n            return true;\n            \n        boolean[] dp = new boolean[A.length];\n        dp[0] = true;\n        for(int i=0;i<dp.length;i++)\n            for(int j=1;j<=A[i] && i+j<dp.length && dp[i]==true &&dp[i+j]!=true;j++)\n                    dp[i+j]=true;\n            \n        return dp[dp.length-1];\n        \n        \n        \n    }\n}", "nl": "azheanda"}
{"code": "public class FindPeakElement {\n\n    public class Solution {\n        public int findPeakElement(int[] num) {\n            assert num.length != 0;\n            for (int i = 0; i < num.length - 1; i++) {\n                if (num[i] > num[i + 1]) {\n                    return i;\n                }\n            }\n            return num.length - 1;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n\n", "nl": "zsxwing"}
{"code": "public class MinimumWindowSubstring\n{\n    public String minWindow( String s, String t )\n    {\n    \tif ( s == null || t == null )\n    \t{\n    \t\treturn \"\";\n    \t}\n    \t\n    \tMap<Character, Integer> tHistogram = new HashMap<>();\n    \tfor ( Character ch : t.toCharArray() )\n    \t{\n    \t\ttHistogram.put( ch, tHistogram.getOrDefault( ch, 0 ) + 1 );\n    \t}\n    \t\n    \tint counter = 0;    \t\n    \tint right = 0;\n    \tint minWinSize = Integer.MAX_VALUE;\n    \tint minWinLeft = 0;\n    \tint minWinRight = 0;\n    \tMap<Character, Integer> sHistogram = new HashMap<>();\n    \tfor ( int left = 0; left < s.length(); left++ )\n    \t{\n    \t\twhile ( counter < t.length() && right < s.length() )\n    \t\t{\n    \t\t\tif ( tHistogram.containsKey( s.charAt( right ) ) )\n    \t\t\t{\n    \t\t\t\tint freqS = sHistogram.getOrDefault( s.charAt( right ), 0 );\n    \t\t\t\tint freqT = tHistogram.get( s.charAt( right ) );\n    \t\t\t\tif ( freqS < freqT )\n    \t\t\t\t{\n    \t\t\t\t\tcounter++;\n    \t\t\t\t}\n    \t\t\t\tsHistogram.put( s.charAt( right ), freqS + 1 );\n    \t\t\t}\t\t\n    \t\t\tright++;\n    \t\t}\n    \t\t\n    \t\tif ( counter == t.length() )\n    \t\t{\n    \t\t\tif ( right - left + 1 < minWinSize )\n    \t\t\t{\n    \t\t\t\tminWinRight = right;\n    \t\t\t\tminWinLeft = left;\n    \t\t\t\tminWinSize = right - left + 1;\n    \t\t\t}\n    \t\t\tif ( tHistogram.containsKey( s.charAt( left ) ) )\n    \t\t\t{\n    \t\t\t\tint freqS = sHistogram.get( s.charAt( left ) );\n    \t\t\t\tint freqT = tHistogram.get( s.charAt( left ) );\n    \t\t\t\tif ( freqS <= freqT )\n    \t\t\t\t{\n    \t\t\t\t\tcounter--;\n    \t\t\t\t}\n    \t\t\t\tsHistogram.put( s.charAt( left ), freqS - 1 );\n    \t\t\t}\n    \t\t}    \t\t\n    \t}\n    \t\n    \treturn s.substring( minWinLeft, minWinRight );\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertEquals( \"BANC\", minWindow( \"ADOBECODEBANC\", \"ABC\" ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix.length == 0 || matrix[0].length == 0) return false;\n        int N = matrix.length,M = matrix[0].length;\n        int left = 0, right = M * N - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int row = mid / M, col = mid % M;\n            if (matrix[row][col] == target) return true;\n            if (matrix[row][col] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return false;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int uniquePaths_1(int m, int n) {\n        if (m == 1  || n == 1) return 1;\n        int t = (m-1)+(n-1);\n        int x = (m > n) ? (m-1) : (n-1);\n        long res = 1;\n        for (int i = t; i > x; i--) res *= i;\n        for (int i = t-x; i > 1; i--) res /= i;\n        return (int)res;\n    }\n    public int uniquePaths_2(int m, int n) {\n        if (m == 1  || n == 1) return 1;\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m; i++)\n            dp[i][0] = 1;\n        for (int j = 0; j < n; j++)\n            dp[0][j] = 1;\n        for (int i = 1; i < m; i++)\n            for (int j = 1; j < n; j++)\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        return dp[m-1][n-1];\n    }\n    public int uniquePaths(int m, int n) {\n        if (m == 1  || n == 1) return 1;\n        int[] dp = new int[n];\n        for (int j = 0; j < n; j++)\n            dp[j] = 1;\n        for (int i = 1; i < m; i++)\n            for (int j = 1; j < n; j++)\n                dp[j] = dp[j] + dp[j-1];\n        return dp[n-1];\n    }\n}", "nl": "leetcoders"}
{"code": "public class Combinations {\n\n    public class Solution {\n\n        private void search(int start, int end, int k,\n                ArrayDeque<Integer> queue, ArrayList<ArrayList<Integer>> ans) {\n            if (k == 0) {\n                ans.add(new ArrayList<Integer>(queue));\n                return;\n            }\n\n            for (int i = start; i <= end - k + 1; i++) {\n                queue.offerLast(i);\n                search(i + 1, end, k - 1, queue, ans);\n                queue.removeLast();\n            }\n        }\n\n        public ArrayList<ArrayList<Integer>> combine(int n, int k) {\n            ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n            search(1, n, k, new ArrayDeque<Integer>(), ans);\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MergeSortedArray {\n  public static void main(String[] args) throws Exception {\n    int[] A = {0};\n    int[] B = {1};\n    new MergeSortedArray().merge(A, 0, B, 1);\n    for (int i : A) System.out.println(i);\n  }\n\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m + n - 1, j = m - 1, k = n - 1;\n    while (j >= 0 && k >= 0) nums1[i--] = (nums1[j] > nums2[k]) ? nums1[j--] : nums2[k--];\n    while (k >= 0) nums1[i--] = nums2[k--];\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class MajorityElement {\n\n    public class Solution {\n        public int majorityElement(int[] num) {\n            int majority = num[0];\n            int count = 1;\n            for (int i = 1; i < num.length; i++) {\n                if (majority != num[i]) {\n                    count--;\n                    if (count == 0) {\n                        majority = num[++i];\n                        count = 1;\n                    }\n                } else {\n                    count++;\n                }\n            }\n            return majority;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean isValid(String s) {\n        if (s == null || s.length() == 0) {\n            return true;\n        }\n        if (s.length() % 2 != 0) {\n            return false;\n        }\n        Stack<Character> stack = new Stack<Character>();\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(' || c == '[' || c == '{') {\n                stack.push(c);\n            } else if (c ==')' || c == ']' || c == '}') {\n                if (stack.isEmpty()) {\n                    return false;\n                }   \n                char front = stack.pop();\n                if (c == ')' && front != '(') {\n                    return false;\n                }\n                if (c == ']' && front != '[') {\n                    return false;\n                }\n                if (c == '}' && front != '{') {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class MaximumSubarray {\n\n    public class Solution {\n        public int maxSubArray(int[] A) {\n            int sum = A[0];\n            int maxSum = A[0];\n            for (int i = 1; i < A.length; i++) {\n                sum = Math.max(sum + A[i], A[i]);\n                maxSum = Math.max(maxSum, sum);\n            }\n            return maxSum;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\n        if (beginWord==null||endWord==null||wordList==null||beginWord.equals(endWord)||beginWord.length()!=endWord.length()) {\n            return 0;\n        }\n        Map<String,List<String>> map=new HashMap<String, List<String>>();\n        int count=1;\n        wordList.add(beginWord);\n        wordList.add(endWord);\n        for (String str:wordList) {\n            count++;\n            List<String> list=new ArrayList<String>();\n            char[] cs=str.toCharArray();\n            for (int i = 0; i < cs.length; i++) {\n                char k=cs[i];\n                for (char j = 'a'; j <='z'; j++) {\n                    if (j!=k) {\n                        cs[i]=j;\n                        String test=String.valueOf(cs);\n                        if (wordList.contains(test)) {\n                            list.add(test);\n                        }\n                    }\n                }\n                cs[i]=k;\n            }\n            map.put(str, list);\n        }\n        Map<String,Integer> test=new HashMap<String, Integer>();\n        test.put(beginWord, 1);\n        for (int i = 1; i < count; i++) {\n            Map<String,Integer> newTest=new HashMap<String, Integer>();\n            for (String str:test.keySet()) {\n                List<String> list=map.get(str);\n                for (int j = 0; j < list.size(); j++) {\n                    String k=list.get(j);\n                    if (k.equals(endWord)) {\n                        return i+1;\n                    }\n                    if (test.get(k)==null&&newTest.get(k)==null) {\n                        newTest.put(k, 1);\n                    }\n                }\n            }\n            test=newTest;\n        }\n        return 0;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class TrappingRainWater {\n  \n  public static void main(String[] args) throws Exception {\n    int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    System.out.println(new TrappingRainWater().trap(height));\n  }\n\n  private int trap(int[] height) {\n    if (height.length == 0) return 0;\n\n    int[] left = new int[height.length];\n    int[] right = new int[height.length];\n    int max = 0;\n    left[0] = 0;\n    right[height.length - 1] = 0;\n\n    int total = 0;\n\n    for (int i = 1, l = height.length; i < l; i++) {\n      left[i] = Math.max(max, height[i - 1]);\n      max = left[i];\n    }\n    max = 0;\n    for (int i = height.length - 2; i >= 0; i--) {\n      right[i] = Math.max(max, height[i + 1]);\n      max = right[i];\n    }\n    for (int i = 0, l = height.length; i < l; i++) {\n      int min = Math.min(left[i], right[i]);\n      if (min > height[i]) {\n        total += (min - height[i]);\n      }\n    }\n    return total;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public String addBinary(String a, String b) {\n        StringBuffer res = new StringBuffer();\n        int N = a.length(), M = b.length();\n        int i = N - 1, j = M - 1;\n        int carry = 0;\n        while (i>=0 || j>=0) {\n            int sum = carry;\n            if (i >= 0) sum += a.charAt(i--) - '0';\n            if (j >= 0) sum += b.charAt(j--) - '0';\n            carry = sum / 2;\n            res.insert(0,String.valueOf(sum % 2));\n        }\n        if (carry == 1) res.insert(0,'1');\n        return res.toString();\n    }\n}", "nl": "leetcoders"}
{"code": "public class BinaryTreeInorderTraversal {\n  public ArrayList<Integer> inorderTraversal(TreeNode root) {\n    ArrayList<Integer> inOrder = new ArrayList<Integer>();\n    if (root == null) return inOrder;\n    Stack<TreeNode> s = new Stack<TreeNode>();\n    s.add(root);\n    TreeNode p = root.left;\n    while (!s.empty()) {\n      while (p != null) {\n        s.add(p);\n        p = p.left;\n      }\n      TreeNode n = s.pop();\n      inOrder.add(n.val);\n      p = n.right;\n      if (p != null) {\n        s.add(p);\n        p = p.left;\n      }\n    }\n    return inOrder;\n  }\n}\n", "nl": "mengli"}
{"code": "public class ImplementStrStr {\n\n  \npublic int strStr(String haystack, String needle) {\n  if (needle.isEmpty()) {\n    return 0;\n  }\n  int m = haystack.length();\n  int n = needle.length();\n  for (int i = 0; i <= m - n; i++) {\n    for (int j = 0; j < n; j++) { // Compare each char with needle from the beginning\n      if (haystack.charAt(i + j) != needle.charAt(j)) {\n        break;\n      }\n      if (j == n - 1) { // Found all n characters\n        return i;\n      }\n    }\n  }\n  return -1; // Not found\n}\n}", "nl": "FreeTymeKiyan"}
{"code": "public class InsertInterval {\n\n  public static class Interval {\n    int start;\n    int end;\n\n    Interval() {\n      start = 0;\n      end = 0;\n    }\n\n    Interval(int s, int e) {\n      start = s;\n      end = e;\n    }\n  }\n  \n  public static void main(String[] args) throws Exception {\n    Interval i1 = new Interval(1, 2);\n    Interval i2 = new Interval(3, 5);\n    Interval i3 = new Interval(6, 7);\n    Interval i4 = new Interval(8, 10);\n    Interval i5 = new Interval(12, 16);\n    List<Interval> list = Arrays.asList(i1, i2, i3, i4, i5);\n    List<Interval> result = new InsertInterval().insert(list, new Interval(2, 5));\n    result.stream().map(x -> x.start + \" \" + x.end).forEach(System.out::println);\n  }\n\n  public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n    List<Interval> result = new ArrayList<>();\n    for (int i = 0, l = intervals.size(); i < l; i++) {\n      Interval curr = intervals.get(i);\n      if (newInterval.start >= curr.start && newInterval.end <= curr.end) {\n        insertRest(intervals, result, i);\n        return result; // easy case\n      } else if (newInterval.start < curr.start && newInterval.end > curr.end) {\n        newInterval = new Interval(newInterval.start, newInterval.end);\n      } else if (newInterval.start >= curr.start\n          && newInterval.start <= curr.end\n          && newInterval.end > curr.end) {\n        newInterval = new Interval(curr.start, newInterval.end);\n      } else if (newInterval.start < curr.start\n          && newInterval.end >= curr.start\n          && newInterval.end <= curr.end) {\n        Interval newI = new Interval(newInterval.start, curr.end);\n        result.add(newI);\n        insertRest(intervals, result, i + 1);\n        return result;\n      } else if (newInterval.start > curr.end) {\n        result.add(curr);\n      } else {\n        result.add(newInterval);\n        insertRest(intervals, result, i);\n        return result;\n      }\n    }\n    result.add(newInterval);\n    return result;\n  }\n\n  private void insertRest(List<Interval> intervals, List<Interval> result, int i) {\n    int l = intervals.size();\n    while (i < l) {\n      result.add(intervals.get(i));\n      i++;\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class WordSearch {\n\n  \n  public boolean exist(char[][] board, String word) {\n    if (board == null || board.length == 0 || board[0].length == 0 || word == null) {\n      return false;\n    }\n    if (word.length() == 0) {\n      return true;\n    }\n\n    for (int i = 0; i < board.length; i++) {\n      for (int j = 0; j < board[0].length; j++) {\n        if (board[i][j] == word.charAt(0)) { // Match the first character.\n          if (backtrack(board, i, j, word, 0)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  \n  private boolean backtrack(char[][] board, int i, int j, String word, int pos) {\n    if (word.length() == pos) {\n      return true;\n    }\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(pos)) {\n      return false;\n    }\n    board[i][j] = '#'; // Instead of using another 2D boolean array, mark board with a special character to set as visited.\n    boolean res = backtrack(board, i - 1, j, word, pos + 1)\n        || backtrack(board, i + 1, j, word, pos + 1)\n        || backtrack(board, i, j - 1, word, pos + 1)\n        || backtrack(board, i, j + 1, word, pos + 1);\n    board[i][j] = word.charAt(pos);// Reset.\n    return res;\n  }\n\n  public boolean exist2(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n      for (int j = 0; j < board[i].length; j++) {\n        if (board[i][j] == word.charAt(0)) {\n          if (backtrack(board, word, 0, i, j)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  \n  private boolean backtrack(char[][] board, String word, int pos, int i, int j) {\n    if (word.charAt(pos) == board[i][j] && pos == word.length() - 1) {\n      return true;\n    }\n    if (word.charAt(pos) != board[i][j]) {\n      return false;\n    }\n    board[i][j] = '#'; // Mark visited.\n    boolean res = false;\n    if (!res && i + 1 < board.length && board[i + 1][j] != '#') {\n      res = res || backtrack(board, word, pos + 1, i + 1, j);\n    }\n    if (!res && i - 1 >= 0 && board[i - 1][j] != '#') {\n      res = res || backtrack(board, word, pos + 1, i - 1, j);\n    }\n    if (!res && j + 1 < board[i].length && board[i][j + 1] != '#') {\n      res = res || backtrack(board, word, pos + 1, i, j + 1);\n    }\n    if (!res && j - 1 >= 0 && board[i][j - 1] != '#') {\n      res = res || backtrack(board, word, pos + 1, i, j - 1);\n    }\n    board[i][j] = word.charAt(pos); // Reset.\n    return res;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Subsets {\n  public ArrayList<ArrayList<Integer>> subsets(int[] S) {\n    Arrays.sort(S);\n    ArrayList<ArrayList<Integer>> subsets = new ArrayList<ArrayList<Integer>>();\n    subsets.add(new ArrayList<Integer>());\n    for (int i = 0; i < S.length; i++) {\n      int size = subsets.size();\n      for (int j = 0; j < size; j++) {\n        ArrayList<Integer> subset = new ArrayList<Integer>(subsets.get(j));\n        subset.add(S[i]);\n        subsets.add(subset);\n      }\n    }\n    return subsets;\n  }\n}\n", "nl": "mengli"}
{"code": "public class FlattenBinaryTreetoLinkedList {\n\tpublic void flatten(TreeNode root) {\n\t\tif (root != null) {\n\t\t\twhile (root.left != null || root.right != null) {\n\t\t\t\tif (root.left != null) {\n\t\t\t\t\tTreeNode rightmost = root.left;\n\t\t\t\t\tTreeNode right = root.left;\n\t\t\t\t\tTreeNode temp = root.right;\n\t\t\t\t\twhile (rightmost.right != null) {\n\t\t\t\t\t\trightmost = rightmost.right;\n\t\t\t\t\t}\n\t\t\t\t\trightmost.right = temp;\n\t\t\t\t\troot.right = right;\n\t\t\t\t\troot.left = null;\n\t\t\t\t\troot = root.right;\n\t\t\t\t} else\n\t\t\t\t\troot = root.right;\n\t\t\t}\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class HouseRobber3 {\n\tpublic int rob(int[] nums) {\n\t\tif (nums.length < 1)\n\t\t\treturn 0;\n\t\telse if (nums.length < 2)\n\t\t\treturn nums[0];\n\t\tint beforePrevious = nums[0], previous = Math.max(beforePrevious, nums[1]);\n\t\tfor (int i = 2; i < nums.length; i++) {\n\t\t\tif (previous > beforePrevious + nums[i]) {\n\t\t\t\tbeforePrevious = previous;\n\t\t\t} else {\n\t\t\t\tint temp = previous;\n\t\t\t\tprevious = beforePrevious + nums[i];\n\t\t\t\tbeforePrevious = temp;\n\t\t\t}\n\t\t}\n\t\treturn Math.max(previous, beforePrevious);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int strStr_1(String haystack, String needle) {\n        int sLen = haystack.length(), tLen = needle.length();\n        if(tLen == 0) return 0;\n        if (haystack==null || needle==null || sLen==0) return -1;\n        int i = 0, j = 0;\n        while (i < sLen) {\n            for (j = 0; j < tLen && (i+j) < sLen && haystack.charAt(i+j) == needle.charAt(j); ++j);\n            if (j == tLen) return i;\n            ++i;\n        }\n        return (int)-1;\n    }\n    void getNext(String T, int[] next){\n        int i=0, j=-1;\n        next[0]=-1;\n        int n = next.length;\n        while(i < n - 1){\n            while(j>-1&&T.charAt(j)!=T.charAt(i)) j = next[j];\n            ++i; ++j;\n            if(i < n - 1 && j < n - 1 && T.charAt(j)==T.charAt(i)) next[i]=next[j];\n            else next[i]=j;\n        }\n    }\n    public int strStr_2(String haystack, String needle) {\n        int sLen = haystack.length(), tLen = needle.length();\n        if(tLen == 0) return 0;\n        if (haystack==null || needle==null || sLen==0) return -1;\n        int[] next = new int[tLen+1];\n        getNext(needle, next);\n        int i = 0, j = 0;\n        while (i < sLen) {\n            while (j > -1 && needle.charAt(j) != haystack.charAt(i)) j = next[j];\n            ++i; ++j;\n            if (j == tLen) return i - j;\n        }\n        return -1;\n    }\n    public int strStr_3(String haystack, String needle) {\n        int sLen = haystack.length(), tLen = needle.length();\n        if (tLen == 0) return 0;\n        if (haystack==null || needle==null || sLen==0 || sLen < tLen) return -1;\n        long fh = 0, fn = 0;\n        int head = 0, tail = tLen - 1;\n        for (int i = 0; i < tLen; ++i) {\n            fh += haystack.charAt(i);\n            fn += needle.charAt(i);\n        }\n        while (tail < sLen) {\n            if (fn == fh) {\n                int i = 0;\n                while (i < tLen && needle.charAt(i) == haystack.charAt(i + head)){\n                    ++i;\n                }\n                if (i == tLen) return head;\n            }\n            if (tail == sLen - 1) return -1;\n            fh -= haystack.charAt(head++);\n            fh += haystack.charAt(++tail);\n        }\n        return -1;\n    }\n}", "nl": "leetcoders"}
{"code": "public class ClimbingStairs {\n  \n  public static void main(String[] args) throws Exception {}\n\n  public int climbStairs(int n) {\n    if (n == 0 || n == 1) return 1;\n    int[] A = new int[n + 1];\n    A[n] = 1;\n    A[n - 1] = 1;\n    for (int i = n - 2; i >= 0; i--) A[i] = A[i + 1] + A[i + 2];\n    return A[0];\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class ReverseLinkedList {\n\n  \n  public ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) { // Empty list or just 1 node.\n      return head;\n    }\n    \n    ListNode newHead = reverseList(head.next);\n    head.next.next = head; // Connect next node with current node.\n    head.next = null; // Disconnect current node.\n    return newHead;\n  }\n\n  \n  public ListNode reverseList2(ListNode head) {\n    ListNode newHead = null;\n    while (head != null) {\n      ListNode next = head.next;\n      head.next = newHead;\n      newHead = head;\n      head = next;\n    }\n    return newHead;\n  }\n\n  \n  public ListNode reverseList3(ListNode head) {\n    ListNode cur = head;\n    ListNode prev = null;\n    while (cur != null) {\n      ListNode next = cur.next;\n      cur.next = prev;\n      prev = cur;\n      cur = next;\n    }\n    return prev;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class InsertionSortList\n{\n    public ListNode insertionSortList(ListNode head)\n    {\n        return null;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class L068_Text_Justification {\n\n\tString space(int len) {\n\t\tchar[] s = new char[len];\n\t\tArrays.fill(s, ' ');\n\t\treturn new String(s);\n\t}\n\n\tpublic List<String> fullJustify(String[] words, int L) {\n\n\t\tArrayList<String> text = new ArrayList<String>();\n\n\t\tint p = 0;\n\t\tint lastp = 0;\n\t\twhile (p < words.length) {\n\n\t\t\tif (L == 0 && \"\".equals(words[p])) {\n\t\t\t\ttext.add(\"\");\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint l = 0;\n\t\t\twhile (l < L && p < words.length) {\n\t\t\t\tl += words[p++].length() + 1;\n\t\t\t}\n\n\t\t\tif (l - 1 > L)\n\t\t\t\tl -= words[--p].length() + 1;\n\n\t\t\tint count = p - lastp;\n\t\t\tint left = L - l + count;\n\n\t\t\tint add;\n\t\t\tif (count == 1)\n\t\t\t\tadd = left;\n\t\t\telse if (p - 1 == words.length - 1) {\n\t\t\t\tadd = 1;\n\t\t\t\tleft = count - 1;\n\t\t\t} else\n\t\t\t\tadd = left / (count - 1);\n\n\t\t\tleft -= add * (count - 1);\n\n\t\t\tString s = \"\";\n\t\t\tfor (int i = lastp; i < p - 1; i++) {\n\t\t\t\tif (left > 0) {\n\t\t\t\t\ts += words[i] + space(add + 1);\n\t\t\t\t\tleft--;\n\t\t\t\t} else {\n\t\t\t\t\ts += words[i] + space(add);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tleft = L - s.length() - words[p - 1].length();\n\n\t\t\tif (count == 1 || p - 1 == words.length - 1)\n\t\t\t\ts += words[p - 1] + space(left);\n\t\t\telse\n\t\t\t\ts += space(left) + words[p - 1];\n\n\t\t\ttext.add(s);\n\t\t\tlastp = p;\n\t\t}\n\n\t\treturn text;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class CombinationSum {\n\tpublic ArrayList<ArrayList<Integer>> combinationSum(int[] candidates, int target) {\n\t\tArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\t\tif (candidates == null || candidates.length == 0)\n\t\t\treturn res;\n\t\tArrays.sort(candidates);\n\t\thelper(candidates, 0, target, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\n\tprivate void helper(int[] candidates, int start, int target, ArrayList<Integer> item,\n\t\t\tArrayList<ArrayList<Integer>> res) {\n\t\tif (target < 0)\n\t\t\treturn;\n\t\tif (target == 0) {\n\t\t\tres.add(new ArrayList<Integer>(item));\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = start; i < candidates.length; i++) {\n\t\t\tif (i > 0 && candidates[i] == candidates[i - 1])\n\t\t\t\tcontinue;\n\t\t\titem.add(candidates[i]);\n\t\t\thelper(candidates, i, target - candidates[i], item, res);\n\t\t\titem.remove(item.size() - 1);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class SearchInRotatedSortedArray {\n\tpublic int search(int[] A, int target) {\n\t\tint left = 0;\n\t\tint right = A.length - 1;\n\n\t\twhile (left <= right) {\n\t\t\tint mid = (left + right) / 2;\n\n\t\t\tif (A[mid] == target) {\n\t\t\t\treturn mid;\n\t\t\t}\n\n\t\t\tif (A[mid] >= A[left]) { \n\t\t\t\tif (A[mid] > target && A[left] <= target) {\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tleft = mid + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (A[mid] < target && A[right] >= target) {\n\t\t\t\t\tleft = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = { 3, 1, 2 };\n\n\t\tSearchInRotatedSortedArray slt = new SearchInRotatedSortedArray();\n\t\tSystem.out.println(slt.search(a, 1));\n\t\tSystem.out.println(slt.search(a, 4));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast.next != null && fast.next.next != null) {\n            if (slow == fast) {\n                return true;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow == fast;\n    }\n}\n\n\n    \n", "nl": "awangdev"}
{"code": "public class _437_pathSum {\n    public static void main(String[] args) {\n        _437_pathSum pathSum = new _437_pathSum();\n        TreeNode root = new TreeNode(10);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(-3);\n        root.left.left = new TreeNode(3);\n        root.left.right = new TreeNode(2);\n        root.right.right = new TreeNode(11);\n        root.left.left.left = new TreeNode(3);\n        root.left.left.right = new TreeNode(-2);\n        root.left.right.left = new TreeNode(1);\n        System.out.println(pathSum.pathSum(root, 8));\n        TreeNode r1 = new TreeNode(-2);\n        r1.right = new TreeNode(-3);\n        System.out.println(pathSum.pathSum(r1, -5));\n        TreeNode r2 = new TreeNode(1);\n        r2.left = new TreeNode(-2);\n        r2.right = new TreeNode(-3);\n        r2.left.left = new TreeNode(1);\n        r2.left.right = new TreeNode(3);\n        r2.left.left.left = new TreeNode(-1);\n        r2.right.left = new TreeNode(-2);\n        System.out.println(pathSum.pathSum(r2, 3));\n        TreeNode r3 = new TreeNode(0);\n        r3.left = new TreeNode(1);\n        r3.right = new TreeNode(1);\n        System.out.println(pathSum.pathSum(r3, 1));\n    }\n\n    int result = 0;\n\n    \n    public int pathSum(TreeNode root, int sum) {\n        result = 0;\n        List<TreeNode> list = new LinkedList<>();\n        dfs(root, list, sum);\n        return result;\n    }\n\n    private void dfs(TreeNode root, List<TreeNode> list, int sum) {\n        if (root == null) return;\n        int tempSum = 0;\n        list.add(root);\n        for (int i = list.size() - 1; i >= 0; i--) {\n            tempSum += list.get(i).val;\n            if (tempSum == sum) {\n                result++;\n            }\n        }\n        dfs(root.left, list, sum);\n        dfs(root.right, list, sum);\n        list.remove(root);\n    }\n\n}\n", "nl": "pphdsny"}
{"code": "public class RotateImage2 {\n\tpublic void rotate(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n / 2; i++) {\n\t\t\tfor (int j = 0; j < Math.ceil(((double) n) / 2.); j++) {\n\t\t\t\tint temp = matrix[i][j];\n\t\t\t\tmatrix[i][j] = matrix[n - 1 - j][i];\n\t\t\t\tmatrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\n\t\t\t\tmatrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\n\t\t\t\tmatrix[j][n - 1 - i] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int numTrees(int n) {\n        return f(n,new HashMap<Integer, Integer>());\n    }\n    public int f(int n,Map<Integer,Integer> map){\n        if (map.get(n)!=null) {\n            return map.get(n);\n        }else {\n            \n            if (n==1||n==0) {\n                return 1;\n            }else {\n                int sum=0;\n                for (int i = 0; i < n; i++) {\n                    int left=f(i,map);\n                    int right=f((n-1-i),map);\n                    sum+=(left*right);\n                }\n                map.put(n,sum);\n                return sum;\n            }\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class ConvertSortedListtoBinarySearchTree2 {\n\tpublic TreeNode sortedListToBST(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn null;\n\t\tint len = getLength(head);\n\t\treturn sortedListToBST(head, 0, len - 1);\n\t}\n\n\tpublic int getLength(ListNode head) {\n\t\tint len = 0;\n\t\tListNode p = head;\n\t\twhile (p != null) {\n\t\t\tlen++;\n\t\t\tp = p.next;\n\t\t}\n\t\treturn len;\n\t}\n\n\tpublic TreeNode sortedListToBST(ListNode head, int start, int end) {\n\t\tif (start > end)\n\t\t\treturn null;\n\t\tint mid = (start + end) / 2;\n\t\tListNode p = head;\n\t\t@SuppressWarnings(\"unused\")\n\t\tListNode prev = head,fast=head;\n\t\twhile (fast!=null&&fast.next!=null) {\n\t\t\tprev = p;\n\t\t\tfast=fast.next.next;\n\t\t\tp = p.next;\n\t\t}\n\t\tprev = null;\n\t\tTreeNode root = new TreeNode(p.val);\n\t\tTreeNode left = sortedListToBST(head, start, mid - 1);\n\t\tTreeNode right = sortedListToBST(p.next, mid + 1, end);\n\t\troot.left = left;\n\t\troot.right = right;\n\t\treturn root;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int largestRectangleArea(int[] height) {\n        Stack<Pair> stack = new Stack<Pair>();\n        int max_area=0;\n        int pos=0;\n\n        for(pos=0;pos<height.length;pos++){\n            int start = pos;\n        \twhile(true){\n        \t\tif(stack.empty() || height[pos]>stack.peek().height)\n        \t\t\tstack.push(new Pair(height[pos],start));\n        \t\telse if(!stack.empty() && height[pos]<stack.peek().height){\n        \t\t\tmax_area = Math.max(max_area,stack.peek().height*(pos-stack.peek().start));\n        \t\t\tstart = stack.pop().start;\n        \t\t\tcontinue;\n        \t\t}\n        \t\tbreak;\n        \t}\n\n        }\n\n        while(!stack.empty()){\n        \tPair p = stack.pop();\n        \tmax_area = Math.max(max_area,p.height*(pos-p.start));//pos=height.length\n        }\n        return max_area;\n\n    }\n\n    private class Pair{\n    \tpublic int height;\n    \tpublic int start;\n    \tpublic Pair(int height,int start){\n    \t\tthis.height = height;\n    \t\tthis.start = start;\n    \t}\n    }\n\n}", "nl": "azheanda"}
{"code": "public class MaximumDepthofBinaryTree\n{\n    public int maxDepth( TreeNode root )\n    {\n    \tint[] max = new int[1];\n    \tmaxDepthUpdateAtChild( root, 1, max );\n    \treturn max[0];\n    }\n    \n    private void maxDepthUpdateAtChild( TreeNode root, int depth, int[] max )\n    {\n    \tif ( root == null )\n    \t{\n    \t\treturn;\n    \t}\n    \t\n    \tmax[0] = Math.max( max[0], depth );\n    \t\n    \tmaxDepthUpdateAtChild( root.left, depth + 1, max );\n    \tmaxDepthUpdateAtChild( root.right, depth + 1, max );\n    }\n    \n    public int maxDepth2( TreeNode root )\n    {\n    \treturn maxDepthUpdateAtParent( root, 1 );\n    }\n    \n    private int maxDepthUpdateAtParent( TreeNode root, int depth )\n    {\n    \tif ( root == null )\n    \t{\n    \t\treturn depth - 1;\n    \t}\n    \t\n    \treturn Math.max( maxDepthUpdateAtParent( root.left, depth + 1 ),\n    \t\t\t\t\t maxDepthUpdateAtParent( root.right, depth + 1 ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class SameTree {\n\n}\n", "nl": "FreemanZhang"}
{"code": "public class Subsets {\n\n  \n  public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> res = new ArrayList<>();\n    backtrack(res, nums, 0, new ArrayList<>());\n    return res;\n  }\n\n  private void backtrack(List<List<Integer>> res, int[] nums, int pos, List<Integer> subset) {\n    if (pos == nums.length) {\n      res.add(new ArrayList<>(subset));\n      return;\n    }\n    backtrack(res, nums, pos + 1, subset); // Without current number.\n    subset.add(nums[pos]);\n    backtrack(res, nums, pos + 1, subset); // With current number.\n    subset.remove(subset.size() - 1); // Reset.\n  }\n\n  \n  public List<List<Integer>> subsets2(int[] nums) {\n    List<List<Integer>> res = new ArrayList<>();\n    subsets2(res, nums, 0, new ArrayList<>());\n    return res;\n  }\n\n  \n  public void subsets2(List<List<Integer>> subsets, int[] nums, int pos, List<Integer> set) {\n    subsets.add(new ArrayList<>(set)); // Dereference and add current subset to result.\n    for (int i = pos; i < nums.length; i++) {\n      set.add(nums[i]);\n      subsets2(subsets, nums, i + 1, set); // Backtrack to generate add subsets with s[i].\n      set.remove(set.size() - 1); // Remove s[i], next round there won't be s[i].\n    }\n  }\n\n  \n  public List<List<Integer>> subsets3(int[] nums) {\n    List<List<Integer>> subsets = new ArrayList<>();\n    subsets.add(new ArrayList<>()); // Add empty set.\n    for (int i = 0; i < nums.length; i++) {\n      int n = subsets.size();\n      for (int j = 0; j < n; j++) {\n        List<Integer> set = new ArrayList<>(subsets.get(j)); // Dereference.\n        set.add(nums[i]);\n        subsets.add(set);\n      }\n    }\n    return subsets;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class MinStack3 {\n    List<Integer> s = new LinkedList();\n    List<Integer> min = new LinkedList();\n\n    public void push(int x) {\n        if (min.isEmpty()) min.add(x);\n        else if (x <= min.get(min.size() - 1)) min.add(x);\n        s.add(x);\n    }\n\n    public void pop() {\n        if (s.size() < 1) return;\n        if (top() == min.get(min.size() - 1))\n            min.remove(min.size() - 1);\n        s.remove(s.size() - 1);\n    }\n\n    public int top() {\n        if (s.size() < 1) return 0;\n        return s.get(s.size() - 1);\n    }\n\n    public int getMin() {\n        return min.get(min.size() - 1);\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class SearchinRotatedSortedArray {\n  public int search(int[] A, int target) {\n    int low = 0;\n    int high = A.length - 1;\n    int mid = 0;\n    while (low <= high) {\n      mid = (low + high) / 2;\n      if (A[mid] == target) return mid;\n      else {\n        if (A[low] <= A[mid]) {\n          if (target >= A[low] && target < A[mid]) {\n            high = mid - 1;\n          } else {\n            low = mid + 1;\n          }\n        } else {\n          if (target <= A[high] && target > A[mid]) {\n            low = mid + 1;\n          } else {\n            high = mid - 1;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n}\n", "nl": "mengli"}
{"code": "public class SubsetsII {\n\n}\n", "nl": "gaohannk"}
{"code": "public class ValidParentheses \n{\n    public boolean isValid( String s )\n    {\n        Stack<Character> stack = new Stack<>();\n        Map<Character, Character> openToClose = new HashMap<>();\n        openToClose.put( '(', ')' );\n        openToClose.put( '[', ']' );\n        openToClose.put( '{', '}' );\n        \n        for ( char ch : s.toCharArray() )\n        {\n        \tif ( openToClose.containsKey( ch ) )\n        \t{\n        \t\tstack.push( ch );\n        \t}\n        \telse\n        \t{\n        \t\tif ( stack.isEmpty() || ch != openToClose.get( stack.peek() ) )\n        \t\t{\n        \t\t\treturn false;\n        \t\t}\n        \t\tstack.pop();\n        \t}\n        }\n        \n        return stack.size() == 0;\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertFalse( isValid( \"(]\" ) );\n    \tassertFalse( isValid( \"([)]\" ) );\n    \tassertTrue( isValid( \"()[]{}\" ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head==null) {\n            return head;\n        }\n        List<ListNode> list=zuhe(head, new ArrayList<ListNode>());\n        for (int i = list.size()-1; i >0; i--) {\n            list.get(i).next=list.get(i-1);\n        }\n        list.get(0).next=null;\n        return list.get(list.size()-1);\n    }\n    \n    public List<ListNode> zuhe(ListNode head,List<ListNode> list){\n        if (head!=null) {\n            list.add(head);\n            list=zuhe(head.next,list);\n        }\n        return list;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MergekSortedLists2 {\n\tpublic ListNode mergeKLists(ArrayList<ListNode> lists) {\n\t\tif (lists == null || lists.size() == 0)\n\t\t\treturn null;\n\t\treturn helper(lists, 0, lists.size() - 1);\n\t}\n\n\tprivate ListNode helper(ArrayList<ListNode> lists, int l, int r) {\n\t\tif (l < r) {\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn mergeTwoLists(helper(lists, l, m), helper(lists, m + 1, r));\n\t\t}\n\t\treturn lists.get(l);\n\t}\n\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tListNode newhead = new ListNode(0);\n\t\tListNode p = newhead;\n\t\twhile (l1 != null && l2 != null) {\n\t\t\tif (l1.val > l2.val) {\n\t\t\t\tp.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t} else {\n\t\t\t\tp.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}\n\t\t\tp = p.next;\n\t\t}\n\t\tif (l1 == null)\n\t\t\tp.next = l2;\n\t\telse\n\t\t\tp.next = l1;\n\t\treturn newhead.next;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if (n <= 1) return 0;\n        int res = 0, minVal = prices[0];\n        for (int i = 1; i < n; ++i) {\n            res = Math.max(res, prices[i] - minVal);\n            minVal = Math.min(minVal, prices[i]);\n        }\n        return res;\n    }\n}\n", "nl": "leetcoders"}
{"code": "public class WordBreak {\n  public boolean wordBreak(String s, Set<String> dict) {\n    Map<String, Boolean> wordMap = new HashMap<String, Boolean>();\n    for (String w : dict) {\n      wordMap.put(w, true);\n    }\n    int len = s.length();\n    boolean[] strMap = new boolean[len + 1];\n    strMap[0] = true;\n    for (int i = 1; i <= len; i++) {\n      for (int j = 0; j < i; j++) {\n        if (strMap[j] && wordMap.containsKey(s.substring(j, i))) {\n          strMap[i] = true;\n        }\n      }\n    }\n    return strMap[len];\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public int[] searchRange(int[] A, int target) {\n        int[] rst = new int[]{-1, -1};\n        if (A == null || A.length == 0) {\n            return rst;\n        }\n        int start = 0;\n        int end = A.length - 1;\n        int mid = start + (end - start)/2;\n\n        int first = 0;\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            if (A[mid] == target) {\n                if (mid - 1 >= 0 && A[mid - 1] == target) {\n                    end = mid;\n                    continue;\n                }\n                break;\n            } else if (A[mid] < target) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        if (A[start] == target) {\n            first = start;\n        } else if (A[mid] == target) {\n            first = mid;\n        } else if (A[end] == target) {\n            first = end;\n        } else {\n            return rst;\n        }\n        rst[0] = first;\n\n        int last = 0;\n        start = first;\n        end = A.length - 1;\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            if (A[mid] == target) {\n                if (mid + 1 < A.length && A[mid + 1] == target) {\n                    start = mid;\n                    continue;\n                }\n                break;\n            } else if (A[mid] < target) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        if (A[end] == target) {\n            last = end;\n        } else if (A[mid] == target) {\n            last = mid;\n        } else if (A[start] == target) {\n            last = start;\n        } else {\n            last = first;\n        }\n        rst[1] = last;\n        \n        return rst;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class L069_Sqrt_x {\n\n\tpublic int mySqrt(int x) {\n\n\t\tif (x < 0) {\n\t\t\treturn -1;\n\t\t} else if (x == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint start = 1;\n\t\tint end = x;\n\n\t\twhile (start < end) {\n\n\t\t\tint m = start + (end - start) / 2;\n\n\t\t\tint m1 = x / m;\n\t\t\tint m2 = x / (m + 1);\n\n\t\t\tif (m == m1) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t\tif (m + 1 == m2) {\n\t\t\t\treturn m + 1;\n\t\t\t}\n\n\t\t\tif (m < m1 && m + 1 > m2) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t\tif (m1 < m) {\n\t\t\t\tend = m;\n\t\t\t} else {\n\t\t\t\tstart = m + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn 1;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class Solution {\n    public boolean wordBreak(String s, List<String> dict) {\n        if (s == null || s.length() == 0 || dict == null || dict.size() == 0) return false;\n\n        Set<String> words = new HashSet<>(dict);\n        int n = s.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < i; j++) {\n                dp[i] |= dp[j] && words.contains(s.substring(j, i));\n                if (dp[i]) break;\n            }\n        }\n        \n        return dp[n];\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class L088_Merge_Sorted_Array {\n\n\tpublic int help(int[] nums, int k) {\n\n\t\tif (k < 0) {\n\t\t\treturn Integer.MIN_VALUE;\n\t\t}\n\n\t\treturn nums[k];\n\t}\n\n\tpublic void merge(int[] nums1, int m, int[] nums2, int n) {\n\n\t\tif (nums1 == null || nums2 == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint t = m + n - 1;\n\n\t\twhile (t >= 0) {\n\n\t\t\tint n1 = help(nums1, m - 1);\n\t\t\tint n2 = help(nums2, n - 1);\n\n\t\t\tif (n1 > n2) {\n\t\t\t\tnums1[t] = n1;\n\t\t\t\tm--;\n\t\t\t} else {\n\t\t\t\tnums1[t] = n2;\n\t\t\t\tn--;\n\t\t\t}\n\n\t\t\tt--;\n\t\t}\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class LongestPalindromicSubstring2 {\n\tpublic static String longestPalindrome(String s) {\n\t\tif (s == null || s.length() <= 1)\n\t\t\treturn s;\n\n\t\tint maxLen = 0;\n\t\tString longestStr = null;\n\t\tint length = s.length();\n\n\t\tint[][] table = new int[length][length];\n\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\ttable[i][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= length - 2; i++) {\n\t\t\tif (s.charAt(i) == s.charAt(i + 1)) {\n\t\t\t\ttable[i][i + 1] = 1;\n\t\t\t\tlongestStr = s.substring(i, i + 2);\n\t\t\t}\n\t\t}\n\t\tfor (int l = 3; l <= length; l++) {\n\t\t\tfor (int i = 0; i <= length - l; i++) {\n\t\t\t\tint j = i + l - 1;\n\t\t\t\tif (s.charAt(i) == s.charAt(j)) {\n\t\t\t\t\ttable[i][j] = table[i + 1][j - 1];\n\t\t\t\t\tif (table[i][j] == 1 && l > maxLen)\n\t\t\t\t\t\tlongestStr = s.substring(i, j + 1);\n\t\t\t\t} else {\n\t\t\t\t\ttable[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn longestStr;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class SubsetsII {\n\n    public class Solution {\n        public ArrayList<ArrayList<Integer>> subsetsWithDup(int[] num) {\n            Arrays.sort(num);\n            ArrayList<ArrayList<Integer>> subsets = new ArrayList<ArrayList<Integer>>();\n            subsets.add(new ArrayList<Integer>());\n            int last = 1;\n            for (int i = 0; i < num.length; i++) {\n                int start = 0;\n                if (i != 0 && num[i] == num[i - 1]) {\n                    start = last;\n                }\n                last = subsets.size();\n                for (int j = start; j < last; j++) {\n                    ArrayList<Integer> subset = new ArrayList<Integer>(\n                            subsets.get(j));\n                    subset.add(num[i]);\n                    subsets.add(subset);\n                }\n            }\n            return subsets;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class BestTimetoBuyandSellStockII {\n\n    public class Solution {\n        public int maxProfit(int[] prices) {\n            if (prices.length == 0) {\n                return 0;\n            }\n            int profit = 0;\n            for (int i = 1; i < prices.length; i++) {\n                profit += Math.max(0, prices[i] - prices[i - 1]);\n            }\n            return profit;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean canJump(int[] A) {\n        int pos = 0, n = A.length;\n        for (int i = 0; i < n; ++i) {\n            if (pos >= i) {\n                pos = Math.max(pos, i + A[i]);\n            }\n        }\n        return pos >= n - 1;\n    }\n}", "nl": "leetcoders"}
{"code": "class PalindromePartitioning2 {\n\n  public static void main(String[] args) {\n    \n    \n    PalindromePartitioning2 palindromePartition = new PalindromePartitioning2();\n    System.out.println(palindromePartition.minCut(\"a\"));\n    System.out.println(palindromePartition.minCut(\"aa\"));\n    System.out.println(palindromePartition.minCut(\"aab\"));\n    System.out.println(palindromePartition.minCut(\"aabbcc\"));\n    System.out.println(palindromePartition.minCut(\"aabbccdd\"));\n    System.out.println(palindromePartition.minCut(\"abcdcba\"));\n    System.out.println(palindromePartition.minCut(\"abcd\"));\n  }\n\n  \n  public static int minCut3(String s) {\n    Set<String> palin = new HashSet<>();\n    return minCut3(s, 0, palin);\n  }\n\n  public static int minCut3(String s, int count, Set<String> palin) {\n    if (s == null || s.length() == 0 || isPalindrome(s)) {\n      palin.add(s);\n      return count;\n    }\n\n    int min = Integer.MAX_VALUE;\n    for (int i = s.length() - 1; i >= 0; i--) {\n      if (isPalindrome(s.substring(0, i))) {\n        palin.add(s.substring(0, i));\n        int result = palin.contains(s.substring(i)) ? count : minCut3(s.substring(i), count + 1, palin);\n        min = Math.min(min, result);\n      }\n    }\n    return min;\n  }\n\n  \n  private static boolean isPalindrome(String s) {\n    if (s == null || s.length() == 0) return false;\n    if (s.length() == 1) return true;\n\n    int i = 0;\n    int len = s.length();\n    while (i < len / 2) {\n      if (s.charAt(i) != s.charAt(len - i - 1)) return false;\n      i++;\n    }\n    return true;\n  }\n\n  \n  public int minCut(String s) {\n    if (s == null || s.length() == 0) return 0;\n    int len = s.length();\n    int[] cuts = new int[len + 1]; // store results\n    for (int i = 0; i <= len; i++) cuts[i] = i - 1; // max cuts\n    for (int i = 0; i < len; i++) {\n      for (int j = 0; i - j >= 0 && i + j < len && s.charAt(i - j) == s.charAt(i + j); j++)\n        cuts[i + j + 1] = Math.min(cuts[i + j + 1], 1 + cuts[i - j]);\n      for (int j = 1; i - j + 1 >= 0 && i + j < len && s.charAt(i - j + 1) == s.charAt(i + j); j++)\n        cuts[i + j + 1] = Math.min(cuts[i + j + 1], 1 + cuts[i - j + 1]);\n    }\n    return cuts[len];\n  }\n\n  \n  public int minCut2(String s) {\n    if (s == null || s.length() == 0) return 0;\n    int len = s.length();\n    boolean[][] p = new boolean[len][len];\n    for (int i = 0; i < len; i++) Arrays.fill(p[i], false);\n    int[] results = new int[len];\n\n    for (int start = len - 1; start >= 0; start--) {\n      results[start] = len - start - 1;\n      for (int end = start; end < len; end++) {\n        if (s.charAt(start) == s.charAt(end)) {\n          if (end - start < 2) p[start][end] = true;\n          else\n            p[start][end] = p[start + 1][end - 1];\n        }\n        if (p[start][end]) {\n          if (end == len - 1) results[start] = 0;\n          else results[start] = Math.min(results[start], results[end + 1] + 1);\n        }\n      }\n    }\n    return results[0];\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class DecodeWays {\n\tpublic int numDecodings(String s) {\n\n\t\tif (s == null || s.length() == 0)\n\t\t\treturn 0;\n\t\tif (s.charAt(0) == '0')\n\t\t\treturn 0;\n\n\t\tif (s.length() == 1)\n\t\t\treturn 1;\n\t\tif (s.length() == 2) {\n\t\t\tif (s.charAt(1) == 0)\n\t\t\t\treturn 1;\n\t\t\telse if (Integer.parseInt(s.substring(0, 2)) > 26)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 2;\n\t\t}\n\n\t\tif (s.charAt(s.length() - 1) == '0')\n\t\t\treturn numDecodings(s.substring(0, s.length() - 2));\n\t\telse {\n\t\t\tint i = Integer.parseInt(s.substring(s.length() - 2, s.length()));\n\t\t\tif (i > 26)\n\t\t\t\treturn numDecodings(s.substring(0, s.length() - 1));\n\t\t\telse\n\t\t\t\treturn numDecodings(s.substring(0, s.length() - 1)) + numDecodings(s.substring(0, s.length() - 2));\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L048_Rotate_Image {\n\n\tpublic void rotate(int[][] matrix) {\n\n\t\tif (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int mx = matrix.length;\n\t\tfinal int my = matrix[0].length;\n\t\tint x, y;\n\n\t\tint t;\n\n\t\tint _my = my - 1;\n\t\tfor (x = 0; x < mx - 1; x++) {\n\t\t\tfor (y = 0; y < _my; y++) {\n\t\t\t\tint ny = mx - 1 - x;\n\t\t\t\tint nx = my - 1 - y;\n\n\t\t\t\tt = matrix[y][x];\n\t\t\t\tmatrix[y][x] = matrix[ny][nx];\n\t\t\t\tmatrix[ny][nx] = t;\n\n\t\t\t}\n\t\t\t_my--;\n\t\t}\n\n\t\tfor (x = 0; x < mx; x++) {\n\t\t\tfor (y = 0; y < my / 2; y++) {\n\t\t\t\tint ny = my - 1 - y;\n\t\t\t\tint nx = x;\n\n\t\t\t\tt = matrix[y][x];\n\t\t\t\tmatrix[y][x] = matrix[ny][nx];\n\t\t\t\tmatrix[ny][nx] = t;\n\t\t\t}\n\t\t}\n\n\t}\n}\n", "nl": "LjyYano"}
{"code": "class Solution {\n\n    public ArrayList<ArrayList<String>> solveNQueens(int n) {\n      ArrayList<ArrayList<String>> rst = new ArrayList<ArrayList<String>>();\n      if (n <= 0) {\n        return rst;\n      }\n      ArrayList<Integer> list = new ArrayList<Integer>(); //1D array\n      helper(rst, list, n);\n\n      return rst;\n    }\n\n    \n    public boolean validate(ArrayList<Integer> list, int rowNum) {\n      int colNum = list.size(); // the column that rowNum is going to be put on\n      for (int col = 0; col < list.size(); col++) {\n        if (list.get(col) == rowNum) {\n          return false;\n        }\n        if (col - colNum == list.get(col) - rowNum) {\n          return false;\n        }\n        if (col - colNum == -(list.get(col) - rowNum)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    public ArrayList<String> createBoard(ArrayList<Integer> list){\n      ArrayList<String> board = new ArrayList<String>();\n      for (int row = 0; row < list.size(); row++) {\n        StringBuffer sb = new StringBuffer();\n        for (int col : list) {\n          if (row == col) {\n            sb.append(\"Q\");\n          } else {\n            sb.append(\".\");\n          }\n        }\n        board.add(sb.toString());\n      }\n      return board;\n    }\n\n\n    public void helper(ArrayList<ArrayList<String>> rst, ArrayList<Integer> list, int n){\n      if (list.size() == n) {\n        rst.add(createBoard(list));\n        return;\n      }\n      for (int i = 0; i < n; i++) {\n        if (validate(list, i)) {\n          list.add(i);\n          helper(rst, list, n);\n          list.remove(list.size() - 1);\n        }\n      }\n    }\n};\n\n\n\n\nclass NQueens {\n    \n    ArrayList<ArrayList<String>> solveNQueens(int n) {\n      ArrayList<ArrayList<String>> rst = new ArrayList<ArrayList<String>>();\n      if (n <= 0) {\n        return rst;\n      }\n      search(n, new ArrayList<Integer>(), rst);\n      return rst;\n    } \n\n    ArrayList<String> createBoard(ArrayList<Integer> cols) {\n      ArrayList<String> solution = new ArrayList<String>();\n      for (int i = 0; i < cols.size(); i++) {\n            StringBuffer sb = new StringBuffer();\n        for (int j = 0; j < cols.size(); j++){\n          if (j == cols.get(i)) {\n            sb.append( \"Q\");\n          } else {\n            sb.append( \".\");\n          }\n        }\n        solution.add(sb.toString());\n      }\n      return solution;\n    }\n\n    boolean isValid (ArrayList<Integer> cols, int col) {\n      int row = cols.size();\n      for (int i = 0; i < row; i++) {\n      if (cols.get(i) == col ) {\n        return false;\n      }\n      if (i - cols.get(i) == row - col) {\n        return false;\n      }   \n      if (i + cols.get(i) == row + col) {\n        return false;\n      }\n      }\n      return true;\n    }\n\n    void search(int n, ArrayList<Integer> cols, ArrayList<ArrayList<String>> rst) {\n      if (cols.size() == n) {\n        rst.add(createBoard(cols));\n        return;\n      }\n      for (int i = 0; i < n; i++) {\n        if (!isValid(cols, i)) {\n          continue;\n        }\n        cols.add(i);\n        search(n, cols, rst);\n        cols.remove(cols.size() - 1);\n      }\n    }\n\n    public static void main(String[] args){\n      NQueens test = new NQueens();\n      test.solveNQueens(4);\n    }\n\n};\n   ", "nl": "awangdev"}
{"code": "public class SortList\n{\n    public ListNode sortList(ListNode head) {\n        return null;\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class ValidateBinarySearchTree {\n\tpublic boolean isValidBST(TreeNode root) {\n\t\treturn validate(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t}\n\n\tpublic static boolean validate(TreeNode root, int min, int max) {\n\t\tif (root == null)\n\t\t\treturn true;\n\t\tif (root.val <= min || root.val >= max)\n\t\t\treturn false;\n\t\treturn validate(root.left, min, root.val) && validate(root.right, root.val, max);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head==null) {\n            return head;\n        }\n        ListNode l=head;\n        List<ListNode> list=new ArrayList<ListNode>();\n        while (l!=null) {\n            list.add(l);\n            l=l.next;\n        }\n        k=k%list.size();\n        if (k==0) {\n            return head;\n        }\n        list.get(list.size()-k-1).next=null;\n        list.get(list.size()-1).next=head;\n        return list.get(list.size()-k);\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MinimumWindowSubstring {\n  private int[] hash = new int[256];\n  private int[] curr = new int[256];\n\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(new MinimumWindowSubstring().minWindow(\"ADOBECODEBANC\", \"ABC\"));\n  }\n\n  public String minWindow(String s, String t) {\n    if (s.isEmpty() && t.isEmpty()) return \"\";\n    if (t.length() > s.length()) return \"\";\n    int start = -1, end = -1, min = Integer.MAX_VALUE;\n    for (int i = 0, l = t.length(); i < l; i++) {\n      hash[t.charAt(i)]++;\n    }\n\n    for (int i = 0, l = t.length() - 1; i < l; i++) {\n      curr[s.charAt(i)]++;\n    }\n\n    for (int i = 0, j = t.length() - 1, l = s.length(); j < l; ) {\n      curr[s.charAt(j)]++;\n      if (isMatch()) {\n        if (j - i < min) {\n          min = j - i;\n          start = i;\n          end = j;\n        }\n        while (j > i) {\n          curr[s.charAt(i)]--;\n          i++;\n          if (isMatch()) {\n            if (j - i < min) {\n              min = j - i;\n              start = i;\n              end = j;\n            }\n          } else break;\n        }\n      }\n      j++;\n    }\n    if (min == Integer.MAX_VALUE) {\n      return \"\";\n    }\n    return s.substring(start, end + 1);\n  }\n\n  private boolean isMatch() {\n    for (int i = 0; i < 256; i++) {\n      if (curr[i] < hash[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        fast = slow.next;\n        slow.next = null;\n        ListNode l1 = sortList(head);\n        ListNode l2 = sortList(fast);\n        return mergeTwoLists(l1, l2);\n    }\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head = new ListNode(0);\n        ListNode cur = head;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        if (l1 != null) cur.next = l1;\n        if (l2 != null) cur.next = l2;\n        return head.next;\n    }\n}", "nl": "leetcoders"}
{"code": "class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1 == null || num1.length() == 0) return num2;\n        if (num2 == null || num2.length() == 0) return num1;\n        \n        int m = num1.length(), n = num2.length();\n        int[] rst = new int[m + n];\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) rst[i + j + 1] += toInt(num1, i) * toInt(num2, j);\n        }\n        \n        StringBuffer sb = new StringBuffer();\n        for (int i = rst.length - 1; i > 0; i--) {\n            rst[i - 1] += rst[i] / 10;\n            rst[i] %= 10;\n            sb.insert(0, (char)(rst[i] + '0'));\n        }\n        sb.insert(0, (char)(rst[0] + '0'));\n        \n        while (sb.length() > 1) {\n            if (sb.charAt(0) != '0') break;\n            sb.deleteCharAt(0);\n        }\n        \n        return sb.toString();\n    }\n    \n    private int toInt(String s, int x) {\n        return s.charAt(x) - '0';\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int maxArea(int[] height) {\n        int left = 0, right = height.length - 1;\n        int res = 0;\n        while (left < right) {\n            res = Math.max(res, Math.min(height[left],height[right]) * (right - left));\n            if (height[left] > height[right]) --right;\n            else ++left;\n        }\n        return res;\n    }\n}\n", "nl": "leetcoders"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> combine(int n, int k) {\n            \n        return find_combine(n,k);        \n    }\n    \n    public ArrayList<ArrayList<Integer>> find_combine(int n,int k){\n        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n        if(k==0 || k>n)\n            res.add(new ArrayList<Integer>());\n        else if (k==n){\n            ArrayList<Integer> combo = new ArrayList<Integer>();\n            for(int i=1;i<=n;i++)\n                combo.add(i);\n            res.add(combo);\n        }else{\n            for(ArrayList<Integer> list : find_combine(n-1,k))\n                res.add(list);\n            for(ArrayList<Integer> list : find_combine(n-1,k-1)){\n                ArrayList<Integer> combo = new ArrayList<Integer> ();\n                for(Integer i : list)\n                    combo.add(i);\n                combo.add(n);\n                res.add(combo);\n            }\n        }\n        return res;\n    }\n}", "nl": "azheanda"}
{"code": "public class BinaryTreeLevelOrderTraversal2 {\n\n  public List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> q = new LinkedList<>();\n    q.add(root);\n\n    while (!q.isEmpty()) {\n      int size = q.size();\n      List<Integer> curLevel = new ArrayList<>();\n      for (int i = 0; i < size; i++) {\n        TreeNode n = q.poll();\n        curLevel.add(n.val);\n        if (n.left != null) q.add(n.left);\n        if (n.right != null) q.add(n.right);\n      }\n      result.add(0, curLevel);\n    }\n\n    return result;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "class Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) return 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int level = 0;\n        while (!queue.isEmpty()) {\n            level++;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (node.left == null && node.right == null) return level;\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n        }\n        return level;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class CloneGraph {\n\n    public class Solution {\n        private UndirectedGraphNode cloneGraph(UndirectedGraphNode node,\n                HashMap<UndirectedGraphNode, UndirectedGraphNode> nodes) {\n            UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);\n            nodes.put(node, newNode);\n            for (UndirectedGraphNode neighbor : node.neighbors) {\n                UndirectedGraphNode newNeighbor = nodes.get(neighbor);\n                if (newNeighbor == null) {\n                    newNeighbor = cloneGraph(neighbor, nodes);\n                }\n                newNode.neighbors.add(newNeighbor);\n            }\n            return newNode;\n        }\n\n        public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n            if (node == null) {\n                return null;\n            }\n            return cloneGraph(node,\n                    new HashMap<UndirectedGraphNode, UndirectedGraphNode>());\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MergeSortedArray {\n\tpublic void merge(int A[], int m, int B[], int n) {\n\t\tint idx = m + n - 1;\n\t\tint i = m - 1;\n\t\tint j = n - 1;\n\n\t\twhile (i >= 0 && j >= 0) {\n\t\t\tif (A[i] >= B[j]) {\n\t\t\t\tA[idx--] = A[i--];\n\t\t\t} else {\n\t\t\t\tA[idx--] = B[j--];\n\t\t\t}\n\t\t}\n\n\t\tif (i == -1) {\n\t\t\twhile (j >= 0) {\n\t\t\t\tA[j] = B[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMergeSortedArray slt = new MergeSortedArray();\n\t\tint A[] = new int[5];\n\t\tA[0] = 1;\n\t\tA[1] = 3;\n\t\tA[2] = 5;\n\t\tint B[] = { 2, 4 };\n\t\tslt.merge(A, 3, B, 2);\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tSystem.out.print(A[i] + \" \");\n\t\t}\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    public ArrayList<String> generateParenthesis(int n) {\n        ArrayList<String> res = new ArrayList<String>();\n        ArrayList<String> preres = new ArrayList<String>();\n\n        if(n==0)\n            return res;\n        \n        res.add(\"(\");\n        for(int i=1;i<2*n;i++){\n            for(String str:res)\n                if(str.length()==i){\n                    if(countChar(str,\"(\")<n)\n                        preres.add(str+\"(\");\n                    if(countChar(str,\")\")<countChar(str,\"(\"))\n                        preres.add(str+\")\");\n                }\n            res = preres;\n            preres = new ArrayList<String>();\n                    \n            \n        }\n        return res;\n    }\n    \n    public int countChar(String str,String chr){\n        return str.length()-str.replace(chr,\"\").length();\n    }\n}", "nl": "azheanda"}
{"code": "public class L075_Sort_Colors {\n\n\tpublic void sortColors(int[] nums) {\n\n\t\tif (nums == null || nums.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tint red = 0;\n\t\tint white = 0;\n\t\tint blue = 0;\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (nums[i] == 0) {\n\t\t\t\tred++;\n\t\t\t} else if (nums[i] == 1) {\n\t\t\t\twhite++;\n\t\t\t} else {\n\t\t\t\tblue++;\n\t\t\t}\n\t\t}\n\n\t\tint i = 0;\n\t\twhile (red-- > 0) {\n\t\t\tnums[i++] = 0;\n\t\t}\n\t\twhile (white-- > 0) {\n\t\t\tnums[i++] = 1;\n\t\t}\n\t\twhile (blue-- > 0) {\n\t\t\tnums[i++] = 2;\n\t\t}\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public int findMin(int[] num) {\n        if (num.length == 0) return 0;\n        int left = 0, right = num.length -1;\n        while (left < right && num[left] > num[right]) {\n            int mid = left + (right - left) / 2;\n            if (num[mid] > num[right]) left = mid + 1;\n            else right = mid;\n        }\n        return num[left];\n    }\n}", "nl": "leetcoders"}
{"code": "public class L096_Unique_Binary_Search_Trees {\n\n\tpublic int numTrees(int n) {\n\n\t\tif (n == 1 || n == 2) {\n\t\t\treturn n;\n\t\t}\n\n\t\tint[] record = new int[n + 1];\n\n\t\trecord[0] = 1;\n\t\trecord[1] = 1; // 1\u4e2a\u5143\u7d20\u65f6\uff0c\u60c5\u51b5\u4e3a1\n\t\trecord[2] = 2; // 2\u4e2a\u5143\u7d20\u65f6\uff0c\u60c5\u51b5\u4e3a2\n\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tint tmp = 0;\n\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\ttmp += (record[k] * record[i - k - 1]);\n\t\t\t}\n\t\t\trecord[i] = tmp;\n\t\t}\n\n\t\treturn record[n];\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class MultiplyStrings\n{\n    public String multiply( String num1, String num2 )\n    {\n    \tif ( num1 == null || num2 == null )\n    \t{\n    \t\treturn null;\n    \t}\n    \t\n    \tint[] buffer = new int[num1.length() + num2.length()];\n    \tfor ( int i = num1.length() - 1; i >= 0; i-- )\n    \t{\n    \t\tfor ( int j = num2.length() - 1; j >= 0; j-- )\n    \t\t{\n    \t\t\tint product = ( num1.charAt( i ) - '0' ) * ( num2.charAt( j ) - '0' );\n    \t\t\tint sum = product + buffer[i + j + 1];\n    \t\t\tbuffer[ i + j + 1 ] = sum % 10;\n    \t\t\tbuffer[ i + j ] += sum / 10;\n    \t\t}\n    \t}\n    \t\n    \tStringBuilder result = new StringBuilder();\n    \tfor ( int digit : buffer )\n    \t{\n    \t\tif ( !( result.length() == 0 && digit == 0 ) )\n    \t\t{\n    \t\t\tresult.append( digit );\n    \t\t}\n    \t}\n    \treturn result.length() == 0 ? \"0\" : result.toString();\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class UniquePaths4 {\n\t\n\tpublic int uniquePaths(int m, int n) {\n        int[] res = new int[n];\n         \n        for(int j = 0; j < n; j++) {\n            res[j] = 1;\n        }\n         \n        for(int i = 1; i < m; i++) {\n            res[0] = 1;\n            for(int j = 1; j < n; j++) {\n                res[j] = res[j - 1] + res[j];\n            }\n        } \n        return res[n - 1];\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class SortColors {\n\n    public class Solution {\n        public void sortColors(int[] A) {\n            int zero = -1;\n            int one = -1;\n            for (int i = 0; i < A.length; i++) {\n                if (A[i] == 0) {\n                    A[i] = A[++zero];\n                    A[zero] = 0;\n                    one = Math.max(zero, one);\n                }\n                if (A[i] == 1) {\n                    A[i] = A[++one];\n                    A[one] = 1;\n                }\n            }\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class InsertionSortList {\n\n    public class Solution {\n        public ListNode insertionSortList(ListNode head) {\n            ListNode dummy = new ListNode(0);\n            ListNode p = head;\n            while (p != null) {\n                ListNode pre = dummy;\n                while (pre.next != null) {\n                    if (pre.next.val <= p.val) { // stable sort\n                        pre = pre.next;\n                    } else {\n                        break;\n                    }\n                }\n                ListNode temp = p.next;\n                p.next = pre.next;\n                pre.next = p;\n                p = temp;\n            }\n            return dummy.next;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class LongestValidParentheses\n{\n    public int longestValidParentheses( String s )\n    {\n    \tif ( s == null || s.length() == 0 )\n    \t{\n    \t\treturn 0;\n    \t}\n    \t\n    \tint longestLength = 0;\n    \tStack<Integer> leftIndexes = new Stack<>();\n    \tleftIndexes.push( -1 );\n    \tfor ( int i = 0; i < s.length(); i++ )\n    \t{\n    \t\tif ( s.charAt( i ) == '(' )\n    \t\t{\n    \t\t\tleftIndexes.push( i );\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tif ( leftIndexes.size() == 1 )\n    \t\t\t{\n    \t\t\t\tleftIndexes.pop();\n    \t\t\t\tleftIndexes.push( i );\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tleftIndexes.pop();\n    \t\t\t\tlongestLength = Math.max( longestLength, i - leftIndexes.peek() );\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn longestLength;\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertEquals( 2, longestValidParentheses( \"()\" ) );\n    \tassertEquals( 4, longestValidParentheses( \")()())\" ) );\n    \tassertEquals( 2, longestValidParentheses( \"()))()\" ) );\n    \tassertEquals( 0, longestValidParentheses( \"((((((\" ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class L005_Longest_Palindromic_Substring {\n\n\tpublic String longestPalindrome(String s) {\n\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tint start = 0;\n\t\tint end = 0;\n\n\t\tfor (int i = 0; i < s.length() - 1; i++) {\n\n\t\t\tint len1 = longest(s, i, i);\n\t\t\tint len2 = longest(s, i, i + 1);\n\n\t\t\tint len = Math.max(len1, len2);\n\n\t\t\tif (end - start < len) {\n\t\t\t\tstart = i - (len - 1) / 2;\n\t\t\t\tend = i + len / 2;\n\t\t\t}\n\n\t\t}\n\n\t\treturn s.substring(start, end + 1);\n\t}\n\n\tprivate int longest(String s, int left, int right) {\n\n\t\twhile (left >= 0 && right < s.length()\n\t\t\t\t&& s.charAt(left) == s.charAt(right)) {\n\t\t\tleft--;\n\t\t\tright++;\n\t\t}\n\n\t\treturn right - left - 1;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "class JumpGame2 {\n\n  \n  public int jump(int[] A) {\n    int step = 0;\n    int last = 0; // How far we already can reach\n    int cur = 0; // How far can we reach for next step\n\n    for (int i = 0; i < A.length; i++) {\n      if (i > last) { // Run out of we can reach, need one more step\n        last = cur;\n        step++;\n        if (last >= A.length) return step;\n      }\n      cur = Math.max(cur, i + A[i]);\n    }\n    return step;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<TreeNode>> answerList = new ArrayList<List<TreeNode>>();\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\n        if (root == null) {\n            return list;\n        }\n        List<TreeNode> initList = new ArrayList<TreeNode>();\n        initList.add(root);\n        answerList.add(initList);\n        for (int i = 0; i < answerList.size(); i++) {\n            List<Integer> l = new ArrayList<Integer>();\n            List<TreeNode> newList = new ArrayList<TreeNode>();\n            for (int j = 0; j < answerList.get(i).size(); j++) {\n                TreeNode tree = answerList.get(i).get(j);\n                l.add(answerList.get(i).get(j).val);\n                if (tree.left != null) {\n                    newList.add(tree.left);\n                }\n                if (tree.right != null) {\n                    newList.add(tree.right);\n                }\n            }\n            list.add(l);\n            if (newList.size() != 0) {\n                answerList.add(newList);\n            }\n        }\n        return list;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public int maxSubArray(int[] nums) {\n        if (nums == null || nums.length == 0) return Integer.MIN_VALUE;\n        int preMaxSum = 0, max = Integer.MIN_VALUE;\n        for (int num : nums) {\n            preMaxSum = Math.max(num, preMaxSum + num);\n            max = Math.max(max, preMaxSum);\n        }\n        return max;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    \n    public int maxSubArray(ArrayList<Integer> nums) {\n        if (nums == null || nums.size() == 0) {\n            return 0;\n        }\n        int[] sums = new int[nums.size()];\n        sums[0] = nums.get(0);\n        int maxSum = sums[0];\n        for (int i = 1; i < sums.length; i++) {\n            if (sums[i - 1] < 0) {\n                sums[i] = nums.get(i);\n            } else {\n                sums[i] = sums[i - 1] + nums.get(i);\n            }\n             maxSum = Math.max(maxSum, sums[i]);\n        }\n        return maxSum;\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class ValidateBinarySearchTree {\n\n    public class Solution {\n        private boolean isValidBST(TreeNode root, int[] minMax) {\n            int min = root.val;\n            int max = root.val;\n            if (root.left != null) {\n                if (!isValidBST(root.left, minMax) || root.val <= minMax[1]) {\n                    return false;\n                }\n                min = minMax[0];\n            }\n            if (root.right != null) {\n                if (!isValidBST(root.right, minMax) || root.val >= minMax[0]) {\n                    return false;\n                }\n                max = minMax[1];\n            }\n            minMax[0] = min;\n            minMax[1] = max;\n            return true;\n        }\n\n        public boolean isValidBST(TreeNode root) {\n            if (root == null) {\n                return true;\n            }\n            return isValidBST(root, new int[2]);\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> combinationSum2(int[] num, int target) {\n        Arrays.sort(num);\n        int size = num[num.length-1]>target?num[num.length-1]+1:target+1;\n        Vector<ArrayList<ArrayList<Integer>>> dp = new Vector<ArrayList<ArrayList<Integer>>>(size);\n        for(int i=0;i<size;i++)\n            dp.add(new ArrayList<ArrayList<Integer>>());\n        \n        HashMap<Integer,Integer> count = new HashMap<Integer,Integer>();\n        for(int i=0;i<num.length;i++){\n            if(count.containsKey(num[i]))\n    \t\t\tcount.put(num[i],count.get(num[i])+ 1);\n            else\n                count.put(num[i],1);\n        }\n        \n            \n        for(int i=0;i<target+1;i++)\n            for(int j=num.length-1;j>=0;j--)\n                if(j+1<num.length && num[j] == num[j+1])\n                    continue;\n                else if(i-num[j]==0 ){\n                    ArrayList<Integer> list = new ArrayList<Integer>();\n                    list.add(num[j]);\n                    dp.get(i).add(list);                  \n                }else if(i-num[j]>0)\n                    for(ArrayList<Integer> list:dp.get(i-num[j]))\n                        if(list.get(list.size()-1)<=num[j]){\n                            int numOfNum=1;\n                            for(Integer in:list)\n                                if(in==num[j])\n                                    numOfNum++;\n                            if(numOfNum<=count.get(num[j])){\n                                ArrayList<Integer> combo = new ArrayList<Integer>(list);\n                                combo.add(num[j]);\n                                dp.get(i).add(combo);\n                            }\n                        }\n                    \n                \n        return dp.get(target);\n        \n        \n    }\n}", "nl": "azheanda"}
{"code": "public class RegularExpressionMatching {\n  public boolean isMatch(String s, String p) {\n    return isMatch(s, 0, p, 0);\n  }\n\n  private boolean isMatch(String s, int i, String p, int j) {\n    int ls = s.length();\n    int lp = p.length();\n    if (j == lp) {\n      return i == ls;\n    }\n    if ((j < lp - 1 && p.charAt(j + 1) != '*') || j == lp - 1) {\n      return (i < ls && s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')\n          && isMatch(s, i + 1, p, j + 1);\n    }\n    while ((i < ls && s.charAt(i) == p.charAt(j)) || (p.charAt(j) == '.' && i < ls)) {\n      if (isMatch(s, i, p, j + 2)) return true;\n      i++;\n    }\n    return isMatch(s, i, p, j + 2);\n  }\n}\n", "nl": "mengli"}
{"code": "public class Subsets2 {\n\n  \n  public List<List<Integer>> subsetsWithDup(int[] num) {\n    if (null == num || num.length == 0) {\n      return Collections.emptyList();\n    }\n    List<List<Integer>> subsets = new ArrayList<>();\n    Arrays.sort(num); // Sort first.\n    backtrack(subsets, num, 0, new ArrayList<>());\n    return subsets;\n  }\n\n  \n  private void backtrack(List<List<Integer>> subsets, int[] nums, int pos, List<Integer> set) {\n    subsets.add(new ArrayList<>(set)); // Dereference.\n    for (int i = pos; i < nums.length; i++) {\n      if (i != pos && nums[i] == nums[i - 1]) { // Check and skip duplicates.\n        continue;\n      }\n      set.add(nums[i]);\n      backtrack(subsets, nums, i + 1, set); // Backtrack the rest of the numbers, so i -> i + 1.\n      set.remove(set.size() - 1);\n    }\n  }\n\n  \n  private void backtrack2(List<List<Integer>> res, int[] nums, int pos, List<Integer> subset) {\n    if (pos == nums.length) {\n      res.add(new ArrayList<>(subset)); // Dereference.\n      return;\n    }\n    subset.add(nums[pos]); // Add.\n    backtrack2(res, nums, pos + 1, subset); // Backtrack.\n    subset.remove(subset.size() - 1); // Reset.\n    if (pos > 0 && nums[pos] == nums[pos - 1] && !subset.isEmpty() && nums[pos - 1] == subset\n        .get(subset.size() - 1)) {\n      return;\n    }\n    backtrack2(res, nums, pos + 1, subset);\n  }\n\n  \n  public List<List<Integer>> subsetsWithDup2(int[] nums) {\n    List<List<Integer>> res = new ArrayList<>();\n    res.add(new ArrayList<>()); // Empty set.\n    if (null == nums || nums.length == 0) {\n      return res;\n    }\n    Arrays.sort(nums); // Sort first.\n\n    int j, prevSize = 0;\n    for (int i = 0; i < nums.length; i++) {\n      if (i != 0 && nums[i] == nums[i - 1]) { // Duplicate.\n        j = prevSize; // # of previous sets before last number.\n      } else {\n        j = 0; // No dup, start from beginning.\n      }\n      prevSize = res.size(); // # of previous sets.\n      for (; j < prevSize; j++) {\n        List<Integer> temp = new ArrayList<>(res.get(j));\n        temp.add(nums[i]);\n        res.add(temp);\n      }\n    }\n    return res;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class GenerateParentheses {\n  public static void main(String[] args) throws Exception {\n    System.out.println(new GenerateParentheses().generateParenthesis(4));\n  }\n\n  public List<String> generateParenthesis(int n) {\n    List<String> list = new ArrayList<>();\n    backTrack(list, \"\", 0, 0, n);\n    return list;\n  }\n\n  private void backTrack(List<String> list, String str, int open, int close, int n) {\n    if (str.length() == n * 2) {\n      list.add(str);\n    } else {\n      if (open < n) backTrack(list, str.concat(\"(\"), open + 1, close, n);\n      if (close\n          < open) // number of close should be less than open or else it can result in unbalanced\n      backTrack(list, str.concat(\")\"), open, close + 1, n);\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Powxn {\n\n    public class Solution {\n        public double pow(double x, int n) {\n            boolean overflow = false;\n            if (n == Integer.MIN_VALUE) {\n                overflow = true;\n                n++;\n            }\n            boolean negative = n < 0;\n            n = Math.abs(n);\n            double re = 1;\n            double times = x;\n            while (n != 0) {\n                if ((n & 1) == 1) {\n                    re *= times;\n                }\n                times *= times;\n                n >>= 1;\n            }\n            if (negative) {\n                return overflow ? 1 / (re * x) : 1 / re;\n            } else {\n                return re;\n            }\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class GrayCode {\n\tpublic ArrayList<Integer> grayCode(int n) {\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\tif (n == 0) {\n\t\t\tresult.add(0);\n\t\t\treturn result;\n\t\t}\n\t\tresult.add(0);\n\t\tresult.add(1);\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tint addNumber = 1 << (i - 1);\n\t\t\tfor (int j = result.size() - 1; j >= 0; j--) {\n\t\t\t\tresult.add(addNumber + result.get(j));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class LongestPalindromicSubstring {\n\n    public class Solution {\n        public String longestPalindrome(String s) {\n            String t = \"^#\";\n            for (int i = 0; i < s.length(); i++) {\n                t += s.charAt(i);\n                t += '#';\n            }\n            t += '$';\n\n            int[] p = new int[t.length()];\n            int id = 1;\n            p[1] = 1;\n            int rightIndex = 2;\n            for (int i = 2; i < t.length() - 1; i++) {\n                if (rightIndex > i) {\n                    p[i] = Math.min(p[2 * id - i], rightIndex - i);\n                } else {\n                    p[i] = 1;\n                }\n                while (t.charAt(i + p[i]) == t.charAt(i - p[i])) {\n                    p[i]++;\n                }\n                if (rightIndex < i + p[i]) {\n                    rightIndex = i + p[i];\n                    id = i;\n                }\n            }\n\n            int maxId = 1;\n            for (int i = 2; i < t.length() - 1; i++) {\n                if (p[maxId] < p[i]) {\n                    maxId = i;\n                }\n            }\n\n            int length = p[maxId] - 1;\n            int startIndex = (maxId - p[maxId]) / 2;\n            return s.substring(startIndex, startIndex + length);\n        }\n    }\n\n    public static class UnitTest {\n\n        @Test\n        public void testLongestPalindrome() {\n            Solution s = new LongestPalindromicSubstring().new Solution();\n            assertEquals(\"a\", s.longestPalindrome(\"a\"));\n        }\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n        public int trap(int[] height) {\n        if (height.length<=1) {\n            return 0;\n        }\n        int a=0;\n        int h=height[a];\n        \n        for (int i = 1; i < height.length; i++) {\n            if (height[i]>h) {\n                a=i;\n                h=height[i];\n            }\n        }\n        Map<String, Integer> leftMap=new HashMap<String, Integer>();\n        Map<String, Integer> rightMap=new HashMap<String, Integer>();\n        leftMap.put(\"result\", 0);\n        leftMap.put(\"a\",a);\n        rightMap.put(\"result\", 0);\n        rightMap.put(\"a\",a);\n        Map<String, Integer> leftrRsult=new Solution().left(leftMap, height);\n        Map<String, Integer> rightResult=new Solution().right(leftMap, height);\n        return leftrRsult.get(\"result\")+rightResult.get(\"result\");\n    }\n    \n    \n    public Map<String, Integer> left(Map<String, Integer> m,int[] height){\n        Map<String, Integer> map=new HashMap<String, Integer>();\n        if (m==null||m.get(\"a\")==null) {\n            return m;\n        }\n        if (m.get(\"a\")<=1) {\n            return m;\n        }\n        int h=height[0];\n        int result=m.get(\"result\");\n        int sum=0;\n        int a=0;\n        for (int i = 1; i <m.get(\"a\"); i++) {\n            if (height[i]<h) {\n                sum+=(h-height[i]);\n            }else {\n                sum=0;\n                h=height[i];\n                a=i;\n            }\n        }\n        result+=sum;\n        map.put(\"result\", result);\n        map.put(\"a\", a);\n                \n        return left(map, height);\n    }\n    \n    public Map<String, Integer> right(Map<String, Integer> m,int[] height){\n        Map<String, Integer> map=new HashMap<String, Integer>();\n        if (m==null||m.get(\"a\")==null) {\n            return m;\n        }\n        if (m.get(\"a\")>=height.length-2) {\n            return m;\n        }\n        int h=height[height.length-1];\n        int result=m.get(\"result\");\n        int sum=0;\n        int a=0;\n        for (int i = height.length-1; i>m.get(\"a\"); i--) {\n            if (height[i]<h) {\n                sum+=(h-height[i]);\n            }else {\n                sum=0;\n                h=height[i];\n                a=i;\n            }\n        }\n        result+=sum;\n        map.put(\"result\", result);\n        map.put(\"a\", a);\n                \n        return right(map, height);\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public List<List<Integer>> subsets(int[] S) {\n        return subsets_2(S);\n    }\n    public List<List<Integer>> subsets_1(int[] S) {\n        Arrays.sort(S);\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> path = new ArrayList<Integer>();\n        subsetsRe(S, 0, path, res);\n        return res;\n    }\n    void subsetsRe(int[] S, int start, List<Integer> path, List<List<Integer>> res) {\n        List<Integer> sub = new ArrayList<Integer>(path);\n        res.add(sub);\n        for (int i = start; i < S.length; ++i) {\n            path.add(S[i]);\n            subsetsRe(S, i + 1, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n    public List<List<Integer>> subsets_2(int[] S) {\n        Arrays.sort(S);\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        res.add(new ArrayList<Integer>());\n        for (int i = 0; i < S.length; ++i) {\n            int sz = res.size();\n            for (int j = 0; j < sz; ++j) {\n                List<Integer> path = new ArrayList<Integer>(res.get(j));\n                path.add(S[i]);\n                res.add(path);\n            }\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length>2) {\n            ListNode[] l1=new ListNode[lists.length/2];\n            ListNode[] l2=new ListNode[lists.length-lists.length/2];\n            for (int i = 0; i < lists.length; i++) {\n                if (i<lists.length/2) {\n                    l1[i]=lists[i];\n                }else {\n                    l2[i-lists.length/2]=lists[i];\n                }\n            }\n            return mergeTwoLists(mergeKLists(l1),mergeKLists(l2));\n        }else if (lists.length==2){\n            return mergeTwoLists(lists[0],lists[1]);\n        }else if (lists.length==1){\n            return lists[0];\n        }else {\n            return null;\n        }\n    }\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {  \n        if (l1==null) {  \n            return l2;  \n        }  \n        if (l2==null) {  \n            return l1;  \n        }  \n        ListNode l=null;  \n        if (l1.val>l2.val) {  \n            l=new ListNode(l2.val);  \n            l.next=mergeTwoLists(l1,l2.next);  \n        }else {  \n            l=new ListNode(l1.val);  \n            l.next=mergeTwoLists(l1.next,l2);  \n        }  \n        return l;  \n    }  \n}", "nl": "corpsepiges"}
{"code": "public class MinStack {\n\n    private Stack<Integer> values;\n    \n    private Stack<Integer> minValues;\n    \n    \n    public MinStack() {\n        values = new Stack<>();\n        minValues = new Stack<>();\n    }\n    \n    public void push(int x) {\n        values.push( x );\n        if ( minValues.isEmpty() )\n        {\n            minValues.push( x );\n        }\n        else\n        {\n            if ( minValues.peek() < x )\n            {\n                minValues.push( minValues.peek() );\n            }\n            else\n            {\n                minValues.push( x );\n            }\n        }\n    }\n    \n    public void pop() \n    {\n        minValues.pop();\n        values.pop();\n    }\n    \n    public int top() \n    {\n        return values.peek();\n    }\n    \n    public int getMin() \n    {\n        return minValues.peek();\n    }\n}\n\n\n", "nl": "FreemanZhang"}
{"code": "public class RestoreIPAddresses \n{\n    public List<String> restoreIpAddresses(String s)\n    {\n        return new ArrayList<>();\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class RemoveDuplicatesfromSortedList2 {\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\t\tif (head == null || head.next == null)\n\t\t\treturn head;\n\n\t\tListNode p = head;\n\t\twhile (p != null && p.next != null) {\n\t\t\tif (p.val == p.next.val) {\n\t\t\t\tp.next = p.next.next;\n\t\t\t} else {\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t}\n\n\t\treturn head;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class RegularExpressionMatching {\n\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(new RegularExpressionMatching().isMatch(\"aa\", \"a*a*a\"));\n  }\n\n  public boolean isMatch(String s, String p) {\n    return backTrack(0, 0, s, p);\n  }\n\n  private boolean backTrack(int si, int pi, String s, String p) {\n    if (si >= s.length() && pi >= p.length())\n      return true; // end of the string has been reached hence return true\n    else {\n      if (pi >= p.length()) return false; // pattern has exhausted hence return false\n      else if (si >= s.length()) {\n        if (pi + 1 < p.length() && p.charAt(pi + 1) == '*') {\n          return backTrack(si, pi + 2, s, p);\n        } else\n          return false; // string has exhausted and pattern does not contain wildcard hence return\n      } else if (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == '.') {\n        if (pi + 1 < p.length() && p.charAt(pi + 1) == '*') {\n          if (backTrack(si, pi + 2, s, p)) return true;\n          for (int i = si, l = s.length(); i < l; i++) {\n            if (s.charAt(i) == p.charAt(pi) || p.charAt(pi) == '.') {\n              if (backTrack(i + 1, pi + 2, s, p)) return true;\n            } else {\n              return false;\n            }\n          }\n          return backTrack(s.length(), pi, s, p);\n        } else {\n          return backTrack(si + 1, pi + 1, s, p); // not wildcard match immediate chars\n        }\n      } else {\n        if (pi + 1 < p.length() && p.charAt(pi + 1) == '*') {\n          return backTrack(si, pi + 2, s, p);\n        } else return false;\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class LargestRectangleinHistogram {\n\tpublic int largestRectangleArea(int[] height) {\n\t\tint maxV = 0;\n\t\tfor (int i = 0; i < height.length; i++) {\n\t\t\tint minheight = height[i];\n\t\t\tfor (int j = i+1; j >= 0; j--) {\n\t\t\t\tminheight = Math.min(minheight, height[j]);\n\t\t\t\tint area = minheight * (i - j + 1);\n\t\t\t\tif (area > maxV)\n\t\t\t\t\tmaxV = area;\n\t\t\t}\n\t\t}\n\t\treturn maxV;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public ArrayList<Integer> spiralOrder(int[][] matrix) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        if(matrix.length==0)\n            return res;\n        \n        int M = matrix.length;\n        int N = matrix[0].length;\n        int lvl = M<=N? (M+1)/2:(N+1)/2;\n        \n        \n        for(int clvl=0;clvl<lvl;clvl++){          \n            for(int j=clvl;j<N-clvl;j++)        // top\n                res.add(matrix[clvl][j]);\n            for(int i=clvl+1;i<M-clvl;i++)      // right\n                res.add(matrix[i][N-clvl-1]);\n            \n            if(clvl < M-clvl-1)\n                for(int j=N-clvl-2;j>=clvl;j--)     // bot\n                    res.add(matrix[M-clvl-1][j]);\n            if(clvl < N-clvl-1)\n                for(int i=M-clvl-2;i>clvl;i--)      // left\n                    res.add(matrix[i][clvl]);              \n        }\n                    \n        \n        return res;\n        \n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    \n    public int findMin(int[] num) {\n        if (num == null || num.length == 0) {\n            return -1;\n        }\n        int start = 0;\n        int end = num.length - 1;\n        int mid = 0;\n        while (start + 1 < end) {\n            mid = start + (end - start) / 2;\n            if (num[mid] > num[end]) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        if (num[start] < num[end]) {\n            return num[start];\n        } else {\n            return num[end];\n        }\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class WordBreak {\n  \n  public static void main(String[] args) throws Exception {\n    List<String> dic = new ArrayList<>();\n    String[] arr = {\n      \"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\", \"aaaaaa\", \"aaaaaaa\", \"aaaaaaaa\", \"aaaaaaaaa\", \"aaaaaaaaaa\"\n    };\n    for (String s : arr) dic.add(s);\n    System.out.println(\n        new WordBreak()\n            .wordBreak(\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n                dic));\n  }\n\n  public boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dictionary = new HashSet<>();\n    dictionary.addAll(wordDict);\n    Map<Integer, Boolean> dic = new HashMap<>();\n    for (int i = s.length() - 1; i >= 0; i--) dp(i, s, dic, dictionary);\n    return dic.get(0);\n  }\n\n  private boolean dp(int i, String s, Map<Integer, Boolean> dic, Set<String> dictionary) {\n    if (i == s.length()) return true;\n    else if (dic.containsKey(i)) return dic.get(i);\n    else {\n      for (int j = i, l = s.length(); j < l; j++) {\n        String subStr = s.substring(i, j + 1);\n        if (dictionary.contains(subStr)) {\n          if (dp(j + 1, s, dic, dictionary)) {\n            dic.put(i, true);\n            break;\n          }\n        }\n      }\n    }\n    if (!dic.containsKey(i)) dic.put(i, false);\n    return dic.get(i);\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public int singleNumber(int[] A) {\n        int res = 0;\n        for (int i : A) {\n            res = res^i;\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class L147_Insertion_Sort_List {\n\n\tpublic ListNode insertionSortList(ListNode head) {\n\n\t\tif (head == null)\n\t\t\treturn null;\n\t\tif (head.next == null)\n\t\t\treturn head;\n\n\t\tfinal ListNode _head = new ListNode(Integer.MIN_VALUE);\n\t\t_head.next = head;\n\n\t\thead = head.next;\n\t\t_head.next.next = null;\n\n\t\tnext: while (head != null) {\n\n\t\t\tListNode taken = head;\n\t\t\thead = head.next;\n\n\t\t\tListNode cur = _head.next;\n\t\t\tListNode last = _head;\n\n\t\t\twhile (cur != null) {\n\n\t\t\t\tif (cur.val > taken.val) {\n\t\t\t\t\tlast.next = taken;\n\t\t\t\t\ttaken.next = cur;\n\n\t\t\t\t\tcontinue next;\n\n\t\t\t\t}\n\n\t\t\t\tcur = cur.next;\n\t\t\t\tlast = last.next;\n\t\t\t}\n\n\t\t\tlast.next = taken;\n\t\t\ttaken.next = null;\n\n\t\t}\n\n\t\treturn _head.next;\n\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public List<Integer> postorderTraversal_1(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) return res;\n        Stack<TreeNode> stk = new Stack<TreeNode>();\n        TreeNode cur = root;\n        TreeNode pre = null;\n        while (stk.isEmpty() == false || cur != null) {\n            if (cur != null) {\n                stk.push(cur);\n                cur = cur.left;\n            } else {\n                TreeNode peak = stk.peek();\n                if (peak.right != null && pre != peak.right) {\n                    cur = peak.right;\n                } else {\n                    res.add(peak.val);\n                    stk.pop();\n                    pre = peak;\n                }\n            }\n        }\n        return res;\n    }\n    public List<Integer> postorderTraversal_2(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) return res;\n        List<Integer> left = postorderTraversal(root.left);\n        List<Integer> right = postorderTraversal(root.right);\n        res.addAll(left);\n        res.addAll(right);\n        res.add(root.val);\n        return res;\n    }\n    public List<Integer> postorderTraversal_3(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) return res;\n        Stack<Integer> stk = new Stack<Integer>();\n        TreeNode dummy = new TreeNode(-1);\n        dummy.left = root;\n        TreeNode cur = dummy;\n        while (cur != null) {\n            if (cur.left == null) {\n                cur = cur.right;\n            } else {\n                TreeNode node = cur.left;\n                while (node.right != null && node.right != cur)\n                    node = node.right;\n                if (node.right == null) {\n                    node.right = cur;\n                    cur = cur.left;\n                } else {\n                    TreeNode temp = cur.left;\n                    while (temp != cur) {\n                        stk.push(temp.val);\n                        temp = temp.right;\n                    }\n                    while (stk.isEmpty() == false) res.add(stk.pop());\n                    node.right = null;\n                    cur = cur.right;\n                }\n            }\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class ClimbingStairs {\n  public int climbStairs(int n) {\n    int[] arr = new int[n + 1];\n    arr[0] = 1;\n    arr[1] = 1;\n    for (int i = 2; i <= n; i++) {\n      arr[i] = arr[i - 1] + arr[i - 2];\n    }\n    return arr[n];\n  }\n}\n", "nl": "mengli"}
{"code": "class Solution {\n    \n    public void mergeSortedArray(int[] A, int m, int[] B, int n) {\n        int index = m + n;\n        while (m > 0 && n > 0) {\n            if (A[m - 1] > B[n - 1]) {\n                A[--index] = A[--m];\n            } else {\n                A[--index] = B[--n];\n            }\n        }//While\n        \n        while (n > 0) {\n            A[--index] = B[--n];\n        }\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n        int profit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1]) {\n                profit += prices[i] - prices[i - 1];\n            }\n        }\n        return profit;\n    }\n}", "nl": "awangdev"}
{"code": "public class FlattenBinaryTreetoLinkedList {\n  public void flatten(TreeNode root) {\n    if (root == null) return;\n    if (root.left != null) {\n      TreeNode rightMost = findRightMost(root.left);\n      TreeNode rightChild = root.right;\n      root.right = root.left;\n      root.left = null;\n      rightMost.right = rightChild;\n    }\n    flatten(root.right);\n  }\n\n  private TreeNode findRightMost(TreeNode root) {\n    if (root == null || root.right == null) return root;\n    return findRightMost(root.right);\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public ArrayList<String[]> solveNQueens(int n) {\n        ArrayList<String[]> res = new ArrayList<String[]>();    \n        solveNQueens(0,new int[n],res);\n        return res;\n    }\n    \n    public void solveNQueens(int cur, int[] row, ArrayList<String[]> res) {\n        int n = row.length;\n        if(cur == n)\n            res.add(generateSol(row));\n        else        \n            for(int i=0;i<n;i++){\n                boolean ok = true;\n                row[cur]=i;\n                for(int j=0;j<cur;j++){\n                    if(row[cur]==row[j] || cur-row[cur]==j-row[j] || cur+row[cur]==j+row[j])\n                    {ok= false;break;}\n              }\n              if(ok)\n                  solveNQueens(cur+1,row,res);\n            }       \n    }\n    \n    public String[] generateSol(int[] row){\n        int n = row.length;\n        String[] sol = new String[n];\n        for(int i=0;i<n;i++){\n            String line =\"\";\n            for(int j=0;j<n;j++)\n                if(j==row[i]) line+=\"Q\";\n                else line+=\".\";\n            sol[i] = line;                \n        }\n        return sol;\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public int lengthOfLastWord(String s) {\n        if (s.length()==0) {\n            return 0;\n        }\n        int e=-1;\n        for (int i = s.length()-1; i >=0; i--) {\n            if (!s.substring(i,i+1).equals(\" \")) {\n                e=i;\n                break;\n            }\n        }\n        if (e==-1) {\n            return 0;\n        }\n        int b=-1;\n        for (int i = e-1; i >=0; i--) {\n            if (s.substring(i,i+1).equals(\" \")) {\n                b=i;\n                break;\n            }\n        }\n        System.out.println(\"b=\"+b);\n        return b==-1?e+1:e-b;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public boolean isMatch(String s, String p) {\n        if (p.length()==0) {\n            return s.length()==0;\n        }\n        if (s.length()==0) {\n            if (p.length()%2!=0) {\n                return false;\n            }\n            char[] c=p.toCharArray();\n            for (int i = 1; i < c.length; i+=2) {\n                if (c[i]!='*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        int pl=p.length();\n        int sl=s.length();\n        String ep=p.substring(pl-1,pl);\n        if (ep.equals(\"*\")) {\n            if (p.substring(pl-2,pl-1).equals(\".\")) {\n                for (int i = sl-1; i >=0-1; i--) {\n                    if (isMatch(s.substring(0, i+1),p.substring(0, pl-2))) {\n                        return true;\n                    }\n                }\n                return false;\n            }else {\n                String k=p.substring(pl-2,pl-1);\n                for (int i = sl-1; i >=0; i--) {\n                    String t=s.substring(i,i+1);\n                    if (t.equals(k)) {\n                        if (isMatch(s.substring(0, i+1),p.substring(0, pl-2))) {\n                            return true;\n                        }\n                    }else {\n                        return isMatch(s.substring(0, i+1),p.substring(0, pl-2));\n                    }\n                }\n                return isMatch(\"\",p.substring(0, pl-2));\n            }\n        }else if(ep.equals(\".\")){\n            return isMatch(s.substring(0, sl-1),p.substring(0, pl-1));\n        }else {\n            String es=s.substring(sl-1,sl);\n            if (ep.equals(es)) {\n                return isMatch(s.substring(0, sl-1),p.substring(0, pl-1));\n            }\n            return false;\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public int maximalRectangle_1(char[][] matrix) {\n        if (matrix.length == 0 || matrix[0].length == 0) return 0;\n        int M = matrix.length, N = matrix[0].length;\n        int[][][] dp = new int[M][N][2];\n        int res = 0;\n        for (int i = 0; i < M; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (matrix[i][j] == '0') continue;\n                dp[i][j][0] = (j==0)?1:dp[i][j-1][0] + 1;\n                dp[i][j][1] = (i==0)?1:dp[i-1][j][1] + 1;\n                int minheight = dp[i][j][1];\n                for (int k = j; k > j - dp[i][j][0]; --k) {\n                    minheight = Math.min(minheight, dp[i][k][1]);\n                    res = Math.max(res, minheight*(j-k+1));\n                }\n            }\n        }\n        return res;\n    }\n    public int cal(int[] dp) {\n        int N = dp.length;\n        Stack<Integer> stk = new Stack<Integer>();\n        int i = 0, res = 0;\n        while (i < N) {\n            if (stk.empty() || dp[i] >= dp[stk.peek()]) {\n                stk.push(i++);\n                continue;\n            }\n            int idx = stk.pop();\n            int width = stk.empty()?i:(i-stk.peek()-1);\n            res = Math.max(res, width*dp[idx]);\n        }\n        return res;\n    }\n    public int maximalRectangle_2(char[][] matrix) {\n        if (matrix.length == 0 || matrix[0].length == 0) return 0;\n        int M = matrix.length, N = matrix[0].length;\n        int[] dp = new int[N+1];\n        int res = 0;\n        for (int i = 0; i < M; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (matrix[i][j] == '0') dp[j] = 0;\n                else dp[j] = dp[j] + 1;\n            }\n            res = Math.max(res, cal(dp));\n        }\n        return res;\n    }\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0 || matrix[0].length == 0) return 0;\n        int M = matrix.length, N = matrix[0].length;\n        int[] L = new int[N]; Arrays.fill(L,0);\n        int[] R = new int[N]; Arrays.fill(R,N);\n        int[] H = new int[N]; Arrays.fill(H,0);\n        int res = 0;\n        for (int i = 0; i < M; ++i) {\n            int left = 0, right = N;\n            for (int j = 0; j < N; ++j) {\n                if (matrix[i][j] == '1') {\n                    L[j] = Math.max(L[j], left);\n                    H[j] = H[j] + 1;\n                } else {\n                    H[j] = 0; L[j] = 0; R[j] = N;\n                    left = j + 1;\n                }\n            }\n            for (int j = N - 1; j >= 0; --j) {\n                if (matrix[i][j] == '1') {\n                    R[j] = Math.min(R[j], right);\n                    res = Math.max(res, (R[j]-L[j])*H[j]);\n                } else {\n                    right = j;\n                }\n            }\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public String addBinary(String a, String b) {\n        int ap=a.length()-1;\n        int bp=b.length()-1;\n        int count = 0;\n        String sum =\"\";\n        \n        while(ap>=0||bp>=0||count>0){\n            if(ap>=0 && a.charAt(ap)=='1')\n                count++;\n            if(bp>=0 && b.charAt(bp)=='1')\n                count++;\n            sum = count%2+sum;\n            count = count/2;\n            ap--;bp--;\n        }\n        return sum;\n        \n    }\n    \n    \n}", "nl": "azheanda"}
{"code": "public class Solution {\n\tprivate int start, maxLen;\n\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() <= 1) {\n        \treturn s;\n        }\n        for (int i = 0; i < s.length() - 1; i++) {\n        \tfindMaxLen(s, i, i); // odd middle point i\n\t\t\tfindMaxLen(s, i, i + 1); // even s(i) == s(i+1)\n        }\n        return s.substring(start, start + maxLen);\n    }\n\n    public void findMaxLen(String s, int i, int j) {\n    \twhile (i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n    \t\ti--;\n    \t\tj++;\n    \t}\n\t\tif (maxLen < j - i - 1) {\n\t\t\tmaxLen = j - i - 1;\n\t\t\tstart = i + 1;\n\t\t}\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class CountandSay {\n  public String countAndSay(int n) {\n    StringBuilder s1 = new StringBuilder(\"1\");\n    StringBuilder s2 = new StringBuilder();\n    for (int i = 1; i < n; i++) {\n      int j = 0;\n      int len = s1.length();\n      while (j < len) {\n        int count = 1;\n        char c = s1.charAt(j);\n        while (j < len - 1 && s1.charAt(j + 1) == s1.charAt(j)) {\n          count++;\n          j++;\n        }\n        s2.append(count + \"\");\n        s2.append(c);\n        if (j == len - 1) {\n          break;\n        }\n        j++;\n      }\n      s1 = s2;\n      s2 = new StringBuilder();\n    }\n    return s1.toString();\n  }\n}\n", "nl": "mengli"}
{"code": "public class FindPeakElement \n{\n    public int findPeakElement(int[] nums) \n    {\n        int start = 0;\n        int end = nums.length - 1;\n        while ( start + 1 < end )\n        {\n        \tint mid = start + ( end - start ) / 2;\n        \tif ( nums[mid] < nums[mid-1] )\n        \t{\n        \t\tend = mid;\n        \t}\n        \telse \n        \t{\n        \t\tstart = mid;\n        \t}\n        }\n        \n        if ( nums[start] < nums[end] )\n        {\n        \treturn end;\n        }\n        else\n        {\n        \treturn start;\n        }\n    }\n    \n    @Test\n    public void test()\n    {\n    \tassertEquals( 2, findPeakElement( new int[]{1, 2, 3, 1}) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class _93_restoreIpAddresses {\n    public static void main(String[] args) {\n        Util.printStringList(restoreIpAddresses(\"25525511135\"));\n        Util.printStringList(restoreIpAddresses(\"0000\"));\n        Util.printStringList(restoreIpAddresses(\"9245587303\"));\n        Util.printStringList(restoreIpAddresses(\"010010\"));\n    }\n\n    \n    public static List<String> restoreIpAddresses(String s) {\n        List<String> retList = new ArrayList<>();\n        int[] next = new int[]{1, 2, 3};\n        int length = s.length();\n\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < next.length; i++) {\n            int endI = next[i];\n            if (endI >= length) continue;\n            String si = s.substring(0, endI);\n            if (!isValid(si)) {\n                continue;\n            }\n            builder.append(si).append(\".\");\n            for (int j = 0; j < next.length; j++) {\n                int endJ = endI + next[j];\n                if (endJ >= length) continue;\n                String sj = s.substring(endI, endJ);\n                if (!isValid(sj)) {\n                    continue;\n                }\n                builder.append(sj).append(\".\");\n                for (int k = 0; k < next.length; k++) {\n                    int endK = endJ + next[k];\n                    if (endK >= length) continue;\n                    String sk = s.substring(endJ, endK);\n                    if (!isValid(sk)) {\n                        continue;\n                    }\n                    builder.append(sk).append(\".\");\n                    int endL = length;\n                    String sl = s.substring(endK, endL);\n                    if (isValid(sl)) {\n                        builder.append(sl);\n                        retList.add(builder.toString());\n                    }\n                    builder.delete(endK + 3, endL + 3);\n                    builder.delete(endJ + 2, endK + 3);\n                }\n                builder.delete(endI + 1, endJ + 2);\n            }\n            builder.delete(0, endI + 1);\n        }\n        return retList;\n    }\n\n    private static boolean isValid(String s) {\n        if (s.length() > 3) return false;\n        int i = Integer.parseInt(s);\n        if (i > 255 || i < 0 || !s.equals(i + \"\")) {\n            return false;\n        }\n        return true;\n    }\n\n}\n", "nl": "pphdsny"}
{"code": "class ContainerWithMostWater {\n    public static void main(String[] args) {\n\n    }\n\n    \n    public int maxArea(int[] height) {\n        if (height == null || height.length == 0) return 0;\n        int ans = 0;\n        int low = 0, high = height.length - 1;\n        while (low < high) { // note low < high, not <=\n            ans = Math.max(ans, (high - low) * Math.min(height[low], height[high]));\n            if (height[low] < height[high]) low++;\n            else high--;\n        }\n        return ans;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "class Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int n = nums.length;\n        long[] dp = new long[n + 1];\n        dp[0] = 0; \n        dp[1] = nums[0];\n        for (int i = 2; i <= n; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n        }\n        return (int) dp[n];\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public void rotate(int[][] matrix) {\n        int n=matrix.length;\n        for (int i = 0; i < n/2; i++) {\n            for (int j = i; j <n-i-1; j++) {\n                int k=matrix[i][j];\n                matrix[i][j]=matrix[n-1-j][i];\n                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];\n                matrix[n-1-i][n-1-j]=matrix[j][n-1-i];\n                matrix[j][n-1-i]=k;\n            }\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    \n    public int climbStairs(int n) {\n        if (n <= 2) {\n            return n;\n        }\n        int last = 1;   //Init f[1]\n        int lastlast = 1;   //Init f[0]\n        int now = 0;\n        for (int i = 2; i <= n; i++) {  //Start from level2\n            now = last + lastlast;\n            lastlast = last;\n            last = now;\n        }\n        return now;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class CloneGraph2 {\n\tclass UndirectedGraphNode {\n\t\tint label;\n\t\tList<UndirectedGraphNode> neighbors;\n\n\t\tUndirectedGraphNode(int x) {\n\t\t\tlabel = x;\n\t\t\tneighbors = new ArrayList<UndirectedGraphNode>();\n\t\t}\n\t}\n\n\tpublic UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n\t\tif (node == null)\n\t\t\treturn null;\n\n\t\tHashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n\t\tUndirectedGraphNode head = new UndirectedGraphNode(node.label);\n\t\tmap.put(node, head);\n\n\t\tDFS(map, node);// DFS\n\t\treturn head;\n\t}\n\n\tpublic void DFS(HashMap<UndirectedGraphNode, UndirectedGraphNode> map, UndirectedGraphNode node) {\n\t\tif (node == null)\n\t\t\treturn;\n\n\t\tfor (UndirectedGraphNode aneighbor : node.neighbors) {\n\t\t\tif (!map.containsKey(aneighbor)) {\n\t\t\t\tUndirectedGraphNode newneighbor = new UndirectedGraphNode(aneighbor.label);\n\t\t\t\tmap.put(aneighbor, newneighbor);\n\t\t\t\tDFS(map, aneighbor);// DFS\n\t\t\t}\n\t\t\tmap.get(node).neighbors.add(map.get(aneighbor));\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public String addBinary(String a, String b) {\n        char[] aChars=a.toCharArray();\n        char[] bChars=b.toCharArray();\n        int ap=aChars.length-1;\n        int bp=bChars.length-1;\n        int step = 0;\n        String sum =\"\";\n        \n        while(ap>=0||bp>=0||step>0){\n            if(ap>=0||bp>=0){\n                int temp =0;\n                if(ap>=0 && bp>=0)\n                    temp = step+Integer.parseInt(aChars[ap]+\"\")+Integer.parseInt(bChars[bp]+\"\");       \n                else if(ap>=0)\n                    temp = step+Integer.parseInt(aChars[ap]+\"\");\n                else\n                    temp = step+Integer.parseInt(bChars[bp]+\"\");\n                switch(temp){\n                    case 0: sum = \"0\"+sum;step=0;break;\n                    case 1: sum = \"1\"+sum;step=0;break;\n                    case 2: sum = \"0\"+sum;step=1;break;\n                    case 3: sum = \"1\"+sum;step=1;break;\n\n                }\n            }\n            else if(step==1){\n                sum= \"1\"+sum;\n                step=0;\n            }\n                \n            ap--;bp--;\n        }\n        return sum;\n        \n    }\n    \n    \n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head==null||head.next==null) {\n            return head;\n        }\n        if (head.val==head.next.val) {\n            head.next=head.next.next;\n            head=deleteDuplicates(head);\n        }else {\n            head.next=deleteDuplicates(head.next);\n        }\n        return head;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    \n    public List<List<Integer>> combinationSum(int[] num, int target) {\n        List<List<Integer>> rst = new ArrayList<List<Integer>>();\n        List<Integer> list = new ArrayList<Integer>();\n        if (num == null || num.length == 0 || target < 0) {\n            return rst;\n        }\n        Arrays.sort(num);\n        helper(rst, list, num, target, 0, 0);\n        return rst;\n    }\n    public void helper(List<List<Integer>> rst, List<Integer> list,\n                int[] num, int target, int sum, int start) {\n        if (sum == target) {\n            rst.add(new ArrayList(list));\n            return;\n        } else if (sum > target) {//Stop if greater than target\n            return;\n        }\n        int prev = -1;//Repeat detection\n        for (int i = start; i < num.length; i++) {\n            if (prev != -1 && prev == num[i]) {\n                continue;\n            }\n            list.add(num[i]);\n            sum += num[i];\n            helper(rst, list, num, target, sum, i);\n            sum -= num[i];\n            list.remove(list.size() - 1);\n            prev = num[i];\n        }\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public int minDepth(TreeNode root) {\n        if(root==null)  \n            return 0;\n        else if(root.left!=null && root.right!=null)\n            return 1+Math.min(minDepth(root.right),minDepth(root.left));\n        else if(root.left!=null)\n            return 1+minDepth(root.left);\n        else\n            return 1+minDepth(root.right);\n            \n    }\n}", "nl": "azheanda"}
{"code": "public class RemoveDuplicatesfromSortedArray2 {\n\t   \n    public static int removeDuplicates(int[] A) {\n        int count = 0;\n        int len = A.length;\n        for (int i = 0; i < len; i++) {\n            if (count == 0 || A[i] != A[count - 1]) {\n                A[count++] = A[i];\n            }\n        }\n        return count;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class LRUCache {\n\n  public class CacheItem<K, V> {\n\n    private K key;\n    private V value;\n    private CacheItem<K, V> prev;\n    private CacheItem<K, V> next;\n\n    public CacheItem<K, V> getPrev() {\n      return prev;\n    }\n\n    public void setPrev(CacheItem<K, V> prev) {\n      this.prev = prev;\n    }\n\n    public CacheItem<K, V> getNext() {\n      return next;\n    }\n\n    public void setNext(CacheItem<K, V> next) {\n      this.next = next;\n    }\n\n    public CacheItem(K key, V value) {\n      this.key = key;\n      this.value = value;\n    }\n  }\n\n  public class BidirectionalList<K, V> {\n    private CacheItem<K, V> head = new CacheItem<K, V>(null, null);\n    private CacheItem<K, V> tail = head;\n\n    public void insertTail(CacheItem<K, V> node) {\n      tail.next = node;\n      node.prev = tail;\n      node.next = null;\n      tail = node;\n    }\n\n    public void delete(CacheItem<K, V> node) {\n      if (head.next == null) return;\n      if (node == head.next) {\n        deleteHead();\n      } else if (node == tail) {\n        deleteTail();\n      } else {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        node.next = null;\n        node.prev = null;\n      }\n    }\n\n    public CacheItem<K, V> deleteTail() {\n      if (head.next == null) return null;\n      CacheItem<K, V> ret = tail;\n      tail = tail.prev;\n      tail.next = null;\n      ret.prev = null;\n      ret.next = null;\n      return ret;\n    }\n\n    public CacheItem<K, V> deleteHead() {\n      if (head.next == null) return null;\n      if (head.next == tail) {\n        tail = tail.prev;\n      }\n      CacheItem<K, V> ret = head.next;\n      head.next = ret.next;\n      if (ret.next != null) {\n        ret.next.prev = head;\n      }\n      ret.next = null;\n      ret.prev = null;\n      return ret;\n    }\n  }\n\n  private Map<Integer, CacheItem<Integer, Integer>> cacheMap =\n      new HashMap<Integer, CacheItem<Integer, Integer>>();\n  private BidirectionalList<Integer, Integer> cacheList = new BidirectionalList<Integer, Integer>();\n  private int cacheSize = 0;\n  private int capacity;\n\n  public LRUCache(int capacity) {\n    this.capacity = capacity;\n  }\n\n  public int get(int key) {\n    CacheItem<Integer, Integer> itm = cacheMap.get(key);\n    if (itm == null) return -1;\n    cacheList.delete(itm);\n    cacheList.insertTail(itm);\n    return itm.value.intValue();\n  }\n\n  public void set(int key, int value) {\n    if (cacheMap.containsKey(key)) {\n      updateItem(key, value);\n    } else if (cacheSize == capacity && removeLeastUsed()) {\n      cacheSize--;\n      addItem(key, value);\n    } else {\n      addItem(key, value);\n    }\n  }\n\n  private void addItem(int key, int value) {\n    CacheItem<Integer, Integer> newCacheItem = new CacheItem<Integer, Integer>(key, value);\n    cacheList.insertTail(newCacheItem);\n    cacheMap.put(key, newCacheItem);\n    cacheSize++;\n  }\n\n  private void updateItem(int key, int value) {\n    CacheItem<Integer, Integer> exitedKey = cacheMap.get(key);\n    exitedKey.value = value;\n    cacheList.delete(exitedKey);\n    cacheList.insertTail(exitedKey);\n  }\n\n  private boolean removeLeastUsed() {\n    CacheItem<Integer, Integer> removedKey = cacheList.deleteHead();\n    cacheMap.remove(removedKey.key);\n    return removedKey == null ? false : true;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    \n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        \n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        \n        return Math.max(left, right) + 1;\n    }\n}\n\n\n   ", "nl": "awangdev"}
{"code": "public class ReverseWordsInAString {\n  public static void main(String[] args) throws Exception {\n    System.out.println(new ReverseWordsInAString().reverseWords(\"  the     sky is blue\"));\n  }\n\n  public String reverseWords(String s) {\n    if (s == null || s.isEmpty()) return \"\";\n    StringBuilder sb = new StringBuilder(s.trim());\n    String reverse = sb.reverse().toString();\n    StringTokenizer st = new StringTokenizer(reverse, \" \");\n    List<String> list = new ArrayList<>();\n    while (st.hasMoreTokens()) {\n      list.add(st.nextToken());\n    }\n    for (int i = 0, l = list.size(); i < l; i++) {\n      String str = list.get(i);\n      String newStr = new StringBuilder(str).reverse().toString();\n      list.set(i, newStr);\n    }\n    StringBuilder result = new StringBuilder();\n    for (String str : list) {\n      result.append(str).append(\" \");\n    }\n    return result.toString().trim();\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class GenerateParentheses \n{\n\t@Test\n\tpublic void test()\n\t{\n\t\tSystem.out.println( generateParenthesis( 3 ) );\n\t}\n\t\n    public List<String> generateParenthesis( int n )\n    {\n    \tList<String> result = new LinkedList<>();\n    \tgenerateParenthesis( result, new StringBuilder(), n, n );\n    \treturn result;\n    }\n    \n    private void generateParenthesis( List<String> result, StringBuilder currStr, int left, int right )\n    {\n    \tif ( left == 0 && right == 0 )\n    \t{\n    \t\tresult.add( currStr.toString() );\n    \t\treturn;\n    \t}\n    \t\n    \tif ( left > 0 )\n    \t{\n    \t\tcurrStr.append( '(' );\n    \t\tgenerateParenthesis( result, currStr, left - 1, right );\n    \t\tcurrStr.deleteCharAt( currStr.length() - 1 );\n    \t}\n    \tif ( right > 0 && left < right )\n    \t{\n\t    \tcurrStr.append( ')' );\n\t    \tgenerateParenthesis( result, currStr, left, right -1 );\n\t    \tcurrStr.deleteCharAt( currStr.length() - 1 );\n    \t}\n    }\n}", "nl": "FreemanZhang"}
{"code": "class BestTimeToBuyAndSellStock4 {\n\n  public static void main(String[] args) {\n    BestTimeToBuyAndSellStock4 b = new BestTimeToBuyAndSellStock4();\n    int[] A = new int[]{3, 3, 5, 0, 0, 3, 1, 4};\n    int[] B = new int[]{3, 2, 6, 5, 0, 3};\n    System.out.println(b.maxProfitOpt(2, A));\n    System.out.println(b.maxProfit(2, A));\n    System.out.println(b.maxProfitOpt(2, B));\n    System.out.println(b.maxProfit(2, B));\n  }\n\n  \n  public int maxProfitOpt(int k, int[] prices) {\n    if (prices == null || prices.length < 2 || k == 0) {\n      return 0;\n    }\n    int n = prices.length;\n    int res = 0;\n    if (k >= n / 2) { // As many transactions as possible\n      for (int i = 1; i < n; i++) {\n        if (prices[i] > prices[i - 1]) {\n          res += prices[i] - prices[i - 1];\n        }\n      }\n      return res;\n    }\n    int[] cur = new int[n + 1];\n    for (int i = 1; i <= k; i++) {\n      int curMax = Integer.MIN_VALUE;\n      for (int j = 0; j < n; j++) {\n        int temp = cur[j + 1];\n        cur[j + 1] = Math.max(Math.max(cur[j + 1], cur[j]), prices[j] + curMax);\n        System.out.print(curMax + \"|\");\n        curMax = Math.max(curMax, temp - prices[j]);\n        System.out.print(curMax + \"\\n\");\n      }\n      System.out.println(Arrays.toString(cur));\n    }\n    return cur[n];\n  }\n\n  \n  public int maxProfit(int k, int[] prices) {\n    if (prices == null || prices.length < 2 || k == 0) {\n      return 0;\n    }\n    int n = prices.length;\n    int res = 0;\n    if (k >= n / 2) {\n      for (int i = 1; i < n; i++) {\n        if (prices[i] > prices[i - 1]) {\n          res += prices[i] - prices[i - 1];\n        }\n      }\n      return res;\n    }\n    int[][] dp = new int[k + 1][n + 1];\n    for (int i = 1; i <= k; i++) {\n      int curMax = Integer.MIN_VALUE;\n      for (int j = 0; j < n; j++) {\n        dp[i][j + 1] = Math.max(Math.max(dp[i - 1][j + 1], dp[i][j]), prices[j] + curMax);\n        curMax = Math.max(curMax, dp[i - 1][j] - prices[j]);\n      }\n    }\n    return dp[k][n];\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class L122_Best_Time_to_Buy_and_Sell_Stock_II {\n\n\tpublic int maxProfit(int[] prices) {\n\n\t\tint profit = 0;\n\n\t\tfor (int i = 1; i < prices.length; i++) {\n\n\t\t\tif (prices[i - 1] < prices[i]) {\n\t\t\t\tprofit += prices[i] - prices[i - 1];\n\t\t\t}\n\t\t}\n\n\t\treturn profit;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class LargestRectangleinHistogram3 {\n\tpublic int largestRectangleArea(int[] height) {\n\t\tStack<Integer> s = new Stack<Integer>();\n\t\tint[] h = Arrays.copyOf(height, height.length + 1);\n\t\th[h.length - 1] = 0;\n\t\tint maxArea = 0;\n\t\tint i = 0;\n\t\twhile (i < h.length) {\n\t\t\tif (s.empty() || h[i] > h[s.peek()])\n\t\t\t\ts.push(i++);\n\t\t\telse {\n\t\t\t\tint tmp = s.pop();\n\t\t\t\tmaxArea = Math.max(maxArea, h[tmp] * (s.empty() ? i : i - s.peek() - 1));\n\t\t\t}\n\t\t}\n\t\treturn maxArea;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ImplementstrStr2 {\n\tpublic int strStr(String haystack, String needle) {\n\t\tif (haystack == null || needle == null)\n\t\t\treturn -1;\n\t\tif (needle.length() > haystack.length())\n\t\t\treturn -1;\n\n\t\tint base = 29;\n\t\tlong patternHash = 0;\n\t\tlong tempBase = 1;\n\t\tlong hayHash = 0;\n\n\t\tfor (int i = needle.length() - 1; i >= 0; i--) {\n\t\t\tpatternHash += (int) needle.charAt(i) * tempBase;\n\t\t\ttempBase *= base;\n\t\t}\n\t\ttempBase = 1;\n\t\tfor (int i = needle.length() - 1; i >= 0; i--) {\n\t\t\thayHash += (int) haystack.charAt(i) * tempBase;\n\t\t\ttempBase *= base;\n\t\t}\n\t\ttempBase /= base;\n\n\t\tif (hayHash == patternHash) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (int i = needle.length(); i < haystack.length(); i++) {\n\t\t\thayHash = (hayHash - (int) haystack.charAt(i - needle.length()) * tempBase) * base\n\t\t\t\t\t+ (int) haystack.charAt(i);\n\t\t\tif (hayHash == patternHash)\n\t\t\t\treturn i - needle.length() + 1;\n\t\t}\n\t\treturn -1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MaximumSubarray {\n\tpublic int maxSubArray(int[] A) {\n\t\tint max = A[0];\n\t\tint[] sum = new int[A.length];\n\t\tsum[0] = A[0];\n\t\tfor (int i = 1; i < A.length; i++) {\n\t\t\tsum[i] = Math.max(A[i], sum[i - 1] + A[i]);\n\t\t\tmax = Math.max(max, sum[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class UniquePaths {\n\tpublic int uniquePaths(int m, int n) {\n\t\tint[][] A = new int[m][n];\n\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tA[i][0] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tA[0][i] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i < m; ++i)\n\t\t\tfor (int j = 1; j < n; ++j) {\n\t\t\t\tA[i][j] = A[i][j - 1] + A[i - 1][j];\n\t\t\t}\n\n\t\treturn A[m - 1][n - 1];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tUniquePaths slt = new UniquePaths();\n\t\tint uPath = slt.uniquePaths(3, 7);\n\t\tSystem.out.println(uPath);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class HouseRobber {\n\tpublic int rob(int[] num) {\n\t\tif (num == null || num.length == 0)\n\t\t\treturn 0;\n\t\tif (num.length == 1)\n\t\t\treturn num[0];\n\t\tif (num.length == 2)\n\t\t\treturn Math.max(num[0], num[1]);\n\t\treturn helper(num, 0, num.length - 1);\n\t}\n\n\tpublic static int helper(int[] num, int start, int end) {\n\t\tif (start > end)\n\t\t\treturn 0;\n\t\tif (start == end)\n\t\t\treturn num[end];\n\t\tif (start + 1 == end)\n\t\t\treturn num[end - 1];\n\t\tint temp1 = helper(num, start + 2, end);\n\t\tint temp2 = helper(num, start + 3, end);\n\t\treturn Math.max(temp1, temp2) + num[start];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int search(int[] A, int target) {\n \t\tint start = 0;\n \t\tint end = A.length-1;\n\n \t\twhile(start<=end){\n \t\t\tint mid = (start+end)/2;\n \t\t\tif(A[mid] == target) \n                return mid;\n \t\t\telse if(A[start]<=A[mid]){  // check the first part is sorted or not\n \t\t\t\tif(A[mid]>target && A[start]<=target)\n \t\t\t\t\tend = mid-1;\n \t\t\t\telse\n \t\t\t\t\tstart = mid+1;\t\n \t\t\t}else{\t\t\t\t\t\t// check the second part\n \t\t\t\tif(A[mid]<target && A[end]>=target)\n \t\t\t\t\tstart = mid+1;\n \t\t\t\telse\n \t\t\t\t\tend = mid-1;\n \t\t\t}\n \t\t}\n \t\treturn -1;\n    }\n\n\n}", "nl": "azheanda"}
{"code": "public class RotateImage {\n  public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    if (n == 0) return;\n    for (int i = 0; i < n; i++) {\n      for (int j = i; j < n; j++) {\n        int t = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = t;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n / 2; j++) {\n        int t = matrix[i][j];\n        matrix[i][j] = matrix[i][n - j - 1];\n        matrix[i][n - j - 1] = t;\n      }\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class BinaryTreePostOrderTraversal \n{\n\tprivate final static int VISIT = 1;\n\tprivate final static int PRINT = 2;\n\t\n\tpublic List<Integer> postorderTraversal( TreeNode root )\n\t{\n\t\tList<Integer> result = new ArrayList<>();\t\t\n\t\tif ( root == null )\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tStack<Pair> postOrderStack = new Stack<>();\n\t\tpostOrderStack.push( new Pair( 1, root) );\n\t\twhile ( !postOrderStack.isEmpty( ) )\n\t\t{\n\t\t\tPair stackTop = postOrderStack.pop( );\n\t\t\tif ( stackTop.type == VISIT )\n\t\t\t{\n\t\t\t\tpostOrderStack.push( new Pair( PRINT, stackTop.node ) );\n\t\t\t\tif ( stackTop.node.right != null )\n\t\t\t\t{\n\t\t\t\t\tpostOrderStack.push( new Pair( VISIT, stackTop.node.right ) );\n\t\t\t\t}\n\t\t\t\tif ( stackTop.node.left != null )\n\t\t\t\t{\n\t\t\t\t\tpostOrderStack.push( new Pair( VISIT, stackTop.node.left ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.add( stackTop.node.val );\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}", "nl": "FreemanZhang"}
{"code": "public class ReverseInteger {\n\tpublic static int reverse(int x) {\n\t\tlong result = 0;\n\t\twhile (x != 0) {\n\t\t\tresult = result * 10 + x % 10;\n\t\t\tx /= 10;\n\t\t\tif (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE)\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn (int) (result);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MedianOfTwoSortedArrays {\n  public double findMedianSortedArrays(int A[], int B[]) {\n    int m = A.length;\n    int n = B.length;\n    int k = m + n;\n    if (k % 2 != 0) {\n      return findKth(A, 0, B, 0, k / 2 + 1);\n    } else {\n      return (findKth(A, 0, B, 0, k / 2) + findKth(A, 0, B, 0, k / 2 + 1)) / 2.0;\n    }\n  }\n\n  private double findKth(int A[], int a, int B[], int b, int k) {\n    if (A.length - a > B.length - b) {\n      return findKth(B, b, A, a, k);\n    }\n    if (a >= A.length) {\n      return B[b + k - 1];\n    }\n    if (k == 1) {\n      return Math.min(A[a], B[b]);\n    }\n    int midA = Math.min(k / 2, A.length - a);\n    int midB = k - midA;\n    if (A[a + midA - 1] < B[b + midB - 1]) {\n      return findKth(A, a + midA, B, b, k - midA);\n    } else if (A[a + midA - 1] > B[b + midB - 1]) {\n      return findKth(A, a, B, b + midB, k - midB);\n    } else {\n      return A[a + midA - 1];\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "class Solution {\n    public boolean isValid(String s) {\n        if (s == null || s.length() == 0) return true;\n        final Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(' || c == '{' || c == '[') {\n                stack.add(c);\n            } else if (c == ')' || c == '}' || c == ']') {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                if (c == ')' && stack.peek() == '(') {\n                    stack.pop();\n                } else if (c == '}' && stack.peek() == '{') {\n                    stack.pop();\n                } else if (c == ']' && stack.peek() == '[') {\n                    stack.pop();\n                } else {\n                    return false;\n                }\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int[] n = new int[gas.length];\n        for (int i = 0; i < n.length; i++) {\n            n[i] = gas[i] - cost[i];\n        }\n        int sum = 0;\n        int begin = 0;\n        int truebegin=0;\n        for (int i = 0; i < n.length*2; i++) {\n            sum += n[i%n.length];\n            while (sum < 0) {\n                sum -= n[truebegin];\n                begin++;\n                truebegin=begin%n.length;\n            }\n            if (i-begin>=n.length) {\n                return truebegin;\n            }\n        }\n        return -1;\n    }\n}", "nl": "corpsepiges"}
{"code": "class Solution {\n    public double myPow(double x, int n) {\n        if (x == 0 || x == 1 || n == 1) {\n            return x;\n        }\n        if (n == 0) {\n            return 1;\n        }\n        double rst = helper(Math.abs(x), Math.abs(n));\n        int sign = x < 0 && n % 2 == 1 ? -1 : 1;\n        if (n < 0) {\n            return sign / rst;\n        } else {\n            return sign * rst;\n        }\n    }\n\n    public double helper(double x, int n) {\n        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n            return x;\n        }\n        double val = helper(x, n / 2);\n        if (n % 2 == 0) {\n            return val * val;\n        } else {\n            return val * val * x;\n        }\n    }\n}\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int removeDuplicates(int[] A) {\n        int N = A.length;\n        int idx = 0;\n        for (int i = 0; i < N; ++i) {\n            if (i == 0 || A[i] != A[i - 1]) {\n                A[idx++] = A[i];\n            }\n        }\n        return idx;\n    }\n}", "nl": "leetcoders"}
{"code": "class Solution {\n    public double findMedianSortedArrays(int[] numsA, int[] numsB) {\n        int n = numsA.length + numsB.length;\n\n        if (n % 2 == 0) {\n            return (\n                findKth(numsA, 0, numsB, 0, n / 2) + \n                findKth(numsA, 0, numsB, 0, n / 2 + 1)\n            ) / 2.0;\n        }\n        return (double)findKth(numsA, 0, numsB, 0, n / 2 + 1);\n    }\n\n    private int findKth(int[] numsA, int startA, int[] numsB, int startB, int k) {\n        if (startA >= numsA.length) return numsB[startB + k - 1]; // A exhausted, take kth in B\n        if (startB >= numsB.length) return numsA[startA + k - 1]; // B exhausted, take kth in A\n\n        if (k == 1) return Math.min(numsA[startA], numsB[startB]);\n\n        int halfKthOfA = startA + k / 2 - 1 < numsA.length ? numsA[startA + k / 2 - 1] : Integer.MAX_VALUE;\n        int halfKthOfB = startB + k / 2 - 1 < numsB.length ? numsB[startB + k / 2 - 1] : Integer.MAX_VALUE;\n        if (halfKthOfA < halfKthOfB) {\n            return findKth(numsA, startA + k / 2, numsB, startB, k - k / 2);\n        } else {\n            return findKth(numsA, startA, numsB, startB + k / 2, k - k / 2);\n        }\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class ValidateBinarySearchTree2 {\n\tpublic boolean isValidBST(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (root == null)\n\t\t\treturn true;\n\t\thelper(root, list);\n\t\tfor (int i = 1; i < list.size(); i++) {\n\t\t\tif (list.get(i) <= list.get(i - 1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic void helper(TreeNode root, ArrayList<Integer> list) {\n\t\tif (root != null) {\n\t\t\thelper(root.left, list);\n\t\t\tlist.add(root.val);\n\t\t\thelper(root.right, list);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class CombinationSumII {\n\n    public class Solution {\n        private void search(List<Integer> nums, List<Integer> counts,\n                int index, int target, ArrayDeque<Integer> s,\n                ArrayList<ArrayList<Integer>> ans) {\n            if (target == 0) {\n                ans.add(new ArrayList<Integer>(s));\n            }\n            if (target <= 0 || index == nums.size()) {\n                return;\n            }\n            int n = nums.get(index);\n            int count = counts.get(index);\n            for (int i = 0; i <= count; i++) {\n                search(nums, counts, index + 1, target - i * n, s, ans);\n                s.offerLast(n);\n            }\n            for (int i = 0; i <= count; i++) {\n                s.removeLast();\n            }\n        }\n\n        public ArrayList<ArrayList<Integer>> combinationSum2(int[] num,\n                int target) {\n            ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n            if (num.length == 0) {\n                return ans;\n            }\n            Arrays.sort(num);\n            List<Integer> nums = new ArrayList<Integer>();\n            List<Integer> counts = new ArrayList<Integer>();\n            int count = 1;\n            int i = 1;\n            for (; i < num.length; i++) {\n                if (num[i] != num[i - 1]) {\n                    nums.add(num[i - 1]);\n                    counts.add(count);\n                    count = 1;\n                } else {\n                    count++;\n                }\n\n            }\n            nums.add(num[i - 1]);\n            counts.add(count);\n            search(nums, counts, 0, target, new ArrayDeque<Integer>(), ans);\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MinStack {\n  class Node {\n    int value, min;\n\n    Node(int value, int min) {\n      this.value = value;\n      this.min = min;\n    }\n  }\n\n  private Stack<Node> stack = new Stack<>();\n\n  \n  public static void main(String[] args) throws Exception {\n    MinStack minStack = new MinStack();\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    System.out.println(minStack.getMin());\n    minStack.pop();\n    System.out.println(minStack.top());\n    System.out.println(minStack.getMin());\n  }\n\n  public MinStack() {}\n\n  public void push(int x) {\n    Node node;\n    if (!stack.isEmpty()) {\n      Node top = stack.peek();\n      node = new Node(x, Math.min(top.min, x));\n    } else {\n      node = new Node(x, x);\n    }\n    stack.push(node);\n  }\n\n  public void pop() {\n    stack.pop();\n  }\n\n  public int top() {\n    return stack.peek().value;\n  }\n\n  public int getMin() {\n    return stack.peek().min;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class BestTimetoBuyandSellStockII2 {\n\tpublic int maxProfit(int[] prices) {\n\t\tint maxprofit = 0;\n\t\tint i = 1;\n\t\twhile (i < prices.length) {\n\t\t\twhile (i < prices.length && prices[i] < prices[i - 1])\n\t\t\t\ti++;\n\t\t\tint buy = prices[i - 1];\n\t\t\twhile (i < prices.length && prices[i] > prices[i - 1])\n\t\t\t\ti++;\n\t\t\tint sell = prices[i - 1];\n\t\t\tmaxprofit += sell - buy;\n\t\t\ti++;\n\t\t}\n\t\treturn maxprofit;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public String minWindow(String S, String T) {\n        int N = S.length(), M = T.length();\n        if (N < M) return new String(\"\");\n        int[] need = new int[256];\n        int[] find = new int[256];\n        for (int i = 0; i < M; ++i)\n            need[T.charAt(i)]++;\n\n        int count = 0, resStart = -1, resEnd = N;\n        for (int start = 0, end = 0; end < N; ++end)\n        {\n            if (need[S.charAt(end)] == 0)\n                continue;\n            if (find[S.charAt(end)] < need[S.charAt(end)])\n                count++;\n            find[S.charAt(end)]++;\n            if (count != M) continue;\n            for (; start < end; ++start) {\n                if (need[S.charAt(start)] == 0) continue;\n                if (find[S.charAt(start)] <= need[S.charAt(start)]) break;\n                find[S.charAt(start)]--;\n            }\n            if (end - start < resEnd - resStart) {\n                resStart = start;\n                resEnd = end;\n            }\n        }\n        return (resStart == -1) ? new String(\"\") : S.substring(resStart, resEnd + 1); \n    }\n}", "nl": "leetcoders"}
{"code": "public class L022_Generate_Parentheses {\n\n\tpublic List<String> generateParenthesis(int n) {\n\n\t\tif (n <= 0) {\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\n\t\tArrayList<String> rt = new ArrayList<String>();\n\t\tdfs(rt, \"\", n, n);\n\t\treturn rt;\n\t}\n\n\tvoid dfs(ArrayList<String> rt, String s, int left, int right) {\n\n\t\tif (left > right) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (left == 0 && right == 0) {\n\t\t\trt.add(s);\n\t\t}\n\n\t\tif (left > 0) {\n\t\t\tdfs(rt, s + \"(\", left - 1, right);\n\t\t}\n\n\t\tif (right > 0) {\n\t\t\tdfs(rt, s + \")\", left, right - 1);\n\t\t}\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class UniqueBinarySearchTrees\n{\n    public int numTrees(int n) \n    {\n        return 0;\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int searchInsert(int[] A, int target) {\n        int i = 0, j = A.length - 1;\n        while (i <= j) {\n            int mid = (i + j) / 2;\n            if (A[mid] == target) return mid;\n            if (A[mid] < target) i = mid + 1;\n            else j = mid - 1;\n        }\n        return i;\n    }\n}", "nl": "leetcoders"}
{"code": "public class WordBreak\n{\n    public boolean wordBreak( String s, Set<String> wordDict )\n    {\n    \tboolean[] canBreak = new boolean[s.length( )+1]; // whether first i characters can be broken\n    \tcanBreak[0] = true;\n    \tfor ( int i = 1; i <= s.length() ; i++ )\n    \t{    \t\t    \t\t\n    \t\tfor ( int lastWordLength = 1; lastWordLength <= i; lastWordLength++ )\n    \t\t{\n    \t\t\tif ( canBreak[i - lastWordLength] \n    \t\t\t\t&& wordDict.contains( s.substring( i - lastWordLength, i ) ) )\n    \t\t\t{\n    \t\t\t\tcanBreak[i] = true;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t}    \t\n    \treturn canBreak[s.length( )];\n    }\n    \n    @Test\n    public void test()\n    {\n    \tSet<String> words = new HashSet<>();\n    \twords.add( \"leet\" );\n    \twords.add( \"code\" );\n    \tassertTrue( wordBreak( \"leetcode\", words ) );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int ladderLength(String start, String end, Set<String> dict) {\n    \tif (start == null || end == null || dict == null || start.length() != end.length()) {\n    \t\treturn 0;\n    \t}\n    \tQueue<String> q = new LinkedList<String>();\n    \tHashSet<String> set = new HashSet<String>();\n    \tint level = 1;\n    \tint len = Integer.MAX_VALUE;\n    \tq.offer(start);\n    \tset.add(start);\n    \twhile(!q.isEmpty()) {//BFS\n    \t\tint size = q.size();//Fix size\n    \t\tlevel++;\n    \t\tfor (int k = 0; k < size; k++) {//LOOP through existing queue: for this specific level\n\t    \t\tString str = q.poll();\n\t    \t\tfor (int i = 0; i < str.length(); i++) {//Alternate each letter position\n\t    \t\t\tfor (int j = 0; j < 26; j++) {//Alter 26 letters\n\t    \t\t\t\tString newStr;\n\t    \t\t\t\tif (i == 0 && str.length() == 1) {\n\t    \t\t\t\t    newStr = \"\" + (char)('a' + j);\n\t    \t\t\t\t}\n\t    \t\t\t\telse if (i == str.length() - 1) {\n\t    \t\t\t\t\tnewStr = str.substring(0, i) + (char)('a' + j);\n\t    \t\t\t\t} else {\n\t \t\t\t\t\t\tnewStr = str.substring(0, i) + (char)('a' + j) + str.substring(i + 1);\n\t    \t\t\t\t}\n\t    \t\t\t\tif (!set.contains(newStr) && dict.contains(newStr)) {\n\t    \t\t\t\t\tif (newStr.equals(end)) {//Found end\n\t    \t\t\t\t\t\tlen = Math.min(len, level);\n\t    \t\t\t\t\t} else {\n\t    \t\t\t\t\t\tset.add(newStr);\n\t    \t\t\t\t\t\tq.offer(newStr);\n\t    \t\t\t\t\t}\n\t    \t\t\t\t}\n\t    \t\t\t}//END FOR J\n\t    \t\t}//END FOR I\n\t    \t}//END FOR K\n    \t}//END WHILE\n    \treturn len;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class MinimumWindowSubstring {\n  public String minWindow(String S, String T) {\n    int[] hasFound = new int[256];\n    int[] needFound = new int[256];\n    int diffCount = T.length();\n    int length = S.length();\n    String window = \"\";\n    int size = Integer.MAX_VALUE;\n    if (length == 0 || diffCount == 0) return window;\n    for (int l = 0; l < diffCount; l++) {\n      needFound[T.charAt(l)]++;\n    }\n    int i = 0, j = 0;\n    while (j < length) {\n      char c = S.charAt(j);\n      if (needFound[c] > 0 && ++hasFound[c] <= needFound[c]) {\n        diffCount--;\n      }\n      if (diffCount == 0) {\n        while (i <= j) {\n          char h = S.charAt(i);\n          i++;\n          if (needFound[h] > 0 && --hasFound[h] < needFound[h]) {\n            if (j - i + 1 < size) {\n              size = j - i + 1;\n              window = S.substring(i - 1, j + 1);\n            }\n            diffCount++;\n            break;\n          }\n        }\n      }\n      j++;\n    }\n    return window;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {\n        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n        \n        if(num.length<3)\n            return result;\n        \n        Arrays.sort(num);        \n        for(int i=0;i<num.length-2;i++)\n            for(int j=i+1;j<num.length-1;j++)\n                for(int p=j+1;p<num.length;p++){\n                    if(num[i]+num[j]+num[p]==0){\n                         ArrayList<Integer> triplet = new ArrayList<Integer>(3);\n                         triplet.add(num[i]);\n                         triplet.add(num[j]);\n                         triplet.add(num[p]);\n                         if(!result.contains(triplet))\n                            result.add(triplet);\n                    }\n                }\n        \n        return result;\n    }\n        \n}", "nl": "azheanda"}
{"code": "public class WordSearch {\n  private static final int[] R = {0, 0, 1, -1};\n  private static final int[] C = {1, -1, 0, 0};\n  private static boolean[][] visited;\n  private static int length = 0, N, M;\n\n  \n  public static void main(String[] args) throws Exception {\n    char[][] board = {{'A'}};\n    System.out.println(new WordSearch().exist(board, \"A\"));\n  }\n\n  public boolean exist(char[][] board, String word) {\n    N = board.length;\n    M = board[0].length;\n    if (N * M < word.length()) return false;\n    visited = new boolean[N][M];\n    length = word.length();\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        if (board[i][j] == word.charAt(0)) {\n          if (dfs(i, j, board, word, 1)) return true;\n          visited[i][j] = false;\n        }\n      }\n    }\n    return false;\n  }\n\n  private boolean dfs(int r, int c, char[][] board, String word, int pos) {\n    if (pos < length) {\n      visited[r][c] = true;\n      for (int i = 0; i < 4; i++) {\n        int newR = r + R[i];\n        int newC = c + C[i];\n        if (newR >= 0 && newR < N && newC >= 0 && newC < M) {\n          if (!visited[newR][newC]) {\n            if (board[newR][newC] == word.charAt(pos)) {\n              if (dfs(newR, newC, board, word, pos + 1)) return true;\n              visited[newR][newC] = false;\n            }\n          }\n        }\n      }\n    } else return true;\n    return false;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class SearchA2DMatrixII \n{\n    public boolean searchMatrix( int[][] matrix, int target )\n    {\n    \tif ( matrix.length == 0 \n    \t\t\t|| matrix[0].length == 0 )\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint xCoor = 0;\n    \tint yCoor = matrix[0].length - 1;\n    \twhile ( xCoor < matrix.length \n    \t\t\t&& yCoor >= 0 )\n    \t{\n    \t\tif ( matrix[xCoor][yCoor] == target )\n    \t\t{\n    \t\t\treturn true;\n    \t\t}\n    \t\telse if ( matrix[xCoor][yCoor] > target )\n    \t\t{\n    \t\t\tyCoor--;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\txCoor++;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }    \n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        combineRe(n, k, 1, path, res);\n        return res;\n    }\n    void combineRe(int n, int k, int start, ArrayList<Integer> path, List<List<Integer>> res){\n        int m = path.size();\n        if (m == k) {\n            ArrayList<Integer> p = new ArrayList<Integer>(path);\n            res.add(p);\n            return;\n        }\n        for (int i = start; i <= n-(k-m)+1; ++i) {\n            path.add(i);\n            combineRe(n,k,i+1, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public String minWindow(String S, String T) {\n            int SLen=S.length();\n\t        int TLen=T.length();\n\t        int[] needToFind = new int[256];\n\t        \n\t        for(int i=0;i<TLen;i++)\n\t            needToFind[T.charAt(i)]++;\n\n\t        int[] hasFound = new int[256];\n\t        int minWindowLen =Integer.MAX_VALUE;\n\t        int count=0;\n\t        int minWindowBegin=0;\n\t        int minWindowEnd =0;\n\t        for(int begin=0,end=0;end<SLen;end++){\n\t        \t\tchar bchar = S.charAt(begin);\n\t        \t\tchar echar = S.charAt(end);\n\n\t        \t\tif(needToFind[echar]==0)\n\t                    continue;\n\t                    \n\t\t\t\t\thasFound[echar]++;       \n\t\t\t\t\tif(hasFound[echar]<=needToFind[echar])    \n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\tif(count == TLen){\n\t\t\t\t\t\twhile(needToFind[bchar]==0|| hasFound[bchar] > needToFind[bchar]){\n\t\t\t\t\t\t\tif(hasFound[bchar] > needToFind[bchar])\n\t\t\t\t\t\t\t\t\thasFound[bchar]--;\n\t\t\t\t\t\t\tbchar = S.charAt(++begin);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint windowLen = end-begin+1;\n\t\t\t\t\t\tif(windowLen < minWindowLen){\n\t\t\t\t\t\t\tminWindowBegin = begin;\n\t\t\t\t\t\t\tminWindowEnd = end;\n\t\t\t\t\t\t\tminWindowLen = windowLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t        }\n\t        return count==TLen?S.substring(minWindowBegin,minWindowEnd+1):\"\";\n\t        \n\t    }\n}", "nl": "azheanda"}
{"code": "public class MaximumDepthofBinaryTree2 {\n\tpublic int maxDepth(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn 0;\n\t\tint left = maxDepth(root.left);\n\t\tint right = maxDepth(root.right);\n\t\treturn Math.max(left,right)+1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int hIndex(int[] citations) {\n        if (citations == null || citations.length == 0) {\n            return 0;\n        }\n        int n = citations.length;\n        Arrays.sort(citations); // nlogn\n        for (int i = 0; i < n; i++) {\n            int h = n - i;\n            if (citations[i] >= h) {\n                return h;\n            }\n        }\n        return 0;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class PalindromePartitioning \n{\n\t@Test\n\tpublic void test()\n\t{\n\t\tSystem.out.println( partition( \"aab\" ) );\n\t\tSystem.out.println( partition( \"aaabcb\" ) );\n\t}\n\t\n    public List<List<String>> partition( String s )\n    {\n    \tif ( s == null )\n    \t{\n    \t\tthrow new IllegalArgumentException();\n    \t}\n    \tList<List<String>> allPartitions = new ArrayList<>();\n    \tif ( s.length() == 0 )\n    \t{\n    \t\treturn allPartitions;\n    \t}\n    \t\n    \tboolean[][] isPalindrome = new boolean[s.length()][s.length()];\n    \tfor ( int i = 0; i < s.length(); i++ )\n    \t{\n    \t\tisPalindrome[i][i] = true;\n    \t}\n    \tfor ( int i = 0; i < s.length() - 1; i++ )\n    \t{\n    \t\tisPalindrome[i][i+1] = s.charAt( i ) == s.charAt( i + 1 );\n    \t}\n    \tfor ( int i = s.length() - 2; i >= 0; i-- )\n    \t{\n    \t\tfor ( int j = i + 2; j < s.length(); j++ )\n    \t\t{\n    \t\t\tisPalindrome[i][j] = s.charAt(i) == s.charAt(j)\n    \t\t\t\t\t\t\t\t&& isPalindrome[i+1][j-1];\n    \t\t}\n    \t}\n    \t\n    \tList<String> onePartition = new ArrayList<>();\n    \tdfs( allPartitions, onePartition, s, isPalindrome, 0, s.length() - 1 );\n    \treturn allPartitions;\n    }\n    \n    private void dfs( List<List<String>> allPartitions, List<String> onePartition, String s, boolean[][] isPalindrome, int start, int end )\n    {\n    \tif ( end == -1 )\n    \t{\n    \t\tallPartitions.add( new ArrayList<>( onePartition ) );\n    \t\treturn;\n    \t}\n    \tif ( end < -1 )\n    \t{\n    \t\treturn;\n    \t}\n    \t\n    \tfor ( int i = end; i >= start; i-- )\n    \t{\n    \t\tif ( isPalindrome[i][end] )\n    \t\t{\n    \t\t\tonePartition.add( 0, s.substring( i, end + 1 ) );\n    \t\t\tdfs( allPartitions, onePartition, s, isPalindrome, start, i - 1 );\n    \t\t\tonePartition.remove( 0 );\n    \t\t}\n    \t}\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class ReverseWordsInAString {\n  public String reverseWords(String s) {\n    if (s == null || s.length() == 0) return \"\";\n    s = s.trim();\n    StringBuilder res = new StringBuilder();\n    String[] words = s.split(\" \");\n    for (int i = words.length - 1; i >= 0; i--) {\n      if (!words[i].equals(\"\")) {\n        res.append(words[i]);\n        if (i != 0) res.append(\" \");\n      }\n    }\n    return res.toString(); // remove last space\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class MergeSortedArray {\n\tpublic void merge(int A[], int m, int B[], int n) {\n\t\tint i = m + n - 1;\n\t\tint j = m - 1;\n\t\tint k = n - 1;\n\t\tif (m == 0)\n\t\t\twhile (k >= 0) {\n\t\t\t\tA[k] = B[k];\n\t\t\t\tk--;\n\t\t\t}\n\t\twhile (j >= 0 && k >= 0) {\n\t\t\tif (A[j] > B[k])\n\t\t\t\tA[i--] = A[j--];\n\t\t\telse\n\t\t\t\tA[i--] = B[k--];\n\t\t}\n\t\twhile (k >= 0) {\n\t\t\tA[i--] = B[k--];\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ValidPalindrome2 {\n\n    \n    public boolean validPalindrome(String s) {\n        if (s == null) return false;\n        int l = 0;\n        int r = s.length() - 1;\n        while (l < r) {\n            if (s.charAt(l) != s.charAt(r)) {\n                return isPalindrome(s, l + 1, r) || isPalindrome(s, l, r - 1);\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n\n    private boolean isPalindrome(String s, int l, int r) {\n        while (l < r) {\n            if (s.charAt(l) != s.charAt(r)) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class ValidateBinarySearchTree3 {\n\tpublic boolean isValidBST(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn true;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tTreeNode node = root;\n\t\twhile (!stack.isEmpty() || node != null) {\n\t\t\twhile (node != null) {\n\t\t\t\tstack.push(node);\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t\tnode = stack.pop();\n\t\t\tlist.add(node.val);\n\t\t\tnode = node.right;\n\t\t}\n\t\tfor (int i = 1; i < list.size(); i++) {\n\t\t\tif (list.get(i) <= list.get(i - 1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ClimbingStairs {\n    public int climbStairs(int n) {\n\t\tif (n == 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tint[] a = new int[n + 1];\n\n\t\ta[0] = 1;\n\t\ta[1] = 1;\n\n\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\ta[i] = a[i - 1] + a[i - 2];\n\t\t}\n\n\t\treturn a[n];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tClimbingStairs slt = new ClimbingStairs();\n\t\tint result = slt.climbStairs(3);\n\t\tSystem.out.println(result);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": " public class Solution {\n    public String countAndSay(int n) {\n        StringBuffer s = new StringBuffer(\"1\");\n        StringBuffer res = new StringBuffer();\n        while((--n) != 0){\n            res.setLength(0);\n            int size = s.length();\n            int cnt = 1;\n            char cur = s.charAt(0);\n            for(int i=1;i<size;i++){\n                if(s.charAt(i)!=cur){\n                    res.append(cnt);\n                    res.append(cur);\n                    cur = s.charAt(i);\n                    cnt = 1;\n                }else ++cnt;\n            }\n            res.append(cnt);\n            res.append(cur);\n            StringBuffer tmp = s;\n            s = res;\n            res = tmp;\n        }\n        return s.toString();\n    }\n}", "nl": "leetcoders"}
{"code": "public class MedianOfTwoSortedArrays {\n\tpublic double findMedianSortedArrays(int A[], int B[]) {\n\t\tint m = A.length;\n\t\tint n = B.length;\n\t\tint total = m + n;\n\t\tif ((total & 0x01) != 0) {\n\t\t\treturn find_kth(A, m, B, n, total / 2 + 1);\n\t\t} else {\n\t\t\treturn (find_kth(A, m, B, n, total / 2) + find_kth(A, m, B, n,\n\t\t\t\t\ttotal / 2 + 1)) / 2.0;\n\t\t}\n\t}\n\n\tpublic double find_kth(int A[], int m, int B[], int n, int k) {\n\t\tif (m > n) {\n\t\t\treturn find_kth(B, n, A, m, k);\n\t\t}\n\t\tif (m == 0) {\n\t\t\treturn B[k - 1];\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn Math.min(A[0], B[0]);\n\t\t}\n\n\t\tint pa = Math.min(k / 2, m);\n\t\tint pb = k - pa;\n\t\tif (A[pa - 1] < B[pb - 1]) {\n\t\t\treturn find_kth(Arrays.copyOfRange(A, pa, A.length), m - pa, B, n,\n\t\t\t\t\tk - pa);\n\t\t} else if (A[pa - 1] > B[pb - 1]) {\n\t\t\treturn find_kth(A, m, Arrays.copyOfRange(B, pb, B.length), n - pb,\n\t\t\t\t\tk - pb);\n\t\t} else {\n\t\t\treturn A[pa - 1];\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] A = { 1, 3 };\n\t\tint[] B = { 2, 4 };\n\t\tMedianOfTwoSortedArrays slt = new MedianOfTwoSortedArrays();\n\t\tdouble result = slt.findMedianSortedArrays(A, B);\n\t\tSystem.out.println(result);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n   public List<String> restoreIpAddresses(String s) {\n        List<String> rst = new ArrayList<String>();\n        if (s == null || s.length() == 0) {\n            return rst;\n        }\n        if (s.length() < 4 || s.length() > 12) {\n        \treturn rst;\n        }\n        List<String> list = new ArrayList<>();\n        helper(rst, list, 0, s.toCharArray());\n\n        return rst;\n    }\n\n    public void helper(List<String> rst, List<String>list, int index, char[] arr) {\n        if (list.size() == 3) {\n            StringBuffer sb = new StringBuffer();\n            for (int i = index; i < arr.length; i++) {\n                sb.append(arr[i]);\n            }\n            \n            if (!isValid(sb.toString())) {\n                return;\n            }\n            list.add(sb.toString());\n            sb = new StringBuffer();\n            for (String str: list) {\n                sb.append(str + \".\");\n            }\n            rst.add(sb.substring(0, sb.length() - 1).toString());\n            list.remove(list.size() - 1);\n            return;\n        }\n        int end = index + 3;\n        StringBuffer sb = new StringBuffer();\n        for (int i = index; i < end && i < arr.length; i++) {\n        \tsb.append(arr[i]);\n            int remainLength = (arr.length - i - 1);\n            boolean remainValid = remainLength > 0 && remainLength <= (4 - list.size() - 1) * 3;\n        \tif (isValid(sb.toString()) && remainValid) {\n\t            list.add(sb.toString());\n\t            helper(rst, list, i + 1, arr);\n\t            list.remove(list.size() - 1);\n            }\n        }\n    }\n\n    public boolean isValid(String str) {\n    \tif (str.charAt(0) == '0') {\n    \t\treturn str.equals(\"0\");\n    \t}\n    \tint num = Integer.parseInt(str);\n    \treturn num <= 255 && num >= 0;\n    }\n\n}\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        \n        ListNode dummyNode = new ListNode(0);\n        ListNode currentNode = dummyNode;\n        \n        while(l1!=null||l2!=null){\n            if(l1!=null&&l2!=null)\n                if(l1.val>l2.val){\n                    currentNode.next =l2;\n                    l2 = l2.next;\n                }else{\n                    currentNode.next =l1;\n                    l1 = l1.next;\n                }\n            else if(l1==null){\n                currentNode.next =l2;\n                    l2 = l2.next;\n            }else{\n                currentNode.next =l1;\n                    l1 = l1.next;\n            }\n            currentNode=currentNode.next;\n                       \n        }\n        return dummyNode.next;\n        \n    }\n}", "nl": "azheanda"}
{"code": "class Solution {\n    int[] dx = {0, 1, 0, -1}; // RIGHT->DOWN->LEFT->UP\n    int[] dy = {1, 0, -1, 0};\n\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> rst = new ArrayList<>();\n        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) {\n            return rst;\n        }\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        if (n == 1) {\n            for (int i = 0; i < m; i++) {\n                rst.add(matrix[i][0]);\n            }\n            return rst;\n        }\n\n        boolean[][] visited = new boolean[m][n];\n\n        int i = 0, x = 0, y = 0;\n        int direction = 0;\n        while (i < m * n) {\n            i++;\n            rst.add(matrix[x][y]);\n            visited[x][y] = true;\n\n            direction = computeDirection(visited, x, y, direction);\n            x += dx[direction];\n            y += dy[direction];\n        }\n\n        return rst;\n    }\n\n    private int computeDirection(boolean[][] visited, int x, int y, int currDirection) {\n        int nextX = x + dx[currDirection];\n        int nextY = y + dy[currDirection];\n        if (nextX >= 0 && nextX < visited.length && nextY >= 0 && nextY < visited[0].length && !visited[nextX][nextY]) {\n            return currDirection;\n        }\n        return (currDirection + 1) % 4;\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class MergeIntervals {\n\n\n    \n    public List<Interval> merge(List<Interval> intervals) {\n        if (intervals == null || intervals.size() <= 1) {\n            return intervals;\n        }\n        List<Interval> merged = new ArrayList<>();\n        Collections.sort(intervals, (i1, i2) -> Integer.compare(i1.start, i2.start));\n        Interval prev = null; // A pointer to the last interval in merged list.\n        for (Interval i : intervals) {\n            if (prev == null || prev.end < i.start) { // Empty list or no overlap.\n                merged.add(i);\n                prev = i; // Update previous pointer.\n            } else if (prev.end < i.end) { // Overlap and the end of current interval is larger.\n                prev.end = i.end; // Update previous end to merge.\n            }\n        }\n        return merged;\n    }\n\n    \n    public List<Interval> merge2(List<Interval> intervals) {\n        intervals.sort(Comparator.comparingInt(i -> i.start));\n        for (int i = 1; i < intervals.size(); i++) {\n            Interval prev = intervals.get(i - 1);\n            Interval current = intervals.get(i);\n            if (prev.end < current.start) continue;\n            prev.end = current.end > prev.end ? current.end : prev.end;\n            intervals.remove(i);\n            i--;\n        }\n        return intervals;\n    }\n\n    \n    public List<Interval> merge3(List<Interval> intervals) {\n        int n = intervals.size();\n        int[] starts = new int[n];\n        int[] ends = new int[n];\n        for (int i = 0; i < n; i++) {\n            starts[i] = intervals.get(i).start;\n            ends[i] = intervals.get(i).end;\n        }\n        Arrays.sort(starts);\n        Arrays.sort(ends);\n        List<Interval> res = new ArrayList<>();\n        for (int i = 0, j = 0; i < n; i++) { // j is start of interval.\n            if (i == n - 1 || starts[i + 1] > ends[i]) {\n                res.add(new Interval(starts[j], ends[i]));\n                j = i + 1;\n            }\n        }\n        return res;\n    }\n\n}", "nl": "FreeTymeKiyan"}
{"code": "public class BinaryTreePostorderTraversal {\n\n  public List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> res = new ArrayList<>();\n    if (root == null) return res;\n    Stack<TreeNode> s = new Stack<>();\n    s.push(root);\n    TreeNode prev = null;\n    TreeNode cur = root;\n    while (!s.isEmpty()) {\n      cur = s.peek();\n      if (prev == null || prev.left == cur || prev.right == cur) {\n        if (cur.left != null) s.push(cur.left);\n        else if (cur.right != null) s.push(cur.right);\n      } else if (cur.left == prev) {\n        if (cur.right != null) s.push(cur.right);\n      } else {\n        res.add(cur.val);\n        s.pop();\n      }\n      prev = cur;\n    }\n    return res;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class GenerateParentheses {\n  public ArrayList<String> generateParenthesis(int n) {\n    ArrayList<String> ret = new ArrayList<String>();\n    StringBuilder sb = new StringBuilder();\n    generateParenthesis(n, 0, 0, 0, sb, ret);\n    return ret;\n  }\n\n  public void generateParenthesis(\n      int n, int s, int e, int l, StringBuilder sb, ArrayList<String> ret) {\n    if (s == n && e == n) {\n      ret.add(sb.toString());\n    } else {\n      if (l > 0 && e < n) {\n        sb.append(')');\n        generateParenthesis(n, s, e + 1, l - 1, sb, ret);\n        sb.deleteCharAt(sb.length() - 1);\n      }\n      if (s < n) {\n        sb.append('(');\n        generateParenthesis(n, s + 1, e, l + 1, sb, ret);\n        sb.deleteCharAt(sb.length() - 1);\n      }\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    \n    public int firstMissingPositive(int[] A) {\n    \tif (A == null || A.length == 0) {\n    \t\treturn 1;\n    \t}\n    \tArrays.sort(A);\n    \tint count = -1;\n    \tfor (int i = 0; i < A.length; i++) {\n    \t\tif (A[i] > 0) {\n    \t\t\tif (count < 0) {//process 1st positive element\n\t    \t\t\tcount = A[i];\n\t    \t\t\tif (count != 1) {\n\t    \t\t\t\treturn 1;\n\t    \t\t\t}\n    \t\t\t} \n    \t\t\telse if (A[i] == A[i - 1]) {//watch out for duplicates\n    \t\t\t\tcount--;\n    \t\t\t}\n\t\t\t\telse if(A[i] != count) {//if not match, kick out\n\t\t\t\t\treturn count;\n\t\t\t\t}\t\n    \t\t\tcount++;\n    \t\t}\n    \t}\n    \tif (count < 0) {//if all negative, return 1\n    \t\treturn 1;\n    \t}\n    \treturn count;\n    }\n}", "nl": "awangdev"}
{"code": "public class MergeSortedArray {\n  public void merge(int A[], int m, int B[], int n) {\n    int i = m - 1, j = n - 1;\n    int k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n      A[k--] = A[i] >= B[j] ? A[i--] : B[j--];\n    }\n    while (j >= 0) {\n      A[k--] = B[j--];\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "class Solution {\n    public void flatten(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        if (root.left == null) {\n            flatten(root.right);\n        } else {\n            TreeNode rightNode = root.right;\n            \n            root.right = root.left;\n            root.left = null;\n\n            flatten(root.right);\n\n            TreeNode node = root;\n            while (node.right != null) {\n                node = node.right;\n            }\n            node.right = rightNode; // connect\n            flatten(root.right);\n        }\n    }\n}\n", "nl": "awangdev"}
{"code": "public class TextJustification {\n  public ArrayList<String> fullJustify(String[] words, int L) {\n    ArrayList<String> ret = new ArrayList<String>();\n    int length = words.length;\n    if (length == 0) return ret;\n    int start = 0, end = start;\n    int len = 0;\n    while (start < length) {\n      StringBuffer line = new StringBuffer();\n      while (end < length) {\n        int sl = words[end].length();\n        if (len + (end - start) + sl > L) {\n          break;\n        }\n        len += sl;\n        end++;\n      }\n      end--;\n      if (end < start) {\n        end = start;\n      }\n      if (start == end) {\n        line.append(words[start]);\n        int spaceCount = L - words[start].length();\n        for (int i = 0; i < spaceCount; i++) {\n          line.append(' ');\n        }\n        ret.add(line.toString());\n      } else {\n        boolean lastLine = end == length - 1;\n        int spaceBase = lastLine ? 1 : (L - len) / (end - start);\n        int bonus = lastLine ? 0 : L - len - spaceBase * (end - start);\n        line.append(words[start]);\n        for (int i = start + 1; i <= end; i++) {\n          for (int j = 0; j < spaceBase; j++) {\n            line.append(' ');\n          }\n          if (bonus > 0) {\n            line.append(' ');\n            bonus--;\n          }\n          line.append(words[i]);\n        }\n        if (lastLine) {\n          for (int i = 0; i < L - len - (end - start); i++) {\n            line.append(' ');\n          }\n        }\n        ret.add(line.toString());\n      }\n      start = end + 1;\n      end = start;\n      len = 0;\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class SwapNodesinPairs2 {\n\tpublic ListNode swapPairs(ListNode head) {\n\t\tListNode start = new ListNode(0); // make head no longer a special case\n\t\tstart.next = head;\n\n\t\tfor (ListNode cur = start; cur.next != null && cur.next.next != null; cur = cur.next.next)\n\t\t\tcur.next = swap(cur.next, cur.next.next);\n\t\treturn start.next;\n\t}\n\n\tprivate ListNode swap(ListNode next1, ListNode next2) {\n\t\tnext1.next = next2.next;\n\t\tnext2.next = next1;\n\t\treturn next2;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] rst = new int[2];\n        if (nums == null || nums.length <= 1) return rst;\n\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i])) {\n                rst[0] = map.get(target - nums[i]);\n                rst[1] = i;\n                break;\n            } \n            map.put(nums[i], i);\n        }\n        return rst;\n    }\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class CloneGraph \n{\n\n\tpublic UndirectedGraphNode cloneGraph(UndirectedGraphNode node) \n\t{\n\t\tif ( node == null )\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn cloneGraphRecurse( node, new HashMap<Integer, UndirectedGraphNode>() );\n\t}\n\n\tprivate UndirectedGraphNode cloneGraphRecurse( UndirectedGraphNode node, Map<Integer, UndirectedGraphNode> labelToNodeMap )\n\t{\n\t\tUndirectedGraphNode clonedNode = new UndirectedGraphNode( node.label );\n\t\tlabelToNodeMap.put( node.label, clonedNode );\n\t\tfor ( UndirectedGraphNode neighbor : node.neighbors )\n\t\t{\n\t\t\tif ( !labelToNodeMap.containsKey( neighbor.label ) )\n\t\t\t{\n\t\t\t\tUndirectedGraphNode clonedNeighbor = cloneGraphRecurse( neighbor, labelToNodeMap );\n\t\t\t\tclonedNode.neighbors.add( clonedNeighbor );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tclonedNode.neighbors.add( labelToNodeMap.get( neighbor.label ) );\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn clonedNode;\n\t}\n}", "nl": "FreemanZhang"}
{"code": "public class Solution {\n   public  List<String> restoreIpAddresses(String s) {\n        List<String> rst = new ArrayList<String>();\n        if (s == null || s.length() == 0) {\n            return rst;\n        }\n        if (s.length() < 4 || s.length() > 12) {\n        \treturn rst;\n        }\n        ArrayList<String> list = new ArrayList<String>();\n        helper(rst, list, 0, s);\n\n        return rst;\n    }\n\n    public  void helper(List<String> rst, ArrayList<String>list,\n        int start, String s) {\n        if (list.size() == 4) {\n        \tif (start != s.length()) {\n        \t\treturn;\n        \t}\n            StringBuffer sb = new StringBuffer();\n            for (String str : list) {\n                sb.append(str + \".\");\n            }\n            rst.add(sb.substring(0, sb.length() - 1).toString());\n            return;\n        }\n        for (int i = start; i < s.length() && i <= start + 3; i++) {\n        \tString temp = s.substring(start, i + 1);\n        \tif (isValid(temp)) {\n\t            list.add(temp);\n\t            helper(rst, list, i + 1, s);\n\t            list.remove(list.size() - 1);\n            }\n        }\n    }\n    public boolean isValid(String str) {\n    \tif (str.charAt(0) == '0') {\n    \t\treturn str.equals(\"0\");\n    \t}\n    \tint num = Integer.parseInt(str);\n    \treturn num <= 255 && num >= 0;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class CombinationSumII {\n  public ArrayList<ArrayList<Integer>> combinationSum2(int[] candidates, int target) {\n    ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> list = new ArrayList<Integer>();\n    Arrays.sort(candidates);\n    dfs(res, 0, candidates, list, target);\n    return res;\n  }\n\n  private void dfs(\n      ArrayList<ArrayList<Integer>> res,\n      int start,\n      int[] candidates,\n      ArrayList<Integer> list,\n      int target) {\n    if (target == 0) {\n      res.add(new ArrayList<Integer>(list));\n      return;\n    }\n    int pre = -1;\n    for (int i = start; i < candidates.length; i++) {\n      if (pre == candidates[i]) continue;\n      if (candidates[i] > target) return;\n      pre = candidates[i];\n      list.add(candidates[i]);\n      dfs(res, i + 1, candidates, list, target - candidates[i]);\n      list.remove(list.size() - 1);\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class CloneGraph3 {\n\tclass UndirectedGraphNode {\n\t\tint label;\n\t\tList<UndirectedGraphNode> neighbors;\n\n\t\tUndirectedGraphNode(int x) {\n\t\t\tlabel = x;\n\t\t\tneighbors = new ArrayList<UndirectedGraphNode>();\n\t\t}\n\t}\n\n\tpublic UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n\t\tif (node == null)\n\t\t\treturn null;\n\n\t\tHashMap<UndirectedGraphNode, UndirectedGraphNode> hm = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n\t\tLinkedList<UndirectedGraphNode> stack = new LinkedList<UndirectedGraphNode>();\n\t\tUndirectedGraphNode head = new UndirectedGraphNode(node.label);\n\t\thm.put(node, head);\n\t\tstack.push(node);\n\n\t\twhile (!stack.isEmpty()) {\n\t\t\tUndirectedGraphNode curnode = stack.pop();\n\t\t\tfor (UndirectedGraphNode aneighbor : curnode.neighbors) {\n\t\t\t\tif (!hm.containsKey(aneighbor)) {\n\t\t\t\t\tstack.push(aneighbor);\n\t\t\t\t\tUndirectedGraphNode newneighbor = new UndirectedGraphNode(aneighbor.label);\n\t\t\t\t\thm.put(aneighbor, newneighbor);\n\t\t\t\t}\n\n\t\t\t\thm.get(curnode).neighbors.add(hm.get(aneighbor));\n\t\t\t}\n\t\t}\n\n\t\treturn head;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int findMin(int[] nums) {\n        int begin=0;\n        int end=nums.length-1;\n        int half=(begin+end)/2;\n        while (end-begin>1) {\n            if (nums[half]>nums[begin]&&nums[half]>nums[end]) {\n                begin=half;\n                half=(begin+end)/2;\n            }else {\n                end=half;\n                half=(begin+end)/2;\n            }\n        }\n        return nums[begin]>nums[end]?nums[end]:nums[begin];\n    }\n}", "nl": "corpsepiges"}
{"code": "public class L053_Maximum_Subarray {\n\n\tpublic int maxSubArray(int[] nums) {\n\n\t\tif (nums == null || nums.length == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint curSum = nums[0];\n\t\tint maxSum = nums[0];\n\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tcurSum = Math.max(curSum + nums[i], nums[i]);\n\t\t\tmaxSum = Math.max(curSum, maxSum);\n\t\t}\n\n\t\treturn maxSum;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int begin=0;\n        int end=matrix.length-1;\n        int t=end/2;\n        if (target<matrix[0][0]||target>matrix[matrix.length-1][matrix[matrix.length-1].length-1]) {\n            return false;\n        }\n        while (end-begin>1) {\n            if (matrix[t][0]==target) {\n                return true;\n            }else if (matrix[end][0]<target) {\n                t=end;\n                begin=end;\n                break;\n            }else if (matrix[t][0]>target) {\n                end=t;\n                t=(begin+end)/2;\n            }else {\n                begin=t;\n                t=(begin+end)/2;\n            }\n        }\n        if (matrix[t][0]==target||matrix[begin][0]==target||matrix[end][0]==target) {\n            return true;\n        }else if (matrix[t][0]>target) {\n            t=t-1;\n        }\n        int b=0;\n        int e=matrix[t].length-1;\n        int tt=(b+e)/2;\n        while (e-b>1) {\n            if (matrix[t][tt]==target) {\n                return true;\n            }else if (matrix[t][tt]>target) {\n                e=tt;\n                tt=(b+e)/2;\n            }else {\n                b=tt;\n                tt=(b+e)/2;\n            }\n        }\n        if (matrix[t][b]==target||matrix[t][e]==target) {\n            return true;\n        }\n        return false;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class L155_Min_Stack {\n\n\tclass MinStack {\n\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tStack<Integer> min = new Stack<Integer>();\n\n\t\tpublic void push(int x) {\n\t\t\tif (stack.isEmpty()) {\n\t\t\t\tstack.push(x);\n\t\t\t\tmin.push(x);\n\t\t\t} else {\n\t\t\t\tstack.push(x);\n\t\t\t\tmin.push(Math.min(stack.peek(), min.peek()));\n\t\t\t}\n\t\t}\n\n\t\tpublic void pop() {\n\t\t\tif (!stack.isEmpty()) {\n\t\t\t\tstack.pop();\n\t\t\t\tmin.pop();\n\t\t\t}\n\t\t}\n\n\t\tpublic int top() {\n\t\t\tif (!stack.isEmpty()) {\n\t\t\t\treturn stack.peek();\n\t\t\t}\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic int getMin() {\n\t\t\tif (!min.isEmpty()) {\n\t\t\t\treturn min.peek();\n\t\t\t}\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {\n        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\n        q.add(root);         \n        \n        while(q.peek()!=null){\n            Queue<TreeNode> p = new LinkedList<TreeNode>();\n            ArrayList<Integer> clvl = new ArrayList<Integer>();\n            \n            while(q.peek()!=null){\n                TreeNode node = q.poll();\n                clvl.add(node.val);\n                if(node.left!=null)\n                    p.add(node.left);\n                if(node.right!=null)\n                    p.add(node.right);                \n            }\n            res.add(clvl);\n            q = p;\n\n        }\n        \n        return res;\n    }\n}", "nl": "azheanda"}
{"code": "public class MaximalRectangle {\n  public int maximalRectangle(char[][] matrix) {\n    int rows = matrix.length;\n    if (rows == 0) return 0;\n    int maxArea = 0;\n    int cols = matrix[0].length;\n    int[][] map = new int[rows][cols];\n    for (int j = 0; j < cols; j++) {\n      map[0][j] = matrix[0][j] == '0' ? 0 : 1;\n    }\n    for (int i = 1; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        map[i][j] = matrix[i][j] == '0' ? map[i - 1][j] : map[i - 1][j] + 1;\n      }\n    }\n    int[] row = new int[cols];\n    for (int i = 0; i < rows; i++) {\n      for (int j = i; j < rows; j++) {\n        for (int k = 0; k < cols; k++) {\n          row[k] = map[j][k] - (i == 0 ? 0 : map[i - 1][k]);\n        }\n        int count = 0;\n        for (int k = 0; k < cols; k++) {\n          if (row[k] == j - i + 1) {\n            maxArea = Math.max(maxArea, ++count * (j - i + 1));\n          } else {\n            maxArea = Math.max(maxArea, count * (j - i + 1));\n            count = 0;\n          }\n        }\n      }\n    }\n    return maxArea;\n  }\n}\n", "nl": "mengli"}
{"code": "public class SearchA2DMatrix {\n  \n  public static void main(String[] args) throws Exception {\n    int[][] matrix = {\n      {1, 3, 5, 7, 9}, // 1, 3, 5, 7, 9\n      {2, 4, 6, 8, 10}, // 2, 4, 6, 8, 10\n      {11, 13, 15, 17, 19}, // 11, 15, 17, 18, 19\n      {12, 14, 16, 18, 20}, // 13, 20, 21, 22, 23\n      {21, 22, 23, 24, 25} // 14, 25, 26, 27, 28\n    };\n\n    System.out.println(new SearchA2DMatrix().searchMatrix(matrix, 11));\n  }\n\n  private boolean searchMatrix(int[][] matrix, int target) {\n    if (matrix.length == 0) return false;\n    int M = matrix.length;\n    int N = matrix[0].length;\n    int r = 0, c = N - 1;\n    while (r < M && c >= 0) {\n      if (matrix[r][c] == target) return true;\n      else if (target < matrix[r][c]) --c;\n      else if (target > matrix[r][c]) r++;\n    }\n    return false;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class TrappingRainWater {\n\n    public class Solution {\n        public int trap(int[] A) {\n            if (A.length == 0) {\n                return 0;\n            }\n            int maxIndex = 0;\n            for (int i = 1; i < A.length; i++) {\n                if (A[i] > A[maxIndex]) {\n                    maxIndex = i;\n                }\n            }\n            int height = A[0];\n            int water = 0;\n            for (int i = 1; i < maxIndex; i++) {\n                if (A[i] > height) {\n                    height = A[i];\n                } else {\n                    water += height - A[i];\n                }\n            }\n            height = A[A.length - 1];\n            for (int i = A.length - 2; i > maxIndex; i--) {\n                if (A[i] > height) {\n                    height = A[i];\n                } else {\n                    water += height - A[i];\n                }\n            }\n            return water;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class SearchinRotatedSortedArray {\n\n    public class Solution {\n        public int search(int[] A, int target) {\n            int left = 0;\n            int right = A.length - 1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (A[mid] == target) {\n                    return mid;\n                }\n                if (A[left] <= A[mid]) {\n                    if (A[left] <= target && target < A[mid]) {\n                        right = mid - 1;\n                    } else {\n                        left = mid + 1;\n                    }\n                } else {\n                    if (A[mid] < target && target <= A[right]) {\n                        left = mid + 1;\n                    } else {\n                        right = mid - 1;\n                    }\n                }\n            }\n            return -1;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "class SearchInsertPosition {\n\n  \n  public int searchInsert(int[] A, int target) {\n    if (A == null || A.length == 0) return 0;\n    int l = 0;\n    int r = A.length - 1;\n    int m;\n    while (l <= r) {\n      m = l + (r - l) / 2;\n      if (A[m] == target) return m;\n      else if (A[m] > target) r = m - 1;\n      else l = m + 1;\n    }\n    return l;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class ConstructBinaryTreeFromInorderAndPostorderTraversal\n{\n    public TreeNode buildTree( int[] inorder, int[] postorder )\n    {\n    \treturn buildTreeRecurse( inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1 );\n    }\n    \n    private TreeNode buildTreeRecurse( int[] inorder, int[] postorder, int inorderStart, int inorderEnd, int postorderStart, int postorderEnd )\n    {\n    \tif ( inorderStart > inorderEnd )\n    \t{\n    \t\treturn null;\n    \t}\n    \t\n    \tTreeNode root = new TreeNode( postorder[postorderEnd] );\n    \t\n    \tint rootInorderIndex = inorderStart;\n    \tfor ( int i = inorderStart; i <= inorderEnd; i++ )\n    \t{\n    \t\tif ( inorder[i] == postorder[postorderEnd] )\n    \t\t{\n    \t\t\trootInorderIndex = i;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \t\n    \tint leftSubtreeSize = rootInorderIndex - inorderStart;\n    \tTreeNode leftChild = buildTreeRecurse( inorder, postorder, inorderStart, inorderStart + leftSubtreeSize - 1, postorderStart, postorderStart + leftSubtreeSize - 1 );\n    \troot.left = leftChild;\n    \tint rightSubtreeSize = inorderEnd - rootInorderIndex;    \t\n    \tTreeNode rightChild = buildTreeRecurse( inorder, postorder, inorderEnd - rightSubtreeSize + 1, inorderEnd, postorderEnd - rightSubtreeSize, postorderEnd - 1 );\n    \troot.right = rightChild;\n    \treturn root;\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class L074_Search_a_2D_Matrix {\n\n\tpublic boolean searchMatrix(int[][] matrix, int target) {\n\n\t\tint mx = matrix.length;\n\t\tint my = matrix[0].length;\n\n\t\tint l = 0;\n\t\tint r = mx * my;\n\n\t\twhile (l < r) {\n\n\t\t\tint m = l + (r - l) / 2;\n\n\t\t\tint x = m / my;\n\t\t\tint y = m % my;\n\n\t\t\tif (matrix[x][y] == target) {\n\t\t\t\treturn true;\n\t\t\t} else if (matrix[x][y] < target) {\n\t\t\t\tl = m + 1;\n\t\t\t} else {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class _167_twoSum {\n\n    public static void main(String[] args) {\n        _167_twoSum twoSum = new _167_twoSum();\n        Util.printArray(twoSum.twoSum(new int[]{2, 7, 11, 15}, 9));\n    }\n\n    public int[] twoSum(int[] numbers, int target) {\n        int[] result = new int[2];\n        int startI = 0, endI = numbers.length - 1;\n        while (startI < endI) {\n            int add = numbers[startI] + numbers[endI];\n            if (add == target) {\n                result[0] = startI + 1;\n                result[1] = endI + 1;\n                break;\n            } else if (add > target) {\n                endI--;\n            } else {\n                startI++;\n            }\n        }\n        return result;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Solution {\n    public int findPeakElement(int[] nums) {\n        if (nums.length==1) {\n            return 0;\n        }\n        int s=0;\n        int e=nums.length-1;\n        int m=(s+e)/2;\n        while (e-s>1) {\n            if (nums[m]>nums[m+1]) {\n                e=m;\n            }else {\n                s=m;\n            }\n            m=(s+e)/2;\n        }\n        return nums[s]>nums[e]?s:e;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MaximumSubarray {\n  public static void main(String[] args) throws Exception {\n    int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    System.out.println(new MaximumSubarray().maxSubArray(nums));\n  }\n\n  public int maxSubArray(int[] nums) {\n    if (nums.length == 1) return nums[0];\n    int max = nums[nums.length - 1];\n    for (int i = nums.length - 2; i >= 0; i--) {\n      nums[i] = Math.max(nums[i], nums[i] + nums[i + 1]);\n      max = Math.max(max, nums[i]);\n    }\n    return max;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public boolean isPalindrome(String s) {\n        if (s.length()<=1) {\n            return true;\n        }\n        char[] c=s.toCharArray();\n        char[] nc=new char[c.length];\n        int a=0;\n        for (int i = 0; i < c.length; i++) {\n            if ((c[i]>96&&c[i]<123)||(c[i]>47&&c[i]<58)) {\n                nc[a]=c[i];\n                a++;\n            }\n            if (c[i]>64&&c[i]<91) {\n                nc[a]=(char) (c[i]+32);\n                a++;\n            }\n        }\n        for (int i = 0; i < a/2; i++) {\n            if (nc[i]!=nc[a-i-1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "nl": "corpsepiges"}
{"code": "class Solution {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }\n        int n = height.length;\n        int[] maxLeft = new int[n];\n        int[] maxRight = new int[n];\n        maxLeft[0] = height[0];\n        maxRight[n - 1] = height[n - 1];\n        for (int i = 1; i < n; i++) {\n            maxLeft[i] = Math.max(maxLeft[i - 1], height[i]);\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            maxRight[i] = Math.max(maxRight[i + 1], height[i]);\n        }\n\n        \n        \n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            int bottom = Math.min(maxLeft[i], maxRight[i]);\n            total += height[i] < bottom  ? bottom - height[i] : 0;\n        }\n        return total;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class MergekSortedLists {\n\n\tpublic ListNode mergeKLists(ArrayList<ListNode> lists) {\n\t\tListNode result = new ListNode(0);\n\t\tif (lists == null || lists.size() == 0)\n\t\t\treturn null;\n\t\tif (lists.size() == 1)\n\t\t\treturn lists.get(0);\n\t\tresult = mergeTwoLists(lists.get(0), lists.get(1));\n\t\tfor (int i = 2; i < lists.size(); i++) {\n\t\t\tresult = mergeTwoLists(result, lists.get(i));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tListNode newhead = new ListNode(0);\n\t\tListNode p = newhead;\n\t\twhile (l1 != null && l2 != null) {\n\t\t\tif (l1.val > l2.val) {\n\t\t\t\tp.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t} else {\n\t\t\t\tp.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}\n\t\t\tp = p.next;\n\t\t}\n\t\tif (l1 == null)\n\t\t\tp.next = l2;\n\t\telse\n\t\t\tp.next = l1;\n\t\treturn newhead.next;\n\t}\n}", "nl": "gaohannk"}
{"code": "public class FindPeakElement2 {\n\tpublic int findPeakElement(int[] num) {\n\t\tif (num.length <= 1)\n\t\t\treturn 0;\n\t\tfor (int i = 0; i < num.length - 1; i++) {\n\t\t\tif (num[i] > num[i + 1]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn num.length - 1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ValidNumber2 {\n\tpublic boolean isNumber(String s) {\n\t\ts = s.trim();\n\t\tif (s.length() > 0 && s.charAt(s.length() - 1) == 'e')\n\t\t\treturn false;\n\t\tString[] t = s.split(\"e\");\n\t\tif (t.length > 2)\n\t\t\treturn false;\n\t\tboolean res = valid(t[0], false);\n\t\tif (t.length == 2)\n\t\t\tres = res && valid(t[1], true);\n\t\treturn res;\n\t}\n\tprivate boolean valid(String s, boolean hasDot) {\n\t\tif (s.length() > 0 && (s.charAt(0) == '+' || s.charAt(0) == '-'))\n\t\t\ts = s.substring(1);\n\n\t\tif (s.length() == 0 || s.equals(\".\"))\n\t\t\treturn false;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '.') {\n\t\t\t\tif (hasDot)\n\t\t\t\t\treturn false;\n\t\t\t\thasDot = true;\n\t\t\t} else if (!('0' <= s.charAt(i) && s.charAt(i) <= '9')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public List<List<Integer>> combine (int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (k <= 0 || n <= 0) {\n            return result;\n        }\n\n        dfs(result, new ArrayList<>(), 1, k , n);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> list, int index, int k, int n) {\n        for (int i = index; i <= n; i++) {\n            list.add(i);\n            if (list.size() == k) {\n                result.add(new ArrayList<>(list));\n                list.remove(list.size() - 1);\n                continue;\n            }\n\n            dfs(result, list, i + 1, k, n);\n            list.remove(list.size() - 1);\n        }\n    }\n}", "nl": "awangdev"}
{"code": "class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> rst = new ArrayList<>();\n        if (root == null) {\n            return rst;\n        }\n        dfs(rst, new ArrayList<>(), root);\n        return rst;\n    }\n    \n    public void dfs(List<String> rst, List<Integer> list, TreeNode node) {\n        if (node == null) return;\n        \n        list.add(node.val);\n        if (node.left == null && node.right == null) {\n            rst.add(convert(list));\n            list.remove(list.size() - 1);\n            return;\n        }\n        \n        dfs(rst, list, node.left);\n        dfs(rst, list, node.right);\n        list.remove(list.size() - 1);\n    }\n    \n    private String convert(List<Integer> list) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < list.size() - 1; i++) {\n            sb.append(list.get(i) + \"->\");\n        }\n        sb.append(list.get(list.size() - 1));\n        return sb.toString();\n    }\n}\n", "nl": "awangdev"}
{"code": "public class RotateList {\n\tpublic ListNode rotateRight(ListNode head, int n) {\n\t\tif (n == 0 || head == null || head.next == null)\n\t\t\treturn head;\n\t\tint len = getLength(head);\n\t\tn %= len;\n\t\tif (n == 0)\n\t\t\treturn head;\n\n\t\tListNode tail = head;\n\t\twhile (n-- > 0)\n\t\t\ttail = tail.next;\n\t\tListNode oldhead = head;\n\t\twhile (tail.next != null) {\n\t\t\thead = head.next;\n\t\t\ttail = tail.next;\n\t\t}\n\t\tListNode newhead = head.next;\n\t\thead.next = null; // broke the list\n\t\ttail.next = oldhead;  // connect the tail and head;\n\t\treturn newhead;\n\t}\n\n\tpublic int getLength(ListNode head) {\n\t\tint len = 0;\n\t\twhile (head != null) {\n\t\t\thead = head.next;\n\t\t\tlen++;\n\t\t}\n\t\treturn len;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L064_Minimum_Path_Sum {\n\n\tpublic int minPathSum(int[][] grid) {\n\n\t\tif (grid == null || grid[0] == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\n\t\tint[][] dp = new int[m][n];\n\t\tdp[0][0] = grid[0][0];\n\n\t\tfor (int y = 1; y < n; y++) {\n\t\t\tdp[0][y] = dp[0][y - 1] + grid[0][y];\n\t\t}\n\n\t\tfor (int x = 1; x < m; x++) {\n\t\t\tdp[x][0] = dp[x - 1][0] + grid[x][0];\n\t\t}\n\n\t\tfor (int y = 1; y < n; y++) {\n\t\t\tfor (int x = 1; x < m; x++) {\n\t\t\t\tint min = Math.min(dp[x - 1][y], dp[x][y - 1]);\n\t\t\t\tdp[x][y] = min + grid[x][y];\n\t\t\t}\n\t\t}\n\n\t\treturn dp[m - 1][n - 1];\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n\n\tclass Point {\n\t\tint x;\n\t\tint flag;\n\t\tpublic Point(int x, int flag) {\n\t\t\tthis.x = x;\n\t\t\tthis.flag = flag;\n\t\t}\n\t}\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        List<Interval> rst = new ArrayList<Interval>();\n        if (intervals == null && newInterval == null) {\n        \treturn rst;\n        } else if (intervals == null) {\n        \trst.add(newInterval);\n        \treturn rst;\n        } else if (newInterval == null) {\n        \treturn intervals;\n        }\n\n        PriorityQueue<Point> queue = new PriorityQueue<Point>(1, new Comparator<Point>(){\n        \tpublic int compare(Point a, Point b){\n        \t\treturn a.x - b.x;\n        \t}\n        });\n\n        for (Interval range: intervals) {\n        \tqueue.add(new Point(range.start, 1));\n        \tqueue.add(new Point(range.end, -1));\n        }\n\n        queue.add(new Point(newInterval.start, 1));\n        queue.add(new Point(newInterval.end, -1));\n\n        int count = 0;\n        int startNew = 0;\n        int endNew = 0;\n        while (!queue.isEmpty()) {\n        \tPoint p = queue.poll();\n        \tif (count == 0) {\n        \t\tstartNew = p.x;\n        \t}\n        \tcount += p.flag;\n\n        \twhile (!queue.isEmpty() && p.x == queue.peek().x) {\n        \t\tp = queue.poll();\n        \t\tcount += p.flag;\n        \t}\n\n        \tif (count == 0) {\n        \t\tendNew = p.x;\n        \t\tInterval addInterval = new Interval(startNew, endNew);\n        \t\trst.add(addInterval);\n        \t}\n\n        }//end while\n\n        return rst;\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class SortList {\n  public ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode fast = head;\n    ListNode slow = head;\n    while (fast.next != null && fast.next.next != null) {\n      fast = fast.next.next;\n      slow = slow.next;\n    }\n    fast = slow.next;\n    slow.next = null;\n    slow = sortList(head);\n    fast = sortList(fast);\n    return merge(slow, fast);\n  }\n\n  private ListNode merge(ListNode slow, ListNode fast) {\n    ListNode head = new ListNode(0);\n    ListNode cur = head;\n    while (slow != null && fast != null) {\n      if (slow.val < fast.val) {\n        cur.next = slow;\n        slow = slow.next;\n      } else {\n        cur.next = fast;\n        fast = fast.next;\n      }\n      cur = cur.next;\n    }\n    if (slow != null) {\n      cur.next = slow;\n    } else if (fast != null) {\n      cur.next = fast;\n    }\n    return head.next;\n  }\n}\n", "nl": "mengli"}
{"code": "public class WordLadder2 {\n\n  \n  public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    Map<String, List<String>> graph = new HashMap<>();\n    Map<String, Integer> distances = new HashMap<>();\n\n    bfs(beginWord, endWord, dict, graph, distances);\n    List<List<String>> paths = new ArrayList<>();\n    dfs(beginWord, endWord, graph, distances, new ArrayList<>(), paths);\n    return paths;\n  }\n\n  \n  private void bfs(String beginWord, String endWord, Set<String> dict, Map<String, List<String>> graph, Map<String, Integer> distances) {\n    Queue<String> queue = new ArrayDeque<>();\n    queue.offer(beginWord);\n    distances.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n      String cur = queue.poll();\n      graph.putIfAbsent(cur, new ArrayList<>());\n      int curDistance = distances.get(cur);\n      List<String> neighbors = getNeighbors(cur, dict);\n\n      for (String n : neighbors) {\n        graph.get(cur).add(n);\n        if (!distances.containsKey(n)) {\n          distances.put(n, curDistance + 1);\n          queue.offer(n);\n        }\n      }\n\n    }\n  }\n\n  \n  private List<String> getNeighbors(String cur, Set<String> dict) {\n    List<String> neighbors = new ArrayList<>();\n    for (int i = 0; i < cur.length(); i++) {\n      for (char c = 'a'; c <= 'z'; c++) {\n        char[] chars = cur.toCharArray();\n        if (chars[i] == c) {\n          continue;\n        }\n        chars[i] = c;\n        String next = new String(chars);\n        if (dict.contains(next)) {\n          neighbors.add(next);\n        }\n      }\n    }\n    return neighbors;\n  }\n\n  \n  private void dfs(String beginWord, String endWord, Map<String, List<String>> graph, Map<String, Integer> distance, ArrayList<String> p, List<List<String>> paths) {\n    if (beginWord.equals(endWord)) {\n      List<String> path = new ArrayList<>(p);\n      path.add(beginWord);\n      paths.add(path);\n      return;\n    }\n\n    int d = distance.get(beginWord);\n    p.add(beginWord);\n    for (String next : graph.get(beginWord)) {\n      if (distance.get(next) == d + 1) {\n        dfs(next, endWord, graph, distance, p, paths);\n      }\n    }\n    p.remove(p.size() - 1);\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class LengthOfLastWord {\n    public int lengthOfLastWord(String s) {\n        int i = s.length() - 1;\n        \n        while(i >= 0 && s.charAt(i) == ' ') {\n        \t--i;\n        }\n        \n        int length = 0;\n        while(i >= 0 && s.charAt(i) != ' ') {\n        \t++length;\n        \t--i;\n        }\n        \n    \treturn length;\n    }\n    \n    public static void main(String[] args) {\n    \tString s = \"Hello word \";\n    \tLengthOfLastWord slt = new LengthOfLastWord();\n    \tint result = slt.lengthOfLastWord(s);\n    \tSystem.out.println(result);\n    }\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    \n    public String countAndSay(int n) {\n        if (n <= 1) {\n            return n + \"\";\n        }\n        String str = \"11\";\n        int ind = 2;\n        while (ind < n) {\n        \tStringBuffer sb = new StringBuffer();\n        \tchar[] arr = str.toCharArray();\n\t        int count = 1;\n\t        int type = Character.getNumericValue(arr[0]);\n\t        for (int i = 1; i < arr.length; i++) {\n\t            if (arr[i] == arr[i - 1]) {\n\t                count++;\n\t            } else {\n\t                sb.append(count + \"\" + type);\n\t                type = Character.getNumericValue(arr[i]);\n\t                count = 1;\n\t            }\n\t        }\n        \tind++;\n        \tsb.append(count + \"\" + type);\n        \tstr = sb.toString();\n        }\n        return str;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class WordLadder {\n\n  class State {\n    String word;\n    int len;\n\n    State(String word, int len) {\n      this.word = word;\n      this.len = len;\n    }\n  }\n\n  private static Queue<State> queue = new ArrayDeque<>();\n  private static Set<String> dictionary = new HashSet<>();\n  private static final String CONST = \"abcdefghijklmnopqrstuvwxyz\";\n  private static Set<String> done = new HashSet<>();\n\n  \n  public static void main(String[] args) throws Exception {\n    List<String> list = new ArrayList<>();\n    list.add(\"hot\");\n    list.add(\"dot\");\n    list.add(\"dog\");\n    list.add(\"lot\");\n    list.add(\"log\");\n    list.add(\"cog\");\n    System.out.println(new WordLadder().ladderLength(\"hit\", \"cog\", list));\n  }\n\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    dictionary.addAll(wordList);\n    queue.offer(new State(beginWord, 0));\n    done.add(beginWord);\n    while (!queue.isEmpty()) {\n      State head = queue.poll();\n      if (head.word.equals(endWord)) return head.len + 1;\n      for (int i = 0, l = CONST.length(); i < l; i++) {\n        StringBuilder word = new StringBuilder(head.word);\n        for (int j = 0, ln = word.length(); j < ln; j++) {\n          char old = word.charAt(j);\n          word.replace(j, j + 1, String.valueOf(CONST.charAt(i)));\n          if (!done.contains(word.toString())) {\n            if (dictionary.contains(word.toString())) {\n              done.add(word.toString());\n              queue.offer(new State(word.toString(), head.len + 1));\n            }\n          }\n          word.replace(j, j + 1, String.valueOf(old));\n        }\n      }\n    }\n    return 0;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class RemoveDuplicatesfromSortedListII2 {\n\tpublic ListNode deleteDuplicates(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn null;\n\t\tListNode p = head, q = head.next;\n\t\twhile (q != null && p.val == q.val) \n\t\t\tq = q.next;\n\n\t\tif (p.next == q) {\n\t\t\thead = p;\n\t\t} else {\n\t\t\thead = q;\n\t\t}\n\n\t\tif (head == null)\n\t\t\treturn head;\n\t\telse if (head == p) {\n\t\t\tp.next = deleteDuplicates(q);\n\t\t\treturn p;\n\t\t} else {// head == q\n\t\t\treturn deleteDuplicates(q);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}

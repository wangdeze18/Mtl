{"code": "public class L061_Rotate_List {\n\n\tpublic ListNode rotateRight(ListNode head, int k) {\n\n\t\tif (head == null)\n\t\t\treturn null;\n\n\t\tint len = 1;\n\n\t\tListNode tail = head;\n\n\t\twhile (tail.next != null) {\n\t\t\tlen++;\n\t\t\ttail = tail.next;\n\t\t}\n\n\t\ttail.next = head; // cycle\n\n\t\tk %= len;\n\n\t\tfor (int i = 1; i < len - k; i++) {\n\t\t\thead = head.next;\n\t\t}\n\n\t\ttry {\n\t\t\treturn head.next;\n\t\t} finally {\n\t\t\thead.next = null; // cut\n\t\t}\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class BestTimetoBuyandSellStock2 {\n    public int maxProfit(int[] prices) {\n        int min = Integer.MAX_VALUE;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            min = prices[i] < min ? prices[i] : min;\n            int profit = prices[i] - min;\n            maxprofit = Math.max(maxprofit, profit);\n        }\n        return maxprofit;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class LRUCache {\n  public static class DLinkList {\n    int key, value;\n    DLinkList left;\n    DLinkList right;\n\n    DLinkList(int key, int value) {\n      this.key = key;\n      this.value = value;\n      left = null;\n      right = null;\n    }\n  }\n\n  private Map<Integer, DLinkList> cache;\n  private DLinkList head, tail;\n  private int capacity, currentSize;\n\n  \n  private DLinkList popHead() {\n    if (!head.right.equals(tail)) {\n      DLinkList node = head.right;\n      head.right = node.right;\n      node.right.left = head;\n      node.right = null;\n      node.left = null;\n      return node;\n    }\n    return null;\n  }\n\n  \n  private void offer(DLinkList node) {\n    tail.left.right = node;\n    node.left = tail.left;\n    node.right = tail;\n    tail.left = node;\n  }\n\n  \n  private void moveToTail(DLinkList node) {\n    node.left.right = node.right;\n    node.right.left = node.left;\n    offer(node);\n  }\n\n  \n  public static void main(String[] args) throws Exception {\n    LRUCache cache = new LRUCache(2);\n    cache.put(1, 1);\n    cache.put(2, 2);\n    System.out.println(cache.get(1));\n    cache.put(3, 3);\n    System.out.println(cache.get(2));\n    cache.put(4, 4);\n    System.out.println(cache.get(1));\n    System.out.println(cache.get(3));\n    System.out.println(cache.get(4));\n  }\n\n  public LRUCache(int capacity) {\n    this.capacity = capacity;\n    this.currentSize = 0;\n    cache = new HashMap<>();\n    head = new DLinkList(-1, -1);\n    tail = new DLinkList(-1, -1);\n    head.right = tail;\n    tail.left = head;\n  }\n\n  public int get(int key) {\n    if (cache.get(key) == null) return -1;\n    DLinkList node = cache.get(key);\n    moveToTail(node);\n    return node.value;\n  }\n\n  public void put(int key, int value) {\n    if (cache.containsKey(key)) {\n      DLinkList node = cache.get(key);\n      node.value = value;\n      moveToTail(node);\n    } else {\n      if (capacity == currentSize) {\n        DLinkList head = popHead();\n        if (head != null) {\n          cache.remove(head.key);\n          DLinkList node = new DLinkList(key, value);\n          offer(node);\n          cache.put(key, node);\n        }\n      } else {\n        DLinkList node = new DLinkList(key, value);\n        offer(node);\n        cache.put(key, node);\n        ++currentSize;\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class CloneGraph {\n\tclass UndirectedGraphNode {\n\t\tint label;\n\t\tList<UndirectedGraphNode> neighbors;\n\n\t\tUndirectedGraphNode(int x) {\n\t\t\tlabel = x;\n\t\t\tneighbors = new ArrayList<UndirectedGraphNode>();\n\t\t}\n\t}\n\n\tpublic UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n\t\tif (node == null)\n\t\t\treturn null;\n\n\t\tLinkedList<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n\t\tHashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n\t\t\n\t\tUndirectedGraphNode newHead = new UndirectedGraphNode(node.label);\n\t\tqueue.add(node);\n\t\tmap.put(node, newHead);\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tUndirectedGraphNode curr = queue.pop();\n\t\t\tList<UndirectedGraphNode> currNeighbors = curr.neighbors;\n\t\t\tfor (UndirectedGraphNode aNeighbor : currNeighbors) {\n\t\t\t\tif (!map.containsKey(aNeighbor)) {\n\t\t\t\t\tUndirectedGraphNode copy = new UndirectedGraphNode(aNeighbor.label);\n\t\t\t\t\tmap.put(aNeighbor, copy);\n\t\t\t\t\tmap.get(curr).neighbors.add(copy);\n\t\t\t\t\tqueue.add(aNeighbor);\n\t\t\t\t} else {\n\t\t\t\t\tmap.get(curr).neighbors.add(map.get(aNeighbor));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn newHead;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public void nextPermutation(int[] nums) {\n        if (nums.length>1) {\n\n            int a=0;\n            for (int i = 1; i < nums.length; i++) {\n                if (nums[i]>nums[i-1]) {\n                    a=i;\n                }\n            }\n            for (int i = a; i < (a+nums.length)/2; i++) {\n                int k=nums[i];\n                nums[i]=nums[nums.length-i+a-1];\n                nums[nums.length-i+a-1]=k;\n            }\n            if (a>0) {\n                for (int i = a; i < nums.length; i++) {\n                    if (nums[a-1]<nums[i]) {\n                        int k=nums[i];\n                        nums[i]=nums[a-1];\n                        nums[a-1]=k;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class HouseRobber3 {\n\n  private HouseRobber3 h;\n\n  \n  public int rob(TreeNode root) {\n    int[] res = dfs(root);\n    return Math.max(res[0], res[1]);\n  }\n\n  \n  private int[] dfs(TreeNode node) {\n    if (node == null) return new int[2]; // Base case\n    int[] res = new int[2];\n    int[] left = dfs(node.left);\n    int[] right = dfs(node.right);\n    res[0] = node.val + left[1] + right[1];\n    res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    return res;\n  }\n\n  @Before\n  public void setUp() {\n    h = new HouseRobber3();\n  }\n\n  @Test\n  public void testExamples() {\n    TreeNode root = new TreeNode(3);\n    root.left = new TreeNode(2);\n    root.right = new TreeNode(3);\n    root.left.right = new TreeNode(3);\n    root.right.right = new TreeNode(1);\n    Assert.assertEquals(7, h.rob(root));\n\n    root = new TreeNode(3);\n    root.left = new TreeNode(4);\n    root.right = new TreeNode(5);\n    root.left.left = new TreeNode(1);\n    root.left.right = new TreeNode(3);\n    root.right.right = new TreeNode(1);\n    Assert.assertEquals(9, h.rob(root));\n\n    root = new TreeNode(4);\n    root.left = new TreeNode(1);\n    root.left.left = new TreeNode(2);\n    root.left.left.left = new TreeNode(3);\n    Assert.assertEquals(7, h.rob(root));\n  }\n\n  @After\n  public void tearDown() {\n    h = null;\n  }\n\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class FindPeakElement {\n  public static void main(String[] args) throws Exception {\n    int[] nums = {3, 4, 3, 2, 1};\n    System.out.println(new FindPeakElement().findPeakElement(nums));\n  }\n\n  public int findPeakElement(int[] nums) {\n    if (nums.length == 1) return 0;\n    if (nums[0] > nums[1]) return 0;\n    else if (nums[nums.length - 1] > nums[nums.length - 2]) return nums.length - 1;\n\n    int l = 0, h = nums.length - 1;\n    int ans = 0;\n    while (l <= h) {\n      int m = l + (h - l) / 2;\n      if (m - 1 >= 0 && m + 1 < nums.length) {\n        if (nums[m] > nums[m - 1] && nums[m] > nums[m + 1]) {\n          return m;\n        }\n      }\n      if (m - 1 >= 0 && nums[m - 1] > nums[m]) { // search left\n        h = m - 1;\n      } else {\n        ans = l; // mark this as the answer and search right\n        l = m + 1;\n      }\n    }\n    return ans;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class CombinationSum {\n  \n  public static void main(String[] args) throws Exception {\n    int[] candidates = {2, 3, 6, 7};\n\n    List<List<Integer>> result = new CombinationSum().combinationSum(candidates, 7);\n  }\n\n  public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    List<Integer> subList = new ArrayList<>();\n    doNext(0, result, 0, candidates, target, subList);\n    return result;\n  }\n\n  private void doNext(\n      int i,\n      List<List<Integer>> result,\n      int count,\n      int[] candidates,\n      int target,\n      List<Integer> subArr) {\n    if (target == 0) {\n      List<Integer> subList = new ArrayList<>();\n      for (int k = 0; k < count; k++) subList.add(subArr.get(k));\n      result.add(subList);\n    } else if (target > 0) {\n      for (int j = i, l = candidates.length; j < l; j++) {\n        subArr.add(candidates[j]);\n        doNext(j, result, count + 1, candidates, target - candidates[j], subArr);\n        subArr.remove(subArr.size() - 1);\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public int trap(int[] heights) {\n        if (heights == null || heights.length == 0) {\n            return 0;\n        }   \n        int[] leftSideHighWall = new int[heights.length + 1];\n        leftSideHighWall[0] = 0;\n        for (int i = 0; i < heights.length; i++) {\n            leftSideHighWall[i + 1] = Math.max(leftSideHighWall[i], heights[i]);\n        }\n        int rightSideHighWall = 0;\n        int sum = 0;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            int minOfTwoWalls = Math.min(leftSideHighWall[i], rightSideHighWall);\n            sum += minOfTwoWalls > heights[i] ? minOfTwoWalls - heights[i] : 0;\n            rightSideHighWall = Math.max(heights[i], rightSideHighWall);\n        }\n        return sum;\n    }\n}\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "class RemoveDuplicatesFromSortedArray2 {\n\n  \n  public int removeDuplicates(int[] nums) {\n    if (nums == null) return 0;\n    int n = nums.length;\n    if (n <= 2)\n      return n;\n    int length = 2;\n    for (int i = 2; i < n; i++) {\n      if (nums[i] != nums[length - 2]) { // Compare with the second last element of the new array.\n        nums[length] = nums[i];\n        length++;\n      }\n    }\n    return length;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "class BestTimeToBuyAndSellStock3 {\n\n  public static void main(String[] args) {\n    BestTimeToBuyAndSellStock3 b = new BestTimeToBuyAndSellStock3();\n    int[] prices = {6, 1, 3, 2, 4, 7, 6, 10, 15};\n    System.out.println(b.maxProfit(prices));\n  }\n\n  \n  public int maxProfit(int[] prices) {\n    int maxProfit = 0;\n    if (prices == null || prices.length < 2) {\n      return maxProfit;\n    }\n    int len = prices.length;\n    int[] maxBy = new int[len];\n    int[] maxSince = new int[len];\n    int valley = prices[0];\n    int peak = prices[len - 1];\n\n    for (int i = 1; i < len; i++) {\n      valley = Math.min(valley, prices[i]);\n      maxBy[i] = Math.max(maxBy[i - 1], prices[i] - valley);\n    }\n    \n    for (int i = len - 2; i >= 0; i--) {\n      peak = Math.max(peak, prices[i]);\n      maxSince[i] = Math.max(maxSince[i + 1], peak - prices[i]);\n      maxProfit =\n          Math.max(maxProfit, maxBy[i]\n              + maxSince[i]); // find i such that maxBy[i]+maxSince[i+1] is the max two-transaction profit, no overlap\n    }\n    return maxProfit;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class UniquePaths {\n  public int uniquePaths(int m, int n) {\n    if (m == 0 || n == 0) return 0;\n    int[][] map = new int[m][n];\n    for (int i = 0; i < m; i++) {\n      map[i][0] = 1;\n    }\n    for (int j = 0; j < n; j++) {\n      map[0][j] = 1;\n    }\n    for (int i = 1; i < m; i++) {\n      for (int j = 1; j < n; j++) {\n        map[i][j] = map[i - 1][j] + map[i][j - 1];\n      }\n    }\n    return map[m - 1][n - 1];\n  }\n}\n", "nl": "mengli"}
{"code": "public class LongestValidParentheses {\n\tpublic int longestValidParentheses(String s) {\n\t\tint res = 0;\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tchar[] arr = s.toCharArray();\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i] == ')' && !stack.isEmpty() && arr[stack.peek()] == '(') {\n\t\t\t\tstack.pop();\n\t\t\t\tif (stack.isEmpty())\n\t\t\t\t\tres = i + 1;\n\t\t\t\telse\n\t\t\t\t\tres = Math.max(res, i - stack.peek());\n\t\t\t} else {\n\t\t\t\tstack.push(i);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class RemoveDuplicatesfromSortedList {\n  public ListNode deleteDuplicates(ListNode head) {\n    if (head == null) return head;\n    int cur = head.val;\n    ListNode p = head.next;\n    ListNode prev = head;\n    while (p != null) {\n      if (p.val == cur) {\n        prev.next = p.next;\n        p = prev.next;\n      } else {\n        cur = p.val;\n        prev = prev.next;\n        p = p.next;\n      }\n    }\n    return head;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public int[] plusOne(int[] digits) {\n        int i=digits.length-1;\n        boolean flag= false;\n        do {\n            if (digits[i]<9) {\n                digits[i]+=1;\n                flag=false;\n            }else {\n                digits[i]=0;\n                flag=true;\n            }\n            i--;\n        } while (flag&&i>=0);\n        if (flag) {\n            int[] answer=new int[digits.length+1];\n            answer[0]=1;\n            return answer;\n        }else {\n            return digits;\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0)\n            return \"\";\n        \n        for(int i=strs[0].length();i>0;i--){\n            boolean isSame= true;\n            String prefix = strs[0].substring(0,i);\n            for(int j=1;j<strs.length;j++){\n        \t\tif(!strs[j].startsWith(prefix)){\n        \t\t\tisSame = false;\n                    break;\n        \t\t}\n        \t}\n            if(isSame)\n                return strs[0].substring(0,i);         \n        }\n        return \"\";\n\n    }\n}", "nl": "azheanda"}
{"code": "public class ValidNumber {\n\tpublic boolean isNumber(String s) {\n\t    if(s==null)\n\t        return false;\n\t    s = s.trim();\n\t    if(s.length()==0)\n\t        return false;\n\t    boolean dotFlag = false;\n\t    boolean eFlag = false;\n\t    for(int i=0;i<s.length();i++)\n\t    {\n\t        switch(s.charAt(i))\n\t        {\n\t            case '.':\n\t                if(dotFlag || eFlag \n\t                || ((i==0||!(s.charAt(i-1)>='0'&&s.charAt(i-1)<='9')) \n\t                    && (i==s.length()-1||!(s.charAt(i+1)>='0'&&s.charAt(i+1)<='9'))))\n\t                    return false;\n\t                dotFlag = true;\n\t                break;\n\t            case '+':\n\t            case '-':\n\t                if((i>0 && (s.charAt(i-1)!='e' && s.charAt(i-1)!='E'))\n\t                  || (i==s.length()-1 || !(s.charAt(i+1)>='0'&&s.charAt(i+1)<='9'||s.charAt(i+1)=='.')))\n\t                    return false;\n\t                break;\n\t            case 'e':\n\t            case 'E':\n\t                if(eFlag || i==s.length()-1 || i==0)\n\t                    return false;\n\t                eFlag = true;\n\t                break;\n\t            case '0':\n\t            case '1':\n\t            case '2':\n\t            case '3':\n\t            case '4':\n\t            case '5':\n\t            case '6':\n\t            case '7':\n\t            case '8':\n\t            case '9':\n\t                break;\n\t            default:\n\t                return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class BinaryTreeLevelOrderTraversal {\n\n    public class Solution {\n        private void search(TreeNode root, int level,\n                ArrayList<ArrayList<Integer>> ans) {\n            if (root == null) {\n                return;\n            }\n            if (level >= ans.size()) {\n                ans.add(new ArrayList<Integer>());\n            }\n            ans.get(level).add(root.val);\n            search(root.left, level + 1, ans);\n            search(root.right, level + 1, ans);\n        }\n\n        public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {\n            ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n            search(root, 0, ans);\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class ValidPalindrome2Test {\n\n    @DataProvider(name = \"examples\")\n    public Object[][] getExamples() {\n        return new Object[][]{\n                new Object[]{\"aba\", true},\n                new Object[]{\"abca\", true},\n                new Object[]{\"acac\", true},\n                new Object[]{\"aacc\", false},\n                new Object[]{\"a\", true},\n                new Object[]{\"ab\", true},\n                new Object[]{\"abc\", false}\n        };\n    }\n\n    @Test(dataProvider = \"examples\")\n    public void testValidPalindromeExamples(String s, boolean expected) {\n        ValidPalindrome2 v = new ValidPalindrome2();\n        Assert.assertEquals(v.validPalindrome(s), expected);\n    }\n\n    @Test\n    public void testNullString() {\n        ValidPalindrome2 v = new ValidPalindrome2();\n        assertFalse(v.validPalindrome(null));\n    }\n\n    @Test\n    public void testEmptyString() {\n        ValidPalindrome2 v = new ValidPalindrome2();\n        assertTrue(v.validPalindrome(\"\"));\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class BinaryTreeInorderTraversal {\n  public static class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    TreeNode root = new TreeNode(3);\n    root.left = new TreeNode(4);\n    root.left.left = new TreeNode(5);\n    root.left.right = new TreeNode(6);\n    root.left.left.left = new TreeNode(9);\n    root.left.left.right = new TreeNode(10);\n    root.right = new TreeNode(2);\n    root.right.left = new TreeNode(7);\n    root.right.right = new TreeNode(8);\n    List<Integer> result = new BinaryTreeInorderTraversal().inorderTraversal(root);\n    System.out.println(result);\n  }\n\n  public List<Integer> inorderTraversal(TreeNode root) {\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode curr = root;\n    List<Integer> result = new ArrayList<>();\n    while (curr != null || !stack.isEmpty()) {\n      while (curr != null) {\n        stack.push(curr);\n        curr = curr.left;\n      }\n      curr = stack.pop();\n      result.add(curr.val);\n      curr = curr.right;\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        return f(candidates,target,candidates.length-1);\n    }\n    public List<List<Integer>> f(int[] candidates, int target,int l) {\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();\n        if (candidates[0]>target||target<0||l<0) {\n            return ans;\n        }\n        for (int i =l; i >=0 ; i--) {\n            int k=candidates[i];\n            if (k==target) {\n                List<Integer> list=new ArrayList<Integer>();\n                list.add(k);\n                ans.add(list);\n            }else {\n                List<List<Integer>> q=f(candidates,target-k,i-1);\n                if (q!=null&&q.size()!=0) {\n                    for (int j = 0; j < q.size(); j++) {\n                        List<Integer> list=q.get(j);\n                        list.add(k);\n                        ans.add(list);\n                    }\n                }\n            }\n            while (i>0&&candidates[i]==candidates[i-1]) {\n                i--;\n            }\n        }\n        return ans;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class SearchInsertPosition {\n  public int searchInsert(int[] A, int target) {\n    int length = A.length;\n    if (A.length == 0) return 0;\n    int i = 0, j = length - 1;\n    while (i < j) {\n      int mid = (i + j) / 2;\n      if (A[mid] == target) return mid;\n      if (A[mid] < target) {\n        i = mid + 1;\n      } else {\n        j = mid - 1;\n      }\n    }\n    return A[i] < target ? i + 1 : i;\n  }\n}\n", "nl": "mengli"}
{"code": "public class _113_pathSum {\n    public static void main(String[] args) {\n        TreeNode treeNode = Util.generateTreeNode();\n        List<List<Integer>> lists = pathSum(treeNode, 22);\n        for (int i = 0; i < lists.size(); i++) {\n            Util.printList(lists.get(i));\n        }\n    }\n\n    public static List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        dfs(root, sum, path, 0, result);\n        return result;\n    }\n\n    private static void dfs(TreeNode root,\n                            int sum,\n                            List<Integer> path,\n                            int pathSum,\n                            List<List<Integer>> result) {\n        if (root == null) {\n            return;\n        }\n        path.add(root.val);\n        pathSum += root.val;\n        if (pathSum == sum && root.left == null && root.right == null) {\n            result.add(new ArrayList<>(path));\n        }\n        dfs(root.left, sum, path, pathSum, result);\n        dfs(root.right, sum, path, pathSum, result);\n        path.remove(path.size() - 1);\n        pathSum -= root.val;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class FlattenBinaryTreetoLinkedList3 {\n\tpublic void flatten(TreeNode root) {\n\t\tflatten(root, new TreeNode[1]);\n\t}\n\n\tprivate void flatten(TreeNode root, TreeNode[] prev) {\n\t\tif (root == null)\n\t\t\treturn;\n\t\tif (prev[0] == null) {\n\t\t\tprev[0] = root;\n\t\t} else {\n\t\t\tprev[0].right = root;\n\t\t\tprev[0] = root;\n\t\t}\n\t\tTreeNode leftBeforeModification = root.left;\n\t\tTreeNode rightBeforeModification = root.right;\n\t\troot.left = null;\n\t\tflatten(leftBeforeModification, prev);\n\t\tflatten(rightBeforeModification, prev);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class JumpGame {\n\n    public class Solution {\n        public boolean canJump(int[] A) {\n            assert A != null;\n            int far = 0;\n            for (int i = 0; i < A.length && i <= far; i++) {\n                far = Math.max(far, A[i] + i);\n            }\n            return far >= A.length - 1;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() <= 1) {\n        \treturn s;\n        }\n        int x = 2 * s.length() - 1;\n        String str = \"\";\n        int max = 0;\n        for (int i = 0; i < x; i++) {//Check through the 2*len - 1\n        \tint left = i / 2;\n        \tint right = i / 2;\n        \tif (i % 2 == 1) {\n        \t\tright++;\n        \t}\n        \twhile(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        \t\tleft--;\n        \t\tright++;\n        \t}\n        \tString temp = s.substring(left + 1, right);\n        \tif (temp.length() > max) {\n        \t\tmax = temp.length();\n        \t\tstr = temp;\n        \t}\n        }//END for\n        return str;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "class Solution {\n    \n    public double findMedianSortedArrays(int[] A, int[] B) {\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Searcha2DMatrixII {\n\tpublic boolean searchMatrix(int[][] matrix, int target) {\n\t\tif(matrix == null || matrix.length < 1 || matrix[0].length <1) {\n\t\t\treturn false;\n\t\t}\n\t\tint col = matrix[0].length-1;\n\t\tint row = 0;\n\t\twhile(col >= 0 && row <= matrix.length-1) {\n\t\t\tif(target == matrix[row][col]) {\n\t\t\t\treturn true;\n\t\t\t} else if(target < matrix[row][col]) {\n\t\t\t\tcol--;\n\t\t\t} else if(target > matrix[row][col]) {\n\t\t\t\trow++;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MultiplyStrings2 {\n\tpublic String multiply(String num1, String num2) {\n\t    num1 = new StringBuilder(num1).reverse().toString();\n\t    num2 = new StringBuilder(num2).reverse().toString();\n\t    int[] d = new int[num1.length() + num2.length()];\n\t    for (int i = 0; i < num1.length(); i++) {\n\t        int a = num1.charAt(i) - '0';\n\t        for (int j = 0; j < num2.length(); j++) {\n\t            int b = num2.charAt(j) - '0';\n\t            d[i + j] += a * b;\n\t        }\n\t    }\n\t    StringBuilder sb = new StringBuilder();\n\t    for (int i = 0; i < d.length; i++) {\n\t        int digit = d[i] % 10;\n\t        int carry = d[i] / 10;\n\t        sb.insert(0, digit);\n\t        if (i < d.length - 1)\n\t            d[i + 1] += carry;\n\t        }\n\t    while (sb.length() > 0 && sb.charAt(0) == '0') {\n\t        sb.deleteCharAt(0);\n\t    }\n\t    return sb.length() == 0 ? \"0\" : sb.toString();\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class LargestRectangleInHistogram {\n  public static void main(String[] args) throws Exception {\n    int[] A = {2, 3};\n    System.out.println(new LargestRectangleInHistogram().largestRectangleArea(A));\n  }\n\n  public int largestRectangleArea(int[] heights) {\n    if (heights.length == 0) return 0;\n    int maxArea = Integer.MIN_VALUE;\n    Stack<Integer> stack = new Stack<>();\n    int i = 0;\n    for (; i < heights.length; i++) {\n      while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n        int top = stack.pop();\n        int base = stack.isEmpty() ? i : i - stack.peek() - 1;\n        maxArea = Math.max(maxArea, base * heights[top]);\n      }\n      stack.push(i);\n    }\n    while (!stack.isEmpty()) {\n      int top = stack.pop();\n      int base = stack.isEmpty() ? i : i - stack.peek() - 1;\n      maxArea = Math.max(maxArea, base * heights[top]);\n    }\n    return maxArea;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class SubsetsII \n{\n    public List<List<Integer>> subsetsWithDup(int[] nums ) \n    {\n    \tList<List<Integer>> allSubsets = new LinkedList<>();\n    \tLinkedList<Integer> oneSubset = new LinkedList<>();\n    \tArrays.sort( nums );\n    \tgenerateSubsets( allSubsets, oneSubset, nums, 0 );\n    \treturn allSubsets;\n    }\n    \n    private void generateSubsets( List<List<Integer>> allSubsets, LinkedList<Integer> oneSubset, int[] nums, int startPos )\n    {\n    \tif ( startPos > nums.length )\n    \t{\n    \t\treturn;\n    \t}\n    \t\n    \tallSubsets.add( new LinkedList<>( oneSubset ) );\n    \t\n    \tfor ( int i = startPos; i < nums.length; i++ )\n    \t{\n    \t\tif ( i > startPos \n    \t\t\t\t&& nums[i] == nums[i-1] )\n    \t\t{\n    \t\t\tcontinue;\n    \t\t}\n    \t\t\n    \t\toneSubset.addLast( nums[i] );\n    \t\tgenerateSubsets( allSubsets, oneSubset, nums, i + 1 );\n    \t\toneSubset.removeLast( );\n    \t}\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class SingleNumber {\n\tpublic int singleNumber(int[] A) {\n\t\tint len = A.length;\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tint record = A[0];\n\t\tfor (int i = 1; i < len; i++) \n\t\t\trecord = record ^ A[i];\n\t\treturn record;\n\t}\n}\n", "nl": "gaohannk"}
{"code": " public class Solution {\n    public boolean isPalindrome(String s) {\n        s = s.toLowerCase().replaceAll(\"\\\\W\", \"\");\n        System.out.println(s);\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j))\n                return false;\n        }\n        return true;   \n    }\n}", "nl": "leetcoders"}
{"code": "public class RemoveDuplicatesfromSortedArray {\n\n    public class Solution {\n        public int removeDuplicates(int[] A) {\n            assert A != null;\n            if (A.length == 0) {\n                return 0;\n            }\n            int len = 1;\n            for (int i = 1; i < A.length; i++) {\n                if (A[len - 1] != A[i]) {\n                    A[len++] = A[i];\n                }\n            }\n            return len;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "class Solution {\n    public int singleNumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        for (int i = 1; i < nums.length; i++) {\n            nums[0] = nums[0] ^ nums[i];\n        }\n        return nums[0];\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class HIndex {\n\n    \n    public int hIndex(int[] citations) {\n        int n = citations.length;\n        int[] counts = new int[n + 1];\n        for (int c : citations) {\n            if (c > n) {\n                counts[n]++;\n            } else {\n                counts[c]++;\n            }\n        }\n        int papers = 0;\n        for (int i = n; i >= 0; i--) {\n            papers += counts[i];\n            if (papers >= i) {\n                return i;\n            }\n        }\n        return 0;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class PowXN {\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(1 / new PowXN().myPow(2.00000, -2147483648));\n  }\n\n  public double myPow(double x, int n) {\n    if (n == 0) return 1D;\n    long N = n; // use long to avoid overflow.\n    return solve(n < 0 ? (1 / x) : x, N < 0 ? (N * -1) : N);\n  }\n\n  public double solve(double x, long n) {\n    if (n == 1) return x;\n    double val = solve(x, n / 2);\n    return val * val * ((n % 2) == 0 ? 1 : x);\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class L028_Implement_strStr {\n\n\tpublic int strStr(String haystack, String needle) {\n\n\t\tif (haystack == null || needle == null\n\t\t\t\t|| haystack.length() < needle.length()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (needle.length() == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (int i = 0; i < haystack.length(); i++) {\n\n\t\t\tif (i + needle.length() > haystack.length()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint m = i;\n\t\t\tfor (int j = 0; j < needle.length(); j++) {\n\t\t\t\tif (needle.charAt(j) == haystack.charAt(m)) {\n\t\t\t\t\tif (j == needle.length() - 1) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class MaximumSubarray {\n\n\n  \n  public int maxSubArray(int[] nums) {\n    if (nums == null || nums.length == 0) return 0;\n    int max = nums[0];\n    int maxEndingHere = nums[0];\n    for (int i = 1; i < nums.length; ++i) {\n      maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);\n      max = Math.max(max, maxEndingHere);\n    }\n    return max;\n  }\n\n  \n  public int maxSubArraySumB(int[] nums) {\n    if (nums == null || nums.length == 0) {\n      return 0;\n    }\n    int[] s = new int[nums.length]; // save max sum so far in an array\n    s[0] = nums[0];\n    int max = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n      s[i] = s[i - 1] > 0 ? (nums[i] + s[i - 1]) : nums[i];\n      max = Math.max(max, s[i]);\n    }\n    return max;\n  }\n\n  \n  public int[] maxSubArrayB(int[] A) {\n    int beginTemp = 0; // save the temporary begining index\n    int begin = 0; // begining index\n    int end = 0; // ending index\n    int maxSoFar = A[0]; // max sum of previous sequence\n    int maxEndingHere = A[0]; // max sum of this group\n\n    for (int i = 1; i < A.length; i++) {\n      if (maxEndingHere < 0) { // last A[i] is too small\n        maxEndingHere = A[i];\n        beginTemp = i; // update begin temp\n      } else {\n        maxEndingHere += A[i];\n      }\n\n      if (maxEndingHere >= maxSoFar) { // update max so far\n        maxSoFar = maxEndingHere;\n        begin = beginTemp; // save index range\n        end = i;\n      }\n    }\n    return new int[]{begin, end, maxSoFar};\n  }\n\n  \n  public int maxSubArray3(int[] nums) {\n    return maxSubArray(nums, 0, nums.length - 1);\n  }\n\n  private int maxSubArray(int[] nums, int start, int end) {\n    if (start == end) return nums[start];\n    int mid = start + (end - start) / 2;\n    int max1 = maxSubArray(nums, start, mid);\n    int max2 = maxSubArray(nums, mid + 1, end);\n    int max3 = crossMidMaxSum(nums, start, end, mid);\n    return Math.max(max1, Math.max(max2, max3));\n  }\n\n  \n  private int crossMidMaxSum(int[] nums, int start, int end, int mid) {\n    int leftMax = Integer.MIN_VALUE;\n    int sum = 0;\n    for (int i = mid; i >= start; i--) {\n      sum += nums[i];\n      if (sum > leftMax) leftMax = sum;\n    }\n\n    int rightMax = Integer.MIN_VALUE;\n    sum = 0;\n    for (int i = mid + 1; i <= end; i++) {\n      sum += nums[i];\n      if (sum > rightMax) rightMax = sum;\n    }\n    return leftMax + rightMax;\n  }\n\n}", "nl": "FreeTymeKiyan"}
{"code": "public class PathSum {\n\n    public class Solution {\n        public boolean hasPathSum(TreeNode root, int sum) {\n            if (root == null) {\n                return false;\n            }\n            if (root.left == null && root.right == null) {\n                return sum == root.val;\n            }\n            return hasPathSum(root.left, sum - root.val)\n                    || hasPathSum(root.right, sum - root.val);\n        }\n    }\n\n    public static class UnitTest {\n\n        @Test\n        public void test() {\n            new PathSum().new Solution().hasPathSum(new TreeNode(1), 1);\n        }\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class BinaryTreePreorderTraversal2 {\n\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (root == null)\n\t\t\treturn list;\n\t\thelper(list, root);\n\t\treturn list;\n\t}\n\n\tpublic void helper(ArrayList<Integer> list, TreeNode node) {\n\t\tif (node != null) {\n\t\t\tlist.add(node.val);\n\t\t\thelper(list, node.left);\n\t\t\thelper(list, node.right);\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Permutations2 {\n\n  \n  public List<List<Integer>> permuteUniqueB(int[] num) {\n    List<List<Integer>> res = new ArrayList<>();\n    if (num == null || num.length == 0) return res;\n    Arrays.sort(num);\n    List<Integer> row = new ArrayList<>();\n    for (int a : num) row.add(a);\n    res.add(new ArrayList<>(row)); // first permutation\n    while (nextPermutation(row)) { // if there is next permutation\n      res.add(new ArrayList<>(row));\n    }\n    return res;\n  }\n\n  \n  private boolean nextPermutation(List<Integer> row) {\n    int last = row.size() - 1;\n    for (int pos = last - 1; pos >= 0; pos--) {\n      if (row.get(pos) < row.get(pos + 1)) {\n        int smallIdx = pos;\n        int biggerIdx = pos + 1;\n        for (int i = pos + 1; i <= last; i++)\n          if (row.get(i) > row.get(pos)) biggerIdx = i;\n        swap(row, smallIdx, biggerIdx);\n        reverse(row, pos + 1, last);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private void swap(List<Integer> row, int a, int b) {\n    int t = row.get(a);\n    row.set(a, row.get(b));\n    row.set(b, t);\n  }\n\n  private void reverse(List<Integer> row, int s, int e) {\n    while (s < e) {\n      swap(row, s, e);\n      s++;\n      e--;\n    }\n  }\n\n  \n  public List<List<Integer>> permuteUnique(int[] num) {\n    if (num == null || num.length == 0) {\n      return Collections.emptyList();\n    }\n    Arrays.sort(num);\n    final List<List<Integer>> res = new ArrayList<>();\n    dfs(num, 0, res);\n    return res;\n  }\n\n  private void dfs(int[] num, int pos, List<List<Integer>> res) {\n    if (pos == num.length) {\n      final List<Integer> row = new ArrayList<>(num.length);\n      for (int a : num) {\n        row.add(a);\n      }\n      res.add(row);\n      return;\n    }\n    for (int i = pos; i < num.length; i++) {\n      boolean skip = false;\n      for (int j = pos; j < i; j++) {\n        if (num[j] == num[i]) {\n          skip = true;\n          break;\n        }\n      }\n      if (skip) continue;\n      swap(num, pos, i);\n      dfs(num, pos + 1, res);\n      swap(num, pos, i); // Reset\n    }\n  }\n\n  private void swap(int[] num, int i, int j) {\n    if (i == j) {\n      return;\n    }\n    num[i] = num[j] - num[i];\n    num[j] = num[j] - num[i];\n    num[i] = num[j] + num[i];\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    List<List<Integer>> ans=new ArrayList<List<Integer>>();\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        if (nums.length<3) {\n            return ans;\n        }\n        int length=nums.length;\n        for (int i = 0; i < length-2; i++) {\n            if (i==0||nums[i]!=nums[i-1]) {\n                f(nums,nums[i],i+1,length-1);\n            }\n        }\n        return ans;\n    }\n    public void f(int[] nums,int target,int s,int e){\n        while (s<e) {\n            int res=nums[s]+nums[e]+target;\n            if (res==0) {\n                List<Integer> list=new ArrayList<Integer>();\n                list.add(target);\n                list.add(nums[s]);\n                list.add(nums[e]);\n                ans.add(list);\n                while (s<e&&nums[s] == nums[s+1]) {\n                    s++;\n                }\n                while (s<e&&nums[e] == nums[e-1]) {\n                    e--;\n                }\n                s++;\n                e--;\n            }else if(res<0) {\n                s++;\n            }else {\n                e--;\n            }\n        }\n    };\n}", "nl": "corpsepiges"}
{"code": "public class JumpGame {\n\tpublic boolean canJump(int[] A) {\n\t\tint farest = 0;\n\t\tfor (int i = 0; i <= farest; i++) {\n\t\t\tif (A[i] + i > farest)\n\t\t\t\tfarest = A[i] + i;\n\t\t\tif (farest >= A.length - 1)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}", "nl": "gaohannk"}
{"code": "public class GenerateParentheses {\n\tpublic ArrayList<String> generateParenthesis(int n) {\n\t\tArrayList<String> res = new ArrayList<String>();\n\t\tgenerate(n, n, \"\", res);\n\t\treturn res;\n\t}\n\n\tpublic void generate(int left, int right, String str, ArrayList<String> res) {\n\t\tif (left == 0 && right == 0) {\n\t\t\tres.add(str);\n\t\t\treturn;\n\t\t}\n\t\tif (left > 0) {\n\t\t\tgenerate(left - 1, right, str + '(', res);\n\t\t}\n\t\tif (right > left) {\n\t\t\tgenerate(left, right - 1, str + ')', res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tGenerateParentheses slt = new GenerateParentheses();\n\t\tArrayList<String> res = slt.generateParenthesis(3);\n\t\tfor (String str : res) {\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "class RotateImage {\n  public static void main(String[] args) {\n    int[][] matrix = {{1, 2}, {4, 3}};\n    new RotateImage().rotate(matrix);\n    for (int i = 0; i < matrix.length; i++) {\n      for (int j = 0; j < matrix[i].length; j++) {\n        System.out.print(matrix[i][j] + \" \");\n      }\n      System.out.println();\n    }\n  }\n\n  \n  public void rotate(int[][] matrix) {\n    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n      return;\n    }\n    int n = matrix.length;\n    for (int i = 0; i < n / 2; i++) {\n      for (int j = i; j < n - i - 1; j++) {\n        int tmp = matrix[i][j]; // Save in a temporary variable\n        matrix[i][j] = matrix[n - j - 1][i]; // First column\n        matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; // Last row\n        matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; // Last column\n        matrix[j][n - i - 1] = tmp;\n      }\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class L039_Combination_Sum {\n\n\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n\n\t\tif (candidates == null || candidates.length == 0) {\n\t\t\treturn new ArrayList<List<Integer>>();\n\t\t}\n\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tArrayList<Integer> cur = new ArrayList<Integer>();\n\n\t\tArrays.sort(candidates);\n\t\tdfs(0, target, result, cur, candidates);\n\n\t\treturn result;\n\t}\n\n\tprivate void dfs(int start, int target, List<List<Integer>> result,\n\t\t\tArrayList<Integer> cur, int[] candidates) {\n\n\t\tif (target == 0) {\n\t\t\tresult.add(new ArrayList<Integer>(cur));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = start; i < candidates.length; i++) {\n\n\t\t\tif (candidates[i] > target) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcur.add(candidates[i]);\n\t\t\tdfs(i, target - candidates[i], result, cur, candidates);\n\t\t\tcur.remove(cur.size() - 1);\n\t\t}\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class AddTwoNumbers2 {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode p = l1, q = l2, curr = dummyHead;\n        int carry = 0;\n        while (p != null || q != null) {\n            int x = (p != null) ? p.val : 0;\n            int y = (q != null) ? q.val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n            if (p != null)\n                p = p.next;\n            if (q != null)\n                q = q.next;\n        }\n        if (carry > 0) {\n            curr.next = new ListNode(carry);\n        }\n        return dummyHead.next;\n    }\n\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums == null || nums.length == 0) return result; // edge case\n\n        Arrays.sort(nums);\n        List<Integer> list = new ArrayList<>();\n\n        result.add(new ArrayList<>(list));\n        dfs(result, list, nums, 0);    \n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> list, int[] nums, int depth) {\n        for (int i = depth; i < nums.length; i++) {\n            if (i > depth && nums[i] == nums[i - 1]) continue; // IMPORTANT, skip duplicate: i > depth && nums[i] == nums[i - 1]\n            list.add(nums[i]);\n            result.add(new ArrayList<>(list));\n            dfs(result, list, nums, i + 1);\n            list.remove(list.size() - 1);\n        }\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class BinaryTreePreorderTraversal {\n  public ArrayList<Integer> preorderTraversal(TreeNode root) {\n    ArrayList<Integer> ret = new ArrayList<Integer>();\n    if (root == null) return ret;\n    Stack<TreeNode> st = new Stack<TreeNode>();\n    TreeNode p = root.left;\n    ret.add(root.val);\n    st.add(root);\n    while (!st.isEmpty()) {\n      while (p != null) {\n        ret.add(p.val);\n        st.add(p);\n        p = p.left;\n      }\n      TreeNode node = st.pop();\n      p = node.right;\n      if (p != null) {\n        ret.add(p.val);\n        st.add(p);\n        p = p.left;\n      }\n    }\n    return ret;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    \n    public int maxArea(int[] heights) {\n    \tif (heights == null || heights.length == 0) {\n    \t\treturn 0;\n    \t}\n    \tint left = 0;\n    \tint right = heights.length - 1;\n    \tint maxWater = Integer.MIN_VALUE;\n    \twhile (left < right) {\n    \t\tmaxWater = Math.max(maxWater, (right-left) * (heights[left] < heights[right] ? heights[left] : heights[right]));\n    \t\tif (heights[left] < heights[right]) {\n    \t\t\tleft++;\n    \t\t} else {\n    \t\t\tright--;\n    \t\t}\n    \t}\n    \treturn maxWater;\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public int[] plusOne(int[] digits) {\n        if(digits.length==0) return digits;\n        digits[digits.length-1] += 1;\n        for(int i = digits.length-1; i>0; i--){\n            if(digits[i] == 10){\n                digits[i]=0;\n                digits[i-1]+=1;\n            }\n            else return digits;\n        }\n        \n        if(digits[0]==10){\n            int[] output = new int[digits.length+1];\n            output[0] = 1;\n            return output;\n        }\n        else return digits;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class UniquePaths3 {\n\tpublic int uniquePaths(int m, int n) {\n\t\tint[][] res = new int[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tres[i][0] = 1;\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tres[0][j] = 1;\n\t\t}\n\t\tfor (int i = 1; i < m; i++) {\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tres[i][j] = res[i - 1][j] + res[i][j - 1];\n\t\t\t}\n\t\t}\n\t\treturn res[m - 1][n - 1];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class CombinationSumII \n{\n    public List<List<Integer>> combinationSum2( int[] candidates, int target )\n    {\n    \tList<List<Integer>> allCombs = new LinkedList<>();\n    \tLinkedList<Integer> oneComb = new LinkedList<>();\n    \tArrays.sort( candidates );\n    \tgenerateCombs( allCombs, oneComb, candidates, 0, target );\n    \treturn allCombs;   \t\n    }\n    \n    private void generateCombs( List<List<Integer>> allCombs, LinkedList<Integer> oneComb, int[] candidates, int startPos, int targetSum )\n    {\n    \tif ( targetSum < 0 )\n    \t{\n    \t\treturn;\n    \t}\n    \t\n    \tif ( targetSum == 0 )\n    \t{\n    \t\tallCombs.add( new LinkedList<>( oneComb ) );\n    \t\treturn;\n    \t}\n    \t\n    \tfor ( int i = startPos; i < candidates.length; i++ )\n    \t{\n    \t\tif ( i > startPos\n    \t\t\t\t&& candidates[i] == candidates[i-1] )\n    \t\t{\n    \t\t\tcontinue;\n    \t\t}\n    \t\toneComb.addLast( candidates[i] );\n    \t\tgenerateCombs( allCombs, oneComb, candidates, i + 1, targetSum - candidates[i] );\n    \t\toneComb.removeLast();\n    \t}\n    }    \n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public void merge(int A[], int m, int B[], int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int x = m + n - 1;\n        while (i >= 0 && j >= 0)\n            if (A[i] >= B[j]) A[x--] = A[i--];\n            else A[x--] = B[j--];\n        while (j >= 0) A[x--] = B[j--];\n    }\n}", "nl": "leetcoders"}
{"code": "public class FlattenBinaryTreetoLinkedList4 {\n\tpublic void flatten(TreeNode root) {\n\t\tif (root == null) \n\t\t\treturn;\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tstack.push(root);\n\t\tTreeNode prev = null;\n\t\twhile (!stack.empty()) {\n\t\t\tTreeNode top = stack.pop();\n\t\t\tif (top.right != null)\n\t\t\t\tstack.push(top.right);\n\t\t\tif (top.left != null)\n\t\t\t\tstack.push(top.left);\n\t\t\tif (prev != null) {\n\t\t\t\tprev.right = top;\n\t\t\t\tprev.left = null;\n\t\t\t}\n\t\t\tprev = top;\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public ListNode addLists(ListNode l1, ListNode l2) {\n        ListNode rst = new ListNode(0);\n        ListNode dummy = rst;\n        int carrier = 0;\n        while (l1 != null || l2 != null) {\n            if (l1 != null) {\n                carrier += l1.val;\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                carrier += l2.val;\n                l2 = l2.next;\n            }\n            rst.next = new ListNode(carrier % 10);\n            carrier = carrier / 10;\n            rst = rst.next;\n        }\n        if (carrier == 1) {\n            rst.next = new ListNode(1);\n        }\n        return dummy.next;\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class RegularExpressionMatching3 {\n\tpublic boolean isMatch(String s, String p) {\n\t\tif (p.length() == 0)\n\t\t\treturn s.length() == 0;\n\n\t\tif (p.length() == 1)\n\t\t\treturn (s.length() == 1) && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.');\n\n\t\tif (p.charAt(1) != '*') {\n\t\t\tif (s.length() < 1)\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\treturn (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.') && isMatch(s.substring(1), p.substring(1));\n\t\t}\n\t\twhile (s.length() > 0 && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')) {\n\t\t\tif (isMatch(s, p.substring(2)))\n\t\t\t\treturn true;\n\t\t\ts = s.substring(1);\n\t\t}\n\t\treturn isMatch(s, p.substring(2));\n\t}\n\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {\n        ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();\n        if(num.length<3)\n            return ret;\n        \n        Arrays.sort(num);        \n        for(int i=0;i<num.length-2;i++){                  \n            int p=i+1, q=num.length-1;\n            while(p<q){\n                if(num[p]+num[q]==-num[i]){\n                         ArrayList<Integer> triplet = new ArrayList<Integer>(3);\n                         triplet.add(num[i]);\n                         triplet.add(num[p]);\n                         triplet.add(num[q]);\n                         if(!ret.contains(triplet))\n                            ret.add(triplet);\n                         p++;    q--;  // add \"q--\" here to avoid more duplicates\n                }\n                else if (num[p]+num[q]>-num[i])\n                    q--;\n                else\n                    p++;\n            }\n        }\n        return ret;\n        \n    }\n}\n\n", "nl": "azheanda"}
{"code": "public class Solution {\n    public ListNode mergeKLists_1(List<ListNode> lists) {\n        Comparator<ListNode> comp =  new Comparator<ListNode>(){  \n            public int compare(ListNode a,  ListNode b) {  \n                if(b.val > a.val) {  \n                    return -1;  \n                }else if(b.val < a.val){  \n                    return 1;  \n                } else {  \n                    return 0;  \n                }  \n            }  \n        };\n\n        Queue<ListNode> q =  new PriorityQueue<ListNode>(10,comp);\n        for (int i = 0; i < lists.size(); ++i)\n            if (lists.get(i) != null)\n                q.add(lists.get(i));\n        \n        ListNode dummy = new ListNode(0);\n        ListNode cur = dummy;\n        while (!q.isEmpty()) {\n            ListNode node = q.poll();\n            cur = cur.next = node;\n            if (node.next != null)\n                q.add(node.next);\n        }\n        return dummy.next;\n    }\n    ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head = new ListNode(0);\n        ListNode cur = head;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        if (l1 != null) cur.next = l1;\n        if (l2 != null) cur.next = l2;\n        return head.next;\n    }\n    public ListNode mergeKLists(List<ListNode> lists) {\n        if(lists.size()==0) return null;\n        int sz = lists.size(), end = sz - 1;\n        while (end > 0) {\n            int begin = 0;\n            while (begin < end) {\n                ListNode node = mergeTwoLists(lists.get(begin), lists.get(end));\n                lists.set(begin, node);\n                ++begin; --end;\n            }\n        }\n        return lists.get(0);\n    }\n}", "nl": "leetcoders"}
{"code": "public class LinkedListCycle {\n  private static Set<Integer> hashCode = new HashSet<>();\n\n  static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n\n  \n  public static void main(String[] args) throws Exception {\n    ListNode node1 = new ListNode(1);\n    ListNode node2 = new ListNode(2);\n    ListNode node3 = new ListNode(3);\n    node1.next = node2;\n    node2.next = node3;\n    node3.next = node1;\n    System.out.println(new LinkedListCycle().hasCycle(node1));\n  }\n\n  public boolean hasCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    while (slow != null && fast != null) {\n      slow = slow.next;\n      fast = fast.next;\n      if (fast != null) fast = fast.next;\n      else break;\n      if (fast != null && slow != null) if (fast.equals(slow)) return true;\n    }\n    return false;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class BestTimetoBuyandSellStock {\n    public int maxProfit(int[] prices) {\n        if (prices.length == 0)\n            return 0;\n        int min = Integer.MAX_VALUE;\n        int[] maxprofit = new int[prices.length];\n        for (int i = 0; i < prices.length; i++) {\n            min = prices[i] < min ? prices[i] : min;\n            int profit = prices[i] - min;\n            maxprofit[i] = Math.max(maxprofit[i - 1], profit);\n        }\n        return maxprofit[prices.length - 1];\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n\t\n\tpublic int singleNumber(int[] A) {\n        if (A == null || A.length == 0) {\n           return 0;\n        }\n        int rst = A[0];\n        for (int i = 1; i < A.length; i++) {\n            rst = rst ^ A[i];\n        }\n        return rst;\n\t}\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class SearchInsertPosition {\n\n    public class Solution {\n        public int searchInsert(int[] A, int target) {\n            int left = 0;\n            int right = A.length - 1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (A[mid] < target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            return left;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if (inorder.length != postorder.length) {\n            return null;\n        }\n        return buildTreeHelper(inorder, 0, inorder.length - 1, \n                                postorder, 0, postorder.length - 1);\n    }\n    \n    public TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd, \n                            int[] postorder, int postStart, int postEnd){\n        if (inStart > inEnd) {\n            return null;\n        }\n        TreeNode root = new TreeNode(postorder[postEnd]);\n        int mid = findMid(inorder, inStart, inEnd, postorder[postEnd]);\n        root.left = buildTreeHelper(inorder, inStart, mid - 1, \n                    postorder, postStart, postStart + (mid - inStart) - 1);\n        root.right = buildTreeHelper(inorder, mid + 1, inEnd,\n                    postorder, postStart + (mid - inStart), postEnd - 1);\n        return root;\n    }\n    \n    public int findMid(int[] arr, int start, int end, int key) {\n        for (int i = start; i <= end; i++) {\n            if (arr[i] == key) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    public ListNode sortList(ListNode head) {  \n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode mid = findMiddle(head);\n        ListNode right = sortList(mid.next);\n        mid.next = null;\n        ListNode left = sortList(head);\n        return merge(left, right);\n    }\n\n    public ListNode findMiddle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n    \n    public ListNode merge(ListNode left, ListNode right) {\n        ListNode dummy = new ListNode(0);\n        ListNode head = dummy;\n        while (left != null && right != null) {\n            if (left.val < right.val) {\n                head.next = left;\n                left = left.next;\n            } else {\n                head.next = right;\n                right = right.next;\n            }\n            head = head.next;\n        }\n        if (left != null) {\n            head.next = left;\n        } else if (right != null){\n            head.next = right;\n        }\n        return dummy.next;\n    }\n}\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public String reverseWords(String s) {\n        if (s.length()<1) {\n            return s;\n        }\n        String a = \"\";\n        String answer = \"\";\n        boolean flag=true;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            String k = s.substring(i, i + 1);\n            if (flag) {\n                if (k.equals(\" \")) {\n                    \n                }else {\n                    flag=false;\n                    a=k+a;\n                }\n            }else {\n                if (k.equals(\" \")) {\n                    flag=true;\n                    answer=answer+\" \"+a;\n                    a=\"\";\n                }else {\n                    a=k+a;\n                }\n            }\n        }\n        if (a.length()!=0) {\n                answer=answer+\" \"+a;\n        }\n        if (answer.length()==0) {\n                return \"\";\n            }\n        while (answer.substring(0,1).equals(\" \")) {\n            if (answer.length()==1) {\n                return \"\";\n            }\n            answer=answer.substring(1, answer.length());\n        }\n        return answer;\n    }\n}\n", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public boolean wordBreak(String s, Set<String> dict) {\n        if (s == null || dict.contains(s)) {\n            return true;\n        }\n        boolean[] rst = new boolean[s.length() + 1];\n        rst[0] = true;\n        int maxLength = calMaxLength(dict);\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = 0; j <= i && j <= maxLength; j++) {\n                if (rst[i - j] && dict.contains(s.substring(i - j, i))) {\n                    rst[i] = true;\n                    break;\n                }\n            }\n        }\n        return rst[s.length()];\n    }\n\n    public int calMaxLength(Set<String> dict) {\n        int length = 0;\n        for (String word : dict) {\n            length = Math.max(length, word.length());\n        }\n        return length;\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class ClimbingStairs2 {\n\tpublic int climbStairs(int n) {\n\t\tif (n == 1)\n\t\t\treturn 1;\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class BinaryTreePreorderTraversal {\n\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (root == null)\n\t\t\treturn null;\n\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tstack.add(root);\n\t\twhile (!stack.isEmpty()) {\n\t\t\tTreeNode node = stack.pop();\n\t\t\tlist.add(node.val);\n\t\t\tif (node.right != null)\n\t\t\t\tstack.add(node.right);\n\t\t\tif (node.left != null) {\n\t\t\t\tstack.add(node.left);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public ListNode swapPairs(ListNode head) {\n    \tif (head == null) {\n    \t\treturn head;\n    \t}\n\t\tListNode dummy = new ListNode(0);\n\t\tdummy.next = head;\n\t\thead = dummy;\n    \twhile (head.next != null && head.next.next != null) {\n    \t\tListNode n1 = head.next;\n    \t\tListNode n2 = head.next.next;\n    \t\t\n    \t\tn1.next = n2.next;\n    \t\tn2.next = n1;\n    \t\tn1 = n2;\n\n    \t\thead = head.next.next;\n    \t}\n    \treturn dummy.next;\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class LargestRectangleinHistogram {\n\n    public class Solution {\n        public int largestRectangleArea(int[] height) {\n            int maxArea = 0;\n            Deque<Integer> p = new ArrayDeque<Integer>();\n            int i = 0;\n            while (i < height.length) {\n                if (p.isEmpty() || height[p.peekLast()] <= height[i]) {\n                    p.offerLast(i++);\n                } else {\n                    int pos = p.removeLast();\n                    maxArea = Math.max(maxArea,\n                            (p.isEmpty() ? i : i - p.peekLast() - 1)\n                                    * height[pos]);\n                }\n            }\n            while (!p.isEmpty()) {\n                int pos = p.removeLast();\n                maxArea = Math.max(maxArea, (p.isEmpty() ? i : i - p.peekLast()\n                        - 1)\n                        * height[pos]);\n            }\n            return maxArea;\n        }\n    }\n\n    public static class UnitTest {\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class L093_Restore_IP_Addresses {\n\n\tList<String> rt = new ArrayList<String>();\n\tString[] stack = new String[4];\n\n\tpublic List<String> restoreIpAddresses(String s) {\n\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\tdfs(s, 0, 0);\n\t\treturn rt;\n\t}\n\n\t\n\tpublic void dfs(String s, int p, int pstack) {\n\n\t\tif (pstack == 4) {\n\n\t\t\tif (p >= s.length()) {\n\t\t\t\tString ip = String.join(\".\", stack);\n\t\t\t\trt.add(ip);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 1; i <= 3; i++) {\n\n\t\t\tif (p + i > s.length()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (i > 1 && s.charAt(p) == '0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString number = s.substring(p, p + i);\n\n\t\t\tif (Integer.parseInt(number) <= 255) {\n\t\t\t\tstack[pstack] = number;\n\t\t\t\tdfs(s, p + i, pstack + 1);\n\t\t\t}\n\t\t}\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class RegularExpressionMatching {\n\n    \n    public boolean isMatch(String s, String p) {\n        int m = s.length(), n = p.length();\n        boolean[][] match = new boolean[m + 1][n + 1];\n        match[0][0] = true; // Both s and p are empty.\n        for (int j = 1; j <= n; j++) { // S is empty but p is not.\n            match[0][j] = j > 1 && match[0][j - 2] && p.charAt(j - 1) == '*';\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p.charAt(j - 1) != '*') { // Last characters match and previous also match.\n                    match[i][j] = match[i - 1][j - 1] && (s.charAt(i - 1) == p.charAt(j - 1) || '.' == p.charAt(j - 1));\n                } else {\n                    match[i][j] = match[i][j - 2] // \"p[j-2]*\" matches empty.\n                            \n                            || (s.charAt(i - 1) == p.charAt(j - 2) || '.' == p.charAt(j - 2)) && match[i - 1][j];\n                }\n            }\n        }\n        return match[m][n];\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }\n        String answer = \"1\";\n        for (int i = 0; i < n - 1; i++) {\n            answer = new Solution().readNum(answer);\n        }\n        return answer;\n    }\n\n    public String readNum(String num) {\n        int n = 1;\n        String t = num.substring(0, 1);\n        StringBuffer answer=new StringBuffer();\n        String k = \"\";\n        for (int i = 1; i < num.length(); i++) {\n            k = num.substring(i, i + 1);\n            if (k.equals(t)) {\n                n++;\n            } else {\n                answer=answer.append(n).append(t);\n                t = k;\n                n = 1;\n            }\n        }\n        answer = answer.append(n).append(t);\n        return answer.toString();\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public String multiply(String num1, String num2) {\n        int l1 = num1.length(), l2 = num2.length();\n        if (l1 == 0 || l2 == 0) return new String(\"\");\n        if (num1.charAt(0) == '0' || num2.charAt(0) == '0') return new String(\"0\");\n        StringBuffer sb = new StringBuffer();\n        int[] res = new int[l1+l2];\n        for (int i = 0; i < l1; ++i) {\n            for (int j = 0; j < l2; ++j) {\n                res[i+j+1] += (num1.charAt(i)-'0') *(num2.charAt(j)-'0');\n            }\n        }\n        int c = 0;\n        for (int i = res.length - 1; i>=1; --i) {\n            res[i] += c;\n            c = res[i] / 10;\n            res[i] = res[i] % 10;\n            sb.insert(0,res[i]);\n        }\n        if (c !=0 || res[0] != 0) {\n            sb.insert(0,c+res[0]);\n        }\n        return sb.toString();\n    }\n}", "nl": "leetcoders"}
{"code": "public class ValidPalindrome {\n\n  \n  public boolean isPalindrome(String s) {\n    if (s == null || s.isEmpty()) return true;\n    for (int i = 0, j = s.length() - 1; i <= j; i++, j--) {\n      while (i <= j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n      while (i <= j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n      if (i > j) return true;\n      if (!compareIgnoreCase(s.charAt(i), s.charAt(j))) return false;\n    }\n    return true;\n  }\n\n  private boolean compareIgnoreCase(char c1, char c2) {\n    return Character.toLowerCase(c1) == Character.toLowerCase(c2);\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class ReverseWordsInAString \n{\n    public String reverseWords( String s )\n    {\n    \tif ( s == null || s.length() == 0 )\n    \t{\n    \t\treturn \"\";\n    \t}\n    \t\n    \tString[] words = s.split( \" \" );\n    \tStringBuilder result = new StringBuilder();\n    \tfor ( int i = words.length - 1; i >= 0; i-- )\n    \t{\n    \t\tif ( !words[i].equals( \"\" ) )\n    \t\t{\n    \t\t\tresult.append( words[i] ).append( \" \" );\n    \t\t}\n    \t}\n    \t\n    \tif ( result.length() != 0 )\n    \t{\n    \t\tresult.deleteCharAt( result.length() - 1 );\n    \t}\n    \treturn result.toString();\n    }\n    \n    @Test\n    public void test()\n    {   \n    \tassertEquals( \"\", reverseWords( \"    \" ) );\n    \tassertEquals( \"word\", reverseWords( \"word\" ) );\n    \t\n    \tassertEquals( \"a\", reverseWords( \"a \" ) );\n    \tassertEquals( \"\", reverseWords( \" \" ) );\n    \t\n    \tassertEquals( \"blue is sky the\", reverseWords( \"the sky is  blue\" ) );\n    \t\n    \tassertEquals( \"blue is sky the\", reverseWords( \"  the sky is blue  \" ) );\n    }\n    \n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public List<List<Integer>> permute_1(int[] num) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> path = new ArrayList<Integer>();\n        boolean[] free = new boolean[num.length];\n        Arrays.fill(free, true);\n        permuteRe(num, res, path,free);\n        return res;\n    }\n    void permuteRe(int[] num, List<List<Integer>> res, List<Integer> path, boolean[] free) {\n        if(path.size() == num.length) {\n            ArrayList<Integer> tmp = new ArrayList<Integer>(path);\n            res.add(tmp);\n            return;\n        }\n        for (int i = 0; i < num.length; ++i) {\n            if (free[i] == true) {\n                free[i] = false;\n                path.add(num[i]);\n                permuteRe(num, res, path, free);\n                path.remove(path.size() - 1);\n                free[i] = true;\n            }\n        }\n    }\n    public boolean nextPermutation(int[] num) {\n        int last = num.length - 1;\n        int i = last;\n        while (i > 0 && num[i - 1] >= num [i]) --i;\n        for (int l = i, r = last; l < r; ++l, --r) {\n            num[l] = num[l] ^ num[r];\n            num[r] = num[l] ^ num[r];\n            num[l] = num[l] ^ num[r];\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = i;\n        while (j <= last && num[i-1] >= num[j]) ++j;\n        num[i-1] = num[i-1] ^ num[j];\n        num[j] = num[i-1] ^ num[j];\n        num[i-1] = num[i-1] ^ num[j];\n        return true;\n    }\n    public List<List<Integer>> permute_2(int[] num) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        Arrays.sort(num);\n        do {\n            List<Integer> path = new ArrayList<Integer>();\n            for (int i : num) path.add(i);\n            res.add(path);\n        } while(nextPermutation(num));\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class CourseSchedule2 {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if (prerequisites == null)\n            return false;\n        if (numCourses == 0 || prerequisites.length == 0)\n            return true;\n        int degree[] = new int[numCourses];\n        Queue<Integer> queue = new LinkedList();\n        for (int edge[] : prerequisites) {\n            degree[edge[0]]++;\n        }\n        for (int i = 0; i < numCourses; i++) {\n            if (degree[i] == 0)\n                queue.add(i);\n        }\n        int count = queue.size();\n        while (!queue.isEmpty()) {\n            int p = queue.poll();\n            for (int edge[] : prerequisites) {\n                if (edge[1] == p) {\n                    degree[edge[0]]--;\n                    if (degree[edge[0]] == 0) {\n                        count++;\n                        queue.add(edge[0]);\n                    }\n                }\n            }\n\n        }\n        return count == numCourses;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class LongestValidParentheses {\n\n    public class Solution {\n        public int longestValidParentheses(String s) {\n            int[] dp = new int[s.length()];\n            int max = 0;\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == ')') {\n                    int p = i - 1;\n                    while (p >= 0) {\n                        if (s.charAt(p) == '(') {\n                            dp[i] = i - p + 1 + (p > 0 ? dp[p - 1] : 0);\n                            break;\n                        } else if (dp[p] == 0) {\n                            break;\n                        }\n                        p = p - dp[p];\n                    }\n                }\n                max = Math.max(max, dp[i]);\n            }\n            return max;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    \n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> rst = new ArrayList<List<Integer>>();\n        if (n <= 0 || k <= 0) {\n            return rst;\n        }\n        List<Integer> solution = new ArrayList<Integer>();\n        helper(rst, solution, n, k, 1);// Start == 1 because we want 1 ~ n in this problem\n        return rst;\n    }\n    public void helper(List<List<Integer>> rst, \n                List<Integer> solution, int n, int k, int start) {\n        if (solution.size() == k) {\n            rst.add(new ArrayList(solution));\n            return;\n        }        \n        for (int i = start; i <= n; i++) {// <=n because we want 1 ~ n in this problem\n            solution.add(i);\n            helper(rst, solution, n, k, i + 1);\n            solution.remove(solution.size() - 1); //Back-track\n        }\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices==null || prices.length==0)\n            return 0;\n\n        int bot = prices[0];\n        int maxProfit = 0;\n        for(int i=0;i<prices.length;i++){\n        \tif(prices[i]<bot)\n        \t\tbot = prices[i];\n        \telse if(prices[i]-bot>maxProfit)\n        \t\tmaxProfit = prices[i]-bot;\n        }\n\n        return maxProfit;\n\n    }\n}", "nl": "azheanda"}
{"code": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums == null || nums.length == 0) return result;\n\n        dfs(result, new ArrayList<>(), nums, 0); // dfs with depth = 0\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> list, int[] nums, int depth) {\n        if (depth >= nums.length) { // closure case\n            result.add(new ArrayList<>(list));\n            return;\n        }\n        list.add(nums[depth]);\n        dfs(result, list, nums, depth + 1);\n\n        list.remove(list.size() - 1);\n        dfs(result, list, nums, depth + 1);\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null) {\n            return p == null && q == null;\n        }\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class LongestValidParentheses2 {\n\tpublic int longestValidParentheses(String s) {\n\t\tif (s.length() == 0)\n\t\t\treturn 0;\n\t\tint maxLen = 0;\n\t\tint[] d = new int[s.length()];\n\t\td[s.length() - 1] = 0;\n\t\tfor (int i = s.length() - 2; i >= 0; i--) {\n\t\t\tif (s.charAt(i) == ')')\n\t\t\t\td[i] = 0;\n\t\t\telse {\n\t\t\t\tint j = (i + 1) + d[i + 1];\n\t\t\t\tif (j < s.length() && s.charAt(j) == ')') {\n\t\t\t\t\td[i] = d[i + 1] + 2; // (()())\u9428\u52eb\ue63b\u9356\u546e\u510f\u9350\n\t\t\t\t\tif (j + 1 < s.length())\n\t\t\t\t\t\td[i] += d[j + 1];// ()()\u9428\u52eb\u6097\u95c8\u3223\u7e55\u93c8\u590c\u6b91\u93af\u546d\u558c\n\t\t\t\t} else\n\t\t\t\t\td[i] = 0;\n\t\t\t}\n\t\t\tmaxLen = Math.max(maxLen, d[i]);\n\t\t}\n\t\treturn maxLen;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class BestTimetoBuyandSellStockII {\n\n\tpublic int maxProfit(int[] prices) {\n\t\tif (prices == null || prices.length == 0)\n\t\t\treturn 0;\n\t\tint maxProfit = 0;\n\t\tfor (int i = 1; i < prices.length; i++) {\n\t\t\tif (prices[i] - prices[i - 1] > 0) {\n\t\t\t\tmaxProfit += prices[i] - prices[i - 1];\n\t\t\t}\n\t\t}\n\t\treturn maxProfit;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class LargestRectangleinHistogram2 {\n\tpublic int largestRectangleArea(int[] height) {\n\t\tint maxV = 0;\n\t\tfor (int i = 0; i < height.length; i++) {\n\t\t\tif (i + 1 < height.length && height[i] <= height[i + 1])\t\t\t\n\t\t\t\tcontinue;\n\t\t\tint minV = height[i];\n\t\t\tfor (int j = i; j >= 0; j--) {\n\t\t\t\tminV = Math.min(minV, height[j]);\n\t\t\t\tint area = minV * (i - j + 1);\n\t\t\t\tif (area > maxV)\n\t\t\t\t\tmaxV = area;\n\t\t\t}\n\t\t}\n\t\treturn maxV;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class ValidNumber {\n\n  \n  public boolean isNumber(String s) {\n    s = s.trim(); // Remove whitespaces first.\n    boolean hasDot = false;\n    boolean hasExp = false;\n    boolean hasNum = false;\n    char[] num = s.toCharArray();\n    for (int i = 0; i < num.length; i++) {\n      if ('0' <= num[i] && num[i] <= '9') { // Is digit.\n        hasNum = true;\n      } else if (num[i] == '.') { // Is dot.\n        if (hasExp || hasDot) { // Cannot appear after exp or dot.\n          return false;\n        }\n        hasDot = true;\n      } else if (num[i] == 'e') { // Is exp.\n        if (hasExp || !hasNum) { // Cannot appear after exp or before number.\n          return false;\n        }\n        hasNum = false; // NOTE here reset the hasNum flag. Avoid 1e.\n        hasExp = true;\n      } else if (num[i] == '-' || num[i] == '+') { // Is sign.\n        if (i != 0 && num[i - 1] != 'e') { // Must be first or after 'e'.\n          return false;\n        }\n      } else { // All other characters are not allowed.\n        return false;\n      }\n    }\n    return hasNum;\n  }\n\n  \n  public boolean isNumber2(String s) {\n    int len = s.length();\n    int i = 0, e = len - 1;\n    while (i <= e && Character.isWhitespace(s.charAt(i))) {\n      i++;\n    }\n    if (i > len - 1) {\n      return false;\n    }\n    while (e >= i && Character.isWhitespace(s.charAt(e))) {\n      e--;\n    }\n    if (s.charAt(i) == '+' || s.charAt(i) == '-') {\n      i++;\n    }\n    boolean hasNum = false; // is a digit\n    boolean hasDot = false; // is a '.'\n    boolean hasExp = false; // is a 'e'\n    while (i <= e) {\n      char c = s.charAt(i);\n      if (Character.isDigit(c)) {\n        hasNum = true;\n      } else if (c == '.') { // '.' appear\n        if (hasExp || hasDot) {\n          return false; // exp can't have '.' or dots\n        }\n        hasDot = true;\n      } else if (c == 'e') { // e appear\n        if (hasExp || hasNum == false) {\n          return false; // already e but not num\n        }\n        hasExp = true; // is exp, see whether is num from now\n        hasNum = false;\n      } else if (c == '+' || c == '-') { // +, - must appear after e\n        if (s.charAt(i - 1) != 'e') {\n          return false;\n        }\n      } else {\n        return false;\n      }\n      i++;\n    }\n    return hasNum; // whether is num or not\n  }\n\n  \n  public boolean isNumber3(String s) {\n    if (s == null || s.length() == 0) {\n      return false;\n    }\n    char[] c = s.trim().toCharArray();\n    if (c.length == 0) {\n      return false; // all whitespaces\n    }\n    int i = 0;\n    int num = 0;\n    if (c[0] == '+' || c[0] == '-') {\n      i++; // skip sign\n    }\n    for (; i < c.length && (c[i] >= '0' && c[i] <= '9'); i++) {\n      num++;\n    }\n    if (i < c.length && c[i] == '.') {\n      i++; // skip point\n    }\n\n    for (; i < c.length && (c[i] >= '0' && c[i] <= '9'); i++) {\n      num++; // !\n    }\n    if (num == 0) {\n      return false; // no digit before or after point\n    }\n\n    if (i == c.length) {\n      return true; // no point or e\n    } else if (i < c.length && c[i] != 'e') {\n      return false; // last letter not e\n    } else {\n      i++; // skip e\n    }\n\n    num = 0; // reset num and check numbers after e\n    if (i < c.length && (c[i] == '+' || c[i] == '-')) {\n      i++;\n    }\n    for (; i < c.length && (c[i] >= '0' && c[i] <= '9'); i++) {\n      num++;\n    }\n    if (num == 0) {\n      return false; // no more numbers after e\n    }\n    return i == c.length; // no other letter except e\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int minPathSum(int[][] grid) {\n        int xl=grid.length;\n        int yl=grid[0].length;\n        Map<String, Integer> map=new HashMap<String, Integer>();\n        return f(grid,0,0,xl,yl,map);\n    }\n    public int f(int[][] grid,int x,int y,int xl,int yl,Map<String, Integer> map){\n        String coordinate=x+\",\"+y;\n        if (map.get(coordinate)==null) {\n            if (x>=xl||y>=yl) {\n                return -1;\n            }else {\n                int xv=f(grid,x+1,y,xl,yl,map);\n                int yv=f(grid,x,y+1,xl,yl,map);\n               int v=0;\n               if (xv<0) {\n                    v=yv;\n                }else if (yv<0) {\n                    v=xv;\n                }else if (xv>yv){\n                    v=yv;\n                }else {\n                    v=xv;\n                }\n                int value=grid[x][y]+(v<0?0:v);\n                map.put(coordinate, value);\n                return value;\n            }\n        }\n        return map.get(coordinate);\n    }\n}\n", "nl": "corpsepiges"}
{"code": "public class PlusOne {\n\n    public class Solution {\n        public int[] plusOne(int[] digits) {\n            int carry = 1;\n            for (int i = digits.length - 1; i >= 0; i--) {\n                int sum = digits[i] + carry;\n                carry = sum / 10;\n                digits[i] = sum % 10;\n            }\n            if (carry == 1) {\n                int[] re = new int[digits.length + 1];\n                System.arraycopy(digits, 0, re, 1, digits.length);\n                re[0] = 1;\n                return re;\n            } else {\n                return digits;\n            }\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class SingleNumber {\n    public int singleNumber(int[] A) {\n        int result = 0;\n        \n        for(int num : A) {\n            result ^= num;\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n\t\tSingleNumber slt = new SingleNumber();\n\t\tint[] A = new int[] { 1, 2, 1, 2, 3, 4, 4 };\n\t\tSystem.out.println(slt.singleNumber(A));\n    }\n}\n", "nl": "lilong-dream"}
{"code": "public class Solution {\n    \n    public int largestRectangleArea(int[] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }    \n        Stack<Integer> stack = new Stack<Integer>();\n        int max = 0;\n        for (int i = 0; i <= height.length; i++) {\n            int current = (i == height.length) ? -1 : height[i];\n            while (!stack.empty() && current <= height[stack.peek()]) {\n                int h = height[stack.pop()];\n                int w = stack.empty() ? i : i - stack.peek() - 1;\n                max = Math.max(max, w * h);\n            }\n            stack.push(i);\n        }\n        return max;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class ReverseLinkedList {\n\n    public class Solution {\n        public ListNode reverseList(ListNode head) {\n            ListNode reversed = null;\n            ListNode p = head;\n            while (p != null) {\n                ListNode temp = p.next;\n                p.next = reversed;\n                reversed = p;\n                p = temp;\n            }\n            return reversed;\n        }\n    }\n}\n\n", "nl": "zsxwing"}
{"code": "public class L079_Word_Search {\n\n\tpublic boolean exist(char[][] board, String word) {\n\n\t\tif (board == null || board[0].length == 0 || board.length == 0\n\t\t\t\t|| word == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint rows = board.length;\n\t\tint cols = board[0].length;\n\t\tboolean[] visited = new boolean[rows * cols];\n\n\t\tint pathLength = 0;\n\t\tfor (int row = 0; row < rows; row++) {\n\t\t\tfor (int col = 0; col < cols; col++) {\n\n\t\t\t\tif (dfs(board, rows, cols, row, col, word, pathLength, visited)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic boolean dfs(char[][] board, int rows, int cols, int row, int col,\n\t\t\tString word, int pathLength, boolean[] visited) {\n\n\t\tif (pathLength == word.length()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tboolean hasPath = false;\n\n\t\tif (row >= 0 && row < rows && col >= 0 && col < cols\n\t\t\t\t&& board[row][col] == word.charAt(pathLength)\n\t\t\t\t&& !visited[row * cols + col]) {\n\n\t\t\tpathLength++;\n\t\t\tvisited[row * cols + col] = true;\n\n\t\t\thasPath = dfs(board, rows, cols, row, col - 1, word, pathLength,\n\t\t\t\t\tvisited)\n\t\t\t\t\t|| dfs(board, rows, cols, row - 1, col, word, pathLength,\n\t\t\t\t\t\t\tvisited)\n\t\t\t\t\t|| dfs(board, rows, cols, row, col + 1, word, pathLength,\n\t\t\t\t\t\t\tvisited)\n\t\t\t\t\t|| dfs(board, rows, cols, row + 1, col, word, pathLength,\n\t\t\t\t\t\t\tvisited);\n\n\t\t\tif (!hasPath) {\n\t\t\t\tpathLength--;\n\t\t\t\tvisited[row * cols + col] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn hasPath;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class BinaryTreeLevelOrderTraversal\n{\n\n    public List<List<Integer>> levelOrder( TreeNode root ) \n    {\n        List<List<Integer>> allLevelNums = new ArrayList<>();\n        List<Integer> currLevelNums = new ArrayList<>();\n\n        if ( root == null )\n        {\n        \treturn allLevelNums;\n        }\n    \tQueue<TreeNode> currLevelNodes = new LinkedList<>();\n        Queue<TreeNode> nextLevelNodes = new LinkedList<>();\n\n        currLevelNodes.add( root );        \n        \n        while ( !currLevelNodes.isEmpty( ) )\n        {\n        \tTreeNode queueHead = currLevelNodes.remove( );\n        \tcurrLevelNums.add( queueHead.val );\n        \tif ( queueHead.left != null )\n        \t{\n        \t\tnextLevelNodes.add( queueHead.left );\n        \t}\n        \tif ( queueHead.right != null )\n        \t{\n        \t\tnextLevelNodes.add( queueHead.right );\n        \t}\n        \t\n        \tif ( currLevelNodes.isEmpty( ) )\n        \t{\n        \t\tallLevelNums.add( currLevelNums );\n        \t\tcurrLevelNums = new ArrayList<>();\n        \t\t\n        \t\tcurrLevelNodes.addAll( nextLevelNodes );\n        \t\tnextLevelNodes = new LinkedList<>();\n        \t}\n        }\n        \n        return allLevelNums;\n    }\n\n}\n", "nl": "FreemanZhang"}
{"code": "class Solution {\n    \n    public List<Interval> merge(List<Interval> intervals) {\n        if (intervals == null || intervals.size() <= 1) {\n            return intervals;\n        }\n\n        Collections.sort(intervals, new Comparator<Interval>(){\n            public int compare(Interval a, Interval b) {\n                return a.start - b.start;\n            }\n        });\n        Interval prev = intervals.get(0);\n        Interval curr;\n\n        for (int i = 1; i < intervals.size(); i++) {\n            curr  = intervals.get(i);\n            if (prev.end >= curr.start) {\n                if (prev.end <= curr.end) {\n                    prev.end = curr.end;\n                }\n                intervals.remove(i);\n                i--;\n            } else {\n                prev = curr;         \n            }\n        }\n\n        return intervals;\n    }\n\n}\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int[] res = new int[2];\n        Map map = new HashMap();\n        for(int i = 0; i < numbers.length; i++){\n            map.put(numbers[i], i);\n        }\n        for(int i = 0; i < numbers.length; i++){\n            int gap = target - numbers[i];\n            if(map.get(gap)!= null && (int)map.get(gap)!= i){\n                res[0] = i+1;\n                res[1] = (int)map.get(gap) + 1;\n                break;\n            }\n        }\n        return res;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class L026_Remove_Duplicates_from_Sorted_Array {\n\n\tpublic int removeDuplicates(int[] nums) {\n\n\t\tif (nums == null) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (nums.length < 2) {\n\t\t\treturn nums.length;\n\t\t}\n\n\t\tint len = 0;\n\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif (nums[len] != nums[i]) {\n\t\t\t\tnums[++len] = nums[i];\n\t\t\t}\n\t\t}\n\n\t\treturn len + 1;\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n          return false;\n        }    \n        int i = 0;\n        int j = matrix[0].length - 1;\n        while (i < matrix.length && j >= 0) {\n          if (matrix[i][j] == target) {\n            return true;\n          } else if (target > matrix[i][j]) {\n            i++;\n          } else {\n            j--;\n          }\n        }\n        return false;\n    }\n}\n", "nl": "awangdev"}
{"code": "public class LinkedListCycle {\n\n    public class Solution {\n        public boolean hasCycle(ListNode head) {\n            ListNode slow = head;\n            ListNode fast = head;\n            do {\n                if (fast == null || fast.next == null) {\n                    return false;\n                }\n                fast = fast.next.next;\n                slow = slow.next;\n            } while (fast != slow);\n            return true;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class L131_Palindrome_Partitioning {\n\n\tpublic List<List<String>> partition(String s) {\n\n\t\tList<List<String>> rt = new ArrayList<List<String>>();\n\n\t\tif (\"\".equals(s)) {\n\t\t\treturn rt;\n\t\t}\n\n\t\tif (s.length() == 1) {\n\t\t\trt.add(Arrays.asList(s));\n\t\t\treturn rt;\n\t\t}\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\n\t\t\tString x = s.substring(0, i + 1);\n\t\t\tList<List<String>> sub = new ArrayList<List<String>>();\n\n\t\t\tif (isPal(x)) {\n\t\t\t\tsub = partition(s.substring(i + 1));\n\n\t\t\t\tif (sub.isEmpty()) {\n\t\t\t\t\trt.add(Arrays.asList(x));\n\t\t\t\t} else {\n\t\t\t\t\tfor (List<String> l : sub) {\n\t\t\t\t\t\tList<String> _l = new ArrayList<String>();\n\t\t\t\t\t\t_l.add(x);\n\t\t\t\t\t\t_l.addAll(l);\n\t\t\t\t\t\trt.add(_l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn rt;\n\t}\n\n\tstatic boolean isPal(String s) {\n\n\t\tint st = 0, ed = s.length() - 1;\n\n\t\twhile (st < ed) {\n\t\t\tif (s.charAt(st++) != s.charAt(ed--)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Searcha2DMatrix {\n\n    public class Solution {\n        public boolean searchMatrix(int[][] matrix, int target) {\n            if (matrix.length == 0 || matrix[0].length == 0) {\n                return false;\n            }\n            int columns = matrix[0].length;\n            int left = 0;\n            int right = matrix.length * columns - 1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                int val = matrix[mid / columns][mid % columns];\n                if (val < target) {\n                    left = mid + 1;\n                } else if (val > target) {\n                    right = mid - 1;\n                } else {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class AddTwoNumbers {\n\tpublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n\t\tint carry = 0;\n\t\tListNode newHead = new ListNode(0);\n\t\tListNode p1 = l1, p2 = l2, p3 = newHead;\n\n\t\twhile (p1 != null || p2 != null||carry!=0) {\n\t\t\tif (p1 != null) {\n\t\t\t\tcarry += p1.val;\n\t\t\t\tp1 = p1.next;\n\t\t\t}\n\t\t\tif (p2 != null) {\n\t\t\t\tcarry += p2.val;\n\t\t\t\tp2 = p2.next;\n\t\t\t}\n\t\t\tint digit=carry%10;\n\t\t\tp3.next = new ListNode(digit);\n\t\t\tp3 = p3.next;\n\t\t\tcarry /= 10;\n\t\t}\n\t\treturn newHead.next;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int increment(int[] num, int index) {\n        int newindex = index + 1;\n        while(newindex < num.length && num[newindex] == num[index])\n            newindex ++;\n        return newindex;\n    }\n\n    public int decrement(int[] num, int index) {\n        int newindex = index - 1;\n        while(newindex >= 0  && num[newindex] == num[index])\n            newindex --;\n        return newindex;\n    }\n    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {\n        ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();\n        if (num.length < 3)\n            return ret;\n\n        Arrays.sort(num);\n        for (int i = 0; i < num.length - 2; i = increment(num, i)) {\n            int p = i + 1, q = num.length - 1;\n            while (p < q) {\n                if (num[p] + num[q] == -num[i]) {\n                    ArrayList<Integer> triplet = new ArrayList<Integer>(3);\n                    triplet.add(num[i]);\n                    triplet.add(num[p]);\n                    triplet.add(num[q]);\n                    \n                    ret.add(triplet);\n                    p = increment(num, p);\n                    q = decrement(num, q);\n                } else if (num[p] + num[q] > -num[i])\n                    q = decrement(num, q);\n                else\n                    p = increment(num, p);\n            }\n        }\n\n        return ret;\n\n    }\n\n\n\n}\n", "nl": "azheanda"}
{"code": "public class RemoveDuplicatesfromSortedArrayII3 {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0)\n            return 0;\n        int stopIndex = 1, countSame = 0, prev = nums[0], curr = 0;\n        for (int i = 1; i < nums.length; i++) {\n            curr = nums[i];\n            if (prev == curr) {\n                countSame++;\n            }\n            else {\n                countSame = 0;\n            }\n            if (countSame < 2) {\n                nums[stopIndex++] = nums[i];\n            }\n            prev = curr;\n        }\n        return stopIndex;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public int trapRainWater(int[] heights) {\n        if (heights == null || heights.length == 0) {\n            return 0;\n        }\n\n        int max = 0;\n        int maxIndex = 0;\n        int sum = 0;\n        int prev = 0;\n        for (int i = 0; i < heights.length; i++) {\n            if (heights[i] > max) {\n                max = heights[i];\n                maxIndex = i;\n            }\n        }\n\n        for (int i = 0; i < maxIndex; i++) {\n            if (heights[i] > prev) {\n                sum += (maxIndex - i) * (heights[i] - prev);\n                prev = heights[i];\n            }\n            sum -= heights[i];\n        }\n\n        prev = 0;\n        for (int i = heights.length - 1; i > maxIndex; i--) {\n            if (heights[i] > prev) {\n                sum += (i - maxIndex) * (heights[i] - prev);\n                prev = heights[i];\n            }\n            sum -= heights[i];\n        }\n\n        return sum;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class RestoreIPAddresses {\n\tpublic ArrayList<String> restoreIpAddresses(String s) {  \n        ArrayList<String> res = new ArrayList<String>();  \n        if (s.length()<4||s.length()>12) return res;  \n        dfs(s,\"\",res,0);  \n        return res;  \n    }  \n      \n    public void dfs(String s, String tmp, ArrayList<String> res, int count){  \n        if (count == 3 && isValid(s)) {  \n            res.add(tmp + s);  \n            return;  \n        }  \n        for(int i=1; i<4 && i<s.length(); i++){  \n            String substr = s.substring(0,i);  \n            if (isValid(substr)){  \n                dfs(s.substring(i), tmp + substr + '.', res, count+1);  \n            }  \n        }  \n    }  \n      \n    public boolean isValid(String s){  \n        if (s.charAt(0)=='0') return s.equals(\"0\");  \n        int num = Integer.parseInt(s);  \n        return num<=255 && num>0;  \n    }  \n}\n", "nl": "gaohannk"}
{"code": "public class SortColors {\n  \n  public static void main(String[] args) throws Exception {\n    int[] nums = {2, 1, 0, 0, 1};\n    new SortColors().sortColors(nums);\n    for (int i : nums) System.out.println(i);\n  }\n\n  public void sortColors(int[] nums) {\n    int s = nums[0]; // save the first index value\n    nums[0] = 1; // overwrite with 1\n    int l = 0, r = 0; // left and right index indicating the start and end index of 1s\n    for (int i = 1; i < nums.length; i++) {\n      switch (nums[i]) {\n        case 0:\n          nums[l] = 0;\n          nums[r + 1] = 1;\n          if (r + 1 != i) {\n            nums[i] = 2;\n          }\n          l++;\n          r++;\n          break;\n\n        case 1:\n          nums[r + 1] = 1;\n          if (r + 1 != i) {\n            nums[i] = 2;\n          }\n          r++;\n          break;\n      }\n    }\n    if (s == 0) nums[l] = 0;\n    else if (s == 2) nums[r] = 2;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> permute(int[] num) {\n        return permute(num,0);\n    }\n    \n    public ArrayList<ArrayList<Integer>> permute(int[] num,int level){\n        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n        if(level==num.length-1){\n           ArrayList<Integer> combo = new ArrayList<Integer>();\n           combo.add(num[level]);\n           result.add(combo);\n           return result;\n        }\n        \n        for(int i=level;i<num.length;i++){\n            swap(num,i,level);\n            for(ArrayList<Integer> combo:permute(num,level+1)){\n                combo.add(num[level]);\n                result.add(combo);\n            }        \n            swap(num,i,level);\n        }\n        return result;\n        \n    }\n    public void swap(int[] num,int i, int j){\n        int temp = num[i];\n        num[i] = num[j];\n        num[j] = temp;\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public ListNode list = null;\n    public TreeNode sortedListToBST(ListNode head) {\n           list = head;\n           int len = 0;\n           ListNode node = head;\n           while(node!=null) {node=node.next;len++;}\n           return sortedListToBST(0,len-1);\n\n    }\n    \n    public TreeNode sortedListToBST(int start, int end){\n    \tif(start>end)\treturn null;\n\n    \tint mid = start+(end-start)/2;\n    \tTreeNode left = sortedListToBST(start,mid-1);\n    \tTreeNode parent = new TreeNode(list.val);\n    \tparent.left = left;\n    \tlist=list.next;\n    \tparent.right = sortedListToBST(mid+1,end);\n    \treturn parent;\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p==null&&q==null) {\n            return true;\n        }else if (p==null||q==null) {\n            return false;\n        }\n        if (p.val!=q.val) {\n            return false;\n        }else{\n            return isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\n        }\n        \n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public ArrayList<String> restoreIpAddresses(String s) {\n        ArrayList<String> res = new ArrayList<String>();\n        \n        for(int i=1;i<s.length();i++){\n             if(!isValid(s,0,i))\n                    break;\n            \n            for(int j=i+1;j<s.length();j++){\n                if(!isValid(s,i,j))\n                    break;\n                \n                for(int k=j+1;k<s.length();k++){\n                    if(!isValid(s,j,k))\n                        break;\n                    \n                    if(isValid(s,k,s.length()))\n                        res.add(s.substring(0,i)+\".\"+s.substring(i,j)+\".\"+s.substring(j,k)+\".\"+s.substring(k,s.length()));\n                }  \n            }\n        }\n        return res;\n        \n        \n    }\n    \n    public boolean isValid(String s, int b, int e){\n        if( e-b>3 ||(e-b>=2 && s.charAt(b)=='0') )    return false;\n        int num = Integer.parseInt(s.substring(b,e));\n\t    return num>=0 && num <=255;\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    \n    public int[] reverse(int start, int end, int[] nums) {\n    \tfor (int i = start, j = end; i < j; i++,j--) {\n    \t\tint temp = nums[i];\n    \t\tnums[i] = nums[j];\n    \t\tnums[j] = temp;\n    \t}\n    \treturn nums;\n    }\n    \n    public int[] nextPermutation(int[] nums) {\n    \tif (nums == null || nums.length == 0) {\n    \t\treturn nums;\n    \t}\n    \tint k = -1;\n    \tfor (int i = nums.length - 2; i >= 0; i--) {\n    \t\tif (nums[i] < nums[i + 1]) {\n    \t\t\tk = i;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \tif (k == -1) {\n    \t\treturn reverse(0, nums.length - 1, nums);\n    \t}\n    \tint bigIndex = -1;\n    \tfor (int i = nums.length - 1; i >= 0; i--) {\n    \t\tif (nums[i] > nums[k]) {\n    \t\t\tbigIndex = i;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \tint temp = nums[k];\n    \tnums[k] = nums[bigIndex];\n    \tnums[bigIndex] = temp;\n\n    \treturn reverse(k + 1, nums.length - 1, nums);\n    }\n\n\n\n}\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class Sqrtx2 {\n\tpublic int sqrt(int x) {\n\t    if (x == 0) return 0;\n\t    double last = 0;\n\t    double res = 1;\n\t    while (res != last)\n\t    {\n\t        last = res;\n\t        res = (res + x / res) / 2;\n\t    }\n\t    return (int)res;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int lengthOfLastWord(String s) {\n            String[] words = s.split(\" \");\n            return words.length==0?0:words[words.length-1].length();\n    }\n}", "nl": "azheanda"}
{"code": "public class Solution {\n    public int majorityElement_1(int[] num) {\n        int n = num.length;\n        if (n == 0) return 0;\n        if (n == 1) return num[0];\n        int res = num[0], cnt = 1;\n        for (int i = 1; i < n; ++i) {\n            if (cnt == 0) {\n                res = num[i];\n                ++cnt;\n                continue;\n            }\n            if (res == num[i]) ++cnt;\n            else --cnt;\n        }\n        return res;\n    }\n    public int majorityElement_2(int[] num) {\n        int n = num.length;\n        if (n == 0) return 0;\n        if (n == 1) return num[0];\n        int res = 0;\n        for (int i = 0; i < 32; ++i) {\n            int one = 0, zero = 0;\n            for (int j = 0; j < n; ++j) {\n                if (((num[j]>>i) & 1) == 1) ++one;\n                else ++zero;\n            }\n            if (one > zero) res = res | (1<<i);\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class FlattenBinaryTreetoLinkedList2 {\n\tpublic void flatten(TreeNode root) {\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tTreeNode p = root;\n\n\t\twhile (p != null || !stack.empty()) {\n\t\t\tif (p.right != null)\n\t\t\t\tstack.push(p.right);\n\t\t\tif (p.left != null) {\n\t\t\t\tp.right = p.left;\n\t\t\t\tp.left = null;\n\t\t\t} else if (!stack.empty())\n\t\t\t\tp.right = stack.pop();\n\t\t\tp = p.right;\n\t\t}\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int[] plusOne(int[] digits) {\n        boolean isNines = true;\n        for(int i=0;i<digits.length;i++)\n            if(digits[i]!=9){\n                isNines = false;\n                break;\n            }\n            \n        if(isNines){\n            int[] result = new int[digits.length+1];\n            result[0] = 1;\n            return result;\n        }\n        \n        int[] result = digits;\n                  \n        int p = result.length-1;\n        int increment=1;\n        \n        while(p>=0 && increment>0){\n            int sum = digits[p]+increment;\n            result[p] = sum%10;\n            increment = sum/10;\n            p--;\n        }\n        return result;\n    }\n}", "nl": "azheanda"}
{"code": "public class TrappingRainWater2 {\n\tpublic int trap(int[] A) {\n\t\tint left = 0, right = A.length - 1;\n\t\tint curlevel = 0, contain = 0, block = 0;\n\t\twhile (left <= right) {\n\t\t\tif (Math.min(A[left], A[right]) > curlevel) {\n\t\t\t\tcontain += (Math.min(A[left], A[right]) - curlevel)\n\t\t\t\t\t\t* (right - left + 1);\n\t\t\t\tcurlevel = Math.min(A[left], A[right]);\n\t\t\t}\n\t\t\tif (A[left] < A[right])\n\t\t\t\tblock += A[left++];\n\t\t\telse\n\t\t\t\tblock += A[right--];\n\t\t}\n\t\treturn contain - block;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class HouseRobber {\n\n    public class Solution {\n        public int rob(int[] nums) {\n            if (nums.length == 0) {\n                return 0;\n            }\n            if (nums.length < 2) {\n                return nums[0];\n            }\n            int f1 = nums[0];\n            int f2 = Math.max(nums[0], nums[1]);\n            for (int i = 2; i < nums.length; i++) {\n                int f = Math.max(f1 + nums[i], f2);\n                f1 = f2;\n                f2 = f;\n            }\n            return f2;\n        }\n    }\n}\n\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public int removeDuplicates(int[] A) {\n        int N = A.length;\n        if (N <= 2) return N;\n        int idx = 2;\n        for (int i = 2; i < N; ++i) {\n            if (A[i] != A[idx-2])\n                A[idx++] = A[i];\n        }\n        return idx;\n    }\n}", "nl": "leetcoders"}
{"code": "public class HIndex {\n\n  public static void main(String[] args) throws Exception {\n    int[] A = {3, 0, 6, 1, 5};\n    System.out.println(new HIndex().hIndex(A));\n  }\n\n  public int hIndex(int[] citations) {\n    int n = citations.length;\n    int[] count = new int[n + 1];\n    int[] S = new int[n + 1];\n    for (int i = 0; i < citations.length; i++) {\n      if (citations[i] > n) {\n        citations[i] = n;\n      }\n    }\n    for (int citation : citations) {\n      count[citation]++;\n    }\n    S[n] = count[n];\n    for (int i = n - 1; i >= 0; i--) {\n      S[i] = count[i] + S[i + 1];\n    }\n    for (int i = n; i >= 0; i--) {\n      if (i <= S[i]) {\n        return i;\n      }\n    }\n    return 0;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class RestoreIpAddresses {\n\n  public List<String> restoreIpAddresses(String s) {\n    List<String> res = new ArrayList<>();\n    if (s.length() > 12) return res;\n    backtrack(s, 3, res, \"\");\n    return res;\n  }\n\n  public void backtrack(String s, int dot, List<String> res, String ip) {\n    if (dot == 0) {\n      if (isValid(s)) {\n        ip += s;\n        System.out.println(ip);\n        res.add(ip);\n      }\n      return;\n    }\n\n    for (int i = 1; i < 4 && i < s.length(); i++) {\n      String pre = s.substring(0, i);\n      if (!isValid(pre)) continue;\n      backtrack(s.substring(i), dot - 1, res, ip + pre + \".\");\n    }\n  }\n\n  public boolean isValid(String s) {\n    if (s.startsWith(\"0\") && s.length() > 1 || Integer.valueOf(s) > 255) return false;\n    return true;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public int climbStairs(int n) {\n        int[] f = new int[n+1];\n        f[0] = 1; f[1] = 1;\n        for (int i = 2; i <= n; ++i)\n            f[i] = f[i-1] + f[i-2];\n        return f[n];\n    }\n}", "nl": "leetcoders"}
{"code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {\n            return;\n        }\n        m--; n--;\n        while (m >= 0 || n >= 0) {\n            if (m >= 0 && n >= 0) {\n                nums1[m + n + 1] = nums1[m] > nums2[n] ? nums1[m--] : nums2[n--];\n            } else if (m < 0) { // n > 0\n                nums1[n] = nums2[n--];\n            } else if (n < 0) {\n                break;\n            }\n        }\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class GenerateParentheses4 {\n\tpublic List<String> generateParenthesis(int n) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tif (n == 0) {\n\t\t\tresult.add(\"\");\n\t\t} else if (n == 1) {\n\t\t\tresult.add(\"()\");\n\t\t} else {\n\t\t\tfor (int i = 1; i <= n - 1; i++) {\n\t\t\t\tList<String> left = generateParenthesis(i);\n\t\t\t\tList<String> right = generateParenthesis(n - i);\n\t\t\t\tfor (String leftstr : left) {\n\t\t\t\t\tfor (String rightstr : right) {\n\t\t\t\t\t\tif (!result.contains(leftstr + rightstr))\n\t\t\t\t\t\t\tresult.add(leftstr + rightstr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n - 1; i++) {\n\t\t\t\tList<String> left = generateParenthesis(i);\n\t\t\t\tList<String> right = generateParenthesis(n - i - 1);\n\t\t\t\tfor (String leftstr : left) {\n\t\t\t\t\tfor (String rightstr : right) {\n\t\t\t\t\t\tif (!result.contains(\"(\" + leftstr + rightstr + \")\"))\n\t\t\t\t\t\t\tresult.add(\"(\" + leftstr + rightstr + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null)\n            return 0;\n        \n        return 1+Math.max(maxDepth(root.right),maxDepth(root.left));\n    }\n}", "nl": "azheanda"}
{"code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (validate(candidates, target)) return result;\n\n        dfs(result, new ArrayList<>(), candidates, 0, target);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> list,\n                     int[] candidates, int index, int target) {\n        for (int i = index; i < candidates.length; i++) {\n            int value = candidates[i];\n            list.add(value);\n            if (target == value) result.add(new ArrayList<>(list)); // one closure\n            else if (target - value > 0) dfs(result, list, candidates, i, target - value);\n            list.remove(list.size() - 1); // backtrack\n        }\n    }\n\n    private boolean validate(int[] candidates, int target) {\n        return candidates == null || candidates.length == 0 || target <= 0;\n    }\n}", "nl": "awangdev"}
{"code": "public class ConvertSortedListtoBinarySearchTree {\n\tstatic ListNode h;\n\n\tpublic TreeNode sortedListToBST(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn null;\n\t\th = head;\n\t\tint len = getLength(head);\n\t\treturn sortedListToBST(0, len - 1);\n\t}\n\n\tpublic int getLength(ListNode head) {\n\t\tint len = 0;\n\t\tListNode p = head;\n\t\twhile (p != null) {\n\t\t\tlen++;\n\t\t\tp = p.next;\n\t\t}\n\t\treturn len;\n\t}\n\n\tpublic TreeNode sortedListToBST(int start, int end) {\n\t\tif (start > end)\n\t\t\treturn null;\n\t\tint mid = (start + end) / 2;\n\t\tTreeNode left = sortedListToBST(start, mid - 1);\n\t\tTreeNode root = new TreeNode(h.val);\n\t\th = h.next;\n\t\tTreeNode right = sortedListToBST(mid + 1, end);\n\t\troot.left = left;\n\t\troot.right = right;\n\t\treturn root;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class InsertInterval3 {\n\tpublic ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {\n\t\tArrayList<Interval> result = new ArrayList<Interval>();\n\t\tfor (int i=0;i<intervals.size();i++) {\n\t\t\tInterval currinter=intervals.get(i);\n\t\t\tif (currinter.end < newInterval.start) {\n\t\t\t\tcontinue;\n\t\t\t} else if (currinter.start > newInterval.end) {\n\t\t\t\tintervals.add(i,newInterval);\n\t\t\t} else if (currinter.end >= newInterval.start || currinter.start <= newInterval.end) {\n\t\t\t\tnewInterval = new Interval(Math.min(currinter.start, newInterval.start), Math.max(newInterval.end,\n\t\t\t\t\t\tcurrinter.end));\n\t\t\t\tintervals.remove(currinter);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    \n    public ArrayList<Integer> inorderTraversal(TreeNode root) {\n        ArrayList<Integer> rst = new ArrayList<Integer>();\n        if (root == null) {\n            return rst;\n        }\n        helper(rst, root);\n        \n        return rst;\n    }\n\n    public void helper(ArrayList<Integer> rst, TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        helper(rst, node.left);\n        rst.add(node.val);\n        helper(rst, node.right);\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class FindMinimuminRotatedSortedArray {\n\n    public static int findMin(int[] nums) {\n        if (nums.length == 1) {\n            return nums[0];\n        }\n        return binarySearch(0, nums.length - 1, nums);\n    }\n\n    public static int binarySearch(int left, int right, int[] nums) {\n        if (left >= right) {\n            return nums[left];\n        }\n        int mid = (left + right) / 2;\n        if (mid >= 1 && nums[mid] < nums[mid - 1]) {\n            return nums[(left + right) / 2];\n        } else if (nums[mid] >= nums[left] && nums[mid] >= nums[right]) {\n            return binarySearch(mid + 1, right, nums);\n        } else\n            return binarySearch(left, mid - 1, nums);\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {5, 1, 2, 3, 4};\n        System.out.print(findMin(nums));\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public String reverseWords(String s) {\n        if (s == null || s.length() == 0 || s.indexOf(\" \") == -1) {\n            return s;\n        }\n\n        String[] strs = s.split(\" \");\n        if (strs.length == 0) {\n            return s;\n        }\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = strs.length - 1; i >= 0; i--) {\n            sb.append(strs[i] + \" \");\n        }\n\n        return sb.substring(0, sb.length() - 1).toString();\n    }\n}\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class SameTree {\n\tpublic boolean isSameTree(TreeNode p, TreeNode q) {\n\t\tif (p == null && q != null || p != null && q == null)\n\t\t\treturn false;\n\t\tif (p == null && q == null)\n\t\t\treturn true;\n\t\tif (p.val == q.val)\n\t\t\treturn isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\t\telse\n\t\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int reverse(int x) {\n        if (x == 0) {\n            return x;    //123\n        }\n        boolean sign = x > 0; //sign = true\n        long rst = 0L;\n        x = Math.abs(x);                        // 123\n        while (x != 0) {                        //x = 123, 12, 1\n            rst = rst * 10 + x % 10;           //rst = 3, 30 + 2 = 32, 320 + 1 = 321\n            x = x / 10;                         //x = 12; 1; 0\n        }\n        if (rst < 0 || rst > Integer.MAX_VALUE) {\n            return 0;\n        }\n        return sign ? (int)rst : -(int)rst;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class SingleNumber3 {\n\n  public int[] singleNumber(int[] nums) {\n    if (nums.length < 3) return nums;\n    int xor = 0;\n    for (int i = 0; i < nums.length; i++) {\n      xor ^= nums[i];\n    }\n\n    xor &= -xor;\n\n    int val1 = 0;\n    int val2 = 0;\n    for (int i = 0; i < nums.length; i++) {\n      if ((nums[i] & xor) != 0) val1 ^= nums[i];\n      else val2 ^= nums[i];\n    }\n    return new int[]{val1, val2};\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "class RemoveDuplicatesFromSortedList {\n    public static void main(String[] args) {\n\n    }\n\n    \n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        while (cur != null) {\n            while (cur.next != null && cur.val == cur.next.val) {\n                cur.next = cur.next.next; // skip next node\n            }\n            cur = cur.next; // to next node\n        }\n        return head;\n    }\n\n    public ListNode myDeleteDuplicates(ListNode head) {\n        if (head == null) return head;\n\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode pre = head;\n        ListNode cur = head.next;\n        while (cur != null) {\n            while (cur != null && pre.val == cur.val) {\n                cur = cur.next;\n            }\n            pre.next = cur;\n            pre = cur;\n            if (cur != null) cur = cur.next;\n        }\n        return dummyHead.next;\n    }\n\n    public class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) {\n            val = x;\n            next = null;\n        }\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        if (matrix.length == 0 || matrix[0].length == 0) return res;\n        int n = matrix.length, m = matrix[0].length, row = 0, col = -1;\n        while (true) {\n            for (int i = 0; i < m; ++i) res.add(matrix[row][++col]);\n            if (--n == 0) break;\n            for (int i = 0; i < n; ++i) res.add(matrix[++row][col]);\n            if (--m == 0) break;\n            for (int i = 0; i < m; ++i) res.add(matrix[row][--col]);\n            if (--n == 0) break;\n            for (int i = 0; i < n; ++i) res.add(matrix[--row][col]);\n            if (--m == 0) break;\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class JumpGameII3 {\n    public int jump(int[] A) {\n        int jumps = 0, curEnd = 0, curFarthest = 0;\n        for (int i = 0; i < A.length - 1; i++) {\n            curFarthest = Math.max(curFarthest, i + A[i]);\n            if (i == curEnd) {\n                jumps++;\n                curEnd = curFarthest;\n            }\n        }\n        return jumps;\n    }\n}", "nl": "gaohannk"}
{"code": "public class Combinations {\n  public ArrayList<ArrayList<Integer>> combine(int n, int k) {\n    ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> subset = new ArrayList<Integer>();\n    int[] num = new int[n];\n    for (int j = 0; j < n; j++) {\n      num[j] = j + 1;\n    }\n    subsets(n, k, num, 0, subset, result);\n    return result;\n  }\n\n  private void subsets(\n      int n,\n      int k,\n      int[] num,\n      int begin,\n      ArrayList<Integer> subset,\n      ArrayList<ArrayList<Integer>> result) {\n    if (subset.size() >= k) {\n      ArrayList<Integer> c = new ArrayList<Integer>(subset);\n      result.add(c);\n    } else {\n      for (int i = begin; i < num.length; i++) {\n        subset.add(num[i]);\n        subsets(n, k, num, i + 1, subset, result);\n        subset.remove(subset.size() - 1);\n      }\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class L040_Combination_Sum_II {\n\n\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n\n\t\tif (candidates == null || candidates.length == 0) {\n\t\t\treturn new ArrayList<List<Integer>>();\n\t\t}\n\n\t\tSet<List<Integer>> rt = new HashSet<List<Integer>>();\n\t\tArrayList<Integer> cur = new ArrayList<Integer>();\n\n\t\tArrays.sort(candidates);\n\t\tdfs(0, target, rt, cur, candidates);\n\n\t\treturn new ArrayList<List<Integer>>(rt);\n\t}\n\n\tprivate void dfs(int start, int target, Set<List<Integer>> rt,\n\t\t\tArrayList<Integer> cur, int[] candidates) {\n\n\t\tif (target == 0) {\n\t\t\trt.add(new ArrayList<Integer>(cur));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = start; i < candidates.length; i++) {\n\n\t\t\tif (candidates[i] > target) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcur.add(candidates[i]);\n\t\t\tdfs(i + 1, target - candidates[i], rt, cur, candidates);\n\t\t\tcur.remove(cur.size() - 1);\n\t\t}\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    \n    public String minWindow(String source, String target) {\n    \tif (source == null || source.length() == 0) {\n    \t\treturn source;\n    \t}\n    \tif (target == null || target.length() == 0) {\n    \t\treturn \"\";\n    \t}\n    \tHashMap<Character, Integer> tCounter = new HashMap<Character, Integer>();\n    \tfor (int i = 0; i < target.length(); i++) {\n    \t\tCharacter c = target.charAt(i);\n    \t\tif (!tCounter.containsKey(c)) {\n    \t\t\ttCounter.put(c, 1);\n    \t\t} else {\n    \t\t\ttCounter.put(c, tCounter.get(c) + 1);\n    \t\t}\n    \t}\n\n\t\tHashMap<Character, Integer> minWindowCounter = new HashMap<Character, Integer>();\n\t\tint count = 0;\n\t\tString rst = \"\";\n\t\tfor (int i = 0; i < source.length(); i++) {\n\t\t\tCharacter c = source.charAt(i);\n\t\t\tif (!tCounter.containsKey(c)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (minWindowCounter.containsKey(c)) {\n\t\t\t\tminWindowCounter.put(c, minWindowCounter.get(c) + 1);\n\t\t\t} else {\n\t\t\t\tminWindowCounter.put(c, 1);\n\t\t\t}\n\t\t\t\t\t\n\t\t\tif (minWindowCounter.get(c) <= tCounter.get(c)) {\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif (count == target.length()) {\n\t\t\t\tint leftBound = 0;\n\t\t\t\twhile (leftBound < source.length()) {\n\t\t\t\t\tCharacter cs = source.charAt(leftBound);\n\t\t\t\t\tif (!minWindowCounter.containsKey(cs)) {//Not part of window\n\t\t\t\t\t\tleftBound++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (minWindowCounter.get(cs) > tCounter.get(cs)) {//Can find shorter window\n\t\t\t\t\t\tminWindowCounter.put(cs, minWindowCounter.get(cs) - 1);\n\t\t\t\t\t\tleftBound++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trst = source.substring(leftBound, i + 1);\n\t\t\t\treturn rst;\n\t\t\t}\n\t\t}\n\t\treturn rst;\n    }\n\n    public static void main(String[] args) {\n    \tSolution test = new Solution();\n    \tString rst = test.minWindow(\"abcd\", \"ac\");\n    \tSystem.out.println(\"resutl is : \" + rst);\n    }\n}\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(Integer.MIN_VALUE);\n        dummy.next = head;\n        ListNode cur = head.next;\n        head.next = null;\n        while (cur != null) {\n            ListNode tmp = dummy;\n            while (tmp.next != null && tmp.next.val <= cur.val) tmp = tmp.next;\n            ListNode next = cur.next;\n            cur.next = tmp.next;\n            tmp.next = cur;\n            cur = next;\n        }\n        return dummy.next;\n    }\n}", "nl": "leetcoders"}
{"code": "public class UniqueBinarySearchTrees {\n\n    public class Solution {\n        public int numTrees(int n) {\n            int c = 1;\n            for (int i = 2; i <= n; i++) {\n                c = c * 2 * (2 * i - 1) / (i + 1);\n            }\n            return c;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class ContainerWithMostWater \n{\n\tpublic int maxArea(int[] height) \n\t{\n\t\treturn 0;\n\t}\n}\n", "nl": "FreemanZhang"}
{"code": "public class MergeSortedArray {\n\n    public class Solution {\n        public void merge(int A[], int m, int B[], int n) {\n            int i = m - 1;\n            int j = n - 1;\n            while (i >= 0 && j >= 0) {\n                A[i + j + 1] = A[i] > B[j] ? A[i--] : B[j--];\n            }\n            while (j >= 0) {\n                A[j] = B[j--];\n            }\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class CombinationSum {\n\n    public class Solution {\n        private void search(int[] n, int index, int target,\n                ArrayDeque<Integer> s, ArrayList<ArrayList<Integer>> ans) {\n            if (target == 0) {\n                ans.add(new ArrayList<Integer>(s));\n                return;\n            }\n            if (index == n.length || target < n[index]) {\n                return;\n            }\n\n            for (int i = 0; i <= target / n[index]; i++) {\n                search(n, index + 1, target - i * n[index], s, ans);\n                s.offerLast(n[index]);\n            }\n            for (int i = 0; i <= target / n[index]; i++) {\n                s.removeLast();\n            }\n        }\n\n        public ArrayList<ArrayList<Integer>> combinationSum(int[] candidates,\n                int target) {\n            ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n            Arrays.sort(candidates);\n            search(candidates, 0, target, new ArrayDeque<Integer>(), ans);\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class MergeTwoSortedLists2 {\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tif (l1 == null && l2 == null)\n\t\t\treturn null;\n\t\tif (l1 == null)\n\t\t\treturn l2;\n\t\tif (l2 == null)\n\t\t\treturn l1;\n\n\t\tListNode p = new ListNode(0);\n\t\tif (l1.val < l2.val) {\n\t\t\tp.next = l1;\n\t\t\tl1.next = mergeTwoLists(l1.next, l2);\n\t\t} else {\n\t\t\tp.next = l2;\n\t\t\tl2.next = mergeTwoLists(l1, l2.next);\n\t\t}\n\t\treturn p.next;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int numTrees_1(int n) {\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 0; j < i; j++)\n                dp[i] += dp[j] * dp[i-j-1];\n        return dp[n];\n    }\n    public int numTrees(int n) {\n        if (n < 0) return 0;\n        int[] dp = new int[n+1];\n        dp[0] = 1; dp[1] = 1;\n        for(int i = 2;i <= n; ++i){\n            dp[i] = dp[i-1] * (4 * i - 2)/(i + 1);\n        }\n        return dp[n];\n    }\n}", "nl": "leetcoders"}
{"code": "public class RemoveDuplicatesfromSortedListII {\n  public ListNode deleteDuplicates(ListNode head) {\n    if (head == null) return head;\n    ListNode start = new ListNode(0);\n    start.next = head;\n    ListNode slow = start;\n    ListNode fast = head;\n    while (fast.next != null) {\n      if (slow.next.val != fast.next.val) {\n        if (slow.next.next == fast.next) {\n          slow = slow.next;\n        } else {\n          slow.next = fast.next;\n        }\n      }\n      fast = fast.next;\n    }\n    if (slow.next.next != fast.next) {\n      slow.next = fast.next;\n    }\n    return start.next;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    \n    public int minDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return getMin(root);\n    }\n    \n    public int getMin(TreeNode root) {\n        if (root == null) {\n            return Integer.MAX_VALUE;\n        }\n        if (root.left == null && root.right == null) {\n            return 1;\n        }\n        return Math.min(getMin(root.left), getMin(root.right)) + 1;\n    }\n}\n\n", "nl": "awangdev"}
{"code": "public class MaximalRectangle {\n\n\tpublic int maximalRectangle(char[][] matrix) {\n\t\tif (matrix.length == 0)\n\t\t\treturn 0;\n\t\tint maxArea = 0;\n\t\tint[] height = new int[matrix[0].length + 1];\n\t\tfor (int i = 0; i < matrix.length; i++) {\n\t\t\tStack<Integer> s = new Stack<Integer>();\n\t\t\tfor (int j = 0; j < matrix[0].length; j++) {\n\t\t\t\tif (matrix[i][j] == '0')\n\t\t\t\t\theight[j] = 0;\n\t\t\t\telse\n\t\t\t\t\theight[j]++;\n\t\t\t}\n\t\t\tint j = 0;\n\t\t\twhile (j < height.length) {\n\t\t\t\tif (s.empty() || height[j] > height[s.peek()])\n\t\t\t\t\ts.push(j++);\n\t\t\t\telse {\n\t\t\t\t\tint tmp = s.pop();\n\t\t\t\t\tmaxArea = Math.max(maxArea, height[tmp] * (s.empty() ? j : j - s.peek() - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxArea;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class CloneGraph {\n\n  static class UndirectedGraphNode {\n    int label;\n    List<UndirectedGraphNode> neighbors;\n\n    UndirectedGraphNode(int x) {\n      label = x;\n      neighbors = new ArrayList<>();\n    }\n  }\n\n  private Map<Integer, UndirectedGraphNode> map;\n  \n  public static void main(String[] args) throws Exception {\n    UndirectedGraphNode node = new UndirectedGraphNode(0);\n    UndirectedGraphNode node1 = new UndirectedGraphNode(1);\n    UndirectedGraphNode node2 = new UndirectedGraphNode(2);\n    node.neighbors.add(node1);\n    node.neighbors.add(node2);\n\n    node1.neighbors.add(node);\n    node1.neighbors.add(node2);\n\n    node2.neighbors.add(node);\n    node2.neighbors.add(node1);\n    node2.neighbors.add(node2);\n    UndirectedGraphNode result = new CloneGraph().cloneGraph(node);\n  }\n\n  public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n    if (node == null) return null;\n    map = new HashMap<>();\n    UndirectedGraphNode clone = new UndirectedGraphNode(node.label);\n    dfs(node, clone);\n    return clone;\n  }\n\n  private void dfs(UndirectedGraphNode original, UndirectedGraphNode clone) {\n    map.put(clone.label, clone);\n    List<UndirectedGraphNode> oChildren = original.neighbors; // original child nodes\n    List<UndirectedGraphNode> cChildren = clone.neighbors; // clone child nodes\n    for (UndirectedGraphNode oChild : oChildren) {\n      if (map.containsKey(oChild.label)) {\n        cChildren.add(map.get(oChild.label));\n      } else {\n        UndirectedGraphNode newChildClone = new UndirectedGraphNode(oChild.label);\n        cChildren.add(newChildClone);\n        dfs(oChild, newChildClone);\n      }\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class FlattenBinaryTreeToLinkedList {\n\n  \n  public void flatten(TreeNode root) {\n    while (root != null) {\n      if (root.left != null) {\n        TreeNode n = root.left;\n        while (n.right != null) {\n          n = n.right;\n        }\n        n.right = root.right;\n        root.right = root.left;\n        root.left = null;\n      }\n      root = root.right;\n    }\n  }\n\n  \n  public void flattenB(TreeNode root) {\n    if (root == null) {\n      return;\n    }\n    flattenB(root.left);\n    flattenB(root.right);\n    TreeNode n = root.right;\n    root.right = root.left;\n    root.left = null; // IMPORTANT! Set left child to null.\n    TreeNode cur = root;\n    while (cur.right != null) {\n      cur = cur.right;\n    }\n    cur.right = n;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        head=findFirst(head);\n        if (head!=null) {\n            head.next=deleteDuplicates(head.next);\n        }\n        return head;\n    }\n    public ListNode findFirst(ListNode head) {\n        if (head==null||head.next==null||head.val!=head.next.val) {\n            return head;\n        }\n        int i=head.val;\n        while (head!=null) {\n            if (head.val!=i) {\n                return findFirst(head);\n            }\n            head=head.next;\n        }\n        return null;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MergeTwoSortedLists {\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tif (l1 == null && l2 == null)\n\t\t\treturn null;\n\t\tif (l1 == null)\n\t\t\treturn l2;\n\t\tif (l2 == null)\n\t\t\treturn l1;\n\n\t\tListNode newhead = new ListNode(0);\n\t\tListNode cur = newhead;\n\t\twhile (l1 != null && l2 != null) {\n\t\t\tif (l1.val > l2.val) {\n\t\t\t\tcur.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t} else {\n\t\t\t\tcur.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif (l1 == null)\n\t\t\tcur.next = l2;\n\t\telse\n\t\t\tcur.next = l1;\n\t\treturn newhead.next;\n\t}\n}", "nl": "gaohannk"}
{"code": "public class L134_Gas_Station {\n\n\tpublic static int canCompleteCircuit(int[] gas, int[] cost) {\n\n\t\tint start = 0;\n\t\tint from_start = 0;\n\n\t\tint total = 0;\n\n\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\tint left = gas[i] - cost[i];\n\t\t\ttotal += left;\n\t\t\tfrom_start += left;\n\n\t\t\tif (from_start < 0) {\n\t\t\t\tfrom_start = 0;\n\t\t\t\tstart = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (total >= 0) {\n\t\t\treturn start;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class L054_Spiral_Matrix {\n\n\tpublic List<Integer> spiralOrder(int[][] matrix) {\n\n\t\tList<Integer> rt = new ArrayList<Integer>();\n\n\t\tif (matrix == null || matrix.length == 0) {\n\t\t\treturn rt;\n\t\t}\n\n\t\tint startx = 0, endx = matrix.length - 1;\n\t\tint starty = 0, endy = matrix[0].length - 1;\n\n\t\twhile (startx <= endx && starty <= endy) {\n\n\t\t\tfor (int y = starty; y <= endy; y++) {\n\t\t\t\trt.add(matrix[startx][y]);\n\t\t\t}\n\n\t\t\tfor (int x = startx + 1; x <= endx; x++) {\n\t\t\t\trt.add(matrix[x][endy]);\n\t\t\t}\n\n\t\t\tif (startx == endx || starty == endy) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int y = endy - 1; y >= starty; y--) {\n\t\t\t\trt.add(matrix[endx][y]);\n\t\t\t}\n\n\t\t\tfor (int x = endx - 1; x >= startx + 1; x--) {\n\t\t\t\trt.add(matrix[x][starty]);\n\t\t\t}\n\n\t\t\tstartx++;\n\t\t\tstarty++;\n\t\t\tendx--;\n\t\t\tendy--;\n\t\t}\n\n\t\treturn rt;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        return add(l1,l2,true);\n    }\n    public ListNode add(ListNode l1, ListNode l2,boolean flag) {\n        boolean a=l1==null;\n        boolean b=l2==null;\n        if (a&&b&&flag) {\n            return null;\n        }\n        int val=(a?0:l1.val)+(b?0:l2.val)+(flag?0:1);\n        int v=val%10;\n        boolean f=(v==val);\n        ListNode answer=new ListNode(v);\n        answer.next=add(a?null:l1.next,b?null:l2.next,f);\n        return answer;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class MergekSortedLists {\n  public ListNode mergeKLists(ArrayList<ListNode> lists) {\n    if (lists == null || lists.isEmpty()) return null;\n\n    Comparator<ListNode> comp =\n        new Comparator<ListNode>() {\n          public int compare(ListNode o1, ListNode o2) {\n            if (o1.val < o2.val) return -1;\n            if (o1.val > o2.val) return 1;\n            return 0;\n          }\n        };\n    PriorityQueue<ListNode> heap = new PriorityQueue<ListNode>(lists.size(), comp);\n    for (ListNode node : lists) {\n      if (node != null) heap.add(node);\n    }\n    ListNode head = null, cur = null;\n    while (!heap.isEmpty()) {\n      if (head == null) {\n        head = heap.poll();\n        cur = head;\n      } else {\n        cur.next = heap.poll();\n        cur = cur.next;\n      }\n      if (cur.next != null) heap.add(cur.next);\n    }\n    return head;\n  }\n}\n", "nl": "mengli"}
{"code": "public class HouseRobber2 {\n\n  public int rob(int[] nums) {\n    if (nums == null || nums.length == 0) return 0;\n    if (nums.length == 1) return nums[0];\n    if (nums.length == 2) return Math.max(nums[0], nums[1]);\n    return Math.max(robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1));\n  }\n\n  private int robRange(int[] nums, int start, int end) {\n    int include = 0, exclude = 0;\n    for (int j = start; j <= end; j++) {\n      int i = include, e = exclude;\n      include = e + nums[j];\n      exclude = Math.max(e, i);\n    }\n    return Math.max(include, exclude);\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SymmetricTree {\n\tpublic boolean isSymmetric(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn true;\n\t\tQueue<TreeNode> left = new LinkedList<TreeNode>();\n\t\tQueue<TreeNode> right = new LinkedList<TreeNode>();\n\n\t\tleft.add(root.left);\n\t\tright.add(root.right);\n\t\twhile (!left.isEmpty() && !right.isEmpty()) {\n\t\t\tTreeNode t1 = left.poll();\n\t\t\tTreeNode t2 = right.poll();\n\t\t\tif (t1 != null && t2 != null) {\n\t\t\t\tif (t1.val != t2.val)\n\t\t\t\t\treturn false;\n\t\t\t\tleft.add(t1.left);\n\t\t\t\tleft.add(t1.right);\n\t\t\t\tright.add(t2.right);\n\t\t\t\tright.add(t2.left);\n\t\t\t} else if (t1 != null && t2 == null || t1 == null && t2 != null) // \u6d93\u5d88\ue6e6\u8e47\u6a3f\ue187\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Graycode {\n  public static void main(String[] args) {\n    System.out.println(new Graycode().grayCode(3));\n  }\n\n  \n  public List<Integer> grayCode(int n) {\n    List<Integer> results = new ArrayList<Integer>();\n    results.add(0); // starts from 0\n    for (int i = 0; i < n; i++) {\n      int inc = 1 << i; // move 1 i times\n      for (int j = results.size() - 1; j >= 0; j--) { // backtracking\n        results.add(results.get(j) + inc);\n      }\n    }\n    return results;\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class SwapNodesInPairs {\n\n  public static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    ListNode node = new ListNode(1);\n    node.next = new ListNode(2);\n    node.next.next = new ListNode(3);\n    node.next.next.next = new ListNode(4);\n    node.next.next.next.next = new ListNode(5);\n    node.next.next.next.next.next = new ListNode(6);\n    ListNode head = new SwapNodesInPairs().swapPairs(node);\n    while (head != null) {\n      System.out.println(head.val);\n      head = head.next;\n    }\n  }\n\n  public ListNode swapPairs(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode newHead = head.next;\n    ListNode curr = head.next;\n    ListNode prev = head;\n    ListNode prevPrev = new ListNode(-1); // dummy node\n    while (curr != null) {\n      prev.next = curr.next;\n      curr.next = prev;\n      prevPrev.next = curr;\n      if (prev.next != null) {\n        curr = prev.next.next;\n        prev = prev.next;\n        prevPrev = prevPrev.next.next;\n      } else {\n        curr = null;\n      }\n    }\n    return newHead;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class ValidNumber {\n\n    enum Status {\n        INIT, SYMBOL, INT, DOT, FRAC, E, SYMBOL_E, INT_E\n    }\n\n    public class Solution {\n\n        public boolean isNumber(String s) {\n            s = s.trim();\n            Status status = Status.INIT;\n            boolean hasInt = false;\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                switch (status) {\n                case INIT:\n                    if (c == '+' || c == '-') {\n                        status = Status.SYMBOL;\n                    } else if (Character.isDigit(c)) {\n                        status = Status.INT;\n                        hasInt = true;\n                    } else if (c == '.') {\n                        status = Status.DOT;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case SYMBOL:\n                    if (Character.isDigit(c)) {\n                        status = Status.INT;\n                        hasInt = true;\n                    } else if (c == '.') {\n                        status = Status.DOT;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case INT:\n                    if (Character.isDigit(c)) {\n\n                    } else if (c == '.') {\n                        status = Status.DOT;\n                    } else if (c == 'E' || c == 'e') {\n                        status = Status.E;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case DOT:\n                    if (Character.isDigit(c)) {\n                        status = Status.FRAC;\n                    } else if (c == 'E' || c == 'e') {\n                        if (!hasInt) {\n                            return false;\n                        }\n                        status = Status.E;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case FRAC:\n                    if (Character.isDigit(c)) {\n                    } else if (c == 'E' || c == 'e') {\n                        status = Status.E;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case E:\n                    if (Character.isDigit(c)) {\n                        status = Status.INT_E;\n                    } else if (c == '+' || c == '-') {\n                        status = Status.SYMBOL_E;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case SYMBOL_E:\n                    if (Character.isDigit(c)) {\n                        status = Status.INT_E;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case INT_E:\n                    if (Character.isDigit(c)) {\n                    } else {\n                        return false;\n                    }\n                    break;\n                }\n            }\n            return (hasInt && status == Status.DOT) || status == Status.INT\n                    || status == Status.FRAC || status == Status.INT_E;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class RegularExpressionMatching \n{\n    public boolean isMatch( String s, String p )\n    {\n        if ( s == null )\n        {\n        \treturn p == null;        \t\n        }\n        if ( p == null )\n        {\n        \treturn false;\n        }\n        int[][] isMatch = new int[s.length()+1][p.length()+1];\n        return isMatch( s, p, s.length() - 1, p.length() - 1, isMatch );\n    }\n    \n    private boolean isMatch( String s, String p, int sIndex, int pIndex, int[][] memorized )\n    {    \t\n    \tif ( memorized[sIndex+1][pIndex+1] != 0 )\n    \t{\n    \t\treturn memorized[sIndex+1][pIndex+1] == 1;\n    \t}\n    \t\n    \tif ( pIndex == -1 )\n    \t{    \t\t\n    \t\tmemorized[sIndex+1][pIndex+1] = ( sIndex == -1 ) ? 1 : -1;\n    \t\treturn memorized[sIndex+1][pIndex+1] == 1;\n    \t}\n    \t\n    \tif ( p.charAt( pIndex ) == '*' )\n    \t{\n    \t\tboolean match = isMatch( s, p, sIndex, pIndex - 2, memorized ) // * matching zero char, if string is valid, then pIndex >= 1. pIndex - 2 >= -1\n    \t\t\t\t|| ( sIndex >= 0 && ( p.charAt( pIndex - 1 ) == s.charAt( sIndex ) || p.charAt( pIndex - 1 ) == '.') && isMatch( s, p, sIndex-1, pIndex, memorized ) ); // * match one char, then sIndex >= 0 to satisfy semantics here; matching multiple chars case will be handled recursively by matching one char case\n    \t\tmemorized[sIndex+1][pIndex+1] = match ? 1 : -1;    \t\t\n    \t}\n    \telse\n    \t{\n    \t\t\n    \t\tboolean match = sIndex >= 0 \n    \t\t\t\t&& ( p.charAt( pIndex ) == s.charAt( sIndex ) || p.charAt( pIndex ) == '.' )\n    \t\t\t\t&& isMatch( s, p, sIndex - 1, pIndex - 1, memorized );\n    \t\tmemorized[sIndex+1][pIndex+1] = match ? 1 : -1;\n    \t}\n    \treturn memorized[sIndex+1][pIndex+1] == 1;\n    }\n\n    @Test\n    public void testLetters()\n    {\n    \tassertTrue( isMatch( \"aa\", \"aa\" ) );\n    \tassertTrue( !isMatch( \"ab\", \"aa\" ) );\n    \tassertTrue( !isMatch( \"caa\", \"aa\" ) );\n    \tassertTrue( !isMatch( \"aa\", \"caa\" ) );\n    }\n    \n    @Test\n    public void testDot()\n    {\n    \tassertTrue( isMatch( \"aa\", \"a.\" ) );\n    \tassertTrue( isMatch( \"ab\", \"a.\" ) );\n    \tassertTrue( !isMatch( \"caa\", \"a.\" ) );\n    \tassertTrue( !isMatch( \"aa\", \"c.a\" ) );\n    }\n    \n    @Test\n    public void testStar()\n    {\n    \tassertTrue( isMatch( \"\", \"a*\" ) );\n    \tassertTrue( isMatch( \"a\", \"a*\" ) );\n    \tassertTrue( isMatch( \"aa\", \"a*\" ) );\n    \tassertTrue( isMatch( \"aaa\", \"a*\" ) );\n    \tassertTrue( !isMatch( \"baa\", \"a*\" ) );\n    \tassertTrue( !isMatch( \"aab\", \"a*\" ) );    \t\n    }\n    \n    @Test\n    public void testDotStar()\n    {\n    \tassertTrue( isMatch( \"\", \".*\" ) );\n    \tassertTrue( isMatch( \"a\", \".*\" ) );\n    \tassertTrue( isMatch( \"aa\", \".*\" ) );\n    \tassertTrue( isMatch( \"aaa\", \".*\" ) );\n    \tassertTrue( isMatch( \"baa\", \".*\" ) );\n    \tassertTrue( isMatch( \"aab\", \".*\" ) );    \t    \t\n    }\n    \n    @Test\n    public void errorProneTest()\n    {\n    \tassertTrue( !isMatch( \"a\", \"ab*a\" ) );\n    \tassertFalse( isMatch( \"aab\", \"b.*\" ) );\n    }\n}", "nl": "FreemanZhang"}
{"code": "class Solution {\n    class Point {\n        int val, flag;\n        public Point(int val, int flag) {\n            this.val = val;\n            this.flag = flag;\n        }\n    }\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        List<Interval> rst = new ArrayList<>();\n        if (intervals == null || intervals.size() == 0 || newInterval == null) {\n            if (newInterval != null) rst.add(newInterval);\n            return rst;\n        }\n        \n        PriorityQueue<Point> queue = buildQueue(intervals, newInterval);\n        int count = 0;\n        Interval interval = new Interval();\n        while (!queue.isEmpty()) {\n            Point p = queue.poll();\n            if (count == 0) {//detect start\n                interval.start = p.val;\n            }    \n            \n            count += p.flag;\n            while (!queue.isEmpty() && p.val == queue.peek().val) {\n                p = queue.poll();\n                count += p.flag;\n            }\n            \n            if (count == 0) {\n                interval.end = p.val;\n                rst.add(interval);\n                interval = new Interval();\n            }\n        }\n        return rst;\n    }\n    \n    private PriorityQueue<Point> buildQueue(List<Interval> intervals, Interval newInterval) {\n        PriorityQueue<Point> queue = new PriorityQueue<>(Comparator.comparing(p -> p.val));\n        queue.offer(new Point(newInterval.start, 1));\n        queue.offer(new Point(newInterval.end, -1));\n        for (Interval interval : intervals) {\n            queue.offer(new Point(interval.start, 1));\n            queue.offer(new Point(interval.end, -1));\n        }\n        return queue;\n    }\n    \n}\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> rst = new ArrayList<Integer>();\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        if (root == null) {\n        \treturn rst;\n        }\n        dfsOnLeft(stack, root);\n        while(!stack.isEmpty()) {\n        \tTreeNode node = stack.pop();\n        \trst.add(node.val);\n        \tif (node.right != null) {\n        \t\tnode = node.right;\n        \t\tdfsOnLeft(stack, node);\n        \t}\n        }//end while\n        return rst;\n    }\n\n    public void dfsOnLeft(Stack<TreeNode> stack, TreeNode node) {\n    \tstack.push(node);\n        while(node.left != null) {\n        \tnode = node.left;\n        \tstack.push(node);\n        }\n    }\n}", "nl": "awangdev"}
{"code": "class SameTree {\n\n  \n  public static boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null || q == null) return p == q; // if one of them is null, it will return false. both null, true.\n    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); // equal val, equal subtrees\n  }\n\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class CourseSchedule {\n\tpublic boolean canFinish(int numCourses, int[][] prerequisites) {\n\t\tint[] status = new int[numCourses];\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tif (status[i] == 0) {\n\t\t\t\tif (!DFS(i, prerequisites, status)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean DFS(int curr, int[][] prerequisites, int[] status) {\n\t\tif (status[curr] == 1) {\n\t\t\treturn false;\n\t\t}\n\t\tstatus[curr] = 1;\n\t\tfor (int[] p : prerequisites) {\n\t\t\tif (p[0] == curr && status[p[1]] != 2) {\n\t\t\t\tif (!DFS(p[1], prerequisites, status)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatus[curr] = 2;\n\t\treturn true;\n\t}\n\n}\n", "nl": "gaohannk"}
{"code": "public class _40_combinationSum2 {\n    public static void main(String[] args) {\n        List<List<Integer>> lists = combinationSum2(new int[]{10, 1, 2, 7, 6, 1, 5}, 8);\n        for (int i = 0; i < lists.size(); i++) {\n            Util.printList(lists.get(i));\n        }\n        Util.printDivideLine();\n        List<List<Integer>> lists2 = combinationSum2(new int[]{2, 5, 2, 1, 2}, 5);\n        for (int i = 0; i < lists2.size(); i++) {\n            Util.printList(lists2.get(i));\n        }\n    }\n\n    \n    public static List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> result = new ArrayList<>();\n        generate(candidates, 0, target, result, new ArrayList<>());\n        return result;\n    }\n\n    private static void generate(int[] nums,\n                                 int index,\n                                 int target,\n                                 List<List<Integer>> result,\n                                 List<Integer> item) {\n        if (index >= nums.length\n                || target < 0) {\n            return;\n        }\n        item.add(nums[index]);\n        target -= nums[index];\n        if (0 == target) {\n            result.add(new ArrayList<>(item));\n        }\n        generate(nums, index + 1, target, result, item);\n        Integer remove = item.remove(item.size() - 1);\n        target += remove;\n        int i = index;\n        while (i < nums.length - 1 && nums[i + 1] == remove) {\n            i++;\n        }\n        generate(nums, i + 1, target, result, item);\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> rst = new ArrayList<String>();\n        if (root == null) {\n            return rst;\n        }   \n        ArrayList<String> list = new ArrayList<String>();\n        DFS(root, list, rst);\n        return rst;\n    }\n    public void DFS(TreeNode node, ArrayList<String> list, List<String> rst) {\n        list.add(node.val+\"\");\n        if(node.left == null && node.right == null) {\n            String str = \"\";\n            for (String s : list) {\n                str += s + \"->\";\n            }\n            rst.add(str.substring(0, str.length() - 2));\n            return;\n        }\n        if (node.left != null) {\n            DFS(node.left, list, rst);\n            list.remove(list.size() - 1);\n        }\n        if (node.right != null) {\n            DFS(node.right, list, rst);\n            list.remove(list.size() - 1);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public ListNode deleteDuplicates_1(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode pre = head, cur = head.next;\n        while(cur != null) {\n            if(pre.val == cur.val) {\n                pre.next = cur.next;\n            } else {\n                pre = pre.next;\n            }\n            cur = cur.next;\n        }\n        return head;\n    }\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode pre = head, cur = head.next;\n        while(cur != null) {\n            if (pre.val != cur.val) {\n                pre.next.val = cur.val;\n                pre = pre.next;\n            }\n            cur = cur.next;\n        }\n        pre.next = null;\n        return head;\n    }\n}", "nl": "leetcoders"}
{"code": "public class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int N = gas.length;\n        int res = 0, min = gas[0] - cost[0], sum = min;\n        for (int i = 1; i < N; ++i) {\n            sum += gas[i] - cost[i];\n            if (sum < min) {\n                min = sum;\n                res = i;\n            }\n        }\n        return sum >= 0 ? (res + 1) % N : -1;\n    }\n}", "nl": "leetcoders"}
{"code": "public class SymmetricTree {\n  public boolean isSymmetric(TreeNode root) {\n    if (root == null) return true;\n    Stack<TreeNode> s1 = new Stack<TreeNode>();\n    Stack<TreeNode> s2 = new Stack<TreeNode>();\n    s1.push(root.left);\n    s2.push(root.right);\n    while (!s1.isEmpty() && !s2.isEmpty()) {\n      TreeNode n1 = s1.pop();\n      TreeNode n2 = s2.pop();\n      if (n1 == null && n2 == null) {\n        continue;\n      } else if (n1 == null || n2 == null) {\n        return false;\n      } else if (n1.val != n2.val) {\n        return false;\n      } else {\n        s1.push(n1.left);\n        s1.push(n1.right);\n        s2.push(n2.right);\n        s2.push(n2.left);\n      }\n    }\n    return true;\n  }\n}\n", "nl": "mengli"}
{"code": "public class WordSearch {\n\n    public class Solution {\n        private boolean search(char[][] board, int i, int j, String word,\n                int begin) {\n            if (begin == word.length()) {\n                return true;\n            }\n            if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {\n                return false;\n            }\n            if (board[i][j] == '*' || board[i][j] != word.charAt(begin)) {\n                return false;\n            }\n            char c = board[i][j];\n            board[i][j] = '*';\n            boolean re = search(board, i + 1, j, word, begin + 1)\n                    || search(board, i - 1, j, word, begin + 1)\n                    || search(board, i, j + 1, word, begin + 1)\n                    || search(board, i, j - 1, word, begin + 1);\n            board[i][j] = c;\n            return re;\n        }\n\n        public boolean exist(char[][] board, String word) {\n            for (int i = 0; i < board.length; i++) {\n                for (int j = 0; j < board[0].length; j++) {\n                    if (search(board, i, j, word, 0)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1.equals(\"0\")||num2.equals(\"0\")) {\n            return \"0\";\n        }\n        if (num1.length()<num2.length()) {\n            return multiply(num2,num1);\n        }\n        int l1=num1.length();\n        int[] n1=new int[l1];\n        for (int i = 0; i <l1; i++) {\n            n1[l1-i-1]=Integer.parseInt(num1.substring(i, i+1));\n        }\n        int l2=num2.length();\n        int[] n2=new int[l1];\n        for (int i = 0; i <l2; i++) {\n            n2[l2-i-1]=Integer.parseInt(num2.substring(i, i+1));\n        }\n        int[] a=new int[l1+l2-1];\n        int sum=0;\n        int carry=0;\n        for (int i = 0; i < a.length; i++) {\n            for (int j = Math.max(0,i-l2+1); j <= Math.min(i,l1-1); j++) {\n                sum += n1[j] * n2[i-j];\n            }\n            sum += carry;\n            carry = sum / 10;\n            sum%=10;\n            a[i]=sum;\n            sum = 0;\n        }\n        StringBuffer sb=new StringBuffer();\n        if (carry!=0) {\n            sb.append(String.valueOf(carry));\n        }\n        for (int i = a.length-1; i >=0 ; i--) {\n            sb.append(String.valueOf(a[i]));\n        }\n        return sb.toString();\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n\npublic List<Integer> grayCode(int n) {\n\nList<Integer> rst = new ArrayList<Integer>();\n\nif (n < 0) {\n\nreturn rst;\n\n}\n\nchar[] bits = new char[n];\n\nfor (int i = 0; i < bits.length; i++) {\n\nbits[i] = '0';\n\n}\n\nString str = new String(bits);\n\nif (n == 0) {\n\nstr = \"0\";\n\n}\n\nrst.add(Integer.parseInt(str, 2));\n\nint step = n - 1;\n\nboolean LR = true;//L: true; R: false\n\nint steps = (int)Math.pow(2, n) - 1;\n\nfor (int i = 0; i < steps; i++) {\n\nbits[step] = bits[step] == '0' ? '1' : '0';\n\nstr = new String(bits);\n\nrst.add(Integer.parseInt(str, 2));\n\nif (LR) {\n\nstep--;\n\n} else {\n\nstep++;\n\n}\n\nif (step == (n - 1) || step == 0) {//Turn around\n\nLR = !LR;\n\n}\n\n}\n\nreturn rst;\n\n}\n\n}\n   ", "nl": "awangdev"}
{"code": "public class RemoveDuplicatesFromSortedArray {\n\n    \n    public int removeDuplicates(int[] nums) {\n        int len = 0;\n        for (int n : nums) {\n            if (len == 0 || n != nums[len - 1]) {\n                nums[len++] = n;\n            }\n        }\n        return len;\n    }\n\n    public int removeDuplicates2(int[] nums) {\n        int len = 1;\n        for (int i = 1, j = i; i < nums.length; i = j) {\n            while (j < nums.length && nums[j] == nums[len - 1]) {\n                j++;\n            }\n            if (j < nums.length) {\n                nums[len] = nums[j];\n                len++;\n            }\n        }\n        return len;\n    }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class CountAndSay {\n\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(new CountAndSay().countAndSay(4));\n  }\n\n  public String countAndSay(int n) {\n    String result = \"1\";\n    for (int i = 1; i < n; i++) {\n      int count = 1;\n      char num = result.charAt(0);\n      StringBuilder temp = new StringBuilder();\n      for (int j = 1, l = result.length(); j < l; j++) {\n        if (result.charAt(j) == num) {\n          count++;\n        } else {\n          temp = temp.append(String.valueOf(count)).append(String.valueOf(num));\n          num = result.charAt(j);\n          count = 1;\n        }\n      }\n      temp = temp.append(String.valueOf(count)).append(String.valueOf(num));\n      result = temp.toString();\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    \n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n        \treturn \"\";\n        }\n        if (strs.length == 1) {\n            return strs[0];\n        }\n        String prefix = \"\";\n        int ind = 0;\n        while (ind < strs[0].length()) {\n        \tchar c = strs[0].charAt(ind);\n        \tboolean valid = false;\n        \tfor (int i = 1; i < strs.length; i++) {\n        \t\tif (strs[i].length() > ind && strs[i].charAt(ind) == c) {\n        \t\t\tvalid = true;\n        \t\t} else {\n        \t\t\tvalid = false;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \tif (valid) {\n        \t\tprefix += \"\" + c;\n        \t} else {\n        \t\tbreak;\n        \t}\n        \tind++;\n        }//END WHILE\n        return prefix;\n    }\n}", "nl": "awangdev"}
{"code": "class PalindromePartitioning {\n\n  public static void main(String[] args) {\n    System.out.println(partition(\"aab\"));\n    System.out.println(partition(\"aa\"));\n  }\n\n  \n  public static List<List<String>> partition(String s) {\n    List<List<String>> res = new ArrayList<>();\n    if (s == null || s.length() == 0) return res;\n    partition(s, 0, res, new ArrayList<>());\n    return res;\n  }\n\n  public static void partition(String s, int pos, List<List<String>> res, List<String> cut) {\n    if (pos == s.length()) { // note the stop condition\n      res.add(new ArrayList<String>(cut)); // dereference\n      return;\n    }\n    for (int i = pos + 1; i <= s.length(); i++) {\n      String prefix = s.substring(pos, i);\n      if (isPalindrome(prefix)) {\n        cut.add(prefix);\n        partition(s, i, res, cut); // update pos with i\n        cut.remove(cut.size() - 1);\n      }\n    }\n  }\n\n  private static boolean isPalindrome(String str) {\n    int s = 0;\n    int e = str.length() - 1;\n    while (s < e) {\n      if (str.charAt(s) != str.charAt(e)) return false;\n      s++;\n      e--;\n    }\n    return true;\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class ValidPalindrome {\n  public boolean isPalindrome(String s) {\n    s = s.toUpperCase();\n    int i = 0, j = s.length() - 1;\n    while (i < j) {\n      if (!isAlphabet(s.charAt(i))) {\n        i++;\n      } else if (!isAlphabet(s.charAt(j))) {\n        j--;\n      } else if (s.charAt(i) != s.charAt(j)) {\n        return false;\n      } else {\n        i++;\n        j--;\n      }\n    }\n    return true;\n  }\n\n  private boolean isAlphabet(char c) {\n    return (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');\n  }\n}\n", "nl": "mengli"}
{"code": "public class ValidPalindrome {\n\tpublic boolean isPalindrome(String s) {\n\n\t\tif (s == null)\n\t\t\treturn false;\n\t\tchar[] chars = s.toCharArray();\n\t\tint i = 0;\n\t\tint j = s.length() - 1;\n\n\t\twhile (i < j) {\n\t\t\twhile (i < s.length() - 1 && !isAlphaandNum(chars[i]))\n\t\t\t\ti++;\n\t\t\tchar left = chars[i];\n\t\t\twhile (j > 0 && !isAlphaandNum(chars[j]))\n\t\t\t\tj--;\n\t\t\tchar right = chars[j];\n\n\t\t\tif (i >= j)\n\t\t\t\tbreak;\n\n\t\t\tif (!isSame(left, right))\n\t\t\t\treturn false;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic boolean isAlphaandNum(char a) {\n\t\tif ((a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z') || a >= '0' && a <= '9')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tpublic boolean isSame(char a, char b) {\n\t\tif (Character.toLowerCase(a) == Character.toLowerCase(b) || a == b)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public boolean exist(char[][] board, String word) {\n        int N = board.length;\n        int M = board[0].length;\n        for(int i=0;i<N;i++)\n            for(int j=0;j<M;j++)\n                if(board[i][j]==word.charAt(0)){\n        \t\t\tif(bfs(i,j,board,word,0))\n        \t\t\t\treturn true;\n            \t}\n        return false;\n    }\n\n    public boolean bfs(int i, int j, char[][] board, String word, int p){\n    \tif(p==word.length())\treturn true;\n      \n        int N = board.length;\n        int M = board[0].length;\n\n        if(i>=0 && i<N && j>=0 && j<M  && board[i][j]==word.charAt(p)){\n            char temp = board[i][j];\n            board[i][j] =  '#';\n            p++;\n          \tif(bfs(i,j+1,board,word,p) || bfs(i+1,j,board,word,p) ||\n        \t\tbfs(i,j-1,board,word,p) || bfs(i-1,j,board,word,p)) \n    \t    \treturn true;\n            board[i][j] = temp;\n    \t}\n      \n    \n    \treturn false;\n    }\n}", "nl": "azheanda"}
{"code": "class WordBreak2 {\n\n    \n    Map<String, List<String>> res = new HashMap<String, List<String>>();\n\n    \n    public List<String> wordBreak(String s, Set<String> dict) {\n        List<String> words = new ArrayList<String>();\n\n        int len = s.length();\n        for (int i = 1; i <= len; i++) {\n            String pref = s.substring(0, i);\n            if (dict.contains(pref)) {\n                if (i == len) {\n                    words.add(pref); // reach the end\n                } else {\n                    String remain = s.substring(i, len); // remaining string\n                    List<String> remainDecomp = res.containsKey(remain) ?\n                                                res.get(remain) : wordBreak(remain,\n                                                                            dict); // avoid backtracking if a decomposition is already there\n                    if (remainDecomp != null) {\n                        for (String w : remainDecomp) {\n                            words.add(pref + \" \" + w);\n                        }\n                        res.put(remain, remainDecomp); // add to cache\n                    }\n                }\n            }\n        }\n        return words;\n    }\n\n    \n    public List<String> wordBreakB(String s, Set<String> dict) {\n        List<String> words = new ArrayList<String>();\n\n        int len = s.length();\n        for (int i = 1; i <= len; i++) {\n            String pref = s.substring(0, i);\n            if (dict.contains(pref)) {\n                if (i == len) {\n                    words.add(pref);\n                } else {\n                    String remain = s.substring(i, len);\n                    List<String> remainDecomp = wordBreakB(remain, dict);\n                    if (remainDecomp != null) { // has decompositions\n                        for (String item : remainDecomp) {\n                            words.add(pref + \" \" + item);\n                        }\n                    }\n                }\n            }\n        }\n        return words;\n    }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class TrappingRainWater3 {\n\tpublic int trap(int[] A) {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < A.length - 1; i++) {\n\t\t\tint max_left = 0, max_right = 0;\n\t\t\tfor (int j = i; j >= 0; j--) { //Search the left part for max bar size\n\t\t\t\tmax_left = Math.max(max_left, A[j]);\n\t\t\t}\n\t\t\tfor (int j = i; j < A.length; j++) { //Search the right part for max bar size\n\t\t\t\tmax_right = Math.max(max_right, A[j]);\n\t\t\t}\n\t\t\tans += Math.min(max_left, max_right) - A[i];\n\t\t}\n\t\treturn ans;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class InsertionSortList {\n\n  \n  public ListNode insertionSortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode pre = new ListNode(0);\n    pre.next = head;\n\n    for (ListNode p = head.next, prev = head; p != null; prev = p, p = p.next) {\n      for (ListNode c = pre; c.next != p; c = c.next) {\n        if (c.next.val > p.val) {\n          prev.next = p.next; // skip p\n          p.next = c.next; // insert between cur and cur.next\n          c.next = p;\n          p = prev; // p is inserted to somewhere in the front, reset\n          break;\n        }\n      }\n    }\n    return pre.next;\n  }\n\n  public static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n      val = x;\n      next = null;\n    }\n  }\n}\n", "nl": "FreeTymeKiyan"}
{"code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> list = new ArrayList<>();\n        List<String> rst = new ArrayList<>();\n        int width = 0;\n        for (String s : words) {\n            if (getRowLength(list, width) + s.length() + 1 > maxWidth) {\n                rst.add(aggregate(list, width, maxWidth));\n                list = new ArrayList<>();\n                width = 0;\n            }\n            list.add(s);\n            width += s.length();\n        }\n        \n        if (list.size() == 0) return rst;\n        \n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < list.size() - 1; i++) {\n            sb.append(list.get(i) + \" \");\n        }\n        sb.append(list.get(list.size() - 1));\n        sb.append(generateSpace(maxWidth - sb.length()));\n        rst.add(sb.toString());\n        return rst;\n    }\n    \n    private int getRowLength(List<String> list, int width) {\n        return width + list.size() - 1; // overall width + (n - 1) spaces\n    }\n    \n    private String aggregate(List<String> list, int width, int max) {\n        int slot = list.size() - 1, diff = max - width;\n        if (slot == 0) return (list.get(0) + generateSpace(diff));\n\n        int length = diff / (slot);\n        int remain = diff % slot; // less than list.size() - 1\n        String space = generateSpace(length);\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < slot; i++) {\n            sb.append(list.get(i) + space);\n            if (i < remain) sb.append(\" \");\n        }\n        sb.append(list.get(slot));\n        sb.append(generateSpace(max - sb.length()));\n        return sb.toString();\n    }\n    \n    private String generateSpace(int x) {\n        if (x <= 0) return \"\";\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < x; i++) {\n            sb.append(\" \");\n        }\n        return sb.toString();\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class JumpGameII2 {\n    public int jump(int[] A) {\n        if (A == null || A.length == 0 || A.length == 1)\n            return 0;\n        int start = 0, end = 0;\n        int jump_times = 0, max = 0;\n        while (end < A.length) {\n            max = 0;\n            jump_times++;\n            for (int i = start; i <= end; i++) {\n                if ((A[i] + i) >= (A.length - 1))\n                    return jump_times;\n                if ((A[i] + i) > max)\n                    max = A[i] + i;\n            }\n            start = end + 1;\n            end = max;\n        }\n        return jump_times;\n    }\n}\n", "nl": "gaohannk"}
{"code": "public class MinStack {\n\tprivate Stack<Integer> stack = new Stack<>();\n\tprivate Stack<Integer> minStack = new Stack<>();\n\n\tpublic void push(int x) {\n\t\tstack.push(x);\n\t\tif (minStack.isEmpty() || x <= minStack.peek()) {\n\t\t\tminStack.push(x);\n\t\t}\n\t}\n\n\tpublic void pop() {\n\t\tif (stack.peek().equals(minStack.peek()))\n\t\t\tminStack.pop();\n\t\tstack.pop();\n\t}\n\n\tpublic int top() {\n\t\treturn stack.peek();\n\t}\n\n\tpublic int getMin() {\n\t\treturn minStack.peek();\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n    \tListNode node = new ListNode(0);\n    \tListNode dummy = node;\n        if (lists == null || lists.length == 0) {\n        \treturn dummy.next;\n        }\n        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(new Comparator<ListNode>(){\n        \tpublic int compare(ListNode a, ListNode b){\n        \t\treturn a.val - b.val;\n        \t}\n        });\n        for (int i = 0; i < lists.length; i++) {\n        \tif(lists[i] != null) {\n        \t\tqueue.offer(lists[i]);\n        \t}\n        }\n\n        while (!queue.isEmpty()) {\n        \tListNode temp = queue.poll();\n        \tnode.next = temp;\n        \tif (temp.next != null) {\n        \t\tqueue.offer(temp.next);\n        \t}\n        \tnode = node.next;\n        }\n        return dummy.next;\n    }\n}\n    ", "nl": "awangdev"}
{"code": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if (l1 == null || l2 == null) {\n            return l1 == null ? l2 : l1;\n        }\n        int carry = 0;\n        ListNode node = new ListNode(-1);\n        ListNode head = node;\n        while (l1 != null || l2 != null) {\n            int sum = carry;\n            if (l1 != null) {\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            carry = sum / 10;\n            sum = sum % 10;\n            node.next = new ListNode(sum);\n            node = node.next;\n        }\n\n        if (carry != 0) {\n            node.next = new ListNode(carry);\n        }\n\n        return head.next;\n    }\n}", "nl": "awangdev"}
{"code": "public class _38_countAndSay {\n\n    public static void main(String[] args) {\n        _38_countAndSay countAndSay = new _38_countAndSay();\n        System.out.println(countAndSay.countAndSay(4));\n        System.out.println(countAndSay.countAndSay(5));\n        System.out.println(countAndSay.countAndSay(6));\n    }\n\n    \n    public String countAndSay(int n) {\n        String str = \"1\";\n        for (int i = 2; i <= n; i++) {\n            StringBuilder builder = new StringBuilder();\n            char pre = str.charAt(0);\n            int count = 1;\n            for (int j = 1; j < str.length(); j++) {\n                char c = str.charAt(j);\n                if (c == pre) {\n                    count++;\n                } else {\n                    builder.append(count).append(pre);\n                    pre = c;\n                    count = 1;\n                }\n            }\n            builder.append(count).append(pre);\n            str = builder.toString();\n        }\n\n        return str;\n    }\n}\n", "nl": "pphdsny"}
{"code": "public class L050_Pow_x_n {\n\n\tpublic double myPow(double x, int n) {\n\t\tif (n < 0) {\n\t\t\treturn 1 / pow(x, -n);\n\t\t} else {\n\t\t\treturn pow(x, n);\n\t\t}\n\t}\n\n\tprivate double pow(double x, int n) {\n\n\t\tif (n == 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tdouble v = pow(x, n / 2);\n\n\t\tif (n % 2 == 0) {\n\t\t\treturn v * v;\n\t\t} else {\n\t\t\treturn v * v * x;\n\t\t}\n\t}\n}\n", "nl": "LjyYano"}
{"code": "public class Combinations \n{\t\n    public List<List<Integer>> combine( int n, int k )\n    {\n    \tList<List<Integer>> allCombs = new LinkedList<>();\n    \tLinkedList<Integer> oneComb = new LinkedList<>();\n    \tgenerateCombs( allCombs, oneComb, 1, n, k );\n    \treturn allCombs;\n    }\n    \n    private void generateCombs( List<List<Integer>> allCombs, LinkedList<Integer> oneComb, int start, int end, int k )\n    {\n    \tif ( k < 0 )\n    \t{\n    \t\treturn;\n    \t}    \t\n    \tif ( k == 0 )\n    \t{\n    \t\tallCombs.add( new LinkedList<>( oneComb ) );\n    \t\treturn;\n    \t}\n    \t\n    \tfor ( int i = start; i <= end; i++ )\n    \t{\n    \t\toneComb.addLast( i );\n    \t\tgenerateCombs( allCombs, oneComb, i + 1, end, k - 1 );\n    \t\toneComb.removeLast();\n    \t}\n    }\n    \n    public List<List<Integer>> combine( int[] nums, int k )\n    {\n    \tList<List<Integer>> allCombs = new LinkedList<>();\n    \tLinkedList<Integer> oneComb = new LinkedList<>();\n    \tArrays.sort( nums );\n    \tgenerateCombs( allCombs, oneComb, nums, k, 0 );\n    \treturn allCombs;    \t\n    }\n    \n    private void generateCombs( List<List<Integer>> allCombs, LinkedList<Integer> oneComb, int[] nums, int k, int start )\n    {\n    \t\n    }\n    \n    @Test\n    public void test()\n    {\n    \tSystem.out.print( combine( 3 ,2 ) );\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class LongestCommonPrefix {\n  \n  public static void main(String[] args) throws Exception {\n    String[] A = {\"abc\", \"a\", \"adkd\"};\n    System.out.println(new LongestCommonPrefix().longestCommonPrefix(A));\n  }\n\n  public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String result = strs[0];\n    for (int i = 1; i < strs.length; i++) {\n      String s = strs[i];\n      for (int j = 0; j < result.length(); j++) {\n        if (j >= s.length() || result.charAt(j) != s.charAt(j)) {\n          result = result.substring(0, j);\n          break;\n        }\n      }\n    }\n    return result;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class ConvertSortedListToBinarySearchTree\n{\n\tprivate ListNode nextNode = null;\n\n    public TreeNode sortedListToBST( ListNode head )\n    {\n    \tListNode currNode = head;\n    \tint numListNodes = 0;\n    \twhile ( currNode != null )\n    \t{\n    \t\tnumListNodes++;\n    \t\tcurrNode = currNode.next;\n    \t}\n    \t\n    \tnextNode = head;\n    \treturn buildTreeRecurse( 0, numListNodes - 1 );    \t\n    }\n    \n    private TreeNode buildTreeRecurse( int start, int end )\n    {\n    \tif ( start > end )\n    \t{\n    \t\treturn null;\n    \t}\n    \t\n    \tint rootIndex = ( end - start ) / 2 + start;\n    \tTreeNode leftSubtree = buildTreeRecurse( start, rootIndex - 1 );\n    \tTreeNode root = new TreeNode( nextNode.val );\n    \tnextNode = nextNode.next;\n    \tTreeNode rightSubtree = buildTreeRecurse( rootIndex + 1, end );\n    \troot.left = leftSubtree;\n    \troot.right = rightSubtree;\n    \treturn root;\n    }\n\n}", "nl": "FreemanZhang"}
{"code": "public class RegularExpressionMatching {\n\tpublic boolean isMatch(String s, String p) {\n\t\treturn helper(s, p, 0, 0);\n\t}\n\n\tprivate boolean helper(String s, String p, int i, int j) {\n\t\tif (j == p.length())\n\t\t\treturn i == s.length();\n\t\tif (j == p.length() - 1 || p.charAt(j + 1) != '*') {\n\t\t\tif (i == s.length() || s.charAt(i) != p.charAt(j) && p.charAt(j) != '.')\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\treturn helper(s, p, i + 1, j + 1);\n\t\t}\n\t\twhile (i < s.length() && (p.charAt(j) == '.' || s.charAt(i) == p.charAt(j))) {\n\t\t\tif (helper(s, p, i, j + 2))\n\t\t\t\treturn true;\n\t\t\ti++;\n\t\t}\n\t\treturn helper(s, p, i, j + 2);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int lengthOfLastWord(String s) {\n        int res = 0, i = s.length() - 1;\n        while (i >= 0 && s.charAt(i) == ' ') --i;\n        while (i >= 0 && s.charAt(i) != ' ') {\n            --i; ++res;\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class RegularExpressionMatching {\n\n    public class Solution {\n        public boolean isMatch(String s, String p) {\n            boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];\n            dp[0][0] = true;\n            for (int i = 1; i <= p.length(); i++) {\n                dp[i][0] = p.charAt(i - 1) == '*' && dp[i - 2][0];\n                for (int j = 1; j <= s.length(); j++) {\n                    if (p.charAt(i - 1) == '*') {\n                        if (dp[i - 2][j]) {\n                            dp[i][j] = true;\n                            continue;\n                        }\n                        char prev = p.charAt(i - 2);\n                        for (int k = j; k > 0; k--) {\n                            if (prev != '.' && prev != s.charAt(k - 1)) {\n                                break;\n                            }\n                            if (dp[i - 2][k - 1]) {\n                                dp[i][j] = true;\n                                break;\n                            }\n                        }\n                    } else {\n                        dp[i][j] = dp[i - 1][j - 1]\n                                && (p.charAt(i - 1) == '.' || p.charAt(i - 1) == s\n                                        .charAt(j - 1));\n                    }\n                }\n\n            }\n            return dp[p.length()][s.length()];\n        }\n    }\n\n    public static class UnitTest {\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {\n        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n        \n        if(num.length<3)\n            return result;\n        \n        Arrays.sort(num);        \n        for(int i=0;i<num.length-2;i++)                  \n            for(int j=i+1;j<num.length-1;j++)\n                if(binarySearch(num,j+1,num.length-1,-num[i]-num[j])>=0){\n                    ArrayList<Integer> triplet = new ArrayList<Integer>(3);\n                         triplet.add(num[i]);\n                         triplet.add(num[j]);\n                         triplet.add(-num[i]-num[j]);\n                         if(!result.contains(triplet))\n                            result.add(triplet);\n                }          \n        return result;\n    }\n    \n    public static int binarySearch(int[] num,int p,int r, int val){\n        if(num==null || num.length==0 || p>r)\n            return -1;\n        int m = (p+r)/2;\n        if( val ==num[m])\n            return m;\n        else if (val>num[m])\n            return binarySearch(num,m+1,r,val);\n        else\n            return binarySearch(num,p,m-1,val);\n    }\n        \n}\n\n", "nl": "azheanda"}
{"code": "public class L148_Sort_List {\n\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\n\t\tListNode rt = new ListNode(0);\n\t\tListNode h = rt;\n\n\t\twhile (l1 != null && l2 != null) {\n\t\t\tif (l1.val < l2.val) {\n\t\t\t\trt.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t} else {\n\t\t\t\trt.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\n\t\t\trt = rt.next;\n\t\t}\n\n\t\tif (l1 != null)\n\t\t\trt.next = l1;\n\t\telse\n\t\t\trt.next = l2;\n\n\t\treturn h.next;\n\n\t}\n\n\tpublic ListNode sortList(ListNode head) {\n\t\tif (head == null)\n\t\t\treturn null;\n\t\tif (head.next == null)\n\t\t\treturn head;\n\n\t\tListNode fast = head.next;\n\t\tListNode slow = head;\n\n\t\twhile (fast != null && fast.next != null) {\n\t\t\tslow = slow.next;\n\t\t\tfast = fast.next.next;\n\t\t}\n\n\t\tListNode h2 = slow.next;\n\t\tslow.next = null;\n\n\t\treturn mergeTwoLists(sortList(head), sortList(h2));\n\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class SpiralMatrix {\n  public ArrayList<Integer> spiralOrder(int[][] matrix) {\n    ArrayList<Integer> list = new ArrayList<Integer>();\n    if (matrix.length == 0) return list;\n    int beginX = 0, endX = matrix.length - 1;\n    int beginY = 0, endY = matrix[0].length - 1;\n    while (true) {\n      for (int i = beginY; i <= endY; i++) {\n        list.add(matrix[beginX][i]);\n      }\n      if (++beginX > endX) break;\n      for (int i = beginX; i <= endX; i++) {\n        list.add(matrix[i][endY]);\n      }\n      if (beginY > --endY) break;\n      for (int i = endY; i >= beginY; i--) {\n        list.add(matrix[endX][i]);\n      }\n      if (beginX > --endX) break;\n      for (int i = endX; i >= beginX; i--) {\n        list.add(matrix[i][beginY]);\n      }\n      if (++beginY > endY) break;\n    }\n    return list;\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public int[] searchRange(int[] A, int target) {\n        int[] res = new int[2];\n        res[0] = search(A, target-1)+1;\n        res[1] = search(A, target);\n        if(res[1] == -1 || A[res[1]] != target){\n            res[0] = -1;\n        \tres[1] = -1;\n        }\n        return res;\n\n    }\n\n    public int search(int [] A, int target){\n \t\tint start = 0, end = A.length-1, mid = end/2;\n \t\tint res = -1;\n\n \t\twhile(start<=end){\n \t\t\tif(A[mid]>target)\n \t\t\t\tend = mid-1;\n \t\t\telse {\n \t\t\t\tstart = mid+1;\n \t\t\t\tres = mid;\n \t\t\t}\n \t\t\tmid = (start+end)/2;\n \t\t}\n \t\treturn res;\n\n    }\n}", "nl": "azheanda"}
{"code": "public class PathSum\n{\n    public boolean hasPathSum( TreeNode root, int sum )\n    {\n    \tif ( root == null )\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tif ( root.left == null \n    \t\t\t&& root.right == null \n    \t\t\t&& sum == root.val )\n    \t{\n    \t\treturn true;\n    \t}\n    \t\n    \treturn hasPathSum( root.left, sum - root.val )\n    \t\t\t|| hasPathSum( root.right, sum - root.val );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "public class SpiralMatrix {\n\tpublic static ArrayList<Integer> spiralOrder(int[][] matrix) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif (matrix == null || matrix.length == 0)   \n            return list;\n\t\tint startx = 0, endx = matrix.length - 1;\n\t\tint starty = 0, endy = matrix[0].length - 1;\n\t\twhile (startx <= endx && starty <= endy) {\n\t\t\tfor (int i = starty; i <= endy; i++)\n\t\t\t\tlist.add(matrix[startx][i]);\n\t\t\tfor (int i = startx + 1; i <= endx; i++)\n\t\t\t\tlist.add(matrix[i][endy]);\n\t\t\tif (startx != endx) {\n\t\t\t\tfor (int i = endy - 1; i >= starty; i--)\n\t\t\t\t\tlist.add(matrix[endx][i]);\n\n\t\t\t}\n\t\t\tif (starty != endy) {\n\t\t\t\tfor (int i = endx - 1; i > startx; i--)\n\t\t\t\t\tlist.add(matrix[i][starty]);\n\t\t\t}\n\t\t\tstartx++;\n\t\t\tendx--;\n\t\t\tstarty++;\n\t\t\tendy--;\n\t\t}\n\t\treturn list;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class UniquePaths {\n\n  \n  static int[][] paths = new int[101][101];\n\n  public static void main(String[] args) {\n    System.out.println(uniquePathsMath(10, 20));\n    System.out.println(uniquePathsDP(10, 20));\n  }\n\n  \n  public static int uniquePathsMath(int m, int n) {\n    int k = m > n ? n : m;\n    int N = m + n - 2;\n    double res = 1; // note that res can overflow\n    for (int i = 1; i < k; i++) {\n      res *= N--;\n      res /= i;\n    }\n    return (int) res; // convert to int\n  }\n\n  public static int uniquePathsDP(int m, int n) {\n    if (m <= 0 || n <= 0) return 0;\n    if (m == 1 || n == 1) return 1;\n    if (paths[m][n] == 0)\n      paths[m][n] = uniquePathsDP(m - 1, n) + uniquePathsDP(m, n - 1);\n    return paths[m][n];\n  }\n\n  \n  public static int uniquePaths(int m, int n) {\n    int[][] paths = new int[m + 1][n + 1];\n    paths[m - 1][n] = 1;\n    for (int r = m - 1; r >= 0; r--)\n      for (int c = n - 1; c >= 0; c--)\n        paths[r][c] = paths[r + 1][c] + paths[r][c + 1];\n    return paths[0][0];\n  }\n}", "nl": "FreeTymeKiyan"}
{"code": "public class Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return build(inorder, postorder,0,inorder.length-1,0,postorder.length-1);\n    }\n    public TreeNode build(int[] inorder, int[] postorder,int is,int ie,int ps,int pe){\n        if(ps>pe){\n            return null;\n        }\n        int val=postorder[pe];\n        TreeNode node=new TreeNode(val);\n        int i = is;\n        for (; i <=ie; i++) {\n            if (inorder[i]==val) {\n                break;\n            }\n        }\n        int rang=i-is;\n        node.left=build(inorder, postorder,is,i-1,ps,ps+rang-1);\n        node.right=build(inorder,postorder,i+1,ie,ps+rang,pe-1);\n        return node;\n        \n    }\n}", "nl": "corpsepiges"}
{"code": "class Solution {\n    public void sortColors(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return;\n        }\n\n        int k = 2, end = nums.length - 1;\n        for (int i = 0; i < k; i++) { // 3 different colors\n            end = partition(nums, 0, end, k - i - 1);\n        }\n        \n        \n    }\n    private int partition(int[] nums, int start, int end, int pivot) {\n        int low = start, high = end;\n        while (low <= high) {\n            while(low < high && nums[low] <= pivot) low++;\n            while(high > 0 && nums[high] > pivot) high--;\n            \n            if (low <= high) swap(nums, low++, high--);\n        }\n        return low - 1;\n    }\n\n    private void swap(int[] nums, int x, int y){\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public int[] plusOne(int[] digits) {\n        if(digits.length==0) return digits;\n        \n        digits[digits.length-1] += 1;\n        for(int i = digits.length-1; i>0; i--){\n            if(digits[i] == 10){\n                digits[i]=0;\n                digits[i-1]+=1;\n            }\n            else return digits;\n        }\n        \n        if(digits[0]==10){\n            int[] output = new int[digits.length+1];\n            output[0] = 1;\n            output[1] = 0;\n            for(int i=2; i<output.length-1; i++){\n                output[i]=digits[i-1];\n            }\n            return output;\n        }\n        else return digits;\n    }\n}\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class FirstMissingPositive {\n\tpublic int firstMissingPositive(int[] A) {\n\t\tArrays.sort(A);\n\t\tint count = 1;\n\t\tif (A.length == 0)\n\t\t\treturn 1;\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tif (A[i] <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 0 && A[i] == A[i - 1])\n\t\t\t\tcontinue;\n\t\t\tif (A[i] != count)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class MultiplyStrings {\n\n    public class Solution {\n\n        private List<Integer> multiply(List<Integer> l1, List<Integer> l2) {\n            List<Integer> result = new ArrayList<Integer>();\n            for (int offset = 0; offset < l2.size(); offset++) {\n                if (l2.get(offset) != 0) {\n                    List<Integer> temp = multiplyDigit(l1, l2.get(offset));\n                    result = add(temp, result, offset);\n                }\n            }\n            return result;\n        }\n\n        private List<Integer> add(List<Integer> l1, List<Integer> l2, int offset) {\n            List<Integer> result = new ArrayList<Integer>();\n            int index = 0;\n            while (index < offset) {\n                if (index < l2.size()) {\n                    result.add(l2.get(index));\n                } else {\n                    result.add(0);\n                }\n                index++;\n            }\n            int carry = 0;\n            for (int i : l1) {\n                int value = i + carry + (index < l2.size() ? l2.get(index) : 0);\n                result.add(value % 10);\n                carry = value / 10;\n                index++;\n            }\n            if (carry != 0) {\n                result.add(carry);\n            }\n            return result;\n        }\n\n        private List<Integer> toList(String s) {\n            List<Integer> result = new ArrayList<Integer>();\n            for (int i = s.length() - 1; i >= 0; i--) {\n                result.add(s.charAt(i) - '0');\n            }\n            return result;\n        }\n\n        private String toString(List<Integer> l) {\n            StringBuilder builder = new StringBuilder();\n            int i = l.size() - 1;\n            for (; i >= 0; i--) {\n                if (l.get(i) != 0) {\n                    break;\n                }\n            }\n            for (; i >= 0; i--) {\n                builder.append(l.get(i));\n            }\n            if (builder.length() == 0) {\n                return \"0\";\n            }\n            return builder.toString();\n        }\n\n        private List<Integer> multiplyDigit(List<Integer> l, int digit) {\n            List<Integer> result = new ArrayList<Integer>();\n            int carry = 0;\n            for (int i : l) {\n                result.add((i * digit + carry) % 10);\n                carry = (i * digit + carry) / 10;\n            }\n            if (carry != 0) {\n                result.add(carry);\n            }\n            return result;\n        }\n\n        public String multiply(String num1, String num2) {\n            return toString(multiply(toList(num1), toList(num2)));\n        }\n    }\n\n    public static class UnitTest {\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class LongestPalindromicSubstring {\n  public String longestPalindrome(String s) {\n    int length = s.length();\n    String result = \"\";\n    for (int i = 0; i < length; i++) {\n      String ps = getPalindrome(s, i, i);\n      if (ps.length() > result.length()) {\n        result = ps;\n      }\n      ps = getPalindrome(s, i, i + 1);\n      if (ps.length() > result.length()) {\n        result = ps;\n      }\n    }\n    return result;\n  }\n\n  private String getPalindrome(String s, int l, int r) {\n    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n      l--;\n      r++;\n    }\n    return s.substring(l + 1, r);\n  }\n}\n", "nl": "mengli"}
{"code": "public class Solution {\n    public int search(int[] nums, int target) {\n        if (nums.length==1) {\n            if (nums[0]==target) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n        int begin=0;\n        int end=nums.length-1;\n        int half=(end+begin)/2;\n        while (end-begin>1) {\n            int b=nums[begin];\n            int h=nums[half];\n            int e=nums[end];\n            if (h==target) {\n                return half;\n            }\n            if (b==target) {\n                return begin;\n            }\n            if (e==target) {\n                return end;\n            }\n            if (h>b) {\n                if (target>h) {\n                    begin=half;\n                    half=(end+begin)/2;\n                }else {\n                    if (target>b) {\n                        end=half;\n                        half=(end+begin)/2;\n                    }else {\n                        begin=half;\n                        half=(end+begin)/2;\n                    }\n                }\n            }else {\n                if (target<h) {\n                    end=half;\n                    half=(end+begin)/2;\n                }else {\n                    if (target>e) {\n                        end=half;\n                        half=(end+begin)/2;\n                    }else {\n                        begin=half;\n                        half=(end+begin)/2;\n                    }\n                }\n            }\n        }\n        if (nums[begin]==target) {\n            return begin;\n        }\n        if (nums[end]==target) {\n            return end;\n        }\n\n        return -1;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head = new ListNode(0);\n        ListNode cur = head;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        if (l1 != null) cur.next = l1;\n        if (l2 != null) cur.next = l2;\n        return head.next;\n    }\n}", "nl": "leetcoders"}
{"code": "public class SameTree {\n\n    public class Solution {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n            if (p == q) {\n                return true;\n            }\n            if (p != null && q != null) {\n                return p.val == q.val && isSameTree(p.left, q.left)\n                        && isSameTree(p.right, q.right);\n            }\n            return false;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class LongestValidParentheses {\n\n  private class Node {\n    char c;\n    int i;\n\n    Node(char c, int i) {\n      this.c = c;\n      this.i = i;\n    }\n  }\n\n  \n  public static void main(String[] args) throws Exception {\n    System.out.println(new LongestValidParentheses().longestValidParentheses(\"((()()(((())))))\"));\n  }\n\n  public int longestValidParentheses(String s) {\n    Stack<Node> stack = new Stack<>();\n    int max = 0;\n    for (int i = 0, l = s.length(); i < l; i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '(':\n          stack.push(new Node(c, i));\n          break;\n\n        case ')':\n          if (!stack.isEmpty()) {\n            if (stack.peek().c == '(') {\n              stack.pop();\n              if (stack.isEmpty()) {\n                max = Math.max(max, i + 1);\n              } else {\n                max = Math.max(max, i - stack.peek().i);\n              }\n            } else {\n              stack.push(new Node(c, i));\n            }\n          } else {\n            stack.push(new Node(c, i));\n          }\n      }\n    }\n    return max;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "class Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null) {\n            return false;\n        }\n        if (root.left == null && root.right == null && sum == root.val) {\n            return true;\n        }\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n    }\n}\n\n\n", "nl": "awangdev"}
{"code": "public class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> ansList=new ArrayList<String>();\n        if (root!=null) {\n            List<List<TreeNode>> totalList=new ArrayList<List<TreeNode>>();\n            List<TreeNode> initList=new ArrayList<TreeNode>();\n            initList.add(root);\n            totalList.add(initList);\n            for (int i = 0; i < totalList.size(); i++) {\n                List<TreeNode> list=totalList.get(i);\n                TreeNode node=list.get(list.size()-1);\n                boolean flag=false;\n                if (node.left!=null) {\n                    List<TreeNode> leftList=new ArrayList<TreeNode>();\n                    leftList.addAll(list);\n                    leftList.add(node.left);\n                    totalList.add(leftList);\n                    flag=true;\n                }\n                if (node.right!=null) {\n                    List<TreeNode> rightList=new ArrayList<TreeNode>();\n                    rightList.addAll(list);\n                    rightList.add(node.right);\n                    totalList.add(rightList);\n                    flag=true;\n                }\n                if (flag) {\n                    totalList.remove(i);\n                    i--;\n                }\n            }\n            for (int i = 0; i < totalList.size(); i++) {\n                List<TreeNode> list=totalList.get(i);\n                String ans=\"\"+list.get(0).val;\n                for (int j = 1; j < list.size(); j++) {\n                    ans+=(\"->\"+list.get(j).val);\n                }\n                ansList.add(ans);\n            }\n        }\n        return ansList;\n    }\n}", "nl": "corpsepiges"}
{"code": "public class BinaryTreePaths2 {\n\tpublic List<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> res = new LinkedList<String>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (root == null)\n\t\t\treturn res;\n\t\tsb.append(root.val);\n\t\tif (root.left != null)\n\t\t\thelper(root.left, res, sb);\n\t\tif (root.right != null)\n\t\t\thelper(root.right, res, sb);\n\t\tif (root.left == null && root.right == null)\n\t\t\tres.add(sb.toString());\n\t\treturn res;\n\t}\n\n\tpublic void helper(TreeNode node, List<String> res, StringBuilder sb) {\n\t\tsb.append(\"->\" + node.val);\n\t\tif (node.left == null && node.right == null) {\n\t\t\tres.add(sb.toString());\n\t\t\tsb.delete(sb.length() - 2 - String.valueOf(node.val).length(), sb.length());\n\t\t\treturn;\n\t\t}\n\t\tif (node.left != null)\n\t\t\thelper(node.left, res, sb);\n\t\tif (node.right != null)\n\t\t\thelper(node.right, res, sb);\n\t\tsb.delete(sb.length() - 2 - String.valueOf(node.val).length(), sb.length());\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class HouseRobber\n{\n    public int rob( int[] nums )\n    {\n        if ( nums.length == 0 )\n        {\n        \treturn 0;\n        }\n        if ( nums.length == 1 )\n        {\n        \treturn nums[0];\n        }\n        if ( nums.length == 2 )\n        {\n        \treturn Math.max( nums[0], nums[1] );\n        }\n        \n        int[] maxAmountLocal = new int[nums.length + 1]; \n        maxAmountLocal[1] = nums[0];\n        maxAmountLocal[2] = nums[1];\n        for ( int i = 2; i < nums.length; i++ )\n        {\n        \tmaxAmountLocal[i+1] = Math.max( maxAmountLocal[i - 1], maxAmountLocal[i - 2] ) + nums[i];\n        }\n        return Math.max( maxAmountLocal[maxAmountLocal.length - 1], maxAmountLocal[maxAmountLocal.length - 2] );\n    }\n}", "nl": "FreemanZhang"}
{"code": "public class L035_Search_Insert_Position {\n\n\tpublic int searchInsert(int[] nums, int target) {\n\n\t\tif (nums == null || nums.length == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (target <= nums[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn nums.length;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        if (s == null || p == null) return false;\n        int m = s.length(), n = p.length();\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        char[] ss = s.toCharArray();\n        char[] pp = p.toCharArray();\n        \n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = true;\n                    continue;\n                }\n                if (j == 0) { // When p is empty but s is not empty, should not match\n                    dp[i][j] = false;\n                    continue;\n                }\n\n                dp[i][j] = false;\n                if (pp[j - 1] != '*') {\n                    if (i >= 1 && (ss[i - 1] == pp[j - 1] || pp[j - 1] == '.')) {\n                        dp[i][j] = dp[i - 1][j - 1];\n                    }\n                } else { // tail = '*'. ex: a*\n                    if (j >= 2 ) { // ignore a*, repeat 0 times\n                        dp[i][j] |= dp[i][j - 2];\n                    }\n                    if (j >= 2 && i >= 1 && (ss[i - 1] == pp[j - 2] || pp[j - 2] == '.')) { \n                        dp[i][j] |= dp[i - 1][j];\n                    }\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n   ", "nl": "awangdev"}
{"code": "public class L031_Next_Permutation {\n\n\tpublic void nextPermutation(int[] nums) {\n\n\t\tif (nums == null || nums.length < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tint p = 0;\n\t\tfor (int i = nums.length - 2; i >= 0; i--) {\n\t\t\tif (nums[i] < nums[i + 1]) {\n\t\t\t\tp = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint q = 0;\n\t\tfor (int i = nums.length - 1; i > p; i--) {\n\t\t\tif (nums[i] > nums[p]) {\n\t\t\t\tq = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (p == 0 && q == 0) {\n\t\t\treverse(nums, 0, nums.length - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tint temp = nums[p];\n\t\tnums[p] = nums[q];\n\t\tnums[q] = temp;\n\n\t\tif (p < nums.length - 1) {\n\t\t\treverse(nums, p + 1, nums.length - 1);\n\t\t}\n\n\t}\n\n\tprivate void reverse(int[] nums, int left, int right) {\n\n\t\twhile (left < right) {\n\t\t\tint temp = nums[left];\n\t\t\tnums[left] = nums[right];\n\t\t\tnums[right] = temp;\n\t\t\tleft++;\n\t\t\tright--;\n\t\t}\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class FirstMissingPositive {\n  private int L;\n\n  public static void main(String[] args) throws Exception {\n    int[] nums = {1, 3, 5, 9};\n    System.out.println(new FirstMissingPositive().firstMissingPositive(nums));\n  }\n\n  public int firstMissingPositive(int[] nums) {\n    L = nums.length;\n    for (int i = 0; i < L; i++) {\n      if (nums[i] > 0 && nums[i] <= L && nums[i] != i + 1) {\n        int v = nums[i];\n        nums[i] = -1;\n        replace(v, nums);\n      }\n    }\n\n    for (int i = 0; i < L; i++) {\n      if (nums[i] != i + 1) return i + 1;\n    }\n\n    return L + 1;\n  }\n\n  private void replace(int i, int[] nums) {\n    if (i > 0 && i <= L && i != nums[i - 1]) {\n      int v = nums[i - 1];\n      nums[i - 1] = i;\n      replace(v, nums);\n    }\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class Solution {\n    public int[] searchRange(int[] A, int target) {\n        int[] rst = new int[]{-1, -1};\n        if (A == null || A.length == 0) {\n            return rst;\n        }\n        int start = 0;\n        int end = A.length - 1;\n        int mid = start + (end - start)/2;\n\n        int first = 0;\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            if (A[mid] == target) {\n                if (mid - 1 >= 0 && A[mid - 1] == target) {\n                    end = mid;\n                    continue;\n                }\n                break;\n            } else if (A[mid] < target) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        if (A[start] == target) {\n            first = start;\n        } else if (A[mid] == target) {\n            first = mid;\n        } else if (A[end] == target) {\n            first = end;\n        } else {\n            return rst;\n        }\n\n        int last = first;\n        start = first;\n        end = A.length - 1;\n        while (start + 1 < end) {\n            mid = start + (end - start)/2;\n            if (A[mid] == target) {\n                if (mid + 1 < A.length && A[mid + 1] == target) {\n                    start = mid;\n                    continue;\n                }\n                break;\n            } else if (A[mid] < target) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        if (A[end] == target) {\n            last = end;\n        } else if (A[mid] == target) {\n            last = mid;\n        } else if (A[start] == target) {\n            last = start;\n        }\n        \n        rst[0] = first;\n        rst[1] = last;\n        \n        return rst;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n", "nl": "awangdev"}
{"code": "public class AddTwoNumbers {\n\tpublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n\t\tif (l1 == null) {\n\t\t\treturn l2;\n\t\t}\n\t\tif (l2 == null) {\n\t\t\treturn l1;\n\t\t}\n\n\t\tint len1 = 0;\n\t\tint len2 = 0;\n\n\t\tListNode head = l1;\n\n\t\twhile (head != null) {\n\t\t\t++len1;\n\t\t\thead = head.next;\n\t\t}\n\n\t\thead = l2;\n\n\t\twhile (head != null) {\n\t\t\t++len2;\n\t\t\thead = head.next;\n\t\t}\n\n\t\tListNode longer = len1 >= len2 ? l1 : l2;\n\t\tListNode shorter = len1 < len2 ? l1 : l2;\n\n\t\tListNode result = null;\n\t\tListNode sum = null;\n\n\t\tint val = 0;\n\t\tint carry = 0;\n\n\t\twhile (shorter != null) {\n\t\t\tval = longer.val + shorter.val + carry;\n\t\t\tcarry = val / 10;\n\t\t\tval -= carry * 10;\n\t\t\t\n\t\t\tif (sum == null) {\n\t\t\t\tsum = new ListNode(val);\n\t\t\t\tresult = sum;\n\t\t\t} else {\n\t\t\t\tsum.next = new ListNode(val);\n\t\t\t\tsum = sum.next;\n\t\t\t}\n\t\t\t\n\t\t\tlonger = longer.next;\n\t\t\tshorter = shorter.next;\n\t\t}\n\n\t\twhile (longer != null) {\n\t\t\tval = longer.val + carry;\n\t\t\tcarry = val / 10;\n\t\t\tval -= carry * 10;\n\t\t\t\n\t\t\tsum.next = new ListNode(val);\n\t\t\tsum = sum.next;\n\t\t\t\n\t\t\tlonger = longer.next;\n\t\t}\n\n\t\tif (carry != 0) {\n\t\t\tsum.next = new ListNode(carry);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic void print(ListNode node) {\n\t\twhile (node != null) {\n\t\t\tSystem.out.print(node.val + \"->\");\n\t\t\tnode = node.next;\n\t\t}\n\t}\n    \n\tpublic static void main(String[] args) {\n\t\tListNode l1 = new ListNode(2);\n\t\tListNode n2 = new ListNode(4);\n\t\tListNode n3 = new ListNode(3);\n\n\t\tl1.next = n2;\n\t\tn2.next = n3;\n\n\t\tListNode l2 = new ListNode(5);\n\t\tListNode n4 = new ListNode(6);\n\t\tListNode n5 = new ListNode(4);\n\t\tl2.next = n4;\n\t\tn4.next = n5;\n\n\t\tAddTwoNumbers slt = new AddTwoNumbers();\n\t\tListNode result = slt.addTwoNumbers(l1, l2);\n\t\tslt.print(result);\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class MaximumDepthofBinaryTree {\n\tpublic int maxDepth(TreeNode root) {\n\t\treturn helper(root, 0);\n\t}\n\n\tpublic int helper(TreeNode node, int depth) {\n\t\tif (node == null)\n\t\t\treturn depth;\n\t\tint left=helper(node.left,depth+1);\n\t\tint right=helper(node.right,depth+1);\t\t\n\t\treturn Math.max(left,right);\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class JumpGameII {\n\n    public class Solution {\n        public int jump(int[] A) {\n            int step = 0;\n            int next = 0;\n            int current = 0;\n            for (int i = 0; i < A.length; i++) {\n                if (i > current) {\n                    current = next;\n                    step++;\n                }\n                next = Math.max(next, i + A[i]);\n            }\n            return step;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Permutations2 {\n\tpublic ArrayList<ArrayList<Integer>> permute(int[] num) {\n\t\tArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n\t\tpermute(num, 0, result);\n\t\treturn result;\n\t}\n\n\tpublic void permute(int[] num, int start, ArrayList<ArrayList<Integer>> result) {\n\t\tif (start >= num.length) {\n\t\t\tArrayList<Integer> item = convertArrayToList(num);\n\t\t\tresult.add(item);\n\t\t\treturn;\n\t\t}\n\t\tfor (int j = start; j < num.length; j++) {\n\t\t\tswap(num, start, j);\n\t\t\tpermute(num, start + 1, result);\n\t\t\tswap(num, start, j);\n\t\t}\n\t}\n\n\tprivate ArrayList<Integer> convertArrayToList(int[] num) {\n\t\tArrayList<Integer> item = new ArrayList<Integer>();\n\t\tfor (int h = 0; h < num.length; h++)\n\t\t\titem.add(num[h]);\n\t\treturn item;\n\t}\n\n\tprivate void swap(int[] a, int i, int j) {\n\t\tint temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class L058_Length_of_Last_Word {\n\n\tpublic int lengthOfLastWord(String s) {\n\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint len = 0;\n\t\tint i = s.length() - 1;\n\n\t\twhile (i >= 0 && s.charAt(i) == ' ') {\n\t\t\ti--;\n\t\t}\n\n\t\twhile (i >= 0 && s.charAt(i) != ' ') {\n\t\t\tlen++;\n\t\t\ti--;\n\t\t}\n\n\t\treturn len;\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "class NQueens2 {\n  static int ans, limit;\n\n  public static void main(String[] args) {\n    System.out.println(totalNQueens(2));\n    System.out.println(totalNQueens(3));\n    System.out.println(totalNQueens(4));\n    System.out.println(totalNQueens(5));\n  }\n\n  \npublic static int totalNQueens(int n) {\n  ans = 0;\n  limit = (1 << n) - 1; // note that parentheses can't be ignored\n  dfs(0, 0, 0);\n  return ans;\n}\n\n\npublic static void dfs(int h, int r, int l) {\n  if (h == limit) {\n    ans++;\n    return;\n  }\n  int pos = limit & (~(h | r | l));\n  while (pos != 0) { // has position\n    int p = pos & (-pos); // right most 1\n    pos -= p; // place a queen, 1 -> 0 on that position\n    dfs(h + p, (r + p) << 1, (l + p) >> 1);\n  }\n}\n}\n", "nl": "FreeTymeKiyan"}
{"code": "public class SearchInsertPosition {\n  public static void main(String[] args) throws Exception {\n    int[] A = {1, 3, 5, 6};\n    new SearchInsertPosition().searchInsert(A, 5);\n  }\n\n  public int searchInsert(int[] nums, int target) {\n    int pos = nums.length;\n    int s = 0, e = nums.length - 1;\n    while (s <= e) {\n      int m = s + (e - s) / 2;\n      if (nums[m] >= target) {\n        pos = m;\n        e = m - 1;\n      } else s = m + 1;\n    }\n    return pos;\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class PathSum {\n\tpublic boolean hasPathSum(TreeNode root, int sum) {\n\t\tif (root == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (root.left == null && root.right == null) {\n\t\t\treturn root.val == sum;\n\t\t}\n\n\t\treturn hasPathSum(root.left, sum - root.val)\n\t\t\t\t|| hasPathSum(root.right, sum - root.val);\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tTreeNode n1 = new TreeNode(5);\n\t\tTreeNode n2 = new TreeNode(4);\n\t\tTreeNode n3 = new TreeNode(8);\n\t\tTreeNode n4 = new TreeNode(11);\n\t\tTreeNode n5 = new TreeNode(13);\n\t\tTreeNode n6 = new TreeNode(4);\n\t\tn1.left = n2;\n\t\tn1.right = n3;\n\t\tn2.left = n4;\n\t\tn3.left = n5;\n\t\tn3.right = n6;\n\n\t\tPathSum slt = new PathSum();\n\t\tSystem.out.println(slt.hasPathSum(n1, 20));\n\t\tSystem.out.println(slt.hasPathSum(n1, 21));\n\t}\n}\n", "nl": "lilong-dream"}
{"code": "public class GrayCode {\n\n    public class Solution {\n        public ArrayList<Integer> grayCode(int n) {\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            for (int i = 0; i < (1 << n); i++) {\n                ans.add(i ^ (i >> 1));\n            }\n            return ans;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        if (fast == null || fast.next == null) return false;\n        return true;\n    }\n}", "nl": "leetcoders"}
{"code": "public class JumpGameII {\n\tpublic static int jump(int[] A) {\n\t\tif (A.length < 2)\n\t\t\treturn 0;\n\t\tint[] dist = new int[A.length];\n\t\tdist[A.length - 1] = 0;\n\t\tfor (int i = A.length - 2; i >= 0; i--) {\n\t\t\tint minDist = A.length-1;\n\t\t\tfor (int j = 1; j <= A[i] && i + j < A.length; j++) {\n\t\t\t\tint nextIdx = i + j;\n\t\t\t\tint candidate = dist[nextIdx] + 1;\n\t\t\t\tif (candidate < minDist) {\n\t\t\t\t\tminDist = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist[i] = minDist;\n\t\t}\n\t\treturn dist[0];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public int findMin(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int n = nums.length;\n        int start = 0;\n        int end = n - 1;\n        while (start + 1 < end) {\n            int mid = (start + end) >> 1;\n            if (mid - 1 >= 0 && mid + 1 < n && nums[mid - 1] > nums[mid] && nums[mid] < nums[mid + 1]) {\n                return nums[mid];\n            } else if (nums[mid] > nums[end]) { // nums[end] is definitely < nums[start]; greater than nums[end]: at left slope\n                start = mid;\n            } else {// nums[mid] < nums[start]\n                end = mid;\n            }\n        }\n        return nums[start] < nums[end] ? nums[start] : nums[end];\n    }\n}", "nl": "awangdev"}
{"code": "public class Solution {\n    \n    public double myPow(double x, int n) {\n    \tif(n >= 0) {\n    \t\treturn pow(x, n);\n    \t} else {\n    \t\treturn 1/pow(x, n);\n    \t}\n    }\n\n    public double pow(double x, int n) {\n    \tif (n == 0) {\n    \t\treturn 1;\n    \t}\n    \tdouble num = pow(x, n/2);\n    \tif (n % 2 == 0) {\n    \t\treturn num * num;\n    \t}\n    \treturn num * num * x;\n    }\n}\n\n   ", "nl": "awangdev"}
{"code": "public class Solution {\n    public int maxProfit(int[] prices) {\n        int res = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            res += Math.max(0, prices[i] - prices[i-1]);\n        }\n        return res;\n    }\n}", "nl": "leetcoders"}
{"code": "public class RemoveDuplicatesfromSortedListII {\n\n    public class Solution {\n        public ListNode deleteDuplicates(ListNode head) {\n            if (head == null) {\n                return null;\n            }\n            ListNode pre = null;\n            int count = 1;\n            ListNode p = head;\n            while (p.next != null) {\n                if (p.next.val == p.val) {\n                    count++;\n                } else if (count == 1) {\n                    if (pre == null) {\n                        head = p;\n                    }\n                    pre = p;\n                } else {\n                    if (pre != null) {\n                        pre.next = p.next;\n                    }\n                    count = 1;\n                }\n                p = p.next;\n            }\n            if (count == 1) {\n                if (pre == null) {\n                    return p;\n                } else {\n                    return head;\n                }\n            }\n            if (pre == null) {\n                return null;\n            }\n            pre.next = null;\n            return head;\n        }\n    }\n\n    public static class UnitTest {\n\n    }\n}\n", "nl": "zsxwing"}
{"code": "public class FindMinimuminRotatedSortedArray {\n\tpublic int findMin(int[] num) {\n\t\tint min = findmin(num, 0, num.length - 1);\n\t\treturn min;\n\t}\n\n\tpublic int findmin(int[] num, int left, int right) {\n\t\tint mid = (left + right) / 2;\n\t\tif (left == right)\n\t\t\treturn num[left];\n\t\tif (num[left] <= num[mid] && num[right] < num[mid])\n\t\t\treturn findmin(num, mid + 1, right);\n\t\telse if (num[mid] <= num[right] && num[left] > num[mid])\n\t\t\treturn findmin(num, left, mid);\n\t\treturn num[left];\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class CombinationSum {\n  public ArrayList<ArrayList<Integer>> combinationSum(int[] candidates, int target) {\n    ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> solution = new ArrayList<Integer>();\n    Arrays.sort(candidates);\n    combinationSum(candidates, 0, 0, target, ret, solution);\n    return ret;\n  }\n\n  private void combinationSum(\n      int[] candidates,\n      int start,\n      int sum,\n      int target,\n      ArrayList<ArrayList<Integer>> ret,\n      ArrayList<Integer> solution) {\n    if (sum == target) {\n      ret.add(new ArrayList<Integer>(solution));\n      return;\n    }\n    if (sum > target) return;\n    for (int i = start; i < candidates.length; i++) {\n      solution.add(candidates[i]);\n      combinationSum(candidates, start, sum + candidates[i], target, ret, solution);\n      solution.remove(solution.size() - 1);\n    }\n  }\n}\n", "nl": "mengli"}
{"code": "public class L043_Multiply_Strings {\n\n\tpublic String multiply(String num1, String num2) {\n\n\t\tif (num1 == null || num2 == null) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tint[] paper = new int[num1.length() + num2.length()];\n\n\t\tchar[] _num1 = num1.toCharArray();\n\t\tchar[] _num2 = num2.toCharArray();\n\n\t\tfor (int i = 0; i < _num1.length; i++) {\n\t\t\tfor (int j = 0; j < _num2.length; j++) {\n\t\t\t\tpaper[paper.length - (i + j + 2)] += (_num1[i] - '0')\n\t\t\t\t\t\t* (_num2[j] - '0');\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < paper.length - 1; i++) {\n\t\t\tpaper[i + 1] += paper[i] / 10;\n\t\t\tpaper[i] %= 10;\n\t\t}\n\n\t\tString s = \"\";\n\t\tfor (int i = paper.length - 1; i > 0; i--) {\n\n\t\t\tif (\"\" == s && paper[i] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts += paper[i];\n\t\t}\n\n\t\ts += paper[0];\n\n\t\treturn s;\n\t}\n\n\tpublic String multiply2(String num1, String num2) {\n\n\t\tif (num1 == null || num2 == null) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tBigInteger n1 = new BigInteger(num1);\n\t\tBigInteger n2 = new BigInteger(num2);\n\n\t\treturn n1.multiply(n2).toString();\n\t}\n\n}\n", "nl": "LjyYano"}
{"code": "public class ImplementstrStr {\n\n\tpublic int strStr(String haystack, String needle) {\n\t\tif (haystack == null || needle == null)\n\t\t\treturn -1;\n\t\tif (needle.length() > haystack.length())\n\t\t\treturn -1;\n\t\tfor (int i = 0; i <= haystack.length() - needle.length(); i++) {\n\t\t\tboolean successFlag = true;\n\t\t\tfor (int j = 0; j < needle.length(); j++) {\n\t\t\t\tif (haystack.charAt(i + j) != needle.charAt(j)) {\n\t\t\t\t\tsuccessFlag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (successFlag)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "public class Solution {\n    public int climbStairs(int n) {\n        if (n<=2) {\n            return n;\n        }else {\n            int[] sk=new int[n];\n            sk[0]=1;\n            sk[1]=2;\n            for (int i =2; i < sk.length; i++) {\n                sk[i]=sk[i-1]+sk[i-2];\n            }\n            return sk[n-1];\n        }\n    }\n}", "nl": "corpsepiges"}
{"code": "public class SearchForARange \n{\n\tpublic int[] searchRange( int[] nums, int target )\n    {\n\t\treturn searchRangeRecurse( nums, target, 0, nums.length - 1 );\n    }\n\t\n\tprivate int[] searchRangeRecurse( int[] nums, int target, int start, int end )\n\t{\n\t\tif ( nums.length == 0 )\n\t\t{\n\t\t\treturn new int[]{ -1, -1 };\n\t\t}\n\t\t\n\t\tif ( start > end )\n\t\t{\n\t\t\treturn new int[]{ -1, -1 };\n\t\t}\n\t\t\n\t\tint mid = ( end - start ) / 2 + start;\n\t\tif ( nums[mid] < target )\n\t\t{\n\t\t\treturn searchRangeRecurse( nums, target, mid + 1, end ); \n\t\t}\n\t\telse if ( nums[mid] > target )\n\t\t{\n\t\t\treturn searchRangeRecurse( nums, target, start, mid - 1 );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint[] leftRange = searchRangeRecurse( nums, target, start, mid - 1 );\n\t\t\tint[] rightRange = searchRangeRecurse( nums, target, mid + 1, end );\n\t        int leftEnd = (leftRange[0] == -1 ? mid : leftRange[0]);\n\t        int rightEnd = (rightRange[1] == -1 ? mid : rightRange[1]);\n\t        return new int[]{leftEnd, rightEnd};\n\t\t}\n\t}\n}\n", "nl": "FreemanZhang"}
{"code": "public class Solution {\n    public int removeDuplicates(int[] A) {\n        int i=1;\n\n        while(i<A.length){\n            if(A[i]>A[i-1])\n                i++;\n            else{\n                if(A[i-1]>=A[A.length-1])\n                    return i;\n                \n                for(int j=i+1;j<A.length;j++)\n                    if(A[j]>A[i-1]){\n                        swap(A,i,j);\n                        break;\n                    }            \n            }\n        }   \n        return A.length;\n    }\n    \n    public void swap(int[] A,int i,int j){\n        int temp = A[i];\n        A[i] = A[j];\n        A[j] = temp;\n    }\n}", "nl": "azheanda"}
{"code": "public class MaximumSubarray {\n  public int maxSubArray(int[] A) {\n    int max = Integer.MIN_VALUE;\n    int sum = 0;\n    for (int i = 0; i < A.length; i++) {\n      sum += A[i];\n      if (sum > max) {\n        max = sum;\n      }\n      if (sum < 0) {\n        sum = 0;\n      }\n    }\n    return max;\n  }\n}\n", "nl": "mengli"}
{"code": "public class FlattenBinaryTreeToLinkedList\n{\n    public void flatten( TreeNode root )\n    {\n    \tif ( root == null )\n    \t{\n    \t\treturn;\n    \t}\n    \t\n    \tStack<TreeNode> preorderStack = new Stack<>();\n    \tpreorderStack.push( root );\n    \tTreeNode sentinelHead = new TreeNode( 0 );\n    \tTreeNode sentinelTail = sentinelHead;\n    \twhile ( !preorderStack.isEmpty() )\n    \t{\n    \t\tTreeNode stackTop = preorderStack.pop();\n    \t\tif ( stackTop.right != null )\n    \t\t{\n    \t\t\tpreorderStack.push( stackTop.right );\n    \t\t}\n    \t\tif ( stackTop.left != null )\n    \t\t{\n    \t\t\tpreorderStack.push( stackTop.left );\n    \t\t}\n    \t\tsentinelTail.right = stackTop;\n    \t\tsentinelTail = stackTop;\n\n    \t\tstackTop.left = null;\n    \t\tstackTop.right = null;\n    \t}   \t\n    }\n\n    @Test\n    public void test()\n    {\n    \tTreeNode node0 = new TreeNode( 0 );\n    \tTreeNode node1 = new TreeNode( 1 );\n    \tTreeNode node2 = new TreeNode( 2 );\n    \tTreeNode node3 = new TreeNode( 3 );\n    \tTreeNode node4 = new TreeNode( 4 );\n    \tTreeNode node5 = new TreeNode( 5 );\n    \tnode0.left = node1;\n    \tnode0.right = node4;\n    \tnode1.left = node2;\n    \tnode1.right = node3;\n    \tnode4.right = node5;\n    \tflatten( node0 );\n    }\n}\n", "nl": "FreemanZhang"}
{"code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode node = head;\n        while (node != null && node.next != null) {\n            if (node.val == node.next.val) {\n                node.next = node.next.next;\n            } else {\n                node = node.next;    \n            }\n        }\n        return head;\n    }\n}\n\n\n\n", "nl": "awangdev"}
{"code": "public class HouseRobber {\n  private int[] max;\n\n  \n  public static void main(String[] args) throws Exception {}\n\n  public int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    max = new int[nums.length];\n    if (nums.length == 1) return nums[0];\n    max[nums.length - 1] = nums[nums.length - 1];\n    max[nums.length - 2] = Math.max(nums[nums.length - 1], nums[nums.length - 2]);\n    for (int i = nums.length - 3; i >= 0; i--) {\n      max[i] = Math.max(max[i + 1], nums[i] + max[i + 2]);\n    }\n    return max[0];\n  }\n}\n", "nl": "gouthampradhan"}
{"code": "public class RemoveDuplicatesfromSortedArray {\n\tpublic int removeDuplicates(int[] A) {\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tif (!set.contains(A[i])) {\n\t\t\t\tset.add(A[i]);\n\t\t\t\tA[count++] = A[i];\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n", "nl": "gaohannk"}
{"code": "class Solution {\n    public int mySqrt(int x) {\n        long start = 0;\n        long end = x;\n        while (start + 1 < end) {\n            long mid = (start + end) >> 1;\n            if (mid * mid < x) {\n                start = mid;\n            } else if (mid * mid > x) {\n                end = mid;\n            } else {\n                return (int)mid;\n            }\n        }\n        if (end * end <= x) {\n            return (int)end;\n        } else {\n            return (int)start;\n        }\n    }\n}\n\n\n", "nl": "awangdev"}
